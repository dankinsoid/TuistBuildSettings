
// MARK: Active Build Action
extension BuildSetting {

    /// Active Build Action
    ///
    /// A string identifying the build system action being performed.
    public static func activeBuildAction(_ value: String) -> BuildSetting { 
        BuildSetting(key: .activeBuildAction, value: \(value))
    }

    /// Active Build Action
    ///
    /// A string identifying the build system action being performed.
    public static func activeBuildAction(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .activeBuildAction, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Active Build Action
    ///
    /// A string identifying the build system action being performed.
    public static let activeBuildAction: BuildSettingsKey = "ACTION"
}

// MARK: Additional SDKs
extension BuildSetting {

    /// Additional SDKs
    ///
    /// The locations of any sparse SDKs that should be layered on top of the one specified by [Base SDK (SDKROOT)](itcaec37c2a6.html# devabcaadbaf). If more than one SDK is listed, the first one has highest precedence. Every SDK specified in this setting should be a “sparse” SDK, for example, not an SDK for an entire macOS release.
    public static func additionalSdks(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .additionalSdks, value: .array(value))
    }

    /// Additional SDKs
    ///
    /// The locations of any sparse SDKs that should be layered on top of the one specified by [Base SDK (SDKROOT)](itcaec37c2a6.html# devabcaadbaf). If more than one SDK is listed, the first one has highest precedence. Every SDK specified in this setting should be a “sparse” SDK, for example, not an SDK for an entire macOS release.
    public static func additionalSdks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .additionalSdks, inherit: key)
    }

    /// Additional SDKs
    ///
    /// The locations of any sparse SDKs that should be layered on top of the one specified by [Base SDK (SDKROOT)](itcaec37c2a6.html# devabcaadbaf). If more than one SDK is listed, the first one has highest precedence. Every SDK specified in this setting should be a “sparse” SDK, for example, not an SDK for an entire macOS release.
    public static func additionalSdks(_ value: String...) -> BuildSetting { 
        .additionalSdks(value)
    }
}

extension BuildSettingsKey {

    /// Additional SDKs
    ///
    /// The locations of any sparse SDKs that should be layered on top of the one specified by [Base SDK (SDKROOT)](itcaec37c2a6.html# devabcaadbaf). If more than one SDK is listed, the first one has highest precedence. Every SDK specified in this setting should be a “sparse” SDK, for example, not an SDK for an entire macOS release.
    public static let additionalSdks: BuildSettingsKey = "ADDITIONAL_SDKS"
}

// MARK: Alternate Install Group
extension BuildSetting {

    /// Alternate Install Group
    ///
    /// The group name or gid for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static var alternateInstallGroup: BuildSetting { 
        .alternateInstallGroup(inherit: .installGroup) 
    }

    /// Alternate Install Group
    ///
    /// The group name or gid for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static func alternateInstallGroup(_ value: String) -> BuildSetting { 
        BuildSetting(key: .alternateInstallGroup, value: \(value))
    }

    /// Alternate Install Group
    ///
    /// The group name or gid for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static func alternateInstallGroup(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternateInstallGroup, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Alternate Install Group
    ///
    /// The group name or gid for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static let alternateInstallGroup: BuildSettingsKey = "ALTERNATE_GROUP"
}

// MARK: Alternate Install Permissions
extension BuildSetting {

    /// Alternate Install Permissions
    ///
    /// Permissions used for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static var alternateInstallPermissions: BuildSetting { 
        .alternateInstallPermissions(inherit: .installPermissions) 
    }

    /// Alternate Install Permissions
    ///
    /// Permissions used for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static func alternateInstallPermissions(_ value: String) -> BuildSetting { 
        BuildSetting(key: .alternateInstallPermissions, value: \(value))
    }

    /// Alternate Install Permissions
    ///
    /// Permissions used for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static func alternateInstallPermissions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternateInstallPermissions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Alternate Install Permissions
    ///
    /// Permissions used for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static let alternateInstallPermissions: BuildSettingsKey = "ALTERNATE_MODE"
}

// MARK: Alternate Install Owner
extension BuildSetting {

    /// Alternate Install Owner
    ///
    /// The owner name or uid for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static var alternateInstallOwner: BuildSetting { 
        .alternateInstallOwner(inherit: .installOwner) 
    }

    /// Alternate Install Owner
    ///
    /// The owner name or uid for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static func alternateInstallOwner(_ value: String) -> BuildSetting { 
        BuildSetting(key: .alternateInstallOwner, value: \(value))
    }

    /// Alternate Install Owner
    ///
    /// The owner name or uid for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static func alternateInstallOwner(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternateInstallOwner, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Alternate Install Owner
    ///
    /// The owner name or uid for the files listed under the [Alternate Permissions Files (ALTERNATE_PERMISSIONS_FILES)](itcaec37c2a6.html# dev40b8becae) setting.
    public static let alternateInstallOwner: BuildSettingsKey = "ALTERNATE_OWNER"
}

// MARK: Alternate Permissions Files
extension BuildSetting {

    /// Alternate Permissions Files
    ///
    /// List of files to which the alternate owner, group and permissions are applied.
    public static func alternatePermissionsFiles(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .alternatePermissionsFiles, value: .array(value))
    }

    /// Alternate Permissions Files
    ///
    /// List of files to which the alternate owner, group and permissions are applied.
    public static func alternatePermissionsFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternatePermissionsFiles, inherit: key)
    }

    /// Alternate Permissions Files
    ///
    /// List of files to which the alternate owner, group and permissions are applied.
    public static func alternatePermissionsFiles(_ value: String...) -> BuildSetting { 
        .alternatePermissionsFiles(value)
    }
}

extension BuildSettingsKey {

    /// Alternate Permissions Files
    ///
    /// List of files to which the alternate owner, group and permissions are applied.
    public static let alternatePermissionsFiles: BuildSettingsKey = "ALTERNATE_PERMISSIONS_FILES"
}

// MARK: Always Search User Paths (Deprecated)
extension BuildSetting {

    /// Always Search User Paths (Deprecated)
    ///
    /// This setting is deprecated as of Xcode 8.3 and may not be supported in future versions. It is recommended that you disable the setting. If enabled, both `#include &lt;header.h&gt;`-style and `#include "header.h "`-style directives search the paths in [User Header Search Paths (USER_HEADER_SEARCH_PATHS)](itcaec37c2a6.html# deved642222b) before [Header Search Paths (HEADER_SEARCH_PATHS)](itcaec37c2a6.html# dev3c9f85d97). As a consequence, user headers, such as your own `String.h` header, have precedence over system headers when using `#include &lt;header.h&gt;`. This is done using the `-iquote` flag for the paths provided in [User Header Search Paths (USER_HEADER_SEARCH_PATHS)](itcaec37c2a6.html# deved642222b). If disabled and your compiler fully supports separate user paths, user headers are only accessible with `#include "header.h "`-style preprocessor directives. For backwards compatibility reasons, this setting is enabled by default. Disabling it is strongly recommended.
    public static var alwaysSearchUserPathsDeprecated: BuildSetting { 
        BuildSetting(key: .alwaysSearchUserPathsDeprecated, value: "YES")
    }

    /// Always Search User Paths (Deprecated)
    ///
    /// This setting is deprecated as of Xcode 8.3 and may not be supported in future versions. It is recommended that you disable the setting. If enabled, both `#include &lt;header.h&gt;`-style and `#include "header.h "`-style directives search the paths in [User Header Search Paths (USER_HEADER_SEARCH_PATHS)](itcaec37c2a6.html# deved642222b) before [Header Search Paths (HEADER_SEARCH_PATHS)](itcaec37c2a6.html# dev3c9f85d97). As a consequence, user headers, such as your own `String.h` header, have precedence over system headers when using `#include &lt;header.h&gt;`. This is done using the `-iquote` flag for the paths provided in [User Header Search Paths (USER_HEADER_SEARCH_PATHS)](itcaec37c2a6.html# deved642222b). If disabled and your compiler fully supports separate user paths, user headers are only accessible with `#include "header.h "`-style preprocessor directives. For backwards compatibility reasons, this setting is enabled by default. Disabling it is strongly recommended.
    public static func alwaysSearchUserPathsDeprecated(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .alwaysSearchUserPathsDeprecated, value: value.asText)
    }

    /// Always Search User Paths (Deprecated)
    ///
    /// This setting is deprecated as of Xcode 8.3 and may not be supported in future versions. It is recommended that you disable the setting. If enabled, both `#include &lt;header.h&gt;`-style and `#include "header.h "`-style directives search the paths in [User Header Search Paths (USER_HEADER_SEARCH_PATHS)](itcaec37c2a6.html# deved642222b) before [Header Search Paths (HEADER_SEARCH_PATHS)](itcaec37c2a6.html# dev3c9f85d97). As a consequence, user headers, such as your own `String.h` header, have precedence over system headers when using `#include &lt;header.h&gt;`. This is done using the `-iquote` flag for the paths provided in [User Header Search Paths (USER_HEADER_SEARCH_PATHS)](itcaec37c2a6.html# deved642222b). If disabled and your compiler fully supports separate user paths, user headers are only accessible with `#include "header.h "`-style preprocessor directives. For backwards compatibility reasons, this setting is enabled by default. Disabling it is strongly recommended.
    public static func alwaysSearchUserPathsDeprecated(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alwaysSearchUserPathsDeprecated, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Always Search User Paths (Deprecated)
    ///
    /// This setting is deprecated as of Xcode 8.3 and may not be supported in future versions. It is recommended that you disable the setting. If enabled, both `#include &lt;header.h&gt;`-style and `#include "header.h "`-style directives search the paths in [User Header Search Paths (USER_HEADER_SEARCH_PATHS)](itcaec37c2a6.html# deved642222b) before [Header Search Paths (HEADER_SEARCH_PATHS)](itcaec37c2a6.html# dev3c9f85d97). As a consequence, user headers, such as your own `String.h` header, have precedence over system headers when using `#include &lt;header.h&gt;`. This is done using the `-iquote` flag for the paths provided in [User Header Search Paths (USER_HEADER_SEARCH_PATHS)](itcaec37c2a6.html# deved642222b). If disabled and your compiler fully supports separate user paths, user headers are only accessible with `#include "header.h "`-style preprocessor directives. For backwards compatibility reasons, this setting is enabled by default. Disabling it is strongly recommended.
    public static let alwaysSearchUserPathsDeprecated: BuildSettingsKey = "ALWAYS_SEARCH_USER_PATHS"
}

// MARK: Require Only App-Extension-Safe API
extension BuildSetting {

    /// Require Only App-Extension-Safe API
    ///
    /// When enabled, this causes the compiler and linker to disallow use of APIs that are not available to app extensions and to disallow linking to frameworks that have not been built with this setting enabled.
    public static var requireOnlyAppExtensionSafeApi: BuildSetting { 
        BuildSetting(key: .requireOnlyAppExtensionSafeApi, value: "NO")
    }

    /// Require Only App-Extension-Safe API
    ///
    /// When enabled, this causes the compiler and linker to disallow use of APIs that are not available to app extensions and to disallow linking to frameworks that have not been built with this setting enabled.
    public static func requireOnlyAppExtensionSafeApi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .requireOnlyAppExtensionSafeApi, value: value.asText)
    }

    /// Require Only App-Extension-Safe API
    ///
    /// When enabled, this causes the compiler and linker to disallow use of APIs that are not available to app extensions and to disallow linking to frameworks that have not been built with this setting enabled.
    public static func requireOnlyAppExtensionSafeApi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .requireOnlyAppExtensionSafeApi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Require Only App-Extension-Safe API
    ///
    /// When enabled, this causes the compiler and linker to disallow use of APIs that are not available to app extensions and to disallow linking to frameworks that have not been built with this setting enabled.
    public static let requireOnlyAppExtensionSafeApi: BuildSettingsKey = "APPLICATION_EXTENSION_API_ONLY"
}

// MARK: Convert Copied Files
extension BuildSetting {

    /// Convert Copied Files
    ///
    /// Enabling this setting will cause files in the target’s Copy Files build phases to be processed by build rules. For example, property list files (`.plist`) and strings files will be converted as specified by [Property List Output Encoding (PLIST_FILE_OUTPUT_FORMAT)](itcaec37c2a6.html# dev70f6976ed) and [Strings File Output Encoding (STRINGS_FILE_OUTPUT_ENCODING)](itcaec37c2a6.html# dev8d71dff90), respectively.
    public static var convertCopiedFiles: BuildSetting { 
        BuildSetting(key: .convertCopiedFiles, value: "NO")
    }

    /// Convert Copied Files
    ///
    /// Enabling this setting will cause files in the target’s Copy Files build phases to be processed by build rules. For example, property list files (`.plist`) and strings files will be converted as specified by [Property List Output Encoding (PLIST_FILE_OUTPUT_FORMAT)](itcaec37c2a6.html# dev70f6976ed) and [Strings File Output Encoding (STRINGS_FILE_OUTPUT_ENCODING)](itcaec37c2a6.html# dev8d71dff90), respectively.
    public static func convertCopiedFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .convertCopiedFiles, value: value.asText)
    }

    /// Convert Copied Files
    ///
    /// Enabling this setting will cause files in the target’s Copy Files build phases to be processed by build rules. For example, property list files (`.plist`) and strings files will be converted as specified by [Property List Output Encoding (PLIST_FILE_OUTPUT_FORMAT)](itcaec37c2a6.html# dev70f6976ed) and [Strings File Output Encoding (STRINGS_FILE_OUTPUT_ENCODING)](itcaec37c2a6.html# dev8d71dff90), respectively.
    public static func convertCopiedFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .convertCopiedFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Convert Copied Files
    ///
    /// Enabling this setting will cause files in the target’s Copy Files build phases to be processed by build rules. For example, property list files (`.plist`) and strings files will be converted as specified by [Property List Output Encoding (PLIST_FILE_OUTPUT_FORMAT)](itcaec37c2a6.html# dev70f6976ed) and [Strings File Output Encoding (STRINGS_FILE_OUTPUT_ENCODING)](itcaec37c2a6.html# dev8d71dff90), respectively.
    public static let convertCopiedFiles: BuildSettingsKey = "APPLY_RULES_IN_COPY_FILES"
}

// MARK: Process Header Files
extension BuildSetting {

    /// Process Header Files
    ///
    /// Enabling this setting will cause all Public and Private headers in the target’s Copy Headers build phase to be processed by build rules. This allows custom build rules to be defined to process these headers. Custom script rules can define their outputs relative to `HEADER_OUTPUT_DIR`, which will be provided to that script, taking the header visibility into account. The scripts are also passed `SCRIPT_HEADER_VISIBILITY` (“public” or “private”). Files that should not be processed by build rules may need to be moved to a Copy Files build phase when this setting is enabled.
    public static var processHeaderFiles: BuildSetting { 
        BuildSetting(key: .processHeaderFiles, value: "NO")
    }

    /// Process Header Files
    ///
    /// Enabling this setting will cause all Public and Private headers in the target’s Copy Headers build phase to be processed by build rules. This allows custom build rules to be defined to process these headers. Custom script rules can define their outputs relative to `HEADER_OUTPUT_DIR`, which will be provided to that script, taking the header visibility into account. The scripts are also passed `SCRIPT_HEADER_VISIBILITY` (“public” or “private”). Files that should not be processed by build rules may need to be moved to a Copy Files build phase when this setting is enabled.
    public static func processHeaderFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .processHeaderFiles, value: value.asText)
    }

    /// Process Header Files
    ///
    /// Enabling this setting will cause all Public and Private headers in the target’s Copy Headers build phase to be processed by build rules. This allows custom build rules to be defined to process these headers. Custom script rules can define their outputs relative to `HEADER_OUTPUT_DIR`, which will be provided to that script, taking the header visibility into account. The scripts are also passed `SCRIPT_HEADER_VISIBILITY` (“public” or “private”). Files that should not be processed by build rules may need to be moved to a Copy Files build phase when this setting is enabled.
    public static func processHeaderFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .processHeaderFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Process Header Files
    ///
    /// Enabling this setting will cause all Public and Private headers in the target’s Copy Headers build phase to be processed by build rules. This allows custom build rules to be defined to process these headers. Custom script rules can define their outputs relative to `HEADER_OUTPUT_DIR`, which will be provided to that script, taking the header visibility into account. The scripts are also passed `SCRIPT_HEADER_VISIBILITY` (“public” or “private”). Files that should not be processed by build rules may need to be moved to a Copy Files build phase when this setting is enabled.
    public static let processHeaderFiles: BuildSettingsKey = "APPLY_RULES_IN_COPY_HEADERS"
}

// MARK: Architectures
extension BuildSetting {

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static var architectures: BuildSetting { 
        BuildSetting(key: .architectures, value: "$(ARCHS_STANDARD)")
    }

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static func architectures(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .architectures, value: .array(value))
    }

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static func architectures(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .architectures, inherit: key)
    }

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static func architectures(_ value: String...) -> BuildSetting { 
        .architectures(value)
    }
}

extension BuildSettingsKey {

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static let architectures: BuildSettingsKey = "ARCHS"
}

// MARK: Asset Pack Manifest URL Prefix
extension BuildSetting {

    /// Asset Pack Manifest URL Prefix
    ///
    /// If set to anything other than the empty string, every URL in the `AssetPackManifest.plist` file will consist of this string with the name of the asset pack appended. If not set, the URLs in the `AssetPackManifest.plist` will be formed as appropriate for the build location of the asset packs. The prefix string is not escaped or quoted in any way, so any necessary escaping must be part of the URL string. This setting affects only URLs in the `AssetPackManifest.plist` file — it does not affect where asset packs are built in the local file system.
    public static func assetPackManifestUrlPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetPackManifestUrlPrefix, value: \(value))
    }

    /// Asset Pack Manifest URL Prefix
    ///
    /// If set to anything other than the empty string, every URL in the `AssetPackManifest.plist` file will consist of this string with the name of the asset pack appended. If not set, the URLs in the `AssetPackManifest.plist` will be formed as appropriate for the build location of the asset packs. The prefix string is not escaped or quoted in any way, so any necessary escaping must be part of the URL string. This setting affects only URLs in the `AssetPackManifest.plist` file — it does not affect where asset packs are built in the local file system.
    public static func assetPackManifestUrlPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetPackManifestUrlPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Asset Pack Manifest URL Prefix
    ///
    /// If set to anything other than the empty string, every URL in the `AssetPackManifest.plist` file will consist of this string with the name of the asset pack appended. If not set, the URLs in the `AssetPackManifest.plist` will be formed as appropriate for the build location of the asset packs. The prefix string is not escaped or quoted in any way, so any necessary escaping must be part of the URL string. This setting affects only URLs in the `AssetPackManifest.plist` file — it does not affect where asset packs are built in the local file system.
    public static let assetPackManifestUrlPrefix: BuildSettingsKey = "ASSET_PACK_MANIFEST_URL_PREFIX"
}

// MARK: Bitcode Generation Mode
extension BuildSetting {

    /// Bitcode Generation Mode
    public static var bitcodeGenerationMode: BuildSetting { 
        .bitcodeGenerationMode(.marker) 
    }

    /// Bitcode Generation Mode
    public static func bitcodeGenerationMode(_ value: BitcodeGenerationMode) -> BuildSetting { 
        BuildSetting(key: .bitcodeGenerationMode, value: \(value))
    }

    /// Bitcode Generation Mode
    public static func bitcodeGenerationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bitcodeGenerationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bitcode Generation Mode
    public static let bitcodeGenerationMode: BuildSettingsKey = "BITCODE_GENERATION_MODE"
}

public enum BitcodeGenerationMode: String, Hashable, Codable, CustomStringConvertible {
    case bitcode = "bitcode"
    case marker = "marker"

    public var description: String {
        rawValue
    }
}

// MARK: Build Active Resources Only
extension BuildSetting {

    /// Build Active Resources Only
    public static var buildActiveResourcesOnly: BuildSetting { 
        BuildSetting(key: .buildActiveResourcesOnly, value: "NO")
    }

    /// Build Active Resources Only
    public static func buildActiveResourcesOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .buildActiveResourcesOnly, value: value.asText)
    }

    /// Build Active Resources Only
    public static func buildActiveResourcesOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildActiveResourcesOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Active Resources Only
    public static let buildActiveResourcesOnly: BuildSettingsKey = "BUILD_ACTIVE_RESOURCES_ONLY"
}

// MARK: Active Build Components
extension BuildSetting {

    /// Active Build Components
    ///
    /// A list of components being built during this action.
    public static func activeBuildComponents(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .activeBuildComponents, value: .array(value))
    }

    /// Active Build Components
    ///
    /// A list of components being built during this action.
    public static func activeBuildComponents(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .activeBuildComponents, inherit: key)
    }

    /// Active Build Components
    ///
    /// A list of components being built during this action.
    public static func activeBuildComponents(_ value: String...) -> BuildSetting { 
        .activeBuildComponents(value)
    }
}

extension BuildSettingsKey {

    /// Active Build Components
    ///
    /// A list of components being built during this action.
    public static let activeBuildComponents: BuildSettingsKey = "BUILD_COMPONENTS"
}

// MARK: Build Dir
extension BuildSetting {

    /// Build Dir
    public static var buildDir: BuildSetting { 
        .buildDir(inherit: .buildProductsPath) 
    }

    /// Build Dir
    public static func buildDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .buildDir, value: \(value))
    }

    /// Build Dir
    public static func buildDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Dir
    public static let buildDir: BuildSettingsKey = "BUILD_DIR"
}

// MARK: Build Libraries for Distribution
extension BuildSetting {

    /// Build Libraries for Distribution
    ///
    /// Ensures that your libraries are built for distribution. For Swift, this enables support for library evolution and generation of a module interface file.
    public static var buildLibrariesForDistribution: BuildSetting { 
        BuildSetting(key: .buildLibrariesForDistribution, value: "NO")
    }

    /// Build Libraries for Distribution
    ///
    /// Ensures that your libraries are built for distribution. For Swift, this enables support for library evolution and generation of a module interface file.
    public static func buildLibrariesForDistribution(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .buildLibrariesForDistribution, value: value.asText)
    }

    /// Build Libraries for Distribution
    ///
    /// Ensures that your libraries are built for distribution. For Swift, this enables support for library evolution and generation of a module interface file.
    public static func buildLibrariesForDistribution(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildLibrariesForDistribution, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Libraries for Distribution
    ///
    /// Ensures that your libraries are built for distribution. For Swift, this enables support for library evolution and generation of a module interface file.
    public static let buildLibrariesForDistribution: BuildSettingsKey = "BUILD_LIBRARY_FOR_DISTRIBUTION"
}

// MARK: Build Root
extension BuildSetting {

    /// Build Root
    public static var buildRoot: BuildSetting { 
        .buildRoot(inherit: .buildProductsPath) 
    }

    /// Build Root
    public static func buildRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .buildRoot, value: \(value))
    }

    /// Build Root
    public static func buildRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Root
    public static let buildRoot: BuildSettingsKey = "BUILD_ROOT"
}

// MARK: Build Style
extension BuildSetting {

    /// Build Style
    public static func buildStyle(_ value: String) -> BuildSetting { 
        BuildSetting(key: .buildStyle, value: \(value))
    }

    /// Build Style
    public static func buildStyle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildStyle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Style
    public static let buildStyle: BuildSettingsKey = "BUILD_STYLE"
}

// MARK: Build Variants
extension BuildSetting {

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static var buildVariants: BuildSetting { 
        BuildSetting(key: .buildVariants, value: "normal")
    }

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static func buildVariants(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .buildVariants, value: .array(value))
    }

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static func buildVariants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildVariants, inherit: key)
    }

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static func buildVariants(_ value: String...) -> BuildSetting { 
        .buildVariants(value)
    }
}

extension BuildSettingsKey {

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static let buildVariants: BuildSettingsKey = "BUILD_VARIANTS"
}

// MARK: Built Products Dir
extension BuildSetting {

    /// Built Products Dir
    ///
    /// Identifies the directory under which all the product’s files can be found. This directory contains either product files or symbolic links to them. Run Script build phases can use the value of this build setting as a convenient way to refer to the product files built by one or more targets even when these files are scattered throughout a directory hierarchy (for example, when `DEPLOYMENT_LOCATION` is set to `YES`.
    public static var builtProductsDir: BuildSetting { 
        .builtProductsDir(inherit: .perConfigurationBuildProductsPath) 
    }

    /// Built Products Dir
    ///
    /// Identifies the directory under which all the product’s files can be found. This directory contains either product files or symbolic links to them. Run Script build phases can use the value of this build setting as a convenient way to refer to the product files built by one or more targets even when these files are scattered throughout a directory hierarchy (for example, when `DEPLOYMENT_LOCATION` is set to `YES`.
    public static func builtProductsDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .builtProductsDir, value: \(value))
    }

    /// Built Products Dir
    ///
    /// Identifies the directory under which all the product’s files can be found. This directory contains either product files or symbolic links to them. Run Script build phases can use the value of this build setting as a convenient way to refer to the product files built by one or more targets even when these files are scattered throughout a directory hierarchy (for example, when `DEPLOYMENT_LOCATION` is set to `YES`.
    public static func builtProductsDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .builtProductsDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Built Products Dir
    ///
    /// Identifies the directory under which all the product’s files can be found. This directory contains either product files or symbolic links to them. Run Script build phases can use the value of this build setting as a convenient way to refer to the product files built by one or more targets even when these files are scattered throughout a directory hierarchy (for example, when `DEPLOYMENT_LOCATION` is set to `YES`.
    public static let builtProductsDir: BuildSettingsKey = "BUILT_PRODUCTS_DIR"
}

// MARK: Bundle Contents Folder Path
extension BuildSetting {

    /// Bundle Contents Folder Path
    public static var bundleContentsFolderPath: BuildSetting { 
        BuildSetting(key: .bundleContentsFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH_$(BUNDLE_FORMAT))")
    }

    /// Bundle Contents Folder Path
    public static func bundleContentsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleContentsFolderPath, value: \(value))
    }

    /// Bundle Contents Folder Path
    public static func bundleContentsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleContentsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bundle Contents Folder Path
    public static let bundleContentsFolderPath: BuildSettingsKey = "BUNDLE_CONTENTS_FOLDER_PATH"
}

// MARK: Bundle Executable Folder Path
extension BuildSetting {

    /// Bundle Executable Folder Path
    public static var bundleExecutableFolderPath: BuildSetting { 
        BuildSetting(key: .bundleExecutableFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)$(BUNDLE_EXECUTABLE_FOLDER_NAME_$(BUNDLE_FORMAT))")
    }

    /// Bundle Executable Folder Path
    public static func bundleExecutableFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleExecutableFolderPath, value: \(value))
    }

    /// Bundle Executable Folder Path
    public static func bundleExecutableFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleExecutableFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bundle Executable Folder Path
    public static let bundleExecutableFolderPath: BuildSettingsKey = "BUNDLE_EXECUTABLE_FOLDER_PATH"
}

// MARK: Bundle Format
extension BuildSetting {

    /// Bundle Format
    public static var bundleFormat: BuildSetting { 
        .bundleFormat(.shallow) 
    }

    /// Bundle Format
    public static func bundleFormat(_ value: BundleFormat) -> BuildSetting { 
        BuildSetting(key: .bundleFormat, value: \(value))
    }

    /// Bundle Format
    public static func bundleFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bundle Format
    public static let bundleFormat: BuildSettingsKey = "BUNDLE_FORMAT"
}

public enum BundleFormat: String, Hashable, Codable, CustomStringConvertible {
    case deep = "deep"
    case shallow = "shallow"

    public var description: String {
        rawValue
    }
}

// MARK: Bundle Frameworks Folder Path
extension BuildSetting {

    /// Bundle Frameworks Folder Path
    public static var bundleFrameworksFolderPath: BuildSetting { 
        BuildSetting(key: .bundleFrameworksFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)Frameworks")
    }

    /// Bundle Frameworks Folder Path
    public static func bundleFrameworksFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleFrameworksFolderPath, value: \(value))
    }

    /// Bundle Frameworks Folder Path
    public static func bundleFrameworksFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleFrameworksFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bundle Frameworks Folder Path
    public static let bundleFrameworksFolderPath: BuildSettingsKey = "BUNDLE_FRAMEWORKS_FOLDER_PATH"
}

// MARK: Bundle Loader
extension BuildSetting {

    /// Bundle Loader
    ///
    /// Specifies the executable that will load the bundle output file being linked. Undefined symbols from the bundle are checked against the specified executable as if it is one of the dynamic libraries the bundle was linked with.
    public static func bundleLoader(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleLoader, value: \(value))
    }

    /// Bundle Loader
    ///
    /// Specifies the executable that will load the bundle output file being linked. Undefined symbols from the bundle are checked against the specified executable as if it is one of the dynamic libraries the bundle was linked with.
    public static func bundleLoader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleLoader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bundle Loader
    ///
    /// Specifies the executable that will load the bundle output file being linked. Undefined symbols from the bundle are checked against the specified executable as if it is one of the dynamic libraries the bundle was linked with.
    public static let bundleLoader: BuildSettingsKey = "BUNDLE_LOADER"
}

// MARK: Bundle Plugins Folder Path
extension BuildSetting {

    /// Bundle Plugins Folder Path
    public static var bundlePluginsFolderPath: BuildSetting { 
        BuildSetting(key: .bundlePluginsFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)PlugIns")
    }

    /// Bundle Plugins Folder Path
    public static func bundlePluginsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundlePluginsFolderPath, value: \(value))
    }

    /// Bundle Plugins Folder Path
    public static func bundlePluginsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundlePluginsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bundle Plugins Folder Path
    public static let bundlePluginsFolderPath: BuildSettingsKey = "BUNDLE_PLUGINS_FOLDER_PATH"
}

// MARK: Bundle Private Headers Folder Path
extension BuildSetting {

    /// Bundle Private Headers Folder Path
    public static var bundlePrivateHeadersFolderPath: BuildSetting { 
        BuildSetting(key: .bundlePrivateHeadersFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)PrivateHeaders")
    }

    /// Bundle Private Headers Folder Path
    public static func bundlePrivateHeadersFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundlePrivateHeadersFolderPath, value: \(value))
    }

    /// Bundle Private Headers Folder Path
    public static func bundlePrivateHeadersFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundlePrivateHeadersFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bundle Private Headers Folder Path
    public static let bundlePrivateHeadersFolderPath: BuildSettingsKey = "BUNDLE_PRIVATE_HEADERS_FOLDER_PATH"
}

// MARK: Bundle Public Headers Folder Path
extension BuildSetting {

    /// Bundle Public Headers Folder Path
    public static var bundlePublicHeadersFolderPath: BuildSetting { 
        BuildSetting(key: .bundlePublicHeadersFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)Headers")
    }

    /// Bundle Public Headers Folder Path
    public static func bundlePublicHeadersFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundlePublicHeadersFolderPath, value: \(value))
    }

    /// Bundle Public Headers Folder Path
    public static func bundlePublicHeadersFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundlePublicHeadersFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bundle Public Headers Folder Path
    public static let bundlePublicHeadersFolderPath: BuildSettingsKey = "BUNDLE_PUBLIC_HEADERS_FOLDER_PATH"
}

// MARK: Cc
extension BuildSetting {

    /// Cc
    public static func cc(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cc, value: \(value))
    }

    /// Cc
    public static func cc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cc
    public static let cc: BuildSettingsKey = "CC"
}

// MARK: Class File Dir
extension BuildSetting {

    /// Class File Dir
    public static var classFileDir: BuildSetting { 
        BuildSetting(key: .classFileDir, value: "$(TARGET_TEMP_DIR)/JavaClasses")
    }

    /// Class File Dir
    public static func classFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .classFileDir, value: \(value))
    }

    /// Class File Dir
    public static func classFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .classFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Class File Dir
    public static let classFileDir: BuildSettingsKey = "CLASS_FILE_DIR"
}

// MARK: Clone Headers
extension BuildSetting {

    /// Clone Headers
    public static var cloneHeaders: BuildSetting { 
        BuildSetting(key: .cloneHeaders, value: "NO")
    }

    /// Clone Headers
    public static func cloneHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .cloneHeaders, value: value.asText)
    }

    /// Clone Headers
    public static func cloneHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cloneHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clone Headers
    public static let cloneHeaders: BuildSettingsKey = "CLONE_HEADERS"
}

// MARK: Code Signing Allowed
extension BuildSetting {

    /// Code Signing Allowed
    public static var codeSigningAllowed: BuildSetting { 
        BuildSetting(key: .codeSigningAllowed, value: "NO")
    }

    /// Code Signing Allowed
    public static func codeSigningAllowed(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .codeSigningAllowed, value: value.asText)
    }

    /// Code Signing Allowed
    public static func codeSigningAllowed(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSigningAllowed, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Signing Allowed
    public static let codeSigningAllowed: BuildSettingsKey = "CODE_SIGNING_ALLOWED"
}

// MARK: Code Signing Entitlements
extension BuildSetting {

    /// Code Signing Entitlements
    ///
    /// The path to a file specifying code-signing entitlements.
    public static func codeSigningEntitlements(_ value: String) -> BuildSetting { 
        BuildSetting(key: .codeSigningEntitlements, value: \(value))
    }

    /// Code Signing Entitlements
    ///
    /// The path to a file specifying code-signing entitlements.
    public static func codeSigningEntitlements(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSigningEntitlements, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Signing Entitlements
    ///
    /// The path to a file specifying code-signing entitlements.
    public static let codeSigningEntitlements: BuildSettingsKey = "CODE_SIGN_ENTITLEMENTS"
}

// MARK: Code Signing Identity
extension BuildSetting {

    /// Code Signing Identity
    ///
    /// The name, also known as the **common name**, of a valid code-signing certificate in a keychain within your keychain path. A missing or invalid certificate will cause a build error.
    public static func codeSigningIdentity(_ value: CodeSignIdentity) -> BuildSetting { 
        BuildSetting(key: .codeSigningIdentity, value: \(value))
    }

    /// Code Signing Identity
    ///
    /// The name, also known as the **common name**, of a valid code-signing certificate in a keychain within your keychain path. A missing or invalid certificate will cause a build error.
    public static func codeSigningIdentity(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSigningIdentity, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Signing Identity
    ///
    /// The name, also known as the **common name**, of a valid code-signing certificate in a keychain within your keychain path. A missing or invalid certificate will cause a build error.
    public static let codeSigningIdentity: BuildSettingsKey = "CODE_SIGN_IDENTITY"
}

// MARK: Code Signing Inject Base Entitlements
extension BuildSetting {

    /// Code Signing Inject Base Entitlements
    ///
    /// Automatically inject entitlements from the platform’s BaseEntitlements.plist into the code signatures of executables.
    public static var codeSigningInjectBaseEntitlements: BuildSetting { 
        BuildSetting(key: .codeSigningInjectBaseEntitlements, value: "YES")
    }

    /// Code Signing Inject Base Entitlements
    ///
    /// Automatically inject entitlements from the platform’s BaseEntitlements.plist into the code signatures of executables.
    public static func codeSigningInjectBaseEntitlements(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .codeSigningInjectBaseEntitlements, value: value.asText)
    }

    /// Code Signing Inject Base Entitlements
    ///
    /// Automatically inject entitlements from the platform’s BaseEntitlements.plist into the code signatures of executables.
    public static func codeSigningInjectBaseEntitlements(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSigningInjectBaseEntitlements, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Signing Inject Base Entitlements
    ///
    /// Automatically inject entitlements from the platform’s BaseEntitlements.plist into the code signatures of executables.
    public static let codeSigningInjectBaseEntitlements: BuildSettingsKey = "CODE_SIGN_INJECT_BASE_ENTITLEMENTS"
}

// MARK: Code Sign Local Execution Identity
extension BuildSetting {

    /// Code Sign Local Execution Identity
    public static func codeSignLocalExecutionIdentity(_ value: CodeSignLocalExecutionIdentity) -> BuildSetting { 
        BuildSetting(key: .codeSignLocalExecutionIdentity, value: \(value))
    }

    /// Code Sign Local Execution Identity
    public static func codeSignLocalExecutionIdentity(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSignLocalExecutionIdentity, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Sign Local Execution Identity
    public static let codeSignLocalExecutionIdentity: BuildSettingsKey = "CODE_SIGN_LOCAL_EXECUTION_IDENTITY"
}

public enum CodeSignLocalExecutionIdentity: String, Hashable, Codable, CustomStringConvertible {
    case adHoc = "Ad Hoc"
    case localCertificate = "Local Certificate"

    public var description: String {
        rawValue
    }
}

// MARK: Code Sign Style
extension BuildSetting {

    /// Code Sign Style
    ///
    /// This setting specifies the method used to acquire and locate signing assets. Choose `Automatic` to let Xcode automatically create and update profiles, app IDs, and certificates. Choose `Manual` to create and update these yourself on the developer website.
    public static func codeSignStyle(_ value: CodeSignStyle) -> BuildSetting { 
        BuildSetting(key: .codeSignStyle, value: \(value))
    }

    /// Code Sign Style
    ///
    /// This setting specifies the method used to acquire and locate signing assets. Choose `Automatic` to let Xcode automatically create and update profiles, app IDs, and certificates. Choose `Manual` to create and update these yourself on the developer website.
    public static func codeSignStyle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSignStyle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Sign Style
    ///
    /// This setting specifies the method used to acquire and locate signing assets. Choose `Automatic` to let Xcode automatically create and update profiles, app IDs, and certificates. Choose `Manual` to create and update these yourself on the developer website.
    public static let codeSignStyle: BuildSettingsKey = "CODE_SIGN_STYLE"
}

public enum CodeSignStyle: String, Hashable, Codable, CustomStringConvertible {
    case automatic = "Automatic"
    case manual = "Manual"

    public var description: String {
        rawValue
    }
}

// MARK: Color Diagnostics
extension BuildSetting {

    /// Color Diagnostics
    public static var colorDiagnostics: BuildSetting { 
        BuildSetting(key: .colorDiagnostics, value: "NO")
    }

    /// Color Diagnostics
    public static func colorDiagnostics(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .colorDiagnostics, value: value.asText)
    }

    /// Color Diagnostics
    public static func colorDiagnostics(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .colorDiagnostics, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Color Diagnostics
    public static let colorDiagnostics: BuildSettingsKey = "COLOR_DIAGNOSTICS"
}

// MARK: Enable Index-While-Building Functionality
extension BuildSetting {

    /// Enable Index-While-Building Functionality
    ///
    /// Control whether the compiler should emit index data while building.
    public static var enableIndexWhileBuildingFunctionality: BuildSetting { 
        .enableIndexWhileBuildingFunctionality(.default) 
    }

    /// Enable Index-While-Building Functionality
    ///
    /// Control whether the compiler should emit index data while building.
    public static func enableIndexWhileBuildingFunctionality(_ value: EnableIndexWhileBuildingFunctionality) -> BuildSetting { 
        BuildSetting(key: .enableIndexWhileBuildingFunctionality, value: \(value))
    }

    /// Enable Index-While-Building Functionality
    ///
    /// Control whether the compiler should emit index data while building.
    public static func enableIndexWhileBuildingFunctionality(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableIndexWhileBuildingFunctionality, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Index-While-Building Functionality
    ///
    /// Control whether the compiler should emit index data while building.
    public static let enableIndexWhileBuildingFunctionality: BuildSettingsKey = "COMPILER_INDEX_STORE_ENABLE"
}

public enum EnableIndexWhileBuildingFunctionality: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case `default` = "Default"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Configuration
extension BuildSetting {

    /// Configuration
    ///
    /// Identifies the build configuration, such as `Debug` or `Release`, that the target uses to generate the product.
    public static func configuration(_ value: String) -> BuildSetting { 
        BuildSetting(key: .configuration, value: \(value))
    }

    /// Configuration
    ///
    /// Identifies the build configuration, such as `Debug` or `Release`, that the target uses to generate the product.
    public static func configuration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .configuration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Configuration
    ///
    /// Identifies the build configuration, such as `Debug` or `Release`, that the target uses to generate the product.
    public static let configuration: BuildSettingsKey = "CONFIGURATION"
}

// MARK: Per-configuration Build Products Path
extension BuildSetting {

    /// Per-configuration Build Products Path
    ///
    /// The base path where build products will be placed during a build for a given configuration. By default, this is set to `$(BUILD_DIR)/$(CONFIGURATION)`.
    public static var perConfigurationBuildProductsPath: BuildSetting { 
        .perConfigurationBuildProductsPath(inherit: .buildDir) 
    }

    /// Per-configuration Build Products Path
    ///
    /// The base path where build products will be placed during a build for a given configuration. By default, this is set to `$(BUILD_DIR)/$(CONFIGURATION)`.
    public static func perConfigurationBuildProductsPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .perConfigurationBuildProductsPath, value: \(value))
    }

    /// Per-configuration Build Products Path
    ///
    /// The base path where build products will be placed during a build for a given configuration. By default, this is set to `$(BUILD_DIR)/$(CONFIGURATION)`.
    public static func perConfigurationBuildProductsPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .perConfigurationBuildProductsPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Per-configuration Build Products Path
    ///
    /// The base path where build products will be placed during a build for a given configuration. By default, this is set to `$(BUILD_DIR)/$(CONFIGURATION)`.
    public static let perConfigurationBuildProductsPath: BuildSettingsKey = "CONFIGURATION_BUILD_DIR"
}

// MARK: Per-configuration Intermediate Build Files Path
extension BuildSetting {

    /// Per-configuration Intermediate Build Files Path
    ///
    /// The base path where intermediates will be placed during a build for a given configuration. By default, this is set to `$(PROJECT_TEMP_DIR)/$(CONFIGURATION)`.
    public static var perConfigurationIntermediateBuildFilesPath: BuildSetting { 
        .perConfigurationIntermediateBuildFilesPath(inherit: .projectTempDir) 
    }

    /// Per-configuration Intermediate Build Files Path
    ///
    /// The base path where intermediates will be placed during a build for a given configuration. By default, this is set to `$(PROJECT_TEMP_DIR)/$(CONFIGURATION)`.
    public static func perConfigurationIntermediateBuildFilesPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .perConfigurationIntermediateBuildFilesPath, value: \(value))
    }

    /// Per-configuration Intermediate Build Files Path
    ///
    /// The base path where intermediates will be placed during a build for a given configuration. By default, this is set to `$(PROJECT_TEMP_DIR)/$(CONFIGURATION)`.
    public static func perConfigurationIntermediateBuildFilesPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .perConfigurationIntermediateBuildFilesPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Per-configuration Intermediate Build Files Path
    ///
    /// The base path where intermediates will be placed during a build for a given configuration. By default, this is set to `$(PROJECT_TEMP_DIR)/$(CONFIGURATION)`.
    public static let perConfigurationIntermediateBuildFilesPath: BuildSettingsKey = "CONFIGURATION_TEMP_DIR"
}

// MARK: Preserve HFS Data
extension BuildSetting {

    /// Preserve HFS Data
    ///
    /// Causes the copying of resources to preserve resource forks and Finder info.
    public static var preserveHfsData: BuildSetting { 
        BuildSetting(key: .preserveHfsData, value: "NO")
    }

    /// Preserve HFS Data
    ///
    /// Causes the copying of resources to preserve resource forks and Finder info.
    public static func preserveHfsData(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .preserveHfsData, value: value.asText)
    }

    /// Preserve HFS Data
    ///
    /// Causes the copying of resources to preserve resource forks and Finder info.
    public static func preserveHfsData(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preserveHfsData, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Preserve HFS Data
    ///
    /// Causes the copying of resources to preserve resource forks and Finder info.
    public static let preserveHfsData: BuildSettingsKey = "COPYING_PRESERVES_HFS_DATA"
}

// MARK: Run unifdef on Product Headers
extension BuildSetting {

    /// Run unifdef on Product Headers
    ///
    /// If enabled, headers are run through the `unifdef(1)` tool when copied to the product.
    public static var runUnifdefOnProductHeaders: BuildSetting { 
        BuildSetting(key: .runUnifdefOnProductHeaders, value: "NO")
    }

    /// Run unifdef on Product Headers
    ///
    /// If enabled, headers are run through the `unifdef(1)` tool when copied to the product.
    public static func runUnifdefOnProductHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .runUnifdefOnProductHeaders, value: value.asText)
    }

    /// Run unifdef on Product Headers
    ///
    /// If enabled, headers are run through the `unifdef(1)` tool when copied to the product.
    public static func runUnifdefOnProductHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .runUnifdefOnProductHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Run unifdef on Product Headers
    ///
    /// If enabled, headers are run through the `unifdef(1)` tool when copied to the product.
    public static let runUnifdefOnProductHeaders: BuildSettingsKey = "COPY_HEADERS_RUN_UNIFDEF"
}

// MARK: Unifdef Flags for Product Headers
extension BuildSetting {

    /// Unifdef Flags for Product Headers
    ///
    /// Specifies the flags to pass to `unifdef(1)` when invoking that tool to copy headers. This setting has no effect unless [Run unifdef on Product Headers (COPY_HEADERS_RUN_UNIFDEF)](itcaec37c2a6.html# devc2606cc19) is enabled.
    public static func unifdefFlagsForProductHeaders(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .unifdefFlagsForProductHeaders, value: .array(value))
    }

    /// Unifdef Flags for Product Headers
    ///
    /// Specifies the flags to pass to `unifdef(1)` when invoking that tool to copy headers. This setting has no effect unless [Run unifdef on Product Headers (COPY_HEADERS_RUN_UNIFDEF)](itcaec37c2a6.html# devc2606cc19) is enabled.
    public static func unifdefFlagsForProductHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unifdefFlagsForProductHeaders, inherit: key)
    }

    /// Unifdef Flags for Product Headers
    ///
    /// Specifies the flags to pass to `unifdef(1)` when invoking that tool to copy headers. This setting has no effect unless [Run unifdef on Product Headers (COPY_HEADERS_RUN_UNIFDEF)](itcaec37c2a6.html# devc2606cc19) is enabled.
    public static func unifdefFlagsForProductHeaders(_ value: String...) -> BuildSetting { 
        .unifdefFlagsForProductHeaders(value)
    }
}

extension BuildSettingsKey {

    /// Unifdef Flags for Product Headers
    ///
    /// Specifies the flags to pass to `unifdef(1)` when invoking that tool to copy headers. This setting has no effect unless [Run unifdef on Product Headers (COPY_HEADERS_RUN_UNIFDEF)](itcaec37c2a6.html# devc2606cc19) is enabled.
    public static let unifdefFlagsForProductHeaders: BuildSettingsKey = "COPY_HEADERS_UNIFDEF_FLAGS"
}

// MARK: Strip Debug Symbols During Copy
extension BuildSetting {

    /// Strip Debug Symbols During Copy
    ///
    /// Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be stripped—use [Strip Linked Product (STRIP_INSTALLED_PRODUCT)](itcaec37c2a6.html# dev5c0105d2a) for that.
    public static var stripDebugSymbolsDuringCopy: BuildSetting { 
        BuildSetting(key: .stripDebugSymbolsDuringCopy, value: "YES")
    }

    /// Strip Debug Symbols During Copy
    ///
    /// Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be stripped—use [Strip Linked Product (STRIP_INSTALLED_PRODUCT)](itcaec37c2a6.html# dev5c0105d2a) for that.
    public static func stripDebugSymbolsDuringCopy(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripDebugSymbolsDuringCopy, value: value.asText)
    }

    /// Strip Debug Symbols During Copy
    ///
    /// Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be stripped—use [Strip Linked Product (STRIP_INSTALLED_PRODUCT)](itcaec37c2a6.html# dev5c0105d2a) for that.
    public static func stripDebugSymbolsDuringCopy(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripDebugSymbolsDuringCopy, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Debug Symbols During Copy
    ///
    /// Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be stripped—use [Strip Linked Product (STRIP_INSTALLED_PRODUCT)](itcaec37c2a6.html# dev5c0105d2a) for that.
    public static let stripDebugSymbolsDuringCopy: BuildSettingsKey = "COPY_PHASE_STRIP"
}

// MARK: Create Info.plist Section in Binary
extension BuildSetting {

    /// Create Info.plist Section in Binary
    ///
    /// Enabling this setting will create a section in the product’s linked binary containing the processed `Info.plist` file for the target. This setting only applies to command-line tool targets.
    public static var createInfoPlistSectionInBinary: BuildSetting { 
        BuildSetting(key: .createInfoPlistSectionInBinary, value: "NO")
    }

    /// Create Info.plist Section in Binary
    ///
    /// Enabling this setting will create a section in the product’s linked binary containing the processed `Info.plist` file for the target. This setting only applies to command-line tool targets.
    public static func createInfoPlistSectionInBinary(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .createInfoPlistSectionInBinary, value: value.asText)
    }

    /// Create Info.plist Section in Binary
    ///
    /// Enabling this setting will create a section in the product’s linked binary containing the processed `Info.plist` file for the target. This setting only applies to command-line tool targets.
    public static func createInfoPlistSectionInBinary(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .createInfoPlistSectionInBinary, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Create Info.plist Section in Binary
    ///
    /// Enabling this setting will create a section in the product’s linked binary containing the processed `Info.plist` file for the target. This setting only applies to command-line tool targets.
    public static let createInfoPlistSectionInBinary: BuildSettingsKey = "CREATE_INFOPLIST_SECTION_IN_BINARY"
}

// MARK: Current Project Version
extension BuildSetting {

    /// Current Project Version
    ///
    /// This setting defines the current version of the project. The value must be a integer or floating point number, such as `57` or `365.8`.
    public static func currentProjectVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentProjectVersion, value: \(value))
    }

    /// Current Project Version
    ///
    /// This setting defines the current version of the project. The value must be a integer or floating point number, such as `57` or `365.8`.
    public static func currentProjectVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentProjectVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Current Project Version
    ///
    /// This setting defines the current version of the project. The value must be a integer or floating point number, such as `57` or `365.8`.
    public static let currentProjectVersion: BuildSettingsKey = "CURRENT_PROJECT_VERSION"
}

// MARK: Current Version
extension BuildSetting {

    /// Current Version
    public static func currentVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentVersion, value: \(value))
    }

    /// Current Version
    public static func currentVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Current Version
    public static let currentVersion: BuildSettingsKey = "CURRENT_VERSION"
}

// MARK: Dead Code Stripping
extension BuildSetting {

    /// Dead Code Stripping
    ///
    /// Activating this setting causes the `-dead_strip` flag to be passed to `ld(1)` via `cc(1)` to turn on dead code stripping.
    public static var deadCodeStripping: BuildSetting { 
        BuildSetting(key: .deadCodeStripping, value: "NO")
    }

    /// Dead Code Stripping
    ///
    /// Activating this setting causes the `-dead_strip` flag to be passed to `ld(1)` via `cc(1)` to turn on dead code stripping.
    public static func deadCodeStripping(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deadCodeStripping, value: value.asText)
    }

    /// Dead Code Stripping
    ///
    /// Activating this setting causes the `-dead_strip` flag to be passed to `ld(1)` via `cc(1)` to turn on dead code stripping.
    public static func deadCodeStripping(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deadCodeStripping, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dead Code Stripping
    ///
    /// Activating this setting causes the `-dead_strip` flag to be passed to `ld(1)` via `cc(1)` to turn on dead code stripping.
    public static let deadCodeStripping: BuildSettingsKey = "DEAD_CODE_STRIPPING"
}

// MARK: Debugging Symbols
extension BuildSetting {

    /// Debugging Symbols
    public static var debuggingSymbols: BuildSetting { 
        BuildSetting(key: .debuggingSymbols, value: "YES")
    }

    /// Debugging Symbols
    public static func debuggingSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .debuggingSymbols, value: value.asText)
    }

    /// Debugging Symbols
    public static func debuggingSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .debuggingSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Debugging Symbols
    public static let debuggingSymbols: BuildSettingsKey = "DEBUGGING_SYMBOLS"
}

// MARK: Debug Information Format
extension BuildSetting {

    /// Debug Information Format
    ///
    /// The type of debug information to produce.
    public static var debugInformationFormat: BuildSetting { 
        .debugInformationFormat(.dwarf) 
    }

    /// Debug Information Format
    ///
    /// The type of debug information to produce.
    public static func debugInformationFormat(_ value: DebugInformationFormat) -> BuildSetting { 
        BuildSetting(key: .debugInformationFormat, value: \(value))
    }

    /// Debug Information Format
    ///
    /// The type of debug information to produce.
    public static func debugInformationFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .debugInformationFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Debug Information Format
    ///
    /// The type of debug information to produce.
    public static let debugInformationFormat: BuildSettingsKey = "DEBUG_INFORMATION_FORMAT"
}

public enum DebugInformationFormat: String, Hashable, Codable, CustomStringConvertible {
    case dwarfWithDsym = "dwarf-with-dsym"
    case dwarf = "dwarf"

    public var description: String {
        rawValue
    }
}

// MARK: Default Compiler
extension BuildSetting {

    /// Default Compiler
    public static func defaultCompiler(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultCompiler, value: \(value))
    }

    /// Default Compiler
    public static func defaultCompiler(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultCompiler, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Default Compiler
    public static let defaultCompiler: BuildSettingsKey = "DEFAULT_COMPILER"
}

// MARK: Default Dext Install Path
extension BuildSetting {

    /// Default Dext Install Path
    public static var defaultDextInstallPath: BuildSetting { 
        .defaultDextInstallPath(inherit: .systemDextInstallPath) 
    }

    /// Default Dext Install Path
    public static func defaultDextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultDextInstallPath, value: \(value))
    }

    /// Default Dext Install Path
    public static func defaultDextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultDextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Default Dext Install Path
    public static let defaultDextInstallPath: BuildSettingsKey = "DEFAULT_DEXT_INSTALL_PATH"
}

// MARK: Default Kext Install Path
extension BuildSetting {

    /// Default Kext Install Path
    public static var defaultKextInstallPath: BuildSetting { 
        .defaultKextInstallPath(inherit: .systemKextInstallPath) 
    }

    /// Default Kext Install Path
    public static func defaultKextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultKextInstallPath, value: \(value))
    }

    /// Default Kext Install Path
    public static func defaultKextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultKextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Default Kext Install Path
    public static let defaultKextInstallPath: BuildSettingsKey = "DEFAULT_KEXT_INSTALL_PATH"
}

// MARK: Defines Module
extension BuildSetting {

    /// Defines Module
    ///
    /// If enabled, the product will be treated as defining its own module. This enables automatic production of LLVM module map files when appropriate, and allows the product to be imported as a module.
    public static var definesModule: BuildSetting { 
        BuildSetting(key: .definesModule, value: "NO")
    }

    /// Defines Module
    ///
    /// If enabled, the product will be treated as defining its own module. This enables automatic production of LLVM module map files when appropriate, and allows the product to be imported as a module.
    public static func definesModule(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .definesModule, value: value.asText)
    }

    /// Defines Module
    ///
    /// If enabled, the product will be treated as defining its own module. This enables automatic production of LLVM module map files when appropriate, and allows the product to be imported as a module.
    public static func definesModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .definesModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Defines Module
    ///
    /// If enabled, the product will be treated as defining its own module. This enables automatic production of LLVM module map files when appropriate, and allows the product to be imported as a module.
    public static let definesModule: BuildSettingsKey = "DEFINES_MODULE"
}

// MARK: Deployment Location
extension BuildSetting {

    /// Deployment Location
    ///
    /// If enabled, built products are placed in their installed locations in addition to the built products folder.
    public static var deploymentLocation: BuildSetting { 
        BuildSetting(key: .deploymentLocation, value: "NO")
    }

    /// Deployment Location
    ///
    /// If enabled, built products are placed in their installed locations in addition to the built products folder.
    public static func deploymentLocation(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deploymentLocation, value: value.asText)
    }

    /// Deployment Location
    ///
    /// If enabled, built products are placed in their installed locations in addition to the built products folder.
    public static func deploymentLocation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deploymentLocation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Deployment Location
    ///
    /// If enabled, built products are placed in their installed locations in addition to the built products folder.
    public static let deploymentLocation: BuildSettingsKey = "DEPLOYMENT_LOCATION"
}

// MARK: Deployment Postprocessing
extension BuildSetting {

    /// Deployment Postprocessing
    ///
    /// If enabled, indicates that binaries should be stripped and file mode, owner, and group information should be set to standard values.
    public static var deploymentPostprocessing: BuildSetting { 
        BuildSetting(key: .deploymentPostprocessing, value: "NO")
    }

    /// Deployment Postprocessing
    ///
    /// If enabled, indicates that binaries should be stripped and file mode, owner, and group information should be set to standard values.
    public static func deploymentPostprocessing(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deploymentPostprocessing, value: value.asText)
    }

    /// Deployment Postprocessing
    ///
    /// If enabled, indicates that binaries should be stripped and file mode, owner, and group information should be set to standard values.
    public static func deploymentPostprocessing(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deploymentPostprocessing, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Deployment Postprocessing
    ///
    /// If enabled, indicates that binaries should be stripped and file mode, owner, and group information should be set to standard values.
    public static let deploymentPostprocessing: BuildSettingsKey = "DEPLOYMENT_POSTPROCESSING"
}

// MARK: Derived File Dir
extension BuildSetting {

    /// Derived File Dir
    public static var derivedFileDir: BuildSetting { 
        BuildSetting(key: .derivedFileDir, value: "$(TARGET_TEMP_DIR)/DerivedSources")
    }

    /// Derived File Dir
    public static func derivedFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .derivedFileDir, value: \(value))
    }

    /// Derived File Dir
    public static func derivedFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .derivedFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Derived File Dir
    public static let derivedFileDir: BuildSettingsKey = "DERIVED_FILE_DIR"
}

// MARK: Derived Sources Dir
extension BuildSetting {

    /// Derived Sources Dir
    public static var derivedSourcesDir: BuildSetting { 
        .derivedSourcesDir(inherit: .derivedFileDir) 
    }

    /// Derived Sources Dir
    public static func derivedSourcesDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .derivedSourcesDir, value: \(value))
    }

    /// Derived Sources Dir
    public static func derivedSourcesDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .derivedSourcesDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Derived Sources Dir
    public static let derivedSourcesDir: BuildSettingsKey = "DERIVED_SOURCES_DIR"
}

// MARK: Development Assets
extension BuildSetting {

    /// Development Assets
    ///
    /// Files and directories used only for development. Archive and install builds will exclude this content.
    public static func developmentAssets(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .developmentAssets, value: .array(value))
    }

    /// Development Assets
    ///
    /// Files and directories used only for development. Archive and install builds will exclude this content.
    public static func developmentAssets(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .developmentAssets, inherit: key)
    }

    /// Development Assets
    ///
    /// Files and directories used only for development. Archive and install builds will exclude this content.
    public static func developmentAssets(_ value: String...) -> BuildSetting { 
        .developmentAssets(value)
    }
}

extension BuildSettingsKey {

    /// Development Assets
    ///
    /// Files and directories used only for development. Archive and install builds will exclude this content.
    public static let developmentAssets: BuildSettingsKey = "DEVELOPMENT_ASSET_PATHS"
}

// MARK: Development Team
extension BuildSetting {

    /// Development Team
    ///
    /// The team ID of a development team to use for signing certificates and provisioning profiles.
    public static func developmentTeam(_ value: DevelopmentTeam) -> BuildSetting { 
        BuildSetting(key: .developmentTeam, value: \(value))
    }

    /// Development Team
    ///
    /// The team ID of a development team to use for signing certificates and provisioning profiles.
    public static func developmentTeam(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .developmentTeam, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Development Team
    ///
    /// The team ID of a development team to use for signing certificates and provisioning profiles.
    public static let developmentTeam: BuildSettingsKey = "DEVELOPMENT_TEAM"
}

// MARK: Don't Force Info.plist Generation
extension BuildSetting {

    /// Don't Force Info.plist Generation
    ///
    /// If enabled, don’t automatically generate an Info.plist file for wrapped products when the [Info.plist File (INFOPLIST_FILE)](itcaec37c2a6.html# dev131d2e1c2) build setting is empty.
    public static var donTForceInfoPlistGeneration: BuildSetting { 
        BuildSetting(key: .donTForceInfoPlistGeneration, value: "NO")
    }

    /// Don't Force Info.plist Generation
    ///
    /// If enabled, don’t automatically generate an Info.plist file for wrapped products when the [Info.plist File (INFOPLIST_FILE)](itcaec37c2a6.html# dev131d2e1c2) build setting is empty.
    public static func donTForceInfoPlistGeneration(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .donTForceInfoPlistGeneration, value: value.asText)
    }

    /// Don't Force Info.plist Generation
    ///
    /// If enabled, don’t automatically generate an Info.plist file for wrapped products when the [Info.plist File (INFOPLIST_FILE)](itcaec37c2a6.html# dev131d2e1c2) build setting is empty.
    public static func donTForceInfoPlistGeneration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .donTForceInfoPlistGeneration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Don't Force Info.plist Generation
    ///
    /// If enabled, don’t automatically generate an Info.plist file for wrapped products when the [Info.plist File (INFOPLIST_FILE)](itcaec37c2a6.html# dev131d2e1c2) build setting is empty.
    public static let donTForceInfoPlistGeneration: BuildSettingsKey = "DONT_GENERATE_INFOPLIST_FILE"
}

// MARK: Do Header Scanning In Jam
extension BuildSetting {

    /// Do Header Scanning In Jam
    public static var doHeaderScanningInJam: BuildSetting { 
        BuildSetting(key: .doHeaderScanningInJam, value: "NO")
    }

    /// Do Header Scanning In Jam
    public static func doHeaderScanningInJam(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .doHeaderScanningInJam, value: value.asText)
    }

    /// Do Header Scanning In Jam
    public static func doHeaderScanningInJam(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .doHeaderScanningInJam, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Do Header Scanning In Jam
    public static let doHeaderScanningInJam: BuildSettingsKey = "DO_HEADER_SCANNING_IN_JAM"
}

// MARK: Installation Build Products Location
extension BuildSetting {

    /// Installation Build Products Location
    ///
    /// The path at which all products will be rooted when performing an install build. For instance, to install your products on the system proper, set this path to `/`. Defaults to `/tmp/$(PROJECT_NAME).dst` to prevent a **test** install build from accidentally overwriting valid and needed data in the ultimate install path. Typically this path is not set per target, but is provided as an option on the command line when performing an `xcodebuild install`. It may also be set in a build configuration in special circumstances.
    public static var installationBuildProductsLocation: BuildSetting { 
        BuildSetting(key: .installationBuildProductsLocation, value: "/tmp/$(PROJECT_NAME).dst")
    }

    /// Installation Build Products Location
    ///
    /// The path at which all products will be rooted when performing an install build. For instance, to install your products on the system proper, set this path to `/`. Defaults to `/tmp/$(PROJECT_NAME).dst` to prevent a **test** install build from accidentally overwriting valid and needed data in the ultimate install path. Typically this path is not set per target, but is provided as an option on the command line when performing an `xcodebuild install`. It may also be set in a build configuration in special circumstances.
    public static func installationBuildProductsLocation(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installationBuildProductsLocation, value: \(value))
    }

    /// Installation Build Products Location
    ///
    /// The path at which all products will be rooted when performing an install build. For instance, to install your products on the system proper, set this path to `/`. Defaults to `/tmp/$(PROJECT_NAME).dst` to prevent a **test** install build from accidentally overwriting valid and needed data in the ultimate install path. Typically this path is not set per target, but is provided as an option on the command line when performing an `xcodebuild install`. It may also be set in a build configuration in special circumstances.
    public static func installationBuildProductsLocation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installationBuildProductsLocation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Installation Build Products Location
    ///
    /// The path at which all products will be rooted when performing an install build. For instance, to install your products on the system proper, set this path to `/`. Defaults to `/tmp/$(PROJECT_NAME).dst` to prevent a **test** install build from accidentally overwriting valid and needed data in the ultimate install path. Typically this path is not set per target, but is provided as an option on the command line when performing an `xcodebuild install`. It may also be set in a build configuration in special circumstances.
    public static let installationBuildProductsLocation: BuildSettingsKey = "DSTROOT"
}

// MARK: Dwarf Dsym File Name
extension BuildSetting {

    /// Dwarf Dsym File Name
    public static var dwarfDsymFileName: BuildSetting { 
        BuildSetting(key: .dwarfDsymFileName, value: "$(FULL_PRODUCT_NAME).dSYM")
    }

    /// Dwarf Dsym File Name
    public static func dwarfDsymFileName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .dwarfDsymFileName, value: \(value))
    }

    /// Dwarf Dsym File Name
    public static func dwarfDsymFileName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dwarfDsymFileName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dwarf Dsym File Name
    public static let dwarfDsymFileName: BuildSettingsKey = "DWARF_DSYM_FILE_NAME"
}

// MARK: Dwarf Dsym File Should Accompany Product
extension BuildSetting {

    /// Dwarf Dsym File Should Accompany Product
    public static var dwarfDsymFileShouldAccompanyProduct: BuildSetting { 
        BuildSetting(key: .dwarfDsymFileShouldAccompanyProduct, value: "NO")
    }

    /// Dwarf Dsym File Should Accompany Product
    public static func dwarfDsymFileShouldAccompanyProduct(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .dwarfDsymFileShouldAccompanyProduct, value: value.asText)
    }

    /// Dwarf Dsym File Should Accompany Product
    public static func dwarfDsymFileShouldAccompanyProduct(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dwarfDsymFileShouldAccompanyProduct, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dwarf Dsym File Should Accompany Product
    public static let dwarfDsymFileShouldAccompanyProduct: BuildSettingsKey = "DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT"
}

// MARK: Dwarf Dsym Folder Path
extension BuildSetting {

    /// Dwarf Dsym Folder Path
    public static var dwarfDsymFolderPath: BuildSetting { 
        .dwarfDsymFolderPath(inherit: .perConfigurationBuildProductsPath) 
    }

    /// Dwarf Dsym Folder Path
    public static func dwarfDsymFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .dwarfDsymFolderPath, value: \(value))
    }

    /// Dwarf Dsym Folder Path
    public static func dwarfDsymFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dwarfDsymFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dwarf Dsym Folder Path
    public static let dwarfDsymFolderPath: BuildSettingsKey = "DWARF_DSYM_FOLDER_PATH"
}

// MARK: Compatibility Version
extension BuildSetting {

    /// Compatibility Version
    ///
    /// Determines the compatibility version of the resulting library, bundle, or framework binary. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static func compatibilityVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .compatibilityVersion, value: \(value))
    }

    /// Compatibility Version
    ///
    /// Determines the compatibility version of the resulting library, bundle, or framework binary. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static func compatibilityVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compatibilityVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compatibility Version
    ///
    /// Determines the compatibility version of the resulting library, bundle, or framework binary. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static let compatibilityVersion: BuildSettingsKey = "DYLIB_COMPATIBILITY_VERSION"
}

// MARK: Current Library Version
extension BuildSetting {

    /// Current Library Version
    ///
    /// This setting defines the current version of any framework built by the project. As with [Current Project Version (CURRENT_PROJECT_VERSION)](itcaec37c2a6.html# devd516a860b), the value must be an integer or floating point number, such as `57` or `365.8`. By default, it is set to `$(CURRENT_PROJECT_VERSION)`. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static func currentLibraryVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentLibraryVersion, value: \(value))
    }

    /// Current Library Version
    ///
    /// This setting defines the current version of any framework built by the project. As with [Current Project Version (CURRENT_PROJECT_VERSION)](itcaec37c2a6.html# devd516a860b), the value must be an integer or floating point number, such as `57` or `365.8`. By default, it is set to `$(CURRENT_PROJECT_VERSION)`. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static func currentLibraryVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentLibraryVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Current Library Version
    ///
    /// This setting defines the current version of any framework built by the project. As with [Current Project Version (CURRENT_PROJECT_VERSION)](itcaec37c2a6.html# devd516a860b), the value must be an integer or floating point number, such as `57` or `365.8`. By default, it is set to `$(CURRENT_PROJECT_VERSION)`. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static let currentLibraryVersion: BuildSettingsKey = "DYLIB_CURRENT_VERSION"
}

// MARK: Dynamic Library Install Name Base
extension BuildSetting {

    /// Dynamic Library Install Name Base
    ///
    /// Sets the base value for the internal `install path` (`LC_ID_DYLIB`) in a dynamic library. This will be combined with the [EXECUTABLE_PATH](itcaec37c2a6.html# dev5a0a1bb80) to form the full install path. Setting [Dynamic Library Install Name (LD_DYLIB_INSTALL_NAME)](itcaec37c2a6.html# devbb966571b) directly will override this setting. This setting defaults to the target’s [Installation Directory (INSTALL_PATH)](itcaec37c2a6.html# devabd541cd5). It is ignored when building any product other than a dynamic library.
    public static func dynamicLibraryInstallNameBase(_ value: String) -> BuildSetting { 
        BuildSetting(key: .dynamicLibraryInstallNameBase, value: \(value))
    }

    /// Dynamic Library Install Name Base
    ///
    /// Sets the base value for the internal `install path` (`LC_ID_DYLIB`) in a dynamic library. This will be combined with the [EXECUTABLE_PATH](itcaec37c2a6.html# dev5a0a1bb80) to form the full install path. Setting [Dynamic Library Install Name (LD_DYLIB_INSTALL_NAME)](itcaec37c2a6.html# devbb966571b) directly will override this setting. This setting defaults to the target’s [Installation Directory (INSTALL_PATH)](itcaec37c2a6.html# devabd541cd5). It is ignored when building any product other than a dynamic library.
    public static func dynamicLibraryInstallNameBase(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dynamicLibraryInstallNameBase, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dynamic Library Install Name Base
    ///
    /// Sets the base value for the internal `install path` (`LC_ID_DYLIB`) in a dynamic library. This will be combined with the [EXECUTABLE_PATH](itcaec37c2a6.html# dev5a0a1bb80) to form the full install path. Setting [Dynamic Library Install Name (LD_DYLIB_INSTALL_NAME)](itcaec37c2a6.html# devbb966571b) directly will override this setting. This setting defaults to the target’s [Installation Directory (INSTALL_PATH)](itcaec37c2a6.html# devabd541cd5). It is ignored when building any product other than a dynamic library.
    public static let dynamicLibraryInstallNameBase: BuildSettingsKey = "DYLIB_INSTALL_NAME_BASE"
}

// MARK: Embedded Profile Name
extension BuildSetting {

    /// Embedded Profile Name
    public static func embeddedProfileName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .embeddedProfileName, value: \(value))
    }

    /// Embedded Profile Name
    public static func embeddedProfileName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .embeddedProfileName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Embedded Profile Name
    public static let embeddedProfileName: BuildSettingsKey = "EMBEDDED_PROFILE_NAME"
}

// MARK: Embed Asset Packs In Product Bundle
extension BuildSetting {

    /// Embed Asset Packs In Product Bundle
    ///
    /// Embed all the built asset packs inside the product bundle. Since this negates the performance benefits of the On Demand Resources feature, it is only useful for testing purposes when it isn’t practical to use an asset pack server.
    public static var embedAssetPacksInProductBundle: BuildSetting { 
        BuildSetting(key: .embedAssetPacksInProductBundle, value: "NO")
    }

    /// Embed Asset Packs In Product Bundle
    ///
    /// Embed all the built asset packs inside the product bundle. Since this negates the performance benefits of the On Demand Resources feature, it is only useful for testing purposes when it isn’t practical to use an asset pack server.
    public static func embedAssetPacksInProductBundle(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .embedAssetPacksInProductBundle, value: value.asText)
    }

    /// Embed Asset Packs In Product Bundle
    ///
    /// Embed all the built asset packs inside the product bundle. Since this negates the performance benefits of the On Demand Resources feature, it is only useful for testing purposes when it isn’t practical to use an asset pack server.
    public static func embedAssetPacksInProductBundle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .embedAssetPacksInProductBundle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Embed Asset Packs In Product Bundle
    ///
    /// Embed all the built asset packs inside the product bundle. Since this negates the performance benefits of the On Demand Resources feature, it is only useful for testing purposes when it isn’t practical to use an asset pack server.
    public static let embedAssetPacksInProductBundle: BuildSettingsKey = "EMBED_ASSET_PACKS_IN_PRODUCT_BUNDLE"
}

// MARK: Enable Bitcode
extension BuildSetting {

    /// Enable Bitcode
    ///
    /// Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode.
    public static var enableBitcode: BuildSetting { 
        BuildSetting(key: .enableBitcode, value: "NO")
    }

    /// Enable Bitcode
    ///
    /// Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode.
    public static func enableBitcode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableBitcode, value: value.asText)
    }

    /// Enable Bitcode
    ///
    /// Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode.
    public static func enableBitcode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableBitcode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Bitcode
    ///
    /// Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode.
    public static let enableBitcode: BuildSettingsKey = "ENABLE_BITCODE"
}

// MARK: Enable Default Header Search Paths
extension BuildSetting {

    /// Enable Default Header Search Paths
    public static var enableDefaultHeaderSearchPaths: BuildSetting { 
        BuildSetting(key: .enableDefaultHeaderSearchPaths, value: "YES")
    }

    /// Enable Default Header Search Paths
    public static func enableDefaultHeaderSearchPaths(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableDefaultHeaderSearchPaths, value: value.asText)
    }

    /// Enable Default Header Search Paths
    public static func enableDefaultHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableDefaultHeaderSearchPaths, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Default Header Search Paths
    public static let enableDefaultHeaderSearchPaths: BuildSettingsKey = "ENABLE_DEFAULT_HEADER_SEARCH_PATHS"
}

// MARK: Enable Hardened Runtime
extension BuildSetting {

    /// Enable Hardened Runtime
    ///
    /// Enable hardened runtime restrictions.
    public static var enableHardenedRuntime: BuildSetting { 
        BuildSetting(key: .enableHardenedRuntime, value: "NO")
    }

    /// Enable Hardened Runtime
    ///
    /// Enable hardened runtime restrictions.
    public static func enableHardenedRuntime(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableHardenedRuntime, value: value.asText)
    }

    /// Enable Hardened Runtime
    ///
    /// Enable hardened runtime restrictions.
    public static func enableHardenedRuntime(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableHardenedRuntime, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Hardened Runtime
    ///
    /// Enable hardened runtime restrictions.
    public static let enableHardenedRuntime: BuildSettingsKey = "ENABLE_HARDENED_RUNTIME"
}

// MARK: Enable Header Dependencies
extension BuildSetting {

    /// Enable Header Dependencies
    ///
    /// Specifies whether to automatically track dependencies on included header files.
    public static var enableHeaderDependencies: BuildSetting { 
        BuildSetting(key: .enableHeaderDependencies, value: "YES")
    }

    /// Enable Header Dependencies
    ///
    /// Specifies whether to automatically track dependencies on included header files.
    public static func enableHeaderDependencies(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableHeaderDependencies, value: value.asText)
    }

    /// Enable Header Dependencies
    ///
    /// Specifies whether to automatically track dependencies on included header files.
    public static func enableHeaderDependencies(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableHeaderDependencies, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Header Dependencies
    ///
    /// Specifies whether to automatically track dependencies on included header files.
    public static let enableHeaderDependencies: BuildSettingsKey = "ENABLE_HEADER_DEPENDENCIES"
}

// MARK: Enable On Demand Resources
extension BuildSetting {

    /// Enable On Demand Resources
    ///
    /// If enabled, tagged assets—files and asset catalog entries—are built into asset packs based on their combination of tags. Untagged resources are treated normally.
    public static var enableOnDemandResources: BuildSetting { 
        BuildSetting(key: .enableOnDemandResources, value: "NO")
    }

    /// Enable On Demand Resources
    ///
    /// If enabled, tagged assets—files and asset catalog entries—are built into asset packs based on their combination of tags. Untagged resources are treated normally.
    public static func enableOnDemandResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableOnDemandResources, value: value.asText)
    }

    /// Enable On Demand Resources
    ///
    /// If enabled, tagged assets—files and asset catalog entries—are built into asset packs based on their combination of tags. Untagged resources are treated normally.
    public static func enableOnDemandResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableOnDemandResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable On Demand Resources
    ///
    /// If enabled, tagged assets—files and asset catalog entries—are built into asset packs based on their combination of tags. Untagged resources are treated normally.
    public static let enableOnDemandResources: BuildSettingsKey = "ENABLE_ON_DEMAND_RESOURCES"
}

// MARK: Enable Previews
extension BuildSetting {

    /// Enable Previews
    ///
    /// If enabled, the product will be built with options appropriate for supporting previews.
    public static func enablePreviews(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enablePreviews, value: value.asText)
    }

    /// Enable Previews
    ///
    /// If enabled, the product will be built with options appropriate for supporting previews.
    public static func enablePreviews(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enablePreviews, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Previews
    ///
    /// If enabled, the product will be built with options appropriate for supporting previews.
    public static let enablePreviews: BuildSettingsKey = "ENABLE_PREVIEWS"
}

// MARK: Enable Testability
extension BuildSetting {

    /// Enable Testability
    ///
    /// When this setting is activated, the product will be built with options appropriate for running automated tests, such as making private interfaces accessible to the tests. This may result in tests running slower than they would without testability enabled.
    public static var enableTestability: BuildSetting { 
        BuildSetting(key: .enableTestability, value: "NO")
    }

    /// Enable Testability
    ///
    /// When this setting is activated, the product will be built with options appropriate for running automated tests, such as making private interfaces accessible to the tests. This may result in tests running slower than they would without testability enabled.
    public static func enableTestability(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTestability, value: value.asText)
    }

    /// Enable Testability
    ///
    /// When this setting is activated, the product will be built with options appropriate for running automated tests, such as making private interfaces accessible to the tests. This may result in tests running slower than they would without testability enabled.
    public static func enableTestability(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTestability, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Testability
    ///
    /// When this setting is activated, the product will be built with options appropriate for running automated tests, such as making private interfaces accessible to the tests. This may result in tests running slower than they would without testability enabled.
    public static let enableTestability: BuildSettingsKey = "ENABLE_TESTABILITY"
}

// MARK: Enable Testing Search Paths
extension BuildSetting {

    /// Enable Testing Search Paths
    ///
    /// Specifies whether the build system should add the search paths necessary for compiling and linking against XCTest. This setting is enabled by default if the target is a unit test target or if the target explicitly links to the XCTest framework.
    public static var enableTestingSearchPaths: BuildSetting { 
        BuildSetting(key: .enableTestingSearchPaths, value: "NO")
    }

    /// Enable Testing Search Paths
    ///
    /// Specifies whether the build system should add the search paths necessary for compiling and linking against XCTest. This setting is enabled by default if the target is a unit test target or if the target explicitly links to the XCTest framework.
    public static func enableTestingSearchPaths(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTestingSearchPaths, value: value.asText)
    }

    /// Enable Testing Search Paths
    ///
    /// Specifies whether the build system should add the search paths necessary for compiling and linking against XCTest. This setting is enabled by default if the target is a unit test target or if the target explicitly links to the XCTest framework.
    public static func enableTestingSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTestingSearchPaths, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Testing Search Paths
    ///
    /// Specifies whether the build system should add the search paths necessary for compiling and linking against XCTest. This setting is enabled by default if the target is a unit test target or if the target explicitly links to the XCTest framework.
    public static let enableTestingSearchPaths: BuildSettingsKey = "ENABLE_TESTING_SEARCH_PATHS"
}

// MARK: Entitlements Destination
extension BuildSetting {

    /// Entitlements Destination
    public static func entitlementsDestination(_ value: EntitlementsDestination) -> BuildSetting { 
        BuildSetting(key: .entitlementsDestination, value: \(value))
    }

    /// Entitlements Destination
    public static func entitlementsDestination(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .entitlementsDestination, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Entitlements Destination
    public static let entitlementsDestination: BuildSettingsKey = "ENTITLEMENTS_DESTINATION"
}

public enum EntitlementsDestination: String, Hashable, Codable, CustomStringConvertible {
    case Entitlements = "__entitlements"
    case signature = "Signature"

    public var description: String {
        rawValue
    }
}

// MARK: Excluded Archs
extension BuildSetting {

    /// Excluded Archs
    public static func excludedArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .excludedArchs, value: .array(value))
    }

    /// Excluded Archs
    public static func excludedArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .excludedArchs, inherit: key)
    }

    /// Excluded Archs
    public static func excludedArchs(_ value: String...) -> BuildSetting { 
        .excludedArchs(value)
    }
}

extension BuildSettingsKey {

    /// Excluded Archs
    public static let excludedArchs: BuildSettingsKey = "EXCLUDED_ARCHS"
}

// MARK: Excluded Installsrc Subdirectory Patterns
extension BuildSetting {

    /// Excluded Installsrc Subdirectory Patterns
    public static var excludedInstallsrcSubdirectoryPatterns: BuildSetting { 
        BuildSetting(key: .excludedInstallsrcSubdirectoryPatterns, value: ".DS_Store .svn .git .hg CVS")
    }

    /// Excluded Installsrc Subdirectory Patterns
    public static func excludedInstallsrcSubdirectoryPatterns(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .excludedInstallsrcSubdirectoryPatterns, value: .array(value))
    }

    /// Excluded Installsrc Subdirectory Patterns
    public static func excludedInstallsrcSubdirectoryPatterns(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .excludedInstallsrcSubdirectoryPatterns, inherit: key)
    }

    /// Excluded Installsrc Subdirectory Patterns
    public static func excludedInstallsrcSubdirectoryPatterns(_ value: String...) -> BuildSetting { 
        .excludedInstallsrcSubdirectoryPatterns(value)
    }
}

extension BuildSettingsKey {

    /// Excluded Installsrc Subdirectory Patterns
    public static let excludedInstallsrcSubdirectoryPatterns: BuildSettingsKey = "EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS"
}

// MARK: Sub-Directories to Exclude in Recursive Searches
extension BuildSetting {

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static var subDirectoriesToExcludeInRecursiveSearches: BuildSetting { 
        BuildSetting(key: .subDirectoriesToExcludeInRecursiveSearches, value: "*.nib *.lproj *.framework *.gch *.xcode* *.xcassets (*) .DS_Store CVS .svn .git .hg *.pbproj *.pbxproj")
    }

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static func subDirectoriesToExcludeInRecursiveSearches(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .subDirectoriesToExcludeInRecursiveSearches, value: .array(value))
    }

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static func subDirectoriesToExcludeInRecursiveSearches(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .subDirectoriesToExcludeInRecursiveSearches, inherit: key)
    }

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static func subDirectoriesToExcludeInRecursiveSearches(_ value: String...) -> BuildSetting { 
        .subDirectoriesToExcludeInRecursiveSearches(value)
    }
}

extension BuildSettingsKey {

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static let subDirectoriesToExcludeInRecursiveSearches: BuildSettingsKey = "EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES"
}

// MARK: Excluded Source File Names
extension BuildSetting {

    /// Excluded Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly **exclude** when processing the files in the target’s build phases (see also [Included Source File Names (INCLUDED_SOURCE_FILE_NAMES)](itcaec37c2a6.html# dev278eb3050)). This setting can be used to define complex filters for which files from the phase should be built in response to other build settings; for example, a value of `*.$(CURRENT_ARCH).c` could serve to exclude particular files based on the architecture being built.
    public static func excludedSourceFileNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .excludedSourceFileNames, value: .array(value))
    }

    /// Excluded Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly **exclude** when processing the files in the target’s build phases (see also [Included Source File Names (INCLUDED_SOURCE_FILE_NAMES)](itcaec37c2a6.html# dev278eb3050)). This setting can be used to define complex filters for which files from the phase should be built in response to other build settings; for example, a value of `*.$(CURRENT_ARCH).c` could serve to exclude particular files based on the architecture being built.
    public static func excludedSourceFileNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .excludedSourceFileNames, inherit: key)
    }

    /// Excluded Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly **exclude** when processing the files in the target’s build phases (see also [Included Source File Names (INCLUDED_SOURCE_FILE_NAMES)](itcaec37c2a6.html# dev278eb3050)). This setting can be used to define complex filters for which files from the phase should be built in response to other build settings; for example, a value of `*.$(CURRENT_ARCH).c` could serve to exclude particular files based on the architecture being built.
    public static func excludedSourceFileNames(_ value: String...) -> BuildSetting { 
        .excludedSourceFileNames(value)
    }
}

extension BuildSettingsKey {

    /// Excluded Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly **exclude** when processing the files in the target’s build phases (see also [Included Source File Names (INCLUDED_SOURCE_FILE_NAMES)](itcaec37c2a6.html# dev278eb3050)). This setting can be used to define complex filters for which files from the phase should be built in response to other build settings; for example, a value of `*.$(CURRENT_ARCH).c` could serve to exclude particular files based on the architecture being built.
    public static let excludedSourceFileNames: BuildSettingsKey = "EXCLUDED_SOURCE_FILE_NAMES"
}

// MARK: Executable Extension
extension BuildSetting {

    /// Executable Extension
    ///
    /// This is the extension used for the executable product generated by the target, which has a default value based on the product type.
    public static func executableExtension(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableExtension, value: \(value))
    }

    /// Executable Extension
    ///
    /// This is the extension used for the executable product generated by the target, which has a default value based on the product type.
    public static func executableExtension(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableExtension, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executable Extension
    ///
    /// This is the extension used for the executable product generated by the target, which has a default value based on the product type.
    public static let executableExtension: BuildSettingsKey = "EXECUTABLE_EXTENSION"
}

// MARK: Executable Prefix
extension BuildSetting {

    /// Executable Prefix
    ///
    /// The prefix used for the executable product generated by the target, which has a default value based on the product type.
    public static func executablePrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executablePrefix, value: \(value))
    }

    /// Executable Prefix
    ///
    /// The prefix used for the executable product generated by the target, which has a default value based on the product type.
    public static func executablePrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executablePrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executable Prefix
    ///
    /// The prefix used for the executable product generated by the target, which has a default value based on the product type.
    public static let executablePrefix: BuildSettingsKey = "EXECUTABLE_PREFIX"
}

// MARK: Exported Symbols File
extension BuildSetting {

    /// Exported Symbols File
    ///
    /// This is a project-relative path to a file that lists the symbols to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static func exportedSymbolsFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .exportedSymbolsFile, value: \(value))
    }

    /// Exported Symbols File
    ///
    /// This is a project-relative path to a file that lists the symbols to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static func exportedSymbolsFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .exportedSymbolsFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Exported Symbols File
    ///
    /// This is a project-relative path to a file that lists the symbols to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static let exportedSymbolsFile: BuildSettingsKey = "EXPORTED_SYMBOLS_FILE"
}

// MARK: File List
extension BuildSetting {

    /// File List
    public static var fileList: BuildSetting { 
        BuildSetting(key: .fileList, value: "$(OBJECT_FILE_DIR)/LinkFileList")
    }

    /// File List
    public static func fileList(_ value: String) -> BuildSetting { 
        BuildSetting(key: .fileList, value: \(value))
    }

    /// File List
    public static func fileList(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fileList, inherit: key)
    }
}

extension BuildSettingsKey {

    /// File List
    public static let fileList: BuildSettingsKey = "FILE_LIST"
}

// MARK: Framework Search Paths
extension BuildSetting {

    /// Framework Search Paths
    ///
    /// This is a list of paths to folders containing frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. Paths are delimited by whitespace, so any paths with spaces in them must be properly quoted.
    public static func frameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .frameworkSearchPaths, value: .array(value))
    }

    /// Framework Search Paths
    ///
    /// This is a list of paths to folders containing frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. Paths are delimited by whitespace, so any paths with spaces in them must be properly quoted.
    public static func frameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .frameworkSearchPaths, inherit: key)
    }

    /// Framework Search Paths
    ///
    /// This is a list of paths to folders containing frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. Paths are delimited by whitespace, so any paths with spaces in them must be properly quoted.
    public static func frameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .frameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Framework Search Paths
    ///
    /// This is a list of paths to folders containing frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. Paths are delimited by whitespace, so any paths with spaces in them must be properly quoted.
    public static let frameworkSearchPaths: BuildSettingsKey = "FRAMEWORK_SEARCH_PATHS"
}

// MARK: Framework Version
extension BuildSetting {

    /// Framework Version
    ///
    /// Framework bundles are versioned by having contents in subfolders of a version folder that has links to the current version and its contents.
    public static var frameworkVersion: BuildSetting { 
        BuildSetting(key: .frameworkVersion, value: "A")
    }

    /// Framework Version
    ///
    /// Framework bundles are versioned by having contents in subfolders of a version folder that has links to the current version and its contents.
    public static func frameworkVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .frameworkVersion, value: \(value))
    }

    /// Framework Version
    ///
    /// Framework bundles are versioned by having contents in subfolders of a version folder that has links to the current version and its contents.
    public static func frameworkVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .frameworkVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Framework Version
    ///
    /// Framework bundles are versioned by having contents in subfolders of a version folder that has links to the current version and its contents.
    public static let frameworkVersion: BuildSettingsKey = "FRAMEWORK_VERSION"
}

// MARK: Full Product Name
extension BuildSetting {

    /// Full Product Name
    public static func fullProductName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .fullProductName, value: \(value))
    }

    /// Full Product Name
    public static func fullProductName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fullProductName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Full Product Name
    public static let fullProductName: BuildSettingsKey = "FULL_PRODUCT_NAME"
}

// MARK: Compiler for C/C++/Objective-C
extension BuildSetting {

    /// Compiler for C/C++/Objective-C
    ///
    /// The compiler to use for C, C++, and Objective-C.
    public static func compilerForCCppObjectiveC(_ value: CompilerVersion) -> BuildSetting { 
        BuildSetting(key: .compilerForCCppObjectiveC, value: \(value))
    }

    /// Compiler for C/C++/Objective-C
    ///
    /// The compiler to use for C, C++, and Objective-C.
    public static func compilerForCCppObjectiveC(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compilerForCCppObjectiveC, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compiler for C/C++/Objective-C
    ///
    /// The compiler to use for C, C++, and Objective-C.
    public static let compilerForCCppObjectiveC: BuildSettingsKey = "GCC_VERSION"
}

// MARK: Generated Modulemap Dir
extension BuildSetting {

    /// Generated Modulemap Dir
    public static var generatedModulemapDir: BuildSetting { 
        BuildSetting(key: .generatedModulemapDir, value: "$(OBJROOT)/GeneratedModuleMaps$(EFFECTIVE_PLATFORM_NAME)")
    }

    /// Generated Modulemap Dir
    public static func generatedModulemapDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .generatedModulemapDir, value: \(value))
    }

    /// Generated Modulemap Dir
    public static func generatedModulemapDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatedModulemapDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generated Modulemap Dir
    public static let generatedModulemapDir: BuildSettingsKey = "GENERATED_MODULEMAP_DIR"
}

// MARK: Perform Single-Object Prelink
extension BuildSetting {

    /// Perform Single-Object Prelink
    ///
    /// Activating this setting will cause the object files built by a target to be prelinked using `ld -r` into a single object file, and that object file will then be linked into the final product. This is useful to force the linker to resolve symbols and link the object files into a single module before building a static library. Also, a separate set of link flags can be applied to the prelink allowing additional control over, for instance, exported symbols.
    public static var performSingleObjectPrelink: BuildSetting { 
        BuildSetting(key: .performSingleObjectPrelink, value: "NO")
    }

    /// Perform Single-Object Prelink
    ///
    /// Activating this setting will cause the object files built by a target to be prelinked using `ld -r` into a single object file, and that object file will then be linked into the final product. This is useful to force the linker to resolve symbols and link the object files into a single module before building a static library. Also, a separate set of link flags can be applied to the prelink allowing additional control over, for instance, exported symbols.
    public static func performSingleObjectPrelink(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .performSingleObjectPrelink, value: value.asText)
    }

    /// Perform Single-Object Prelink
    ///
    /// Activating this setting will cause the object files built by a target to be prelinked using `ld -r` into a single object file, and that object file will then be linked into the final product. This is useful to force the linker to resolve symbols and link the object files into a single module before building a static library. Also, a separate set of link flags can be applied to the prelink allowing additional control over, for instance, exported symbols.
    public static func performSingleObjectPrelink(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .performSingleObjectPrelink, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Perform Single-Object Prelink
    ///
    /// Activating this setting will cause the object files built by a target to be prelinked using `ld -r` into a single object file, and that object file will then be linked into the final product. This is useful to force the linker to resolve symbols and link the object files into a single module before building a static library. Also, a separate set of link flags can be applied to the prelink allowing additional control over, for instance, exported symbols.
    public static let performSingleObjectPrelink: BuildSettingsKey = "GENERATE_MASTER_OBJECT_FILE"
}

// MARK: Force Package Info Generation
extension BuildSetting {

    /// Force Package Info Generation
    ///
    /// Forces the `PkgInfo` file to be written to wrapped products even if this file is not expected.
    public static var forcePackageInfoGeneration: BuildSetting { 
        BuildSetting(key: .forcePackageInfoGeneration, value: "NO")
    }

    /// Force Package Info Generation
    ///
    /// Forces the `PkgInfo` file to be written to wrapped products even if this file is not expected.
    public static func forcePackageInfoGeneration(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .forcePackageInfoGeneration, value: value.asText)
    }

    /// Force Package Info Generation
    ///
    /// Forces the `PkgInfo` file to be written to wrapped products even if this file is not expected.
    public static func forcePackageInfoGeneration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .forcePackageInfoGeneration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Force Package Info Generation
    ///
    /// Forces the `PkgInfo` file to be written to wrapped products even if this file is not expected.
    public static let forcePackageInfoGeneration: BuildSettingsKey = "GENERATE_PKGINFO_FILE"
}

// MARK: Generate Profiling Code
extension BuildSetting {

    /// Generate Profiling Code
    ///
    /// Activating this setting will cause the compiler and linker to generate profiling code. For example, GCC will generate code suitable for use with `gprof(1)`.
    public static var generateProfilingCode: BuildSetting { 
        BuildSetting(key: .generateProfilingCode, value: "NO")
    }

    /// Generate Profiling Code
    ///
    /// Activating this setting will cause the compiler and linker to generate profiling code. For example, GCC will generate code suitable for use with `gprof(1)`.
    public static func generateProfilingCode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateProfilingCode, value: value.asText)
    }

    /// Generate Profiling Code
    ///
    /// Activating this setting will cause the compiler and linker to generate profiling code. For example, GCC will generate code suitable for use with `gprof(1)`.
    public static func generateProfilingCode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateProfilingCode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Profiling Code
    ///
    /// Activating this setting will cause the compiler and linker to generate profiling code. For example, GCC will generate code suitable for use with `gprof(1)`.
    public static let generateProfilingCode: BuildSettingsKey = "GENERATE_PROFILING_CODE"
}

// MARK: Enable Text-Based Stubs Generation
extension BuildSetting {

    /// Enable Text-Based Stubs Generation
    ///
    /// Enables the generation of Text-Based stubs for dynamic libraries and frameworks.
    public static var enableTextBasedStubsGeneration: BuildSetting { 
        BuildSetting(key: .enableTextBasedStubsGeneration, value: "NO")
    }

    /// Enable Text-Based Stubs Generation
    ///
    /// Enables the generation of Text-Based stubs for dynamic libraries and frameworks.
    public static func enableTextBasedStubsGeneration(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTextBasedStubsGeneration, value: value.asText)
    }

    /// Enable Text-Based Stubs Generation
    ///
    /// Enables the generation of Text-Based stubs for dynamic libraries and frameworks.
    public static func enableTextBasedStubsGeneration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTextBasedStubsGeneration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Text-Based Stubs Generation
    ///
    /// Enables the generation of Text-Based stubs for dynamic libraries and frameworks.
    public static let enableTextBasedStubsGeneration: BuildSettingsKey = "GENERATE_TEXT_BASED_STUBS"
}

// MARK: Headermap Includes Flat Entries For Target Being Built
extension BuildSetting {

    /// Headermap Includes Flat Entries For Target Being Built
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the target being built.
    public static var headermapIncludesFlatEntriesForTargetBeingBuilt: BuildSetting { 
        BuildSetting(key: .headermapIncludesFlatEntriesForTargetBeingBuilt, value: "YES")
    }

    /// Headermap Includes Flat Entries For Target Being Built
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the target being built.
    public static func headermapIncludesFlatEntriesForTargetBeingBuilt(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapIncludesFlatEntriesForTargetBeingBuilt, value: value.asText)
    }

    /// Headermap Includes Flat Entries For Target Being Built
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the target being built.
    public static func headermapIncludesFlatEntriesForTargetBeingBuilt(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapIncludesFlatEntriesForTargetBeingBuilt, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Headermap Includes Flat Entries For Target Being Built
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the target being built.
    public static let headermapIncludesFlatEntriesForTargetBeingBuilt: BuildSettingsKey = "HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT"
}

// MARK: Headermap Includes Framework Entries For All Product Types
extension BuildSetting {

    /// Headermap Includes Framework Entries For All Product Types
    ///
    /// Specifies whether the header map contains a framework-name/path entry for every header in the target being built, including targets that do not build frameworks.
    public static var headermapIncludesFrameworkEntriesForAllProductTypes: BuildSetting { 
        BuildSetting(key: .headermapIncludesFrameworkEntriesForAllProductTypes, value: "YES")
    }

    /// Headermap Includes Framework Entries For All Product Types
    ///
    /// Specifies whether the header map contains a framework-name/path entry for every header in the target being built, including targets that do not build frameworks.
    public static func headermapIncludesFrameworkEntriesForAllProductTypes(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapIncludesFrameworkEntriesForAllProductTypes, value: value.asText)
    }

    /// Headermap Includes Framework Entries For All Product Types
    ///
    /// Specifies whether the header map contains a framework-name/path entry for every header in the target being built, including targets that do not build frameworks.
    public static func headermapIncludesFrameworkEntriesForAllProductTypes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapIncludesFrameworkEntriesForAllProductTypes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Headermap Includes Framework Entries For All Product Types
    ///
    /// Specifies whether the header map contains a framework-name/path entry for every header in the target being built, including targets that do not build frameworks.
    public static let headermapIncludesFrameworkEntriesForAllProductTypes: BuildSettingsKey = "HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES"
}

// MARK: Headermap Includes Nonpublic Nonprivate Headers
extension BuildSetting {

    /// Headermap Includes Nonpublic Nonprivate Headers
    public static var headermapIncludesNonpublicNonprivateHeaders: BuildSetting { 
        .headermapIncludesNonpublicNonprivateHeaders(inherit: .headermapIncludesProjectHeaders) 
    }

    /// Headermap Includes Nonpublic Nonprivate Headers
    public static func headermapIncludesNonpublicNonprivateHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapIncludesNonpublicNonprivateHeaders, value: value.asText)
    }

    /// Headermap Includes Nonpublic Nonprivate Headers
    public static func headermapIncludesNonpublicNonprivateHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapIncludesNonpublicNonprivateHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Headermap Includes Nonpublic Nonprivate Headers
    public static let headermapIncludesNonpublicNonprivateHeaders: BuildSettingsKey = "HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS"
}

// MARK: Headermap Includes Project Headers
extension BuildSetting {

    /// Headermap Includes Project Headers
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the project, regardless of the headers’ target membership.
    public static var headermapIncludesProjectHeaders: BuildSetting { 
        BuildSetting(key: .headermapIncludesProjectHeaders, value: "YES")
    }

    /// Headermap Includes Project Headers
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the project, regardless of the headers’ target membership.
    public static func headermapIncludesProjectHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapIncludesProjectHeaders, value: value.asText)
    }

    /// Headermap Includes Project Headers
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the project, regardless of the headers’ target membership.
    public static func headermapIncludesProjectHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapIncludesProjectHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Headermap Includes Project Headers
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the project, regardless of the headers’ target membership.
    public static let headermapIncludesProjectHeaders: BuildSettingsKey = "HEADERMAP_INCLUDES_PROJECT_HEADERS"
}

// MARK: Headermap Uses Framework Prefix Entries
extension BuildSetting {

    /// Headermap Uses Framework Prefix Entries
    public static var headermapUsesFrameworkPrefixEntries: BuildSetting { 
        BuildSetting(key: .headermapUsesFrameworkPrefixEntries, value: "YES")
    }

    /// Headermap Uses Framework Prefix Entries
    public static func headermapUsesFrameworkPrefixEntries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapUsesFrameworkPrefixEntries, value: value.asText)
    }

    /// Headermap Uses Framework Prefix Entries
    public static func headermapUsesFrameworkPrefixEntries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapUsesFrameworkPrefixEntries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Headermap Uses Framework Prefix Entries
    public static let headermapUsesFrameworkPrefixEntries: BuildSettingsKey = "HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES"
}

// MARK: Headermap Uses Vfs
extension BuildSetting {

    /// Headermap Uses Vfs
    public static var headermapUsesVfs: BuildSetting { 
        .headermapUsesVfs(inherit: .definesModule) 
    }

    /// Headermap Uses Vfs
    public static func headermapUsesVfs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapUsesVfs, value: value.asText)
    }

    /// Headermap Uses Vfs
    public static func headermapUsesVfs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapUsesVfs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Headermap Uses Vfs
    public static let headermapUsesVfs: BuildSettingsKey = "HEADERMAP_USES_VFS"
}

// MARK: Header Search Paths
extension BuildSetting {

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func headerSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .headerSearchPaths, value: .array(value))
    }

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func headerSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headerSearchPaths, inherit: key)
    }

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func headerSearchPaths(_ value: String...) -> BuildSetting { 
        .headerSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static let headerSearchPaths: BuildSettingsKey = "HEADER_SEARCH_PATHS"
}

// MARK: Hide Bitcode Symbols
extension BuildSetting {

    /// Hide Bitcode Symbols
    public static var hideBitcodeSymbols: BuildSetting { 
        BuildSetting(key: .hideBitcodeSymbols, value: "YES")
    }

    /// Hide Bitcode Symbols
    public static func hideBitcodeSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .hideBitcodeSymbols, value: value.asText)
    }

    /// Hide Bitcode Symbols
    public static func hideBitcodeSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .hideBitcodeSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Hide Bitcode Symbols
    public static let hideBitcodeSymbols: BuildSettingsKey = "HIDE_BITCODE_SYMBOLS"
}

// MARK: Home
extension BuildSetting {

    /// Home
    public static func home(_ value: String) -> BuildSetting { 
        BuildSetting(key: .home, value: \(value))
    }

    /// Home
    public static func home(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .home, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Home
    public static let home: BuildSettingsKey = "HOME"
}

// MARK: Sub-Directories to Include in Recursive Searches
extension BuildSetting {

    /// Sub-Directories to Include in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to include when performing a recursive search. By default, this is empty and is only customized when you want to provide exceptions to the list of filename patterns provided in [Sub-Directories to Exclude in Recursive Searches (EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES)](itcaec37c2a6.html# dev454fb3164).
    public static func subDirectoriesToIncludeInRecursiveSearches(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .subDirectoriesToIncludeInRecursiveSearches, value: .array(value))
    }

    /// Sub-Directories to Include in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to include when performing a recursive search. By default, this is empty and is only customized when you want to provide exceptions to the list of filename patterns provided in [Sub-Directories to Exclude in Recursive Searches (EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES)](itcaec37c2a6.html# dev454fb3164).
    public static func subDirectoriesToIncludeInRecursiveSearches(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .subDirectoriesToIncludeInRecursiveSearches, inherit: key)
    }

    /// Sub-Directories to Include in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to include when performing a recursive search. By default, this is empty and is only customized when you want to provide exceptions to the list of filename patterns provided in [Sub-Directories to Exclude in Recursive Searches (EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES)](itcaec37c2a6.html# dev454fb3164).
    public static func subDirectoriesToIncludeInRecursiveSearches(_ value: String...) -> BuildSetting { 
        .subDirectoriesToIncludeInRecursiveSearches(value)
    }
}

extension BuildSettingsKey {

    /// Sub-Directories to Include in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to include when performing a recursive search. By default, this is empty and is only customized when you want to provide exceptions to the list of filename patterns provided in [Sub-Directories to Exclude in Recursive Searches (EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES)](itcaec37c2a6.html# dev454fb3164).
    public static let subDirectoriesToIncludeInRecursiveSearches: BuildSettingsKey = "INCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES"
}

// MARK: Included Source File Names
extension BuildSetting {

    /// Included Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly **include** when processing the files in the target’s build phases. This setting is only useful when combined with [Excluded Source File Names (EXCLUDED_SOURCE_FILE_NAMES)](itcaec37c2a6.html# devd20926192), and can be used to define complex filters for which files from the phase should be built in response to other build settings.
    public static func includedSourceFileNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .includedSourceFileNames, value: .array(value))
    }

    /// Included Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly **include** when processing the files in the target’s build phases. This setting is only useful when combined with [Excluded Source File Names (EXCLUDED_SOURCE_FILE_NAMES)](itcaec37c2a6.html# devd20926192), and can be used to define complex filters for which files from the phase should be built in response to other build settings.
    public static func includedSourceFileNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .includedSourceFileNames, inherit: key)
    }

    /// Included Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly **include** when processing the files in the target’s build phases. This setting is only useful when combined with [Excluded Source File Names (EXCLUDED_SOURCE_FILE_NAMES)](itcaec37c2a6.html# devd20926192), and can be used to define complex filters for which files from the phase should be built in response to other build settings.
    public static func includedSourceFileNames(_ value: String...) -> BuildSetting { 
        .includedSourceFileNames(value)
    }
}

extension BuildSettingsKey {

    /// Included Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly **include** when processing the files in the target’s build phases. This setting is only useful when combined with [Excluded Source File Names (EXCLUDED_SOURCE_FILE_NAMES)](itcaec37c2a6.html# devd20926192), and can be used to define complex filters for which files from the phase should be built in response to other build settings.
    public static let includedSourceFileNames: BuildSettingsKey = "INCLUDED_SOURCE_FILE_NAMES"
}

// MARK: Expand Build Settings in Info.plist File
extension BuildSetting {

    /// Expand Build Settings in Info.plist File
    ///
    /// Expand build settings in the `Info.plist` file.
    public static var expandBuildSettingsInInfoPlistFile: BuildSetting { 
        BuildSetting(key: .expandBuildSettingsInInfoPlistFile, value: "YES")
    }

    /// Expand Build Settings in Info.plist File
    ///
    /// Expand build settings in the `Info.plist` file.
    public static func expandBuildSettingsInInfoPlistFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .expandBuildSettingsInInfoPlistFile, value: value.asText)
    }

    /// Expand Build Settings in Info.plist File
    ///
    /// Expand build settings in the `Info.plist` file.
    public static func expandBuildSettingsInInfoPlistFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .expandBuildSettingsInInfoPlistFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Expand Build Settings in Info.plist File
    ///
    /// Expand build settings in the `Info.plist` file.
    public static let expandBuildSettingsInInfoPlistFile: BuildSettingsKey = "INFOPLIST_EXPAND_BUILD_SETTINGS"
}

// MARK: Info.plist File
extension BuildSetting {

    /// Info.plist File
    ///
    /// The project-relative path to the property list file that contains the `Info.plist` information used by bundles. For details on information property list files, see [Information Property List Files](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigFiles.html#//apple_ref/doc/uid/20002091-CJBJIEDH) in [Runtime Configuration Guidelines](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/000-Introduction/introduction.html).
    public static func infoPlistFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .infoPlistFile, value: \(value))
    }

    /// Info.plist File
    ///
    /// The project-relative path to the property list file that contains the `Info.plist` information used by bundles. For details on information property list files, see [Information Property List Files](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigFiles.html#//apple_ref/doc/uid/20002091-CJBJIEDH) in [Runtime Configuration Guidelines](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/000-Introduction/introduction.html).
    public static func infoPlistFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Info.plist File
    ///
    /// The project-relative path to the property list file that contains the `Info.plist` information used by bundles. For details on information property list files, see [Information Property List Files](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigFiles.html#//apple_ref/doc/uid/20002091-CJBJIEDH) in [Runtime Configuration Guidelines](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/000-Introduction/introduction.html).
    public static let infoPlistFile: BuildSettingsKey = "INFOPLIST_FILE"
}

// MARK: Info.plist Other Preprocessor Flags
extension BuildSetting {

    /// Info.plist Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when preprocessing the `Info.plist` file.
    public static func infoPlistOtherPreprocessorFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .infoPlistOtherPreprocessorFlags, value: .array(value))
    }

    /// Info.plist Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when preprocessing the `Info.plist` file.
    public static func infoPlistOtherPreprocessorFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistOtherPreprocessorFlags, inherit: key)
    }

    /// Info.plist Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when preprocessing the `Info.plist` file.
    public static func infoPlistOtherPreprocessorFlags(_ value: String...) -> BuildSetting { 
        .infoPlistOtherPreprocessorFlags(value)
    }
}

extension BuildSettingsKey {

    /// Info.plist Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when preprocessing the `Info.plist` file.
    public static let infoPlistOtherPreprocessorFlags: BuildSettingsKey = "INFOPLIST_OTHER_PREPROCESSOR_FLAGS"
}

// MARK: Info.plist Output Encoding
extension BuildSetting {

    /// Info.plist Output Encoding
    ///
    /// Specifies the output encoding for the output `Info.plist`. The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static var infoPlistOutputEncoding: BuildSetting { 
        .infoPlistOutputEncoding(.sameAsInput) 
    }

    /// Info.plist Output Encoding
    ///
    /// Specifies the output encoding for the output `Info.plist`. The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static func infoPlistOutputEncoding(_ value: InfoPlistOutputEncoding) -> BuildSetting { 
        BuildSetting(key: .infoPlistOutputEncoding, value: \(value))
    }

    /// Info.plist Output Encoding
    ///
    /// Specifies the output encoding for the output `Info.plist`. The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static func infoPlistOutputEncoding(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistOutputEncoding, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Info.plist Output Encoding
    ///
    /// Specifies the output encoding for the output `Info.plist`. The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static let infoPlistOutputEncoding: BuildSettingsKey = "INFOPLIST_OUTPUT_FORMAT"
}

public enum InfoPlistOutputEncoding: String, Hashable, Codable, CustomStringConvertible {
    case sameAsInput = "same-as-input"
    case xml = "XML"
    case binary = "binary"

    public var description: String {
        rawValue
    }
}

// MARK: Info.plist Preprocessor Prefix File
extension BuildSetting {

    /// Info.plist Preprocessor Prefix File
    ///
    /// Implicitly include the given file when preprocessing the `Info.plist` file. The path given should either be a project relative path or an absolute path.
    public static func infoPlistPreprocessorPrefixFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .infoPlistPreprocessorPrefixFile, value: \(value))
    }

    /// Info.plist Preprocessor Prefix File
    ///
    /// Implicitly include the given file when preprocessing the `Info.plist` file. The path given should either be a project relative path or an absolute path.
    public static func infoPlistPreprocessorPrefixFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistPreprocessorPrefixFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Info.plist Preprocessor Prefix File
    ///
    /// Implicitly include the given file when preprocessing the `Info.plist` file. The path given should either be a project relative path or an absolute path.
    public static let infoPlistPreprocessorPrefixFile: BuildSettingsKey = "INFOPLIST_PREFIX_HEADER"
}

// MARK: Preprocess Info.plist File
extension BuildSetting {

    /// Preprocess Info.plist File
    ///
    /// Preprocess the `Info.plist` file using the C Preprocessor.
    public static var preprocessInfoPlistFile: BuildSetting { 
        BuildSetting(key: .preprocessInfoPlistFile, value: "NO")
    }

    /// Preprocess Info.plist File
    ///
    /// Preprocess the `Info.plist` file using the C Preprocessor.
    public static func preprocessInfoPlistFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .preprocessInfoPlistFile, value: value.asText)
    }

    /// Preprocess Info.plist File
    ///
    /// Preprocess the `Info.plist` file using the C Preprocessor.
    public static func preprocessInfoPlistFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessInfoPlistFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Preprocess Info.plist File
    ///
    /// Preprocess the `Info.plist` file using the C Preprocessor.
    public static let preprocessInfoPlistFile: BuildSettingsKey = "INFOPLIST_PREPROCESS"
}

// MARK: Info.plist Preprocessor Definitions
extension BuildSetting {

    /// Info.plist Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing the `Info.plist` file.
    public static func infoPlistPreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .infoPlistPreprocessorDefinitions, value: .array(value))
    }

    /// Info.plist Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing the `Info.plist` file.
    public static func infoPlistPreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistPreprocessorDefinitions, inherit: key)
    }

    /// Info.plist Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing the `Info.plist` file.
    public static func infoPlistPreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .infoPlistPreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// Info.plist Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing the `Info.plist` file.
    public static let infoPlistPreprocessorDefinitions: BuildSettingsKey = "INFOPLIST_PREPROCESSOR_DEFINITIONS"
}

// MARK: Initialization Routine
extension BuildSetting {

    /// Initialization Routine
    ///
    /// This is the name of the routine to use for initialization.
    public static func initializationRoutine(_ value: String) -> BuildSetting { 
        BuildSetting(key: .initializationRoutine, value: \(value))
    }

    /// Initialization Routine
    ///
    /// This is the name of the routine to use for initialization.
    public static func initializationRoutine(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .initializationRoutine, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Initialization Routine
    ///
    /// This is the name of the routine to use for initialization.
    public static let initializationRoutine: BuildSettingsKey = "INIT_ROUTINE"
}

// MARK: Enable Text-Based Stubs Inlining
extension BuildSetting {

    /// Enable Text-Based Stubs Inlining
    ///
    /// Enables private framework inlining for Text-Based Stubs.
    public static var enableTextBasedStubsInlining: BuildSetting { 
        BuildSetting(key: .enableTextBasedStubsInlining, value: "NO")
    }

    /// Enable Text-Based Stubs Inlining
    ///
    /// Enables private framework inlining for Text-Based Stubs.
    public static func enableTextBasedStubsInlining(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTextBasedStubsInlining, value: value.asText)
    }

    /// Enable Text-Based Stubs Inlining
    ///
    /// Enables private framework inlining for Text-Based Stubs.
    public static func enableTextBasedStubsInlining(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTextBasedStubsInlining, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Text-Based Stubs Inlining
    ///
    /// Enables private framework inlining for Text-Based Stubs.
    public static let enableTextBasedStubsInlining: BuildSettingsKey = "INLINE_PRIVATE_FRAMEWORKS"
}

// MARK: Perform Copy Files Phases During `installhdrs`
extension BuildSetting {

    /// Perform Copy Files Phases During `installhdrs`
    ///
    /// Specifies whether the target’s Copy Files build phases are executed in `installhdr` builds.
    public static var performCopyFilesPhasesDuringInstallhdrs: BuildSetting { 
        BuildSetting(key: .performCopyFilesPhasesDuringInstallhdrs, value: "NO")
    }

    /// Perform Copy Files Phases During `installhdrs`
    ///
    /// Specifies whether the target’s Copy Files build phases are executed in `installhdr` builds.
    public static func performCopyFilesPhasesDuringInstallhdrs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .performCopyFilesPhasesDuringInstallhdrs, value: value.asText)
    }

    /// Perform Copy Files Phases During `installhdrs`
    ///
    /// Specifies whether the target’s Copy Files build phases are executed in `installhdr` builds.
    public static func performCopyFilesPhasesDuringInstallhdrs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .performCopyFilesPhasesDuringInstallhdrs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Perform Copy Files Phases During `installhdrs`
    ///
    /// Specifies whether the target’s Copy Files build phases are executed in `installhdr` builds.
    public static let performCopyFilesPhasesDuringInstallhdrs: BuildSettingsKey = "INSTALLHDRS_COPY_PHASE"
}

// MARK: Perform Shell Script Phases During `installhdrs`
extension BuildSetting {

    /// Perform Shell Script Phases During `installhdrs`
    ///
    /// Specifies whether the target’s Run Script build phases are executed in `installhdr` builds. See [Active Build Action (ACTION)](itcaec37c2a6.html# dev9697f81df) for details on `installhdr` builds.
    public static var performShellScriptPhasesDuringInstallhdrs: BuildSetting { 
        BuildSetting(key: .performShellScriptPhasesDuringInstallhdrs, value: "NO")
    }

    /// Perform Shell Script Phases During `installhdrs`
    ///
    /// Specifies whether the target’s Run Script build phases are executed in `installhdr` builds. See [Active Build Action (ACTION)](itcaec37c2a6.html# dev9697f81df) for details on `installhdr` builds.
    public static func performShellScriptPhasesDuringInstallhdrs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .performShellScriptPhasesDuringInstallhdrs, value: value.asText)
    }

    /// Perform Shell Script Phases During `installhdrs`
    ///
    /// Specifies whether the target’s Run Script build phases are executed in `installhdr` builds. See [Active Build Action (ACTION)](itcaec37c2a6.html# dev9697f81df) for details on `installhdr` builds.
    public static func performShellScriptPhasesDuringInstallhdrs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .performShellScriptPhasesDuringInstallhdrs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Perform Shell Script Phases During `installhdrs`
    ///
    /// Specifies whether the target’s Run Script build phases are executed in `installhdr` builds. See [Active Build Action (ACTION)](itcaec37c2a6.html# dev9697f81df) for details on `installhdr` builds.
    public static let performShellScriptPhasesDuringInstallhdrs: BuildSettingsKey = "INSTALLHDRS_SCRIPT_PHASE"
}

// MARK: Install Dir
extension BuildSetting {

    /// Install Dir
    ///
    /// Identifies the directory in the developer’s filesystem into which the **installed** product is placed.
    public static var installDir: BuildSetting { 
        BuildSetting(key: .installDir, value: "$(DSTROOT)$(INSTALL_PATH)")
    }

    /// Install Dir
    ///
    /// Identifies the directory in the developer’s filesystem into which the **installed** product is placed.
    public static func installDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installDir, value: \(value))
    }

    /// Install Dir
    ///
    /// Identifies the directory in the developer’s filesystem into which the **installed** product is placed.
    public static func installDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Install Dir
    ///
    /// Identifies the directory in the developer’s filesystem into which the **installed** product is placed.
    public static let installDir: BuildSettingsKey = "INSTALL_DIR"
}

// MARK: Install Group
extension BuildSetting {

    /// Install Group
    ///
    /// The group name or `gid` for installed products.
    public static var installGroup: BuildSetting { 
        BuildSetting(key: .installGroup, value: "$(GROUP)")
    }

    /// Install Group
    ///
    /// The group name or `gid` for installed products.
    public static func installGroup(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installGroup, value: \(value))
    }

    /// Install Group
    ///
    /// The group name or `gid` for installed products.
    public static func installGroup(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installGroup, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Install Group
    ///
    /// The group name or `gid` for installed products.
    public static let installGroup: BuildSettingsKey = "INSTALL_GROUP"
}

// MARK: Install Permissions
extension BuildSetting {

    /// Install Permissions
    ///
    /// Permissions used for installed product files.
    public static var installPermissions: BuildSetting { 
        BuildSetting(key: .installPermissions, value: "u+w,go-w,a+rX")
    }

    /// Install Permissions
    ///
    /// Permissions used for installed product files.
    public static func installPermissions(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installPermissions, value: \(value))
    }

    /// Install Permissions
    ///
    /// Permissions used for installed product files.
    public static func installPermissions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installPermissions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Install Permissions
    ///
    /// Permissions used for installed product files.
    public static let installPermissions: BuildSettingsKey = "INSTALL_MODE_FLAG"
}

// MARK: Install Owner
extension BuildSetting {

    /// Install Owner
    ///
    /// The owner name or `uid` for installed products.
    public static var installOwner: BuildSetting { 
        .installOwner(inherit: .user) 
    }

    /// Install Owner
    ///
    /// The owner name or `uid` for installed products.
    public static func installOwner(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installOwner, value: \(value))
    }

    /// Install Owner
    ///
    /// The owner name or `uid` for installed products.
    public static func installOwner(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installOwner, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Install Owner
    ///
    /// The owner name or `uid` for installed products.
    public static let installOwner: BuildSettingsKey = "INSTALL_OWNER"
}

// MARK: Installation Directory
extension BuildSetting {

    /// Installation Directory
    ///
    /// The directory in which to install the build products. This path is prepended by the [Installation Build Products Location (DSTROOT)](itcaec37c2a6.html# dev438d356c2).
    public static func installationDirectory(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installationDirectory, value: \(value))
    }

    /// Installation Directory
    ///
    /// The directory in which to install the build products. This path is prepended by the [Installation Build Products Location (DSTROOT)](itcaec37c2a6.html# dev438d356c2).
    public static func installationDirectory(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installationDirectory, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Installation Directory
    ///
    /// The directory in which to install the build products. This path is prepended by the [Installation Build Products Location (DSTROOT)](itcaec37c2a6.html# dev438d356c2).
    public static let installationDirectory: BuildSettingsKey = "INSTALL_PATH"
}

// MARK: Install Root
extension BuildSetting {

    /// Install Root
    public static var installRoot: BuildSetting { 
        .installRoot(inherit: .installationBuildProductsLocation) 
    }

    /// Install Root
    public static func installRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installRoot, value: \(value))
    }

    /// Install Root
    public static func installRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Install Root
    public static let installRoot: BuildSettingsKey = "INSTALL_ROOT"
}

// MARK: Java App Stub
extension BuildSetting {

    /// Java App Stub
    public static var javaAppStub: BuildSetting { 
        BuildSetting(key: .javaAppStub, value: "$(SYSTEM_LIBRARY_DIR)/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub")
    }

    /// Java App Stub
    public static func javaAppStub(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaAppStub, value: \(value))
    }

    /// Java App Stub
    public static func javaAppStub(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaAppStub, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Java App Stub
    public static let javaAppStub: BuildSettingsKey = "JAVA_APP_STUB"
}

// MARK: Java Archive Classes
extension BuildSetting {

    /// Java Archive Classes
    public static var javaArchiveClasses: BuildSetting { 
        BuildSetting(key: .javaArchiveClasses, value: "YES")
    }

    /// Java Archive Classes
    public static func javaArchiveClasses(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .javaArchiveClasses, value: value.asText)
    }

    /// Java Archive Classes
    public static func javaArchiveClasses(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaArchiveClasses, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Java Archive Classes
    public static let javaArchiveClasses: BuildSettingsKey = "JAVA_ARCHIVE_CLASSES"
}

// MARK: Java Archive Type
extension BuildSetting {

    /// Java Archive Type
    public static var javaArchiveType: BuildSetting { 
        BuildSetting(key: .javaArchiveType, value: "JAR")
    }

    /// Java Archive Type
    public static func javaArchiveType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaArchiveType, value: \(value))
    }

    /// Java Archive Type
    public static func javaArchiveType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaArchiveType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Java Archive Type
    public static let javaArchiveType: BuildSettingsKey = "JAVA_ARCHIVE_TYPE"
}

// MARK: Java Compiler
extension BuildSetting {

    /// Java Compiler
    public static var javaCompiler: BuildSetting { 
        BuildSetting(key: .javaCompiler, value: "/usr/bin/javac")
    }

    /// Java Compiler
    public static func javaCompiler(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaCompiler, value: \(value))
    }

    /// Java Compiler
    public static func javaCompiler(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaCompiler, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Java Compiler
    public static let javaCompiler: BuildSettingsKey = "JAVA_COMPILER"
}

// MARK: Java Framework Jars
extension BuildSetting {

    /// Java Framework Jars
    public static func javaFrameworkJars(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javaFrameworkJars, value: .array(value))
    }

    /// Java Framework Jars
    public static func javaFrameworkJars(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaFrameworkJars, inherit: key)
    }

    /// Java Framework Jars
    public static func javaFrameworkJars(_ value: String...) -> BuildSetting { 
        .javaFrameworkJars(value)
    }
}

extension BuildSettingsKey {

    /// Java Framework Jars
    public static let javaFrameworkJars: BuildSettingsKey = "JAVA_FRAMEWORK_JARS"
}

// MARK: Java Framework Resources Dirs
extension BuildSetting {

    /// Java Framework Resources Dirs
    public static var javaFrameworkResourcesDirs: BuildSetting { 
        BuildSetting(key: .javaFrameworkResourcesDirs, value: "Resources")
    }

    /// Java Framework Resources Dirs
    public static func javaFrameworkResourcesDirs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javaFrameworkResourcesDirs, value: .array(value))
    }

    /// Java Framework Resources Dirs
    public static func javaFrameworkResourcesDirs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaFrameworkResourcesDirs, inherit: key)
    }

    /// Java Framework Resources Dirs
    public static func javaFrameworkResourcesDirs(_ value: String...) -> BuildSetting { 
        .javaFrameworkResourcesDirs(value)
    }
}

extension BuildSettingsKey {

    /// Java Framework Resources Dirs
    public static let javaFrameworkResourcesDirs: BuildSettingsKey = "JAVA_FRAMEWORK_RESOURCES_DIRS"
}

// MARK: Java Jar Flags
extension BuildSetting {

    /// Java Jar Flags
    public static var javaJarFlags: BuildSetting { 
        BuildSetting(key: .javaJarFlags, value: "cv")
    }

    /// Java Jar Flags
    public static func javaJarFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javaJarFlags, value: .array(value))
    }

    /// Java Jar Flags
    public static func javaJarFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaJarFlags, inherit: key)
    }

    /// Java Jar Flags
    public static func javaJarFlags(_ value: String...) -> BuildSetting { 
        .javaJarFlags(value)
    }
}

extension BuildSettingsKey {

    /// Java Jar Flags
    public static let javaJarFlags: BuildSettingsKey = "JAVA_JAR_FLAGS"
}

// MARK: Java Source Subdir
extension BuildSetting {

    /// Java Source Subdir
    public static var javaSourceSubdir: BuildSetting { 
        BuildSetting(key: .javaSourceSubdir, value: ".")
    }

    /// Java Source Subdir
    public static func javaSourceSubdir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaSourceSubdir, value: \(value))
    }

    /// Java Source Subdir
    public static func javaSourceSubdir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaSourceSubdir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Java Source Subdir
    public static let javaSourceSubdir: BuildSettingsKey = "JAVA_SOURCE_SUBDIR"
}

// MARK: Java Use Dependencies
extension BuildSetting {

    /// Java Use Dependencies
    public static var javaUseDependencies: BuildSetting { 
        BuildSetting(key: .javaUseDependencies, value: "YES")
    }

    /// Java Use Dependencies
    public static func javaUseDependencies(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .javaUseDependencies, value: value.asText)
    }

    /// Java Use Dependencies
    public static func javaUseDependencies(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaUseDependencies, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Java Use Dependencies
    public static let javaUseDependencies: BuildSettingsKey = "JAVA_USE_DEPENDENCIES"
}

// MARK: Java Zip Flags
extension BuildSetting {

    /// Java Zip Flags
    public static var javaZipFlags: BuildSetting { 
        BuildSetting(key: .javaZipFlags, value: "-urg")
    }

    /// Java Zip Flags
    public static func javaZipFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javaZipFlags, value: .array(value))
    }

    /// Java Zip Flags
    public static func javaZipFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaZipFlags, inherit: key)
    }

    /// Java Zip Flags
    public static func javaZipFlags(_ value: String...) -> BuildSetting { 
        .javaZipFlags(value)
    }
}

extension BuildSettingsKey {

    /// Java Zip Flags
    public static let javaZipFlags: BuildSettingsKey = "JAVA_ZIP_FLAGS"
}

// MARK: Preserve Private External Symbols
extension BuildSetting {

    /// Preserve Private External Symbols
    ///
    /// Activating this setting will preserve private external symbols, rather than turning them into static symbols. This setting is also respected when performing a single-object prelink.
    public static var preservePrivateExternalSymbols: BuildSetting { 
        BuildSetting(key: .preservePrivateExternalSymbols, value: "NO")
    }

    /// Preserve Private External Symbols
    ///
    /// Activating this setting will preserve private external symbols, rather than turning them into static symbols. This setting is also respected when performing a single-object prelink.
    public static func preservePrivateExternalSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .preservePrivateExternalSymbols, value: value.asText)
    }

    /// Preserve Private External Symbols
    ///
    /// Activating this setting will preserve private external symbols, rather than turning them into static symbols. This setting is also respected when performing a single-object prelink.
    public static func preservePrivateExternalSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preservePrivateExternalSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Preserve Private External Symbols
    ///
    /// Activating this setting will preserve private external symbols, rather than turning them into static symbols. This setting is also respected when performing a single-object prelink.
    public static let preservePrivateExternalSymbols: BuildSettingsKey = "KEEP_PRIVATE_EXTERNS"
}

// MARK: Kext Cflags
extension BuildSetting {

    /// Kext Cflags
    public static func kextCflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .kextCflags, value: .array(value))
    }

    /// Kext Cflags
    public static func kextCflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .kextCflags, inherit: key)
    }

    /// Kext Cflags
    public static func kextCflags(_ value: String...) -> BuildSetting { 
        .kextCflags(value)
    }
}

extension BuildSettingsKey {

    /// Kext Cflags
    public static let kextCflags: BuildSettingsKey = "KEXT_CFLAGS"
}

// MARK: Kext Cplusplusflags
extension BuildSetting {

    /// Kext Cplusplusflags
    public static var kextCplusplusflags: BuildSetting { 
        .kextCplusplusflags(inherit: .kextCflags) 
    }

    /// Kext Cplusplusflags
    public static func kextCplusplusflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .kextCplusplusflags, value: .array(value))
    }

    /// Kext Cplusplusflags
    public static func kextCplusplusflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .kextCplusplusflags, inherit: key)
    }

    /// Kext Cplusplusflags
    public static func kextCplusplusflags(_ value: String...) -> BuildSetting { 
        .kextCplusplusflags(value)
    }
}

extension BuildSettingsKey {

    /// Kext Cplusplusflags
    public static let kextCplusplusflags: BuildSettingsKey = "KEXT_CPLUSPLUSFLAGS"
}

// MARK: Path to Linker Dependency Info File
extension BuildSetting {

    /// Path to Linker Dependency Info File
    ///
    /// This setting defines the path to which the linker should emit information about what files it used as inputs and generated. Xcode uses this information for its dependency tracking. Setting the value of this setting to empty will disable passing this option to the linker.
    public static var pathToLinkerDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .pathToLinkerDependencyInfoFile, value: "$(OBJECT_FILE_DIR_$(CURRENT_VARIANT))/$(CURRENT_ARCH)/$(PRODUCT_NAME)_dependency_info.dat")
    }

    /// Path to Linker Dependency Info File
    ///
    /// This setting defines the path to which the linker should emit information about what files it used as inputs and generated. Xcode uses this information for its dependency tracking. Setting the value of this setting to empty will disable passing this option to the linker.
    public static func pathToLinkerDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pathToLinkerDependencyInfoFile, value: \(value))
    }

    /// Path to Linker Dependency Info File
    ///
    /// This setting defines the path to which the linker should emit information about what files it used as inputs and generated. Xcode uses this information for its dependency tracking. Setting the value of this setting to empty will disable passing this option to the linker.
    public static func pathToLinkerDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pathToLinkerDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Path to Linker Dependency Info File
    ///
    /// This setting defines the path to which the linker should emit information about what files it used as inputs and generated. Xcode uses this information for its dependency tracking. Setting the value of this setting to empty will disable passing this option to the linker.
    public static let pathToLinkerDependencyInfoFile: BuildSettingsKey = "LD_DEPENDENCY_INFO_FILE"
}

// MARK: Dynamic Library Allowable Clients
extension BuildSetting {

    /// Dynamic Library Allowable Clients
    ///
    /// This setting restricts the clients allowed to link a dylib by passing `-allowable_client` to the linker for each supplied value.
    public static func dynamicLibraryAllowableClients(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .dynamicLibraryAllowableClients, value: .array(value))
    }

    /// Dynamic Library Allowable Clients
    ///
    /// This setting restricts the clients allowed to link a dylib by passing `-allowable_client` to the linker for each supplied value.
    public static func dynamicLibraryAllowableClients(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dynamicLibraryAllowableClients, inherit: key)
    }

    /// Dynamic Library Allowable Clients
    ///
    /// This setting restricts the clients allowed to link a dylib by passing `-allowable_client` to the linker for each supplied value.
    public static func dynamicLibraryAllowableClients(_ value: String...) -> BuildSetting { 
        .dynamicLibraryAllowableClients(value)
    }
}

extension BuildSettingsKey {

    /// Dynamic Library Allowable Clients
    ///
    /// This setting restricts the clients allowed to link a dylib by passing `-allowable_client` to the linker for each supplied value.
    public static let dynamicLibraryAllowableClients: BuildSettingsKey = "LD_DYLIB_ALLOWABLE_CLIENTS"
}

// MARK: Dynamic Library Install Name
extension BuildSetting {

    /// Dynamic Library Install Name
    ///
    /// Sets an internal `install path` (`LC_ID_DYLIB`) in a dynamic library. Any clients linked against the library will record that path as the way `dyld` should locate this library. If this option is not specified, then the `-o` path will be used. This setting is ignored when building any product other than a dynamic library. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func dynamicLibraryInstallName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .dynamicLibraryInstallName, value: \(value))
    }

    /// Dynamic Library Install Name
    ///
    /// Sets an internal `install path` (`LC_ID_DYLIB`) in a dynamic library. Any clients linked against the library will record that path as the way `dyld` should locate this library. If this option is not specified, then the `-o` path will be used. This setting is ignored when building any product other than a dynamic library. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func dynamicLibraryInstallName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dynamicLibraryInstallName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dynamic Library Install Name
    ///
    /// Sets an internal `install path` (`LC_ID_DYLIB`) in a dynamic library. Any clients linked against the library will record that path as the way `dyld` should locate this library. If this option is not specified, then the `-o` path will be used. This setting is ignored when building any product other than a dynamic library. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static let dynamicLibraryInstallName: BuildSettingsKey = "LD_DYLIB_INSTALL_NAME"
}

// MARK: Write Link Map File
extension BuildSetting {

    /// Write Link Map File
    ///
    /// Activating this setting will cause the linker to write a map file to disk, which details all symbols and their addresses in the output image. The path to the map file is defined by the [Path to Link Map File (LD_MAP_FILE_PATH)](itcaec37c2a6.html# dev0f5aa9fe1) setting.
    public static var writeLinkMapFile: BuildSetting { 
        BuildSetting(key: .writeLinkMapFile, value: "NO")
    }

    /// Write Link Map File
    ///
    /// Activating this setting will cause the linker to write a map file to disk, which details all symbols and their addresses in the output image. The path to the map file is defined by the [Path to Link Map File (LD_MAP_FILE_PATH)](itcaec37c2a6.html# dev0f5aa9fe1) setting.
    public static func writeLinkMapFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .writeLinkMapFile, value: value.asText)
    }

    /// Write Link Map File
    ///
    /// Activating this setting will cause the linker to write a map file to disk, which details all symbols and their addresses in the output image. The path to the map file is defined by the [Path to Link Map File (LD_MAP_FILE_PATH)](itcaec37c2a6.html# dev0f5aa9fe1) setting.
    public static func writeLinkMapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .writeLinkMapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Write Link Map File
    ///
    /// Activating this setting will cause the linker to write a map file to disk, which details all symbols and their addresses in the output image. The path to the map file is defined by the [Path to Link Map File (LD_MAP_FILE_PATH)](itcaec37c2a6.html# dev0f5aa9fe1) setting.
    public static let writeLinkMapFile: BuildSettingsKey = "LD_GENERATE_MAP_FILE"
}

// MARK: Path to Link Map File
extension BuildSetting {

    /// Path to Link Map File
    ///
    /// This setting defines the path to the map file written by the linker when the [Write Link Map File (LD_GENERATE_MAP_FILE)](itcaec37c2a6.html# devc1145996b) setting is activated. By default, a separate file will be written for each architecture and build variant, and these will be generated in the Intermediates directory for the target whose product is being linked.
    public static var pathToLinkMapFile: BuildSetting { 
        BuildSetting(key: .pathToLinkMapFile, value: "$(TARGET_TEMP_DIR)/$(PRODUCT_NAME)-LinkMap-$(CURRENT_VARIANT)-$(CURRENT_ARCH).txt")
    }

    /// Path to Link Map File
    ///
    /// This setting defines the path to the map file written by the linker when the [Write Link Map File (LD_GENERATE_MAP_FILE)](itcaec37c2a6.html# devc1145996b) setting is activated. By default, a separate file will be written for each architecture and build variant, and these will be generated in the Intermediates directory for the target whose product is being linked.
    public static func pathToLinkMapFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pathToLinkMapFile, value: \(value))
    }

    /// Path to Link Map File
    ///
    /// This setting defines the path to the map file written by the linker when the [Write Link Map File (LD_GENERATE_MAP_FILE)](itcaec37c2a6.html# devc1145996b) setting is activated. By default, a separate file will be written for each architecture and build variant, and these will be generated in the Intermediates directory for the target whose product is being linked.
    public static func pathToLinkMapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pathToLinkMapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Path to Link Map File
    ///
    /// This setting defines the path to the map file written by the linker when the [Write Link Map File (LD_GENERATE_MAP_FILE)](itcaec37c2a6.html# devc1145996b) setting is activated. By default, a separate file will be written for each architecture and build variant, and these will be generated in the Intermediates directory for the target whose product is being linked.
    public static let pathToLinkMapFile: BuildSettingsKey = "LD_MAP_FILE_PATH"
}

// MARK: Generate Position-Dependent Executable
extension BuildSetting {

    /// Generate Position-Dependent Executable
    ///
    /// Activating this setting will prevent Xcode from building a main executable that is position independent (PIE). When targeting macOS 10.7 or later, PIE is the default for main executables, so activating this setting will change that behavior. When targeting OS X 10.6 or earlier, or when building for i386, PIE is not the default, so activating this setting does nothing. You cannot create a PIE from `.o` files compiled with `-mdynamic-no-pic`. Using PIE means the codegen is less optimal, but the address randomization adds some security.
    public static var generatePositionDependentExecutable: BuildSetting { 
        BuildSetting(key: .generatePositionDependentExecutable, value: "NO")
    }

    /// Generate Position-Dependent Executable
    ///
    /// Activating this setting will prevent Xcode from building a main executable that is position independent (PIE). When targeting macOS 10.7 or later, PIE is the default for main executables, so activating this setting will change that behavior. When targeting OS X 10.6 or earlier, or when building for i386, PIE is not the default, so activating this setting does nothing. You cannot create a PIE from `.o` files compiled with `-mdynamic-no-pic`. Using PIE means the codegen is less optimal, but the address randomization adds some security.
    public static func generatePositionDependentExecutable(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generatePositionDependentExecutable, value: value.asText)
    }

    /// Generate Position-Dependent Executable
    ///
    /// Activating this setting will prevent Xcode from building a main executable that is position independent (PIE). When targeting macOS 10.7 or later, PIE is the default for main executables, so activating this setting will change that behavior. When targeting OS X 10.6 or earlier, or when building for i386, PIE is not the default, so activating this setting does nothing. You cannot create a PIE from `.o` files compiled with `-mdynamic-no-pic`. Using PIE means the codegen is less optimal, but the address randomization adds some security.
    public static func generatePositionDependentExecutable(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatePositionDependentExecutable, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Position-Dependent Executable
    ///
    /// Activating this setting will prevent Xcode from building a main executable that is position independent (PIE). When targeting macOS 10.7 or later, PIE is the default for main executables, so activating this setting will change that behavior. When targeting OS X 10.6 or earlier, or when building for i386, PIE is not the default, so activating this setting does nothing. You cannot create a PIE from `.o` files compiled with `-mdynamic-no-pic`. Using PIE means the codegen is less optimal, but the address randomization adds some security.
    public static let generatePositionDependentExecutable: BuildSettingsKey = "LD_NO_PIE"
}

// MARK: Quote Linker Arguments
extension BuildSetting {

    /// Quote Linker Arguments
    ///
    /// This setting controls whether arguments to the linker should be quoted using `-Xlinker`. By default, Xcode invokes the linker by invoking the driver of the compiler used to build the source files in the target, and passing `-Xlinker` to quote arguments will cause the compiler driver to pass them through to the linker (rather than trying to evaluate them within the driver). By default, this setting is enabled. Disabling it will cause Xcode to not use `-Xlinker` to pass arguments to the linker. Disabling this setting is useful if the target has instructed Xcode to use an alternate linker (for example, by setting the `LD` setting to the path to another linker) and that alternate linker does not recognize `-Xlinker`.
    public static var quoteLinkerArguments: BuildSetting { 
        BuildSetting(key: .quoteLinkerArguments, value: "YES")
    }

    /// Quote Linker Arguments
    ///
    /// This setting controls whether arguments to the linker should be quoted using `-Xlinker`. By default, Xcode invokes the linker by invoking the driver of the compiler used to build the source files in the target, and passing `-Xlinker` to quote arguments will cause the compiler driver to pass them through to the linker (rather than trying to evaluate them within the driver). By default, this setting is enabled. Disabling it will cause Xcode to not use `-Xlinker` to pass arguments to the linker. Disabling this setting is useful if the target has instructed Xcode to use an alternate linker (for example, by setting the `LD` setting to the path to another linker) and that alternate linker does not recognize `-Xlinker`.
    public static func quoteLinkerArguments(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .quoteLinkerArguments, value: value.asText)
    }

    /// Quote Linker Arguments
    ///
    /// This setting controls whether arguments to the linker should be quoted using `-Xlinker`. By default, Xcode invokes the linker by invoking the driver of the compiler used to build the source files in the target, and passing `-Xlinker` to quote arguments will cause the compiler driver to pass them through to the linker (rather than trying to evaluate them within the driver). By default, this setting is enabled. Disabling it will cause Xcode to not use `-Xlinker` to pass arguments to the linker. Disabling this setting is useful if the target has instructed Xcode to use an alternate linker (for example, by setting the `LD` setting to the path to another linker) and that alternate linker does not recognize `-Xlinker`.
    public static func quoteLinkerArguments(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .quoteLinkerArguments, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Quote Linker Arguments
    ///
    /// This setting controls whether arguments to the linker should be quoted using `-Xlinker`. By default, Xcode invokes the linker by invoking the driver of the compiler used to build the source files in the target, and passing `-Xlinker` to quote arguments will cause the compiler driver to pass them through to the linker (rather than trying to evaluate them within the driver). By default, this setting is enabled. Disabling it will cause Xcode to not use `-Xlinker` to pass arguments to the linker. Disabling this setting is useful if the target has instructed Xcode to use an alternate linker (for example, by setting the `LD` setting to the path to another linker) and that alternate linker does not recognize `-Xlinker`.
    public static let quoteLinkerArguments: BuildSettingsKey = "LD_QUOTE_LINKER_ARGUMENTS_FOR_COMPILER_DRIVER"
}

// MARK: Runpath Search Paths
extension BuildSetting {

    /// Runpath Search Paths
    ///
    /// This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func runpathSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .runpathSearchPaths, value: .array(value))
    }

    /// Runpath Search Paths
    ///
    /// This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func runpathSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .runpathSearchPaths, inherit: key)
    }

    /// Runpath Search Paths
    ///
    /// This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func runpathSearchPaths(_ value: String...) -> BuildSetting { 
        .runpathSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Runpath Search Paths
    ///
    /// This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static let runpathSearchPaths: BuildSettingsKey = "LD_RUNPATH_SEARCH_PATHS"
}

// MARK: Library Dext Install Path
extension BuildSetting {

    /// Library Dext Install Path
    public static var libraryDextInstallPath: BuildSetting { 
        BuildSetting(key: .libraryDextInstallPath, value: "$(LOCAL_LIBRARY_DIR)/DriverExtensions")
    }

    /// Library Dext Install Path
    public static func libraryDextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libraryDextInstallPath, value: \(value))
    }

    /// Library Dext Install Path
    public static func libraryDextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libraryDextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Library Dext Install Path
    public static let libraryDextInstallPath: BuildSettingsKey = "LIBRARY_DEXT_INSTALL_PATH"
}

// MARK: Library Flag Nospace
extension BuildSetting {

    /// Library Flag Nospace
    public static var libraryFlagNospace: BuildSetting { 
        BuildSetting(key: .libraryFlagNospace, value: "YES")
    }

    /// Library Flag Nospace
    public static func libraryFlagNospace(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .libraryFlagNospace, value: value.asText)
    }

    /// Library Flag Nospace
    public static func libraryFlagNospace(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libraryFlagNospace, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Library Flag Nospace
    public static let libraryFlagNospace: BuildSettingsKey = "LIBRARY_FLAG_NOSPACE"
}

// MARK: Library Flag Prefix
extension BuildSetting {

    /// Library Flag Prefix
    public static func libraryFlagPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libraryFlagPrefix, value: \(value))
    }

    /// Library Flag Prefix
    public static func libraryFlagPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libraryFlagPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Library Flag Prefix
    public static let libraryFlagPrefix: BuildSettingsKey = "LIBRARY_FLAG_PREFIX"
}

// MARK: Library Kext Install Path
extension BuildSetting {

    /// Library Kext Install Path
    public static var libraryKextInstallPath: BuildSetting { 
        BuildSetting(key: .libraryKextInstallPath, value: "$(LOCAL_LIBRARY_DIR)/Extensions")
    }

    /// Library Kext Install Path
    public static func libraryKextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libraryKextInstallPath, value: \(value))
    }

    /// Library Kext Install Path
    public static func libraryKextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libraryKextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Library Kext Install Path
    public static let libraryKextInstallPath: BuildSettingsKey = "LIBRARY_KEXT_INSTALL_PATH"
}

// MARK: Library Search Paths
extension BuildSetting {

    /// Library Search Paths
    ///
    /// This is a list of paths to folders to be searched by the linker for libraries used by the product. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func librarySearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .librarySearchPaths, value: .array(value))
    }

    /// Library Search Paths
    ///
    /// This is a list of paths to folders to be searched by the linker for libraries used by the product. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func librarySearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .librarySearchPaths, inherit: key)
    }

    /// Library Search Paths
    ///
    /// This is a list of paths to folders to be searched by the linker for libraries used by the product. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func librarySearchPaths(_ value: String...) -> BuildSetting { 
        .librarySearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Library Search Paths
    ///
    /// This is a list of paths to folders to be searched by the linker for libraries used by the product. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static let librarySearchPaths: BuildSettingsKey = "LIBRARY_SEARCH_PATHS"
}

// MARK: Display Mangled Names
extension BuildSetting {

    /// Display Mangled Names
    ///
    /// Activating this setting causes the linker to display mangled names for C++ symbols. Normally, this is not recommended, but turning it on can help to diagnose and solve C++ link errors.
    public static var displayMangledNames: BuildSetting { 
        BuildSetting(key: .displayMangledNames, value: "NO")
    }

    /// Display Mangled Names
    ///
    /// Activating this setting causes the linker to display mangled names for C++ symbols. Normally, this is not recommended, but turning it on can help to diagnose and solve C++ link errors.
    public static func displayMangledNames(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .displayMangledNames, value: value.asText)
    }

    /// Display Mangled Names
    ///
    /// Activating this setting causes the linker to display mangled names for C++ symbols. Normally, this is not recommended, but turning it on can help to diagnose and solve C++ link errors.
    public static func displayMangledNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .displayMangledNames, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Display Mangled Names
    ///
    /// Activating this setting causes the linker to display mangled names for C++ symbols. Normally, this is not recommended, but turning it on can help to diagnose and solve C++ link errors.
    public static let displayMangledNames: BuildSettingsKey = "LINKER_DISPLAYS_MANGLED_NAMES"
}

// MARK: Link With Standard Libraries
extension BuildSetting {

    /// Link With Standard Libraries
    ///
    /// When this setting is enabled, the compiler driver will automatically pass its standard libraries to the linker to use during linking. If desired, this flag can be used to disable linking with the standard libraries, and then individual libraries can be passed as [Other Linker Flags (OTHER_LDFLAGS)](itcaec37c2a6.html# dev4fc8ef90a).
    public static var linkWithStandardLibraries: BuildSetting { 
        BuildSetting(key: .linkWithStandardLibraries, value: "YES")
    }

    /// Link With Standard Libraries
    ///
    /// When this setting is enabled, the compiler driver will automatically pass its standard libraries to the linker to use during linking. If desired, this flag can be used to disable linking with the standard libraries, and then individual libraries can be passed as [Other Linker Flags (OTHER_LDFLAGS)](itcaec37c2a6.html# dev4fc8ef90a).
    public static func linkWithStandardLibraries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .linkWithStandardLibraries, value: value.asText)
    }

    /// Link With Standard Libraries
    ///
    /// When this setting is enabled, the compiler driver will automatically pass its standard libraries to the linker to use during linking. If desired, this flag can be used to disable linking with the standard libraries, and then individual libraries can be passed as [Other Linker Flags (OTHER_LDFLAGS)](itcaec37c2a6.html# dev4fc8ef90a).
    public static func linkWithStandardLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkWithStandardLibraries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Link With Standard Libraries
    ///
    /// When this setting is enabled, the compiler driver will automatically pass its standard libraries to the linker to use during linking. If desired, this flag can be used to disable linking with the standard libraries, and then individual libraries can be passed as [Other Linker Flags (OTHER_LDFLAGS)](itcaec37c2a6.html# dev4fc8ef90a).
    public static let linkWithStandardLibraries: BuildSettingsKey = "LINK_WITH_STANDARD_LIBRARIES"
}

// MARK: Llvm Target Triple Os Version
extension BuildSetting {

    /// Llvm Target Triple Os Version
    public static var llvmTargetTripleOsVersion: BuildSetting { 
        BuildSetting(key: .llvmTargetTripleOsVersion, value: "$(SWIFT_PLATFORM_TARGET_PREFIX)$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// Llvm Target Triple Os Version
    public static func llvmTargetTripleOsVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .llvmTargetTripleOsVersion, value: \(value))
    }

    /// Llvm Target Triple Os Version
    public static func llvmTargetTripleOsVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmTargetTripleOsVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Llvm Target Triple Os Version
    public static let llvmTargetTripleOsVersion: BuildSettingsKey = "LLVM_TARGET_TRIPLE_OS_VERSION"
}

// MARK: Llvm Target Triple Suffix
extension BuildSetting {

    /// Llvm Target Triple Suffix
    public static func llvmTargetTripleSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .llvmTargetTripleSuffix, value: \(value))
    }

    /// Llvm Target Triple Suffix
    public static func llvmTargetTripleSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmTargetTripleSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Llvm Target Triple Suffix
    public static let llvmTargetTripleSuffix: BuildSettingsKey = "LLVM_TARGET_TRIPLE_SUFFIX"
}

// MARK: Llvm Target Triple Vendor
extension BuildSetting {

    /// Llvm Target Triple Vendor
    public static var llvmTargetTripleVendor: BuildSetting { 
        BuildSetting(key: .llvmTargetTripleVendor, value: "apple")
    }

    /// Llvm Target Triple Vendor
    public static func llvmTargetTripleVendor(_ value: String) -> BuildSetting { 
        BuildSetting(key: .llvmTargetTripleVendor, value: \(value))
    }

    /// Llvm Target Triple Vendor
    public static func llvmTargetTripleVendor(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmTargetTripleVendor, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Llvm Target Triple Vendor
    public static let llvmTargetTripleVendor: BuildSettingsKey = "LLVM_TARGET_TRIPLE_VENDOR"
}

// MARK: Localizable Content Dir
extension BuildSetting {

    /// Localizable Content Dir
    public static func localizableContentDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .localizableContentDir, value: \(value))
    }

    /// Localizable Content Dir
    public static func localizableContentDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .localizableContentDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Localizable Content Dir
    public static let localizableContentDir: BuildSettingsKey = "LOCALIZABLE_CONTENT_DIR"
}

// MARK: Localized String Macro Names
extension BuildSetting {

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static var localizedStringMacroNames: BuildSetting { 
        BuildSetting(key: .localizedStringMacroNames, value: "NSLocalizedString CFCopyLocalizedString")
    }

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static func localizedStringMacroNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .localizedStringMacroNames, value: .array(value))
    }

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static func localizedStringMacroNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .localizedStringMacroNames, inherit: key)
    }

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static func localizedStringMacroNames(_ value: String...) -> BuildSetting { 
        .localizedStringMacroNames(value)
    }
}

extension BuildSettingsKey {

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static let localizedStringMacroNames: BuildSettingsKey = "LOCALIZED_STRING_MACRO_NAMES"
}

// MARK: Localized String Swift UI Support
extension BuildSetting {

    /// Localized String Swift UI Support
    ///
    /// When enabled, literal strings passed to the Text() initializer from Swift UI will be extracted during localization export.
    public static var localizedStringSwiftUiSupport: BuildSetting { 
        BuildSetting(key: .localizedStringSwiftUiSupport, value: "YES")
    }

    /// Localized String Swift UI Support
    ///
    /// When enabled, literal strings passed to the Text() initializer from Swift UI will be extracted during localization export.
    public static func localizedStringSwiftUiSupport(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .localizedStringSwiftUiSupport, value: value.asText)
    }

    /// Localized String Swift UI Support
    ///
    /// When enabled, literal strings passed to the Text() initializer from Swift UI will be extracted during localization export.
    public static func localizedStringSwiftUiSupport(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .localizedStringSwiftUiSupport, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Localized String Swift UI Support
    ///
    /// When enabled, literal strings passed to the Text() initializer from Swift UI will be extracted during localization export.
    public static let localizedStringSwiftUiSupport: BuildSettingsKey = "LOCALIZED_STRING_SWIFTUI_SUPPORT"
}

// MARK: Locroot
extension BuildSetting {

    /// Locroot
    public static func locroot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .locroot, value: \(value))
    }

    /// Locroot
    public static func locroot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .locroot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Locroot
    public static let locroot: BuildSettingsKey = "LOCROOT"
}

// MARK: Locsymroot
extension BuildSetting {

    /// Locsymroot
    public static func locsymroot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .locsymroot, value: \(value))
    }

    /// Locsymroot
    public static func locsymroot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .locsymroot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Locsymroot
    public static let locsymroot: BuildSettingsKey = "LOCSYMROOT"
}

// MARK: Logname
extension BuildSetting {

    /// Logname
    public static func logname(_ value: String) -> BuildSetting { 
        BuildSetting(key: .logname, value: \(value))
    }

    /// Logname
    public static func logname(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .logname, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Logname
    public static let logname: BuildSettingsKey = "LOGNAME"
}

// MARK: Mach-O Type
extension BuildSetting {

    /// Mach-O Type
    ///
    /// This setting determines the format of the produced binary and how it can be linked when building other binaries. For information on binary types, see [Building Mach - O Files](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/0 - Introduction/introduction.html)[Mach-O Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/building_files.html#//apple_ref/doc/uid/TP40001828-SW1).
    public static func machOType(_ value: MachOType) -> BuildSetting { 
        BuildSetting(key: .machOType, value: \(value))
    }

    /// Mach-O Type
    ///
    /// This setting determines the format of the produced binary and how it can be linked when building other binaries. For information on binary types, see [Building Mach - O Files](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/0 - Introduction/introduction.html)[Mach-O Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/building_files.html#//apple_ref/doc/uid/TP40001828-SW1).
    public static func machOType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .machOType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mach-O Type
    ///
    /// This setting determines the format of the produced binary and how it can be linked when building other binaries. For information on binary types, see [Building Mach - O Files](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/0 - Introduction/introduction.html)[Mach-O Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/building_files.html#//apple_ref/doc/uid/TP40001828-SW1).
    public static let machOType: BuildSettingsKey = "MACH_O_TYPE"
}

public enum MachOType: String, Hashable, Codable, CustomStringConvertible {
    case mhDylib = "mh_dylib"
    case mhBundle = "mh_bundle"
    case staticlib = "staticlib"
    case mhObject = "mh_object"
    case mhExecute = "mh_execute"

    public var description: String {
        rawValue
    }
}

// MARK: Mac Os X Version Max Allowed
extension BuildSetting {

    /// Mac Os X Version Max Allowed
    public static func macOsXVersionMaxAllowed(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macOsXVersionMaxAllowed, value: \(value))
    }

    /// Mac Os X Version Max Allowed
    public static func macOsXVersionMaxAllowed(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macOsXVersionMaxAllowed, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mac Os X Version Max Allowed
    public static let macOsXVersionMaxAllowed: BuildSettingsKey = "MAC_OS_X_VERSION_MAX_ALLOWED"
}

// MARK: Mac Os X Version Min Required
extension BuildSetting {

    /// Mac Os X Version Min Required
    public static func macOsXVersionMinRequired(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macOsXVersionMinRequired, value: \(value))
    }

    /// Mac Os X Version Min Required
    public static func macOsXVersionMinRequired(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macOsXVersionMinRequired, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mac Os X Version Min Required
    public static let macOsXVersionMinRequired: BuildSettingsKey = "MAC_OS_X_VERSION_MIN_REQUIRED"
}

// MARK: Marketing Version
extension BuildSetting {

    /// Marketing Version
    ///
    /// This setting defines the user-visible version of the project. The value corresponds to the `CFBundleShortVersionString` key in your app’s Info.plist.
    public static func marketingVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .marketingVersion, value: \(value))
    }

    /// Marketing Version
    ///
    /// This setting defines the user-visible version of the project. The value corresponds to the `CFBundleShortVersionString` key in your app’s Info.plist.
    public static func marketingVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .marketingVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Marketing Version
    ///
    /// This setting defines the user-visible version of the project. The value corresponds to the `CFBundleShortVersionString` key in your app’s Info.plist.
    public static let marketingVersion: BuildSettingsKey = "MARKETING_VERSION"
}

// MARK: Metal Library File Base
extension BuildSetting {

    /// Metal Library File Base
    public static var metalLibraryFileBase: BuildSetting { 
        BuildSetting(key: .metalLibraryFileBase, value: "default")
    }

    /// Metal Library File Base
    public static func metalLibraryFileBase(_ value: String) -> BuildSetting { 
        BuildSetting(key: .metalLibraryFileBase, value: \(value))
    }

    /// Metal Library File Base
    public static func metalLibraryFileBase(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .metalLibraryFileBase, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Metal Library File Base
    public static let metalLibraryFileBase: BuildSettingsKey = "METAL_LIBRARY_FILE_BASE"
}

// MARK: Metal Library Output Dir
extension BuildSetting {

    /// Metal Library Output Dir
    public static var metalLibraryOutputDir: BuildSetting { 
        BuildSetting(key: .metalLibraryOutputDir, value: "$(TARGET_BUILD_DIR)/$(UNLOCALIZED_RESOURCES_FOLDER_PATH)")
    }

    /// Metal Library Output Dir
    public static func metalLibraryOutputDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .metalLibraryOutputDir, value: \(value))
    }

    /// Metal Library Output Dir
    public static func metalLibraryOutputDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .metalLibraryOutputDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Metal Library Output Dir
    public static let metalLibraryOutputDir: BuildSettingsKey = "METAL_LIBRARY_OUTPUT_DIR"
}

// MARK: Module Map File
extension BuildSetting {

    /// Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for the compiler. If empty, it will be automatically generated for appropriate products when [Defines Module (DEFINES_MODULE)](itcaec37c2a6.html# dev82471c743) is enabled.
    public static func moduleMapFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleMapFile, value: \(value))
    }

    /// Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for the compiler. If empty, it will be automatically generated for appropriate products when [Defines Module (DEFINES_MODULE)](itcaec37c2a6.html# dev82471c743) is enabled.
    public static func moduleMapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleMapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for the compiler. If empty, it will be automatically generated for appropriate products when [Defines Module (DEFINES_MODULE)](itcaec37c2a6.html# dev82471c743) is enabled.
    public static let moduleMapFile: BuildSettingsKey = "MODULEMAP_FILE"
}

// MARK: Private Module Map File
extension BuildSetting {

    /// Private Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for private headers.
    public static func privateModuleMapFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .privateModuleMapFile, value: \(value))
    }

    /// Private Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for private headers.
    public static func privateModuleMapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .privateModuleMapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Private Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for private headers.
    public static let privateModuleMapFile: BuildSettingsKey = "MODULEMAP_PRIVATE_FILE"
}

// MARK: Module Cache Dir
extension BuildSetting {

    /// Module Cache Dir
    ///
    /// Absolute path of folder in which compiler stores its cached modules—this cache is a performance improvement.
    public static var moduleCacheDir: BuildSetting { 
        BuildSetting(key: .moduleCacheDir, value: "$(DERIVED_DATA_DIR)/ModuleCache.noindex")
    }

    /// Module Cache Dir
    ///
    /// Absolute path of folder in which compiler stores its cached modules—this cache is a performance improvement.
    public static func moduleCacheDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleCacheDir, value: \(value))
    }

    /// Module Cache Dir
    ///
    /// Absolute path of folder in which compiler stores its cached modules—this cache is a performance improvement.
    public static func moduleCacheDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleCacheDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Cache Dir
    ///
    /// Absolute path of folder in which compiler stores its cached modules—this cache is a performance improvement.
    public static let moduleCacheDir: BuildSettingsKey = "MODULE_CACHE_DIR"
}

// MARK: Module Identifier
extension BuildSetting {

    /// Module Identifier
    ///
    /// This is the identifier of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static func moduleIdentifier(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleIdentifier, value: \(value))
    }

    /// Module Identifier
    ///
    /// This is the identifier of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static func moduleIdentifier(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleIdentifier, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Identifier
    ///
    /// This is the identifier of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static let moduleIdentifier: BuildSettingsKey = "MODULE_NAME"
}

// MARK: Module Start Routine
extension BuildSetting {

    /// Module Start Routine
    ///
    /// This defines the name of the kernel module start routine. This is only used when building kernel extensions.
    public static func moduleStartRoutine(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleStartRoutine, value: \(value))
    }

    /// Module Start Routine
    ///
    /// This defines the name of the kernel module start routine. This is only used when building kernel extensions.
    public static func moduleStartRoutine(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleStartRoutine, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Start Routine
    ///
    /// This defines the name of the kernel module start routine. This is only used when building kernel extensions.
    public static let moduleStartRoutine: BuildSettingsKey = "MODULE_START"
}

// MARK: Module Stop Routine
extension BuildSetting {

    /// Module Stop Routine
    ///
    /// This defines the name of the kernel module stop routine. This is only used when building kernel extensions.
    public static func moduleStopRoutine(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleStopRoutine, value: \(value))
    }

    /// Module Stop Routine
    ///
    /// This defines the name of the kernel module stop routine. This is only used when building kernel extensions.
    public static func moduleStopRoutine(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleStopRoutine, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Stop Routine
    ///
    /// This defines the name of the kernel module stop routine. This is only used when building kernel extensions.
    public static let moduleStopRoutine: BuildSettingsKey = "MODULE_STOP"
}

// MARK: Module Version
extension BuildSetting {

    /// Module Version
    ///
    /// This is the version of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static func moduleVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleVersion, value: \(value))
    }

    /// Module Version
    ///
    /// This is the version of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static func moduleVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Version
    ///
    /// This is the version of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static let moduleVersion: BuildSettingsKey = "MODULE_VERSION"
}

// MARK: Native Arch
extension BuildSetting {

    /// Native Arch
    ///
    /// Identifies the architecture on which the build is being performed.
    public static func nativeArch(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nativeArch, value: \(value))
    }

    /// Native Arch
    ///
    /// Identifies the architecture on which the build is being performed.
    public static func nativeArch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nativeArch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Native Arch
    ///
    /// Identifies the architecture on which the build is being performed.
    public static let nativeArch: BuildSettingsKey = "NATIVE_ARCH"
}

// MARK: Native Arch Actual
extension BuildSetting {

    /// Native Arch Actual
    public static func nativeArchActual(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nativeArchActual, value: \(value))
    }

    /// Native Arch Actual
    public static func nativeArchActual(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nativeArchActual, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Native Arch Actual
    public static let nativeArchActual: BuildSettingsKey = "NATIVE_ARCH_ACTUAL"
}

// MARK: Object File Dir
extension BuildSetting {

    /// Object File Dir
    public static var objectFileDir: BuildSetting { 
        BuildSetting(key: .objectFileDir, value: "$(TARGET_TEMP_DIR)/Objects")
    }

    /// Object File Dir
    public static func objectFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .objectFileDir, value: \(value))
    }

    /// Object File Dir
    public static func objectFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objectFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Object File Dir
    public static let objectFileDir: BuildSettingsKey = "OBJECT_FILE_DIR"
}

// MARK: Intermediate Build Files Path
extension BuildSetting {

    /// Intermediate Build Files Path
    ///
    /// The path where intermediate files will be placed during a build. Intermediate files include generated sources, object files, etc. Shell script build phases can place and access files here, as well. Typically this path is not set per target, but is set per project or per user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static var intermediateBuildFilesPath: BuildSetting { 
        .intermediateBuildFilesPath(inherit: .buildProductsPath) 
    }

    /// Intermediate Build Files Path
    ///
    /// The path where intermediate files will be placed during a build. Intermediate files include generated sources, object files, etc. Shell script build phases can place and access files here, as well. Typically this path is not set per target, but is set per project or per user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static func intermediateBuildFilesPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .intermediateBuildFilesPath, value: \(value))
    }

    /// Intermediate Build Files Path
    ///
    /// The path where intermediate files will be placed during a build. Intermediate files include generated sources, object files, etc. Shell script build phases can place and access files here, as well. Typically this path is not set per target, but is set per project or per user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static func intermediateBuildFilesPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .intermediateBuildFilesPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Intermediate Build Files Path
    ///
    /// The path where intermediate files will be placed during a build. Intermediate files include generated sources, object files, etc. Shell script build phases can place and access files here, as well. Typically this path is not set per target, but is set per project or per user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static let intermediateBuildFilesPath: BuildSettingsKey = "OBJROOT"
}

// MARK: Build Active Architecture Only
extension BuildSetting {

    /// Build Active Architecture Only
    ///
    /// If enabled, only the active architecture is built. This setting will be ignored when building with a run destination which does not define a specific architecture, such as a ‘Generic Device’ run destination.
    public static var buildActiveArchitectureOnly: BuildSetting { 
        BuildSetting(key: .buildActiveArchitectureOnly, value: "NO")
    }

    /// Build Active Architecture Only
    ///
    /// If enabled, only the active architecture is built. This setting will be ignored when building with a run destination which does not define a specific architecture, such as a ‘Generic Device’ run destination.
    public static func buildActiveArchitectureOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .buildActiveArchitectureOnly, value: value.asText)
    }

    /// Build Active Architecture Only
    ///
    /// If enabled, only the active architecture is built. This setting will be ignored when building with a run destination which does not define a specific architecture, such as a ‘Generic Device’ run destination.
    public static func buildActiveArchitectureOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildActiveArchitectureOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Active Architecture Only
    ///
    /// If enabled, only the active architecture is built. This setting will be ignored when building with a run destination which does not define a specific architecture, such as a ‘Generic Device’ run destination.
    public static let buildActiveArchitectureOnly: BuildSettingsKey = "ONLY_ACTIVE_ARCH"
}

// MARK: On Demand Resources Initial Install Tags
extension BuildSetting {

    /// On Demand Resources Initial Install Tags
    ///
    /// Defined a set of initial On Demand Resources tags to be downloaded and installed with your application.
    public static func onDemandResourcesInitialInstallTags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .onDemandResourcesInitialInstallTags, value: .array(value))
    }

    /// On Demand Resources Initial Install Tags
    ///
    /// Defined a set of initial On Demand Resources tags to be downloaded and installed with your application.
    public static func onDemandResourcesInitialInstallTags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .onDemandResourcesInitialInstallTags, inherit: key)
    }

    /// On Demand Resources Initial Install Tags
    ///
    /// Defined a set of initial On Demand Resources tags to be downloaded and installed with your application.
    public static func onDemandResourcesInitialInstallTags(_ value: String...) -> BuildSetting { 
        .onDemandResourcesInitialInstallTags(value)
    }
}

extension BuildSettingsKey {

    /// On Demand Resources Initial Install Tags
    ///
    /// Defined a set of initial On Demand Resources tags to be downloaded and installed with your application.
    public static let onDemandResourcesInitialInstallTags: BuildSettingsKey = "ON_DEMAND_RESOURCES_INITIAL_INSTALL_TAGS"
}

// MARK: On Demand Resources Prefetch Order
extension BuildSetting {

    /// On Demand Resources Prefetch Order
    ///
    /// Once your app is installed, this defined a set of On Demand Resources tags that should be downloaded. These tags are downloaded after the initial installation of your application, and will be downloaded in the order the tags provided in the list from first to last.
    public static func onDemandResourcesPrefetchOrder(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .onDemandResourcesPrefetchOrder, value: .array(value))
    }

    /// On Demand Resources Prefetch Order
    ///
    /// Once your app is installed, this defined a set of On Demand Resources tags that should be downloaded. These tags are downloaded after the initial installation of your application, and will be downloaded in the order the tags provided in the list from first to last.
    public static func onDemandResourcesPrefetchOrder(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .onDemandResourcesPrefetchOrder, inherit: key)
    }

    /// On Demand Resources Prefetch Order
    ///
    /// Once your app is installed, this defined a set of On Demand Resources tags that should be downloaded. These tags are downloaded after the initial installation of your application, and will be downloaded in the order the tags provided in the list from first to last.
    public static func onDemandResourcesPrefetchOrder(_ value: String...) -> BuildSetting { 
        .onDemandResourcesPrefetchOrder(value)
    }
}

extension BuildSettingsKey {

    /// On Demand Resources Prefetch Order
    ///
    /// Once your app is installed, this defined a set of On Demand Resources tags that should be downloaded. These tags are downloaded after the initial installation of your application, and will be downloaded in the order the tags provided in the list from first to last.
    public static let onDemandResourcesPrefetchOrder: BuildSettingsKey = "ON_DEMAND_RESOURCES_PREFETCH_ORDER"
}

// MARK: Order File
extension BuildSetting {

    /// Order File
    ///
    /// The path to a file that alters the order in which functions and data are laid out. For each section in the output file, any symbol in that section that are specified in the order file is moved to the start of its section and laid out in the same order as in the order file. Order files are text files with one symbol name per line. Lines starting with a `#` are comments. A symbol name may be optionally preceded with its object file leafname and a colon (for example, `foo.o:_foo`). This is useful for static functions/data that occur in multiple files. A symbol name may also be optionally preceded with the architecture (for example, `ppc:_foo` or `ppc:foo.o:_foo`). This enables you to have one order file that works for multiple architectures. Literal C-strings may be ordered by quoting the string in the order file (for example, `"Hello, world"`). Generally you should not specify an order file in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func orderFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .orderFile, value: \(value))
    }

    /// Order File
    ///
    /// The path to a file that alters the order in which functions and data are laid out. For each section in the output file, any symbol in that section that are specified in the order file is moved to the start of its section and laid out in the same order as in the order file. Order files are text files with one symbol name per line. Lines starting with a `#` are comments. A symbol name may be optionally preceded with its object file leafname and a colon (for example, `foo.o:_foo`). This is useful for static functions/data that occur in multiple files. A symbol name may also be optionally preceded with the architecture (for example, `ppc:_foo` or `ppc:foo.o:_foo`). This enables you to have one order file that works for multiple architectures. Literal C-strings may be ordered by quoting the string in the order file (for example, `"Hello, world"`). Generally you should not specify an order file in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func orderFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .orderFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Order File
    ///
    /// The path to a file that alters the order in which functions and data are laid out. For each section in the output file, any symbol in that section that are specified in the order file is moved to the start of its section and laid out in the same order as in the order file. Order files are text files with one symbol name per line. Lines starting with a `#` are comments. A symbol name may be optionally preceded with its object file leafname and a colon (for example, `foo.o:_foo`). This is useful for static functions/data that occur in multiple files. A symbol name may also be optionally preceded with the architecture (for example, `ppc:_foo` or `ppc:foo.o:_foo`). This enables you to have one order file that works for multiple architectures. Literal C-strings may be ordered by quoting the string in the order file (for example, `"Hello, world"`). Generally you should not specify an order file in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static let orderFile: BuildSettingsKey = "ORDER_FILE"
}

// MARK: Other C Flags
extension BuildSetting {

    /// Other C Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C and Objective-C files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular C or Objective-C compiler flag.
    public static func otherCFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherCFlags, value: .array(value))
    }

    /// Other C Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C and Objective-C files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular C or Objective-C compiler flag.
    public static func otherCFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherCFlags, inherit: key)
    }

    /// Other C Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C and Objective-C files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular C or Objective-C compiler flag.
    public static func otherCFlags(_ value: String...) -> BuildSetting { 
        .otherCFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other C Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C and Objective-C files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular C or Objective-C compiler flag.
    public static let otherCFlags: BuildSettingsKey = "OTHER_CFLAGS"
}

// MARK: Other Code Signing Flags
extension BuildSetting {

    /// Other Code Signing Flags
    ///
    /// A list of additional options to pass to `codesign(1)`.
    public static func otherCodeSigningFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherCodeSigningFlags, value: .array(value))
    }

    /// Other Code Signing Flags
    ///
    /// A list of additional options to pass to `codesign(1)`.
    public static func otherCodeSigningFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherCodeSigningFlags, inherit: key)
    }

    /// Other Code Signing Flags
    ///
    /// A list of additional options to pass to `codesign(1)`.
    public static func otherCodeSigningFlags(_ value: String...) -> BuildSetting { 
        .otherCodeSigningFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Code Signing Flags
    ///
    /// A list of additional options to pass to `codesign(1)`.
    public static let otherCodeSigningFlags: BuildSettingsKey = "OTHER_CODE_SIGN_FLAGS"
}

// MARK: Other C++ Flags
extension BuildSetting {

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static var otherCppFlags: BuildSetting { 
        .otherCppFlags(inherit: .otherCFlags) 
    }

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static func otherCppFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherCppFlags, value: .array(value))
    }

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static func otherCppFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherCppFlags, inherit: key)
    }

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static func otherCppFlags(_ value: String...) -> BuildSetting { 
        .otherCppFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static let otherCppFlags: BuildSettingsKey = "OTHER_CPLUSPLUSFLAGS"
}

// MARK: Other Linker Flags
extension BuildSetting {

    /// Other Linker Flags
    ///
    /// Options defined in this setting are passed to invocations of the linker.
    public static func otherLinkerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherLinkerFlags, value: .array(value))
    }

    /// Other Linker Flags
    ///
    /// Options defined in this setting are passed to invocations of the linker.
    public static func otherLinkerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherLinkerFlags, inherit: key)
    }

    /// Other Linker Flags
    ///
    /// Options defined in this setting are passed to invocations of the linker.
    public static func otherLinkerFlags(_ value: String...) -> BuildSetting { 
        .otherLinkerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Linker Flags
    ///
    /// Options defined in this setting are passed to invocations of the linker.
    public static let otherLinkerFlags: BuildSettingsKey = "OTHER_LDFLAGS"
}

// MARK: Other Librarian Flags
extension BuildSetting {

    /// Other Librarian Flags
    ///
    /// Options defined in this setting are passed to all invocations of the archive librarian, which is used to generate static libraries.
    public static func otherLibrarianFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherLibrarianFlags, value: .array(value))
    }

    /// Other Librarian Flags
    ///
    /// Options defined in this setting are passed to all invocations of the archive librarian, which is used to generate static libraries.
    public static func otherLibrarianFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherLibrarianFlags, inherit: key)
    }

    /// Other Librarian Flags
    ///
    /// Options defined in this setting are passed to all invocations of the archive librarian, which is used to generate static libraries.
    public static func otherLibrarianFlags(_ value: String...) -> BuildSetting { 
        .otherLibrarianFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Librarian Flags
    ///
    /// Options defined in this setting are passed to all invocations of the archive librarian, which is used to generate static libraries.
    public static let otherLibrarianFlags: BuildSettingsKey = "OTHER_LIBTOOLFLAGS"
}

// MARK: Other Text-Based InstallAPI Flags
extension BuildSetting {

    /// Other Text-Based InstallAPI Flags
    ///
    /// Options defined in this setting are passed to invocations of the `Text-Based InstallAPI` tool.
    public static func otherTextBasedInstallapiFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherTextBasedInstallapiFlags, value: .array(value))
    }

    /// Other Text-Based InstallAPI Flags
    ///
    /// Options defined in this setting are passed to invocations of the `Text-Based InstallAPI` tool.
    public static func otherTextBasedInstallapiFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherTextBasedInstallapiFlags, inherit: key)
    }

    /// Other Text-Based InstallAPI Flags
    ///
    /// Options defined in this setting are passed to invocations of the `Text-Based InstallAPI` tool.
    public static func otherTextBasedInstallapiFlags(_ value: String...) -> BuildSetting { 
        .otherTextBasedInstallapiFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Text-Based InstallAPI Flags
    ///
    /// Options defined in this setting are passed to invocations of the `Text-Based InstallAPI` tool.
    public static let otherTextBasedInstallapiFlags: BuildSettingsKey = "OTHER_TAPI_FLAGS"
}

// MARK: Path Prefixes Excluded From Header Dependencies
extension BuildSetting {

    /// Path Prefixes Excluded From Header Dependencies
    public static var pathPrefixesExcludedFromHeaderDependencies: BuildSetting { 
        BuildSetting(key: .pathPrefixesExcludedFromHeaderDependencies, value: "/usr/include /usr/local/include /System/Library/Frameworks /System/Library/PrivateFrameworks $(SYSTEM_DEVELOPER_DIR)/Headers $(SYSTEM_DEVELOPER_DIR)/SDKs $(SYSTEM_DEVELOPER_DIR)/Platforms")
    }

    /// Path Prefixes Excluded From Header Dependencies
    public static func pathPrefixesExcludedFromHeaderDependencies(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .pathPrefixesExcludedFromHeaderDependencies, value: .array(value))
    }

    /// Path Prefixes Excluded From Header Dependencies
    public static func pathPrefixesExcludedFromHeaderDependencies(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pathPrefixesExcludedFromHeaderDependencies, inherit: key)
    }

    /// Path Prefixes Excluded From Header Dependencies
    public static func pathPrefixesExcludedFromHeaderDependencies(_ value: String...) -> BuildSetting { 
        .pathPrefixesExcludedFromHeaderDependencies(value)
    }
}

extension BuildSettingsKey {

    /// Path Prefixes Excluded From Header Dependencies
    public static let pathPrefixesExcludedFromHeaderDependencies: BuildSettingsKey = "PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES"
}

// MARK: Property List Output Encoding
extension BuildSetting {

    /// Property List Output Encoding
    ///
    /// Specifies the output encoding for property list files (`.plist`). The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static var propertyListOutputEncoding: BuildSetting { 
        .propertyListOutputEncoding(.sameAsInput) 
    }

    /// Property List Output Encoding
    ///
    /// Specifies the output encoding for property list files (`.plist`). The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static func propertyListOutputEncoding(_ value: PropertyListOutputEncoding) -> BuildSetting { 
        BuildSetting(key: .propertyListOutputEncoding, value: \(value))
    }

    /// Property List Output Encoding
    ///
    /// Specifies the output encoding for property list files (`.plist`). The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static func propertyListOutputEncoding(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .propertyListOutputEncoding, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Property List Output Encoding
    ///
    /// Specifies the output encoding for property list files (`.plist`). The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static let propertyListOutputEncoding: BuildSettingsKey = "PLIST_FILE_OUTPUT_FORMAT"
}

public enum PropertyListOutputEncoding: String, Hashable, Codable, CustomStringConvertible {
    case sameAsInput = "same-as-input"
    case xml = "XML"
    case binary = "binary"

    public var description: String {
        rawValue
    }
}

// MARK: Precompiled Header Uses Files From Build Directory
extension BuildSetting {

    /// Precompiled Header Uses Files From Build Directory
    ///
    /// This setting allows for better control of sharing precompiled prefix header files between projects. By default, Xcode assumes that the prefix header file may include header files from the build directory if the build directory is outside of the project directory. Xcode cannot determine this ahead of time since other projects may not have been built into the shared build directory at the time the information is needed. If your prefix file never includes files from the build directory you may set this to `NO` to improve sharing of precompiled headers. If the prefix does use files from a build directory that is inside your project directory, you may set this to `YES` to avoid unintended sharing that may result in build failures.
    public static var precompiledHeaderUsesFilesFromBuildDirectory: BuildSetting { 
        BuildSetting(key: .precompiledHeaderUsesFilesFromBuildDirectory, value: "YES")
    }

    /// Precompiled Header Uses Files From Build Directory
    ///
    /// This setting allows for better control of sharing precompiled prefix header files between projects. By default, Xcode assumes that the prefix header file may include header files from the build directory if the build directory is outside of the project directory. Xcode cannot determine this ahead of time since other projects may not have been built into the shared build directory at the time the information is needed. If your prefix file never includes files from the build directory you may set this to `NO` to improve sharing of precompiled headers. If the prefix does use files from a build directory that is inside your project directory, you may set this to `YES` to avoid unintended sharing that may result in build failures.
    public static func precompiledHeaderUsesFilesFromBuildDirectory(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .precompiledHeaderUsesFilesFromBuildDirectory, value: value.asText)
    }

    /// Precompiled Header Uses Files From Build Directory
    ///
    /// This setting allows for better control of sharing precompiled prefix header files between projects. By default, Xcode assumes that the prefix header file may include header files from the build directory if the build directory is outside of the project directory. Xcode cannot determine this ahead of time since other projects may not have been built into the shared build directory at the time the information is needed. If your prefix file never includes files from the build directory you may set this to `NO` to improve sharing of precompiled headers. If the prefix does use files from a build directory that is inside your project directory, you may set this to `YES` to avoid unintended sharing that may result in build failures.
    public static func precompiledHeaderUsesFilesFromBuildDirectory(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompiledHeaderUsesFilesFromBuildDirectory, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Precompiled Header Uses Files From Build Directory
    ///
    /// This setting allows for better control of sharing precompiled prefix header files between projects. By default, Xcode assumes that the prefix header file may include header files from the build directory if the build directory is outside of the project directory. Xcode cannot determine this ahead of time since other projects may not have been built into the shared build directory at the time the information is needed. If your prefix file never includes files from the build directory you may set this to `NO` to improve sharing of precompiled headers. If the prefix does use files from a build directory that is inside your project directory, you may set this to `YES` to avoid unintended sharing that may result in build failures.
    public static let precompiledHeaderUsesFilesFromBuildDirectory: BuildSettingsKey = "PRECOMPS_INCLUDE_HEADERS_FROM_BUILT_PRODUCTS_DIR"
}

// MARK: Precomp Destination Dir
extension BuildSetting {

    /// Precomp Destination Dir
    public static var precompDestinationDir: BuildSetting { 
        BuildSetting(key: .precompDestinationDir, value: "$(TARGET_TEMP_DIR)/PrefixHeaders")
    }

    /// Precomp Destination Dir
    public static func precompDestinationDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .precompDestinationDir, value: \(value))
    }

    /// Precomp Destination Dir
    public static func precompDestinationDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompDestinationDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Precomp Destination Dir
    public static let precompDestinationDir: BuildSettingsKey = "PRECOMP_DESTINATION_DIR"
}

// MARK: Single-Object Prelink Flags
extension BuildSetting {

    /// Single-Object Prelink Flags
    ///
    /// Additional flags to pass when performing a single-object prelink.
    public static func singleObjectPrelinkFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .singleObjectPrelinkFlags, value: .array(value))
    }

    /// Single-Object Prelink Flags
    ///
    /// Additional flags to pass when performing a single-object prelink.
    public static func singleObjectPrelinkFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .singleObjectPrelinkFlags, inherit: key)
    }

    /// Single-Object Prelink Flags
    ///
    /// Additional flags to pass when performing a single-object prelink.
    public static func singleObjectPrelinkFlags(_ value: String...) -> BuildSetting { 
        .singleObjectPrelinkFlags(value)
    }
}

extension BuildSettingsKey {

    /// Single-Object Prelink Flags
    ///
    /// Additional flags to pass when performing a single-object prelink.
    public static let singleObjectPrelinkFlags: BuildSettingsKey = "PRELINK_FLAGS"
}

// MARK: Prelink libraries
extension BuildSetting {

    /// Prelink libraries
    ///
    /// Additional libraries to pass when performing a single-object prelink.
    public static func prelinkLibraries(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .prelinkLibraries, value: .array(value))
    }

    /// Prelink libraries
    ///
    /// Additional libraries to pass when performing a single-object prelink.
    public static func prelinkLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prelinkLibraries, inherit: key)
    }

    /// Prelink libraries
    ///
    /// Additional libraries to pass when performing a single-object prelink.
    public static func prelinkLibraries(_ value: String...) -> BuildSetting { 
        .prelinkLibraries(value)
    }
}

extension BuildSettingsKey {

    /// Prelink libraries
    ///
    /// Additional libraries to pass when performing a single-object prelink.
    public static let prelinkLibraries: BuildSettingsKey = "PRELINK_LIBS"
}

// MARK: Don't Dead-Strip Inits and Terms
extension BuildSetting {

    /// Don't Dead-Strip Inits and Terms
    ///
    /// Activating this setting, in combination with the [Dead Code Stripping (DEAD_CODE_STRIPPING)](itcaec37c2a6.html# dev9ed8cb7ad) (`-dead_strip`) option, causes the `-no_dead_strip_inits_and_terms` flag to be passed to `ld(1)` via `cc(1)` to disable dead code stripping for initialization and termination routines. This option should not be used without the aforementioned [Dead Code Stripping (DEAD_CODE_STRIPPING)](itcaec37c2a6.html# dev9ed8cb7ad) option.
    public static var donTDeadStripInitsAndTerms: BuildSetting { 
        BuildSetting(key: .donTDeadStripInitsAndTerms, value: "NO")
    }

    /// Don't Dead-Strip Inits and Terms
    ///
    /// Activating this setting, in combination with the [Dead Code Stripping (DEAD_CODE_STRIPPING)](itcaec37c2a6.html# dev9ed8cb7ad) (`-dead_strip`) option, causes the `-no_dead_strip_inits_and_terms` flag to be passed to `ld(1)` via `cc(1)` to disable dead code stripping for initialization and termination routines. This option should not be used without the aforementioned [Dead Code Stripping (DEAD_CODE_STRIPPING)](itcaec37c2a6.html# dev9ed8cb7ad) option.
    public static func donTDeadStripInitsAndTerms(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .donTDeadStripInitsAndTerms, value: value.asText)
    }

    /// Don't Dead-Strip Inits and Terms
    ///
    /// Activating this setting, in combination with the [Dead Code Stripping (DEAD_CODE_STRIPPING)](itcaec37c2a6.html# dev9ed8cb7ad) (`-dead_strip`) option, causes the `-no_dead_strip_inits_and_terms` flag to be passed to `ld(1)` via `cc(1)` to disable dead code stripping for initialization and termination routines. This option should not be used without the aforementioned [Dead Code Stripping (DEAD_CODE_STRIPPING)](itcaec37c2a6.html# dev9ed8cb7ad) option.
    public static func donTDeadStripInitsAndTerms(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .donTDeadStripInitsAndTerms, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Don't Dead-Strip Inits and Terms
    ///
    /// Activating this setting, in combination with the [Dead Code Stripping (DEAD_CODE_STRIPPING)](itcaec37c2a6.html# dev9ed8cb7ad) (`-dead_strip`) option, causes the `-no_dead_strip_inits_and_terms` flag to be passed to `ld(1)` via `cc(1)` to disable dead code stripping for initialization and termination routines. This option should not be used without the aforementioned [Dead Code Stripping (DEAD_CODE_STRIPPING)](itcaec37c2a6.html# dev9ed8cb7ad) option.
    public static let donTDeadStripInitsAndTerms: BuildSettingsKey = "PRESERVE_DEAD_CODE_INITS_AND_TERMS"
}

// MARK: Private Headers Folder Path
extension BuildSetting {

    /// Private Headers Folder Path
    ///
    /// The location to copy the private headers to during building, relative to the built products folder.
    public static func privateHeadersFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .privateHeadersFolderPath, value: \(value))
    }

    /// Private Headers Folder Path
    ///
    /// The location to copy the private headers to during building, relative to the built products folder.
    public static func privateHeadersFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .privateHeadersFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Private Headers Folder Path
    ///
    /// The location to copy the private headers to during building, relative to the built products folder.
    public static let privateHeadersFolderPath: BuildSettingsKey = "PRIVATE_HEADERS_FOLDER_PATH"
}

// MARK: Product Bundle Identifier
extension BuildSetting {

    /// Product Bundle Identifier
    ///
    /// A string that uniquely identifies the bundle. The string should be in reverse DNS format using only alphanumeric characters (`A-Z`, `a-z`, `0-9`), the dot (`.`), and the hyphen (`-`). This value is used as the `CFBundleIdentifier` in the `Info.plist` of the built bundle.
    public static func productBundleIdentifier(_ value: String) -> BuildSetting { 
        BuildSetting(key: .productBundleIdentifier, value: \(value))
    }

    /// Product Bundle Identifier
    ///
    /// A string that uniquely identifies the bundle. The string should be in reverse DNS format using only alphanumeric characters (`A-Z`, `a-z`, `0-9`), the dot (`.`), and the hyphen (`-`). This value is used as the `CFBundleIdentifier` in the `Info.plist` of the built bundle.
    public static func productBundleIdentifier(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productBundleIdentifier, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Product Bundle Identifier
    ///
    /// A string that uniquely identifies the bundle. The string should be in reverse DNS format using only alphanumeric characters (`A-Z`, `a-z`, `0-9`), the dot (`.`), and the hyphen (`-`). This value is used as the `CFBundleIdentifier` in the `Info.plist` of the built bundle.
    public static let productBundleIdentifier: BuildSettingsKey = "PRODUCT_BUNDLE_IDENTIFIER"
}

// MARK: Product Module Name
extension BuildSetting {

    /// Product Module Name
    ///
    /// The name to use for the source code module constructed for this target, and which will be used to import the module in implementation source files. Must be a valid identifier.
    public static var productModuleName: BuildSetting { 
        BuildSetting(key: .productModuleName, value: "$(PRODUCT_NAME:c99extidentifier)")
    }

    /// Product Module Name
    ///
    /// The name to use for the source code module constructed for this target, and which will be used to import the module in implementation source files. Must be a valid identifier.
    public static func productModuleName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .productModuleName, value: \(value))
    }

    /// Product Module Name
    ///
    /// The name to use for the source code module constructed for this target, and which will be used to import the module in implementation source files. Must be a valid identifier.
    public static func productModuleName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productModuleName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Product Module Name
    ///
    /// The name to use for the source code module constructed for this target, and which will be used to import the module in implementation source files. Must be a valid identifier.
    public static let productModuleName: BuildSettingsKey = "PRODUCT_MODULE_NAME"
}

// MARK: Product Name
extension BuildSetting {

    /// Product Name
    ///
    /// This is the basename of the product generated by the target.
    public static func productName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .productName, value: \(value))
    }

    /// Product Name
    ///
    /// This is the basename of the product generated by the target.
    public static func productName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Product Name
    ///
    /// This is the basename of the product generated by the target.
    public static let productName: BuildSettingsKey = "PRODUCT_NAME"
}

// MARK: Profiling Code
extension BuildSetting {

    /// Profiling Code
    public static var profilingCode: BuildSetting { 
        BuildSetting(key: .profilingCode, value: "NO")
    }

    /// Profiling Code
    public static func profilingCode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .profilingCode, value: value.asText)
    }

    /// Profiling Code
    public static func profilingCode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .profilingCode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Profiling Code
    public static let profilingCode: BuildSettingsKey = "PROFILING_CODE"
}

// MARK: Project Derived File Dir
extension BuildSetting {

    /// Project Derived File Dir
    public static var projectDerivedFileDir: BuildSetting { 
        BuildSetting(key: .projectDerivedFileDir, value: "$(OBJROOT)/$(PROJECT_NAME).build/DerivedSources")
    }

    /// Project Derived File Dir
    public static func projectDerivedFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectDerivedFileDir, value: \(value))
    }

    /// Project Derived File Dir
    public static func projectDerivedFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectDerivedFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Project Derived File Dir
    public static let projectDerivedFileDir: BuildSettingsKey = "PROJECT_DERIVED_FILE_DIR"
}

// MARK: Project Dir
extension BuildSetting {

    /// Project Dir
    public static var projectDir: BuildSetting { 
        .projectDir(inherit: .srcroot) 
    }

    /// Project Dir
    public static func projectDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectDir, value: \(value))
    }

    /// Project Dir
    public static func projectDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Project Dir
    public static let projectDir: BuildSettingsKey = "PROJECT_DIR"
}

// MARK: Project Name
extension BuildSetting {

    /// Project Name
    ///
    /// The name of the current project.
    public static func projectName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectName, value: \(value))
    }

    /// Project Name
    ///
    /// The name of the current project.
    public static func projectName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Project Name
    ///
    /// The name of the current project.
    public static let projectName: BuildSettingsKey = "PROJECT_NAME"
}

// MARK: Project Temp Dir
extension BuildSetting {

    /// Project Temp Dir
    ///
    /// Identifies the directory in which the project’s intermediate build files are placed. This directory is shared between all the targets defined by the project. Run Script build phases should generate intermediate build files in the directory identified by `DERIVED_FILE_DIR`, not the location this build setting specifies.
    public static var projectTempDir: BuildSetting { 
        BuildSetting(key: .projectTempDir, value: "$(PROJECT_TEMP_ROOT)/$(PROJECT_NAME).build")
    }

    /// Project Temp Dir
    ///
    /// Identifies the directory in which the project’s intermediate build files are placed. This directory is shared between all the targets defined by the project. Run Script build phases should generate intermediate build files in the directory identified by `DERIVED_FILE_DIR`, not the location this build setting specifies.
    public static func projectTempDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectTempDir, value: \(value))
    }

    /// Project Temp Dir
    ///
    /// Identifies the directory in which the project’s intermediate build files are placed. This directory is shared between all the targets defined by the project. Run Script build phases should generate intermediate build files in the directory identified by `DERIVED_FILE_DIR`, not the location this build setting specifies.
    public static func projectTempDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectTempDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Project Temp Dir
    ///
    /// Identifies the directory in which the project’s intermediate build files are placed. This directory is shared between all the targets defined by the project. Run Script build phases should generate intermediate build files in the directory identified by `DERIVED_FILE_DIR`, not the location this build setting specifies.
    public static let projectTempDir: BuildSettingsKey = "PROJECT_TEMP_DIR"
}

// MARK: Project Temp Root
extension BuildSetting {

    /// Project Temp Root
    public static var projectTempRoot: BuildSetting { 
        .projectTempRoot(inherit: .intermediateBuildFilesPath) 
    }

    /// Project Temp Root
    public static func projectTempRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectTempRoot, value: \(value))
    }

    /// Project Temp Root
    public static func projectTempRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectTempRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Project Temp Root
    public static let projectTempRoot: BuildSettingsKey = "PROJECT_TEMP_ROOT"
}

// MARK: Provisioning Profile Specifier
extension BuildSetting {

    /// Provisioning Profile Specifier
    ///
    /// Must contain a profile name (or UUID). A missing or invalid profile will cause a build error. Use in conjunction with [Development Team (DEVELOPMENT_TEAM)](itcaec37c2a6.html# dev186481df2) to fully specify provisioning profile.
    public static func provisioningProfileSpecifier(_ value: ProvisioningProfileSpecifier) -> BuildSetting { 
        BuildSetting(key: .provisioningProfileSpecifier, value: \(value))
    }

    /// Provisioning Profile Specifier
    ///
    /// Must contain a profile name (or UUID). A missing or invalid profile will cause a build error. Use in conjunction with [Development Team (DEVELOPMENT_TEAM)](itcaec37c2a6.html# dev186481df2) to fully specify provisioning profile.
    public static func provisioningProfileSpecifier(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .provisioningProfileSpecifier, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Provisioning Profile Specifier
    ///
    /// Must contain a profile name (or UUID). A missing or invalid profile will cause a build error. Use in conjunction with [Development Team (DEVELOPMENT_TEAM)](itcaec37c2a6.html# dev186481df2) to fully specify provisioning profile.
    public static let provisioningProfileSpecifier: BuildSettingsKey = "PROVISIONING_PROFILE_SPECIFIER"
}

// MARK: Public Headers Folder Path
extension BuildSetting {

    /// Public Headers Folder Path
    ///
    /// The location to copy the public headers to during building, relative to the built products folder.
    public static func publicHeadersFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .publicHeadersFolderPath, value: \(value))
    }

    /// Public Headers Folder Path
    ///
    /// The location to copy the public headers to during building, relative to the built products folder.
    public static func publicHeadersFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .publicHeadersFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Public Headers Folder Path
    ///
    /// The location to copy the public headers to during building, relative to the built products folder.
    public static let publicHeadersFolderPath: BuildSettingsKey = "PUBLIC_HEADERS_FOLDER_PATH"
}

// MARK: Pwd
extension BuildSetting {

    /// Pwd
    public static func pwd(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pwd, value: \(value))
    }

    /// Pwd
    public static func pwd(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pwd, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pwd
    public static let pwd: BuildSettingsKey = "PWD"
}

// MARK: Reexported Framework Install Names
extension BuildSetting {

    /// Reexported Framework Install Names
    public static func reexportedFrameworkInstallNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reexportedFrameworkInstallNames, value: .array(value))
    }

    /// Reexported Framework Install Names
    public static func reexportedFrameworkInstallNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reexportedFrameworkInstallNames, inherit: key)
    }

    /// Reexported Framework Install Names
    public static func reexportedFrameworkInstallNames(_ value: String...) -> BuildSetting { 
        .reexportedFrameworkInstallNames(value)
    }
}

extension BuildSettingsKey {

    /// Reexported Framework Install Names
    public static let reexportedFrameworkInstallNames: BuildSettingsKey = "REEXPORTED_FRAMEWORK_INSTALL_NAMES"
}

// MARK: Re-Exported Framework Names
extension BuildSetting {

    /// Re-Exported Framework Names
    ///
    /// List of framework names that should have their symbols be reexported from the built library.
    public static func reExportedFrameworkNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reExportedFrameworkNames, value: .array(value))
    }

    /// Re-Exported Framework Names
    ///
    /// List of framework names that should have their symbols be reexported from the built library.
    public static func reExportedFrameworkNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reExportedFrameworkNames, inherit: key)
    }

    /// Re-Exported Framework Names
    ///
    /// List of framework names that should have their symbols be reexported from the built library.
    public static func reExportedFrameworkNames(_ value: String...) -> BuildSetting { 
        .reExportedFrameworkNames(value)
    }
}

extension BuildSettingsKey {

    /// Re-Exported Framework Names
    ///
    /// List of framework names that should have their symbols be reexported from the built library.
    public static let reExportedFrameworkNames: BuildSettingsKey = "REEXPORTED_FRAMEWORK_NAMES"
}

// MARK: Reexported Library Install Names
extension BuildSetting {

    /// Reexported Library Install Names
    public static func reexportedLibraryInstallNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reexportedLibraryInstallNames, value: .array(value))
    }

    /// Reexported Library Install Names
    public static func reexportedLibraryInstallNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reexportedLibraryInstallNames, inherit: key)
    }

    /// Reexported Library Install Names
    public static func reexportedLibraryInstallNames(_ value: String...) -> BuildSetting { 
        .reexportedLibraryInstallNames(value)
    }
}

extension BuildSettingsKey {

    /// Reexported Library Install Names
    public static let reexportedLibraryInstallNames: BuildSettingsKey = "REEXPORTED_LIBRARY_INSTALL_NAMES"
}

// MARK: Re-Exported Library Names
extension BuildSetting {

    /// Re-Exported Library Names
    ///
    /// List of library names that should have their symbols be reexported from the built library.
    public static func reExportedLibraryNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reExportedLibraryNames, value: .array(value))
    }

    /// Re-Exported Library Names
    ///
    /// List of library names that should have their symbols be reexported from the built library.
    public static func reExportedLibraryNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reExportedLibraryNames, inherit: key)
    }

    /// Re-Exported Library Names
    ///
    /// List of library names that should have their symbols be reexported from the built library.
    public static func reExportedLibraryNames(_ value: String...) -> BuildSetting { 
        .reExportedLibraryNames(value)
    }
}

extension BuildSettingsKey {

    /// Re-Exported Library Names
    ///
    /// List of library names that should have their symbols be reexported from the built library.
    public static let reExportedLibraryNames: BuildSettingsKey = "REEXPORTED_LIBRARY_NAMES"
}

// MARK: Re-Exported Library Paths
extension BuildSetting {

    /// Re-Exported Library Paths
    ///
    /// List of library paths that should have their symbols be reexported from the built library.
    public static func reExportedLibraryPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reExportedLibraryPaths, value: .array(value))
    }

    /// Re-Exported Library Paths
    ///
    /// List of library paths that should have their symbols be reexported from the built library.
    public static func reExportedLibraryPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reExportedLibraryPaths, inherit: key)
    }

    /// Re-Exported Library Paths
    ///
    /// List of library paths that should have their symbols be reexported from the built library.
    public static func reExportedLibraryPaths(_ value: String...) -> BuildSetting { 
        .reExportedLibraryPaths(value)
    }
}

extension BuildSettingsKey {

    /// Re-Exported Library Paths
    ///
    /// List of library paths that should have their symbols be reexported from the built library.
    public static let reExportedLibraryPaths: BuildSettingsKey = "REEXPORTED_LIBRARY_PATHS"
}

// MARK: Remove Cvs From Resources
extension BuildSetting {

    /// Remove Cvs From Resources
    ///
    /// Specifies whether to remove `CVS` directories from bundle resources when they are copied.
    public static var removeCvsFromResources: BuildSetting { 
        BuildSetting(key: .removeCvsFromResources, value: "YES")
    }

    /// Remove Cvs From Resources
    ///
    /// Specifies whether to remove `CVS` directories from bundle resources when they are copied.
    public static func removeCvsFromResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeCvsFromResources, value: value.asText)
    }

    /// Remove Cvs From Resources
    ///
    /// Specifies whether to remove `CVS` directories from bundle resources when they are copied.
    public static func removeCvsFromResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeCvsFromResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Remove Cvs From Resources
    ///
    /// Specifies whether to remove `CVS` directories from bundle resources when they are copied.
    public static let removeCvsFromResources: BuildSettingsKey = "REMOVE_CVS_FROM_RESOURCES"
}

// MARK: Remove Git From Resources
extension BuildSetting {

    /// Remove Git From Resources
    ///
    /// Specifies whether to remove `.git` directories from bundle resources when they are copied.
    public static var removeGitFromResources: BuildSetting { 
        BuildSetting(key: .removeGitFromResources, value: "YES")
    }

    /// Remove Git From Resources
    ///
    /// Specifies whether to remove `.git` directories from bundle resources when they are copied.
    public static func removeGitFromResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeGitFromResources, value: value.asText)
    }

    /// Remove Git From Resources
    ///
    /// Specifies whether to remove `.git` directories from bundle resources when they are copied.
    public static func removeGitFromResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeGitFromResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Remove Git From Resources
    ///
    /// Specifies whether to remove `.git` directories from bundle resources when they are copied.
    public static let removeGitFromResources: BuildSettingsKey = "REMOVE_GIT_FROM_RESOURCES"
}

// MARK: Remove Headers From Embedded Bundles
extension BuildSetting {

    /// Remove Headers From Embedded Bundles
    public static var removeHeadersFromEmbeddedBundles: BuildSetting { 
        BuildSetting(key: .removeHeadersFromEmbeddedBundles, value: "YES")
    }

    /// Remove Headers From Embedded Bundles
    public static func removeHeadersFromEmbeddedBundles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeHeadersFromEmbeddedBundles, value: value.asText)
    }

    /// Remove Headers From Embedded Bundles
    public static func removeHeadersFromEmbeddedBundles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeHeadersFromEmbeddedBundles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Remove Headers From Embedded Bundles
    public static let removeHeadersFromEmbeddedBundles: BuildSettingsKey = "REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES"
}

// MARK: Remove Hg From Resources
extension BuildSetting {

    /// Remove Hg From Resources
    ///
    /// Specifies whether to remove `.hg` directories from bundle resources when they are copied.
    public static var removeHgFromResources: BuildSetting { 
        BuildSetting(key: .removeHgFromResources, value: "YES")
    }

    /// Remove Hg From Resources
    ///
    /// Specifies whether to remove `.hg` directories from bundle resources when they are copied.
    public static func removeHgFromResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeHgFromResources, value: value.asText)
    }

    /// Remove Hg From Resources
    ///
    /// Specifies whether to remove `.hg` directories from bundle resources when they are copied.
    public static func removeHgFromResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeHgFromResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Remove Hg From Resources
    ///
    /// Specifies whether to remove `.hg` directories from bundle resources when they are copied.
    public static let removeHgFromResources: BuildSettingsKey = "REMOVE_HG_FROM_RESOURCES"
}

// MARK: Remove Svn From Resources
extension BuildSetting {

    /// Remove Svn From Resources
    ///
    /// Specifies whether to remove `SVN` directories from bundle resources when they are copied.
    public static var removeSvnFromResources: BuildSetting { 
        BuildSetting(key: .removeSvnFromResources, value: "YES")
    }

    /// Remove Svn From Resources
    ///
    /// Specifies whether to remove `SVN` directories from bundle resources when they are copied.
    public static func removeSvnFromResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeSvnFromResources, value: value.asText)
    }

    /// Remove Svn From Resources
    ///
    /// Specifies whether to remove `SVN` directories from bundle resources when they are copied.
    public static func removeSvnFromResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeSvnFromResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Remove Svn From Resources
    ///
    /// Specifies whether to remove `SVN` directories from bundle resources when they are copied.
    public static let removeSvnFromResources: BuildSettingsKey = "REMOVE_SVN_FROM_RESOURCES"
}

// MARK: Resources Targeted Device Family
extension BuildSetting {

    /// Resources Targeted Device Family
    ///
    /// Overrides [Targeted Device Family (TARGETED_DEVICE_FAMILY)](itcaec37c2a6.html# dev2f2f7890b) when the resource copying needs to differ from the default targeted device.
    public static func resourcesTargetedDeviceFamily(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .resourcesTargetedDeviceFamily, value: .array(value))
    }

    /// Resources Targeted Device Family
    ///
    /// Overrides [Targeted Device Family (TARGETED_DEVICE_FAMILY)](itcaec37c2a6.html# dev2f2f7890b) when the resource copying needs to differ from the default targeted device.
    public static func resourcesTargetedDeviceFamily(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resourcesTargetedDeviceFamily, inherit: key)
    }

    /// Resources Targeted Device Family
    ///
    /// Overrides [Targeted Device Family (TARGETED_DEVICE_FAMILY)](itcaec37c2a6.html# dev2f2f7890b) when the resource copying needs to differ from the default targeted device.
    public static func resourcesTargetedDeviceFamily(_ value: String...) -> BuildSetting { 
        .resourcesTargetedDeviceFamily(value)
    }
}

extension BuildSettingsKey {

    /// Resources Targeted Device Family
    ///
    /// Overrides [Targeted Device Family (TARGETED_DEVICE_FAMILY)](itcaec37c2a6.html# dev2f2f7890b) when the resource copying needs to differ from the default targeted device.
    public static let resourcesTargetedDeviceFamily: BuildSettingsKey = "RESOURCES_TARGETED_DEVICE_FAMILY"
}

// MARK: Rez Executable
extension BuildSetting {

    /// Rez Executable
    public static func rezExecutable(_ value: String) -> BuildSetting { 
        BuildSetting(key: .rezExecutable, value: \(value))
    }

    /// Rez Executable
    public static func rezExecutable(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezExecutable, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Rez Executable
    public static let rezExecutable: BuildSettingsKey = "REZ_EXECUTABLE"
}

// MARK: Rez Search Paths
extension BuildSetting {

    /// Rez Search Paths
    ///
    /// This is a list of paths to search for files with resource manager resources. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func rezSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .rezSearchPaths, value: .array(value))
    }

    /// Rez Search Paths
    ///
    /// This is a list of paths to search for files with resource manager resources. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func rezSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezSearchPaths, inherit: key)
    }

    /// Rez Search Paths
    ///
    /// This is a list of paths to search for files with resource manager resources. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func rezSearchPaths(_ value: String...) -> BuildSetting { 
        .rezSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Rez Search Paths
    ///
    /// This is a list of paths to search for files with resource manager resources. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static let rezSearchPaths: BuildSettingsKey = "REZ_SEARCH_PATHS"
}

// MARK: Scan All Source Files for Includes
extension BuildSetting {

    /// Scan All Source Files for Includes
    ///
    /// Activating this setting will cause all source files to be scanned for includes (for example, of header files) when computing the dependency graph, in which case if an included file is changed then the including file will be rebuilt next time a target containing it is built. Normally only certain types of files, such as C-language source files, are scanned. This setting is useful if your project contains files of unusual types, which are compiled using a custom build rule.
    public static var scanAllSourceFilesForIncludes: BuildSetting { 
        BuildSetting(key: .scanAllSourceFilesForIncludes, value: "NO")
    }

    /// Scan All Source Files for Includes
    ///
    /// Activating this setting will cause all source files to be scanned for includes (for example, of header files) when computing the dependency graph, in which case if an included file is changed then the including file will be rebuilt next time a target containing it is built. Normally only certain types of files, such as C-language source files, are scanned. This setting is useful if your project contains files of unusual types, which are compiled using a custom build rule.
    public static func scanAllSourceFilesForIncludes(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .scanAllSourceFilesForIncludes, value: value.asText)
    }

    /// Scan All Source Files for Includes
    ///
    /// Activating this setting will cause all source files to be scanned for includes (for example, of header files) when computing the dependency graph, in which case if an included file is changed then the including file will be rebuilt next time a target containing it is built. Normally only certain types of files, such as C-language source files, are scanned. This setting is useful if your project contains files of unusual types, which are compiled using a custom build rule.
    public static func scanAllSourceFilesForIncludes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .scanAllSourceFilesForIncludes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Scan All Source Files for Includes
    ///
    /// Activating this setting will cause all source files to be scanned for includes (for example, of header files) when computing the dependency graph, in which case if an included file is changed then the including file will be rebuilt next time a target containing it is built. Normally only certain types of files, such as C-language source files, are scanned. This setting is useful if your project contains files of unusual types, which are compiled using a custom build rule.
    public static let scanAllSourceFilesForIncludes: BuildSettingsKey = "SCAN_ALL_SOURCE_FILES_FOR_INCLUDES"
}

// MARK: Base SDK
extension BuildSetting {

    /// Base SDK
    ///
    /// The name or path of the base SDK being used during the build. The product will be built against the headers and libraries located inside the indicated SDK. This path will be prepended to all search paths, and will be passed through the environment to the compiler and linker. Additional SDKs can be specified in the [Additional SDKs (ADDITIONAL_SDKS)](itcaec37c2a6.html# deva1a5b1b82) setting.
    public static func baseSdk(_ value: String) -> BuildSetting { 
        BuildSetting(key: .baseSdk, value: \(value))
    }

    /// Base SDK
    ///
    /// The name or path of the base SDK being used during the build. The product will be built against the headers and libraries located inside the indicated SDK. This path will be prepended to all search paths, and will be passed through the environment to the compiler and linker. Additional SDKs can be specified in the [Additional SDKs (ADDITIONAL_SDKS)](itcaec37c2a6.html# deva1a5b1b82) setting.
    public static func baseSdk(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .baseSdk, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Base SDK
    ///
    /// The name or path of the base SDK being used during the build. The product will be built against the headers and libraries located inside the indicated SDK. This path will be prepended to all search paths, and will be passed through the environment to the compiler and linker. Additional SDKs can be specified in the [Additional SDKs (ADDITIONAL_SDKS)](itcaec37c2a6.html# deva1a5b1b82) setting.
    public static let baseSdk: BuildSettingsKey = "SDKROOT"
}

// MARK: Symbol Ordering Flags
extension BuildSetting {

    /// Symbol Ordering Flags
    ///
    /// These flags are typically used to specify options for ordering symbols within segments, for example the `-sectorder` option to `ld`. Generally you should not specify symbol ordering options in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func symbolOrderingFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .symbolOrderingFlags, value: .array(value))
    }

    /// Symbol Ordering Flags
    ///
    /// These flags are typically used to specify options for ordering symbols within segments, for example the `-sectorder` option to `ld`. Generally you should not specify symbol ordering options in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func symbolOrderingFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .symbolOrderingFlags, inherit: key)
    }

    /// Symbol Ordering Flags
    ///
    /// These flags are typically used to specify options for ordering symbols within segments, for example the `-sectorder` option to `ld`. Generally you should not specify symbol ordering options in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func symbolOrderingFlags(_ value: String...) -> BuildSetting { 
        .symbolOrderingFlags(value)
    }
}

extension BuildSettingsKey {

    /// Symbol Ordering Flags
    ///
    /// These flags are typically used to specify options for ordering symbols within segments, for example the `-sectorder` option to `ld`. Generally you should not specify symbol ordering options in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static let symbolOrderingFlags: BuildSettingsKey = "SECTORDER_FLAGS"
}

// MARK: Separate Strip
extension BuildSetting {

    /// Separate Strip
    public static var separateStrip: BuildSetting { 
        BuildSetting(key: .separateStrip, value: "NO")
    }

    /// Separate Strip
    public static func separateStrip(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .separateStrip, value: value.asText)
    }

    /// Separate Strip
    public static func separateStrip(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .separateStrip, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Separate Strip
    public static let separateStrip: BuildSettingsKey = "SEPARATE_STRIP"
}

// MARK: Separately Edit Symbols
extension BuildSetting {

    /// Separately Edit Symbols
    ///
    /// Activating this setting when the linked product’s symbols are to be edited will cause editing to occur via a separate invocation of `nmedit(1)`. Otherwise editing will occur during linking, if possible.
    public static var separatelyEditSymbols: BuildSetting { 
        BuildSetting(key: .separatelyEditSymbols, value: "NO")
    }

    /// Separately Edit Symbols
    ///
    /// Activating this setting when the linked product’s symbols are to be edited will cause editing to occur via a separate invocation of `nmedit(1)`. Otherwise editing will occur during linking, if possible.
    public static func separatelyEditSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .separatelyEditSymbols, value: value.asText)
    }

    /// Separately Edit Symbols
    ///
    /// Activating this setting when the linked product’s symbols are to be edited will cause editing to occur via a separate invocation of `nmedit(1)`. Otherwise editing will occur during linking, if possible.
    public static func separatelyEditSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .separatelyEditSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Separately Edit Symbols
    ///
    /// Activating this setting when the linked product’s symbols are to be edited will cause editing to occur via a separate invocation of `nmedit(1)`. Otherwise editing will occur during linking, if possible.
    public static let separatelyEditSymbols: BuildSettingsKey = "SEPARATE_SYMBOL_EDIT"
}

// MARK: Shared Derived File Dir
extension BuildSetting {

    /// Shared Derived File Dir
    public static var sharedDerivedFileDir: BuildSetting { 
        BuildSetting(key: .sharedDerivedFileDir, value: "$(BUILT_PRODUCTS_DIR)/DerivedSources")
    }

    /// Shared Derived File Dir
    public static func sharedDerivedFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sharedDerivedFileDir, value: \(value))
    }

    /// Shared Derived File Dir
    public static func sharedDerivedFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sharedDerivedFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Shared Derived File Dir
    public static let sharedDerivedFileDir: BuildSettingsKey = "SHARED_DERIVED_FILE_DIR"
}

// MARK: Precompiled Headers Cache Path
extension BuildSetting {

    /// Precompiled Headers Cache Path
    ///
    /// The path where precompiled prefix header files are placed during a build. Defaults to `$(OBJROOT)/SharedPrecompiledHeaders`. Using a common location allows precompiled headers to be shared between multiple projects.
    public static var precompiledHeadersCachePath: BuildSetting { 
        BuildSetting(key: .precompiledHeadersCachePath, value: "$(OBJROOT)/SharedPrecompiledHeaders")
    }

    /// Precompiled Headers Cache Path
    ///
    /// The path where precompiled prefix header files are placed during a build. Defaults to `$(OBJROOT)/SharedPrecompiledHeaders`. Using a common location allows precompiled headers to be shared between multiple projects.
    public static func precompiledHeadersCachePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .precompiledHeadersCachePath, value: \(value))
    }

    /// Precompiled Headers Cache Path
    ///
    /// The path where precompiled prefix header files are placed during a build. Defaults to `$(OBJROOT)/SharedPrecompiledHeaders`. Using a common location allows precompiled headers to be shared between multiple projects.
    public static func precompiledHeadersCachePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompiledHeadersCachePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Precompiled Headers Cache Path
    ///
    /// The path where precompiled prefix header files are placed during a build. Defaults to `$(OBJROOT)/SharedPrecompiledHeaders`. Using a common location allows precompiled headers to be shared between multiple projects.
    public static let precompiledHeadersCachePath: BuildSettingsKey = "SHARED_PRECOMPS_DIR"
}

// MARK: Shell
extension BuildSetting {

    /// Shell
    public static func shell(_ value: String) -> BuildSetting { 
        BuildSetting(key: .shell, value: \(value))
    }

    /// Shell
    public static func shell(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .shell, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Shell
    public static let shell: BuildSettingsKey = "SHELL"
}

// MARK: Skip Install
extension BuildSetting {

    /// Skip Install
    ///
    /// If enabled, don’t install built products even if deployment locations are active.
    public static var skipInstall: BuildSetting { 
        BuildSetting(key: .skipInstall, value: "NO")
    }

    /// Skip Install
    ///
    /// If enabled, don’t install built products even if deployment locations are active.
    public static func skipInstall(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .skipInstall, value: value.asText)
    }

    /// Skip Install
    ///
    /// If enabled, don’t install built products even if deployment locations are active.
    public static func skipInstall(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .skipInstall, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Skip Install
    ///
    /// If enabled, don’t install built products even if deployment locations are active.
    public static let skipInstall: BuildSettingsKey = "SKIP_INSTALL"
}

// MARK: Source Root
extension BuildSetting {

    /// Source Root
    public static var sourceRoot: BuildSetting { 
        .sourceRoot(inherit: .srcroot) 
    }

    /// Source Root
    public static func sourceRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sourceRoot, value: \(value))
    }

    /// Source Root
    public static func sourceRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sourceRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Source Root
    public static let sourceRoot: BuildSettingsKey = "SOURCE_ROOT"
}

// MARK: Srcroot
extension BuildSetting {

    /// Srcroot
    ///
    /// Identifies the directory containing the target’s source files.
    public static var srcroot: BuildSetting { 
        BuildSetting(key: .srcroot, value: ".")
    }

    /// Srcroot
    ///
    /// Identifies the directory containing the target’s source files.
    public static func srcroot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .srcroot, value: \(value))
    }

    /// Srcroot
    ///
    /// Identifies the directory containing the target’s source files.
    public static func srcroot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .srcroot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Srcroot
    ///
    /// Identifies the directory containing the target’s source files.
    public static let srcroot: BuildSettingsKey = "SRCROOT"
}

// MARK: Strings File Output Encoding
extension BuildSetting {

    /// Strings File Output Encoding
    ///
    /// Specify the encoding to be used for Strings files (by default, the output encoding will be 16-bit Unicode). The value can be either an `NSStringEncoding`, such as one of the numeric values recognized by `NSString`, or it can be an IANA character set name as understood by `CFString`. The operation will fail if the file cannot be converted to the specified encoding.
    public static var stringsFileOutputEncoding: BuildSetting { 
        .stringsFileOutputEncoding(.utf16) 
    }

    /// Strings File Output Encoding
    ///
    /// Specify the encoding to be used for Strings files (by default, the output encoding will be 16-bit Unicode). The value can be either an `NSStringEncoding`, such as one of the numeric values recognized by `NSString`, or it can be an IANA character set name as understood by `CFString`. The operation will fail if the file cannot be converted to the specified encoding.
    public static func stringsFileOutputEncoding(_ value: StringsFileOutputEncoding) -> BuildSetting { 
        BuildSetting(key: .stringsFileOutputEncoding, value: \(value))
    }

    /// Strings File Output Encoding
    ///
    /// Specify the encoding to be used for Strings files (by default, the output encoding will be 16-bit Unicode). The value can be either an `NSStringEncoding`, such as one of the numeric values recognized by `NSString`, or it can be an IANA character set name as understood by `CFString`. The operation will fail if the file cannot be converted to the specified encoding.
    public static func stringsFileOutputEncoding(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stringsFileOutputEncoding, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strings File Output Encoding
    ///
    /// Specify the encoding to be used for Strings files (by default, the output encoding will be 16-bit Unicode). The value can be either an `NSStringEncoding`, such as one of the numeric values recognized by `NSString`, or it can be an IANA character set name as understood by `CFString`. The operation will fail if the file cannot be converted to the specified encoding.
    public static let stringsFileOutputEncoding: BuildSettingsKey = "STRINGS_FILE_OUTPUT_ENCODING"
}

public enum StringsFileOutputEncoding: String, Hashable, Codable, CustomStringConvertible {
    case utf8 = "UTF-8"
    case binary = "binary"
    case utf16 = "UTF-16"

    public var description: String {
        rawValue
    }
}

// MARK: Additional Strip Flags
extension BuildSetting {

    /// Additional Strip Flags
    ///
    /// Additional flags to be passed when stripping the linked product of the build.
    public static func additionalStripFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .additionalStripFlags, value: .array(value))
    }

    /// Additional Strip Flags
    ///
    /// Additional flags to be passed when stripping the linked product of the build.
    public static func additionalStripFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .additionalStripFlags, inherit: key)
    }

    /// Additional Strip Flags
    ///
    /// Additional flags to be passed when stripping the linked product of the build.
    public static func additionalStripFlags(_ value: String...) -> BuildSetting { 
        .additionalStripFlags(value)
    }
}

extension BuildSettingsKey {

    /// Additional Strip Flags
    ///
    /// Additional flags to be passed when stripping the linked product of the build.
    public static let additionalStripFlags: BuildSettingsKey = "STRIPFLAGS"
}

// MARK: Strip Bitcode From Copied Files
extension BuildSetting {

    /// Strip Bitcode From Copied Files
    public static var stripBitcodeFromCopiedFiles: BuildSetting { 
        BuildSetting(key: .stripBitcodeFromCopiedFiles, value: "NO")
    }

    /// Strip Bitcode From Copied Files
    public static func stripBitcodeFromCopiedFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripBitcodeFromCopiedFiles, value: value.asText)
    }

    /// Strip Bitcode From Copied Files
    public static func stripBitcodeFromCopiedFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripBitcodeFromCopiedFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Bitcode From Copied Files
    public static let stripBitcodeFromCopiedFiles: BuildSettingsKey = "STRIP_BITCODE_FROM_COPIED_FILES"
}

// MARK: Strip Linked Product
extension BuildSetting {

    /// Strip Linked Product
    ///
    /// If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing.
    public static func stripLinkedProduct(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripLinkedProduct, value: value.asText)
    }

    /// Strip Linked Product
    ///
    /// If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing.
    public static func stripLinkedProduct(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripLinkedProduct, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Linked Product
    ///
    /// If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing.
    public static let stripLinkedProduct: BuildSettingsKey = "STRIP_INSTALLED_PRODUCT"
}

// MARK: Strip Style
extension BuildSetting {

    /// Strip Style
    ///
    /// The level of symbol stripping to be performed on the linked product of the build. The default value is defined by the target’s product type.
    public static var stripStyle: BuildSetting { 
        .stripStyle(.all) 
    }

    /// Strip Style
    ///
    /// The level of symbol stripping to be performed on the linked product of the build. The default value is defined by the target’s product type.
    public static func stripStyle(_ value: StripStyle) -> BuildSetting { 
        BuildSetting(key: .stripStyle, value: \(value))
    }

    /// Strip Style
    ///
    /// The level of symbol stripping to be performed on the linked product of the build. The default value is defined by the target’s product type.
    public static func stripStyle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripStyle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Style
    ///
    /// The level of symbol stripping to be performed on the linked product of the build. The default value is defined by the target’s product type.
    public static let stripStyle: BuildSettingsKey = "STRIP_STYLE"
}

public enum StripStyle: String, Hashable, Codable, CustomStringConvertible {
    case nonGlobal = "non-global"
    case debugging = "debugging"
    case all = "all"

    public var description: String {
        rawValue
    }
}

// MARK: Strip Swift Symbols
extension BuildSetting {

    /// Strip Swift Symbols
    ///
    /// Adjust the level of symbol stripping specified by the STRIP_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed.
    public static var stripSwiftSymbols: BuildSetting { 
        BuildSetting(key: .stripSwiftSymbols, value: "YES")
    }

    /// Strip Swift Symbols
    ///
    /// Adjust the level of symbol stripping specified by the STRIP_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed.
    public static func stripSwiftSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripSwiftSymbols, value: value.asText)
    }

    /// Strip Swift Symbols
    ///
    /// Adjust the level of symbol stripping specified by the STRIP_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed.
    public static func stripSwiftSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripSwiftSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Swift Symbols
    ///
    /// Adjust the level of symbol stripping specified by the STRIP_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed.
    public static let stripSwiftSymbols: BuildSettingsKey = "STRIP_SWIFT_SYMBOLS"
}

// MARK: Supported Platforms
extension BuildSetting {

    /// Supported Platforms
    ///
    /// The list of supported platforms from which a base SDK can be used. This setting is used if the product can be built for multiple platforms using different SDKs.
    public static func supportedPlatforms(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .supportedPlatforms, value: .array(value))
    }

    /// Supported Platforms
    ///
    /// The list of supported platforms from which a base SDK can be used. This setting is used if the product can be built for multiple platforms using different SDKs.
    public static func supportedPlatforms(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .supportedPlatforms, inherit: key)
    }

    /// Supported Platforms
    ///
    /// The list of supported platforms from which a base SDK can be used. This setting is used if the product can be built for multiple platforms using different SDKs.
    public static func supportedPlatforms(_ value: String...) -> BuildSetting { 
        .supportedPlatforms(value)
    }
}

extension BuildSettingsKey {

    /// Supported Platforms
    ///
    /// The list of supported platforms from which a base SDK can be used. This setting is used if the product can be built for multiple platforms using different SDKs.
    public static let supportedPlatforms: BuildSettingsKey = "SUPPORTED_PLATFORMS"
}

// MARK: Supports Text-Based InstallAPI
extension BuildSetting {

    /// Supports Text-Based InstallAPI
    ///
    /// Enable to indicate that the target supports `Text-Based InstallAPI`, which will enable its generation during `install` builds.
    public static var supportsTextBasedInstallapi: BuildSetting { 
        BuildSetting(key: .supportsTextBasedInstallapi, value: "NO")
    }

    /// Supports Text-Based InstallAPI
    ///
    /// Enable to indicate that the target supports `Text-Based InstallAPI`, which will enable its generation during `install` builds.
    public static func supportsTextBasedInstallapi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .supportsTextBasedInstallapi, value: value.asText)
    }

    /// Supports Text-Based InstallAPI
    ///
    /// Enable to indicate that the target supports `Text-Based InstallAPI`, which will enable its generation during `install` builds.
    public static func supportsTextBasedInstallapi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .supportsTextBasedInstallapi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Supports Text-Based InstallAPI
    ///
    /// Enable to indicate that the target supports `Text-Based InstallAPI`, which will enable its generation during `install` builds.
    public static let supportsTextBasedInstallapi: BuildSettingsKey = "SUPPORTS_TEXT_BASED_API"
}

// MARK: Swift Platform Target Prefix
extension BuildSetting {

    /// Swift Platform Target Prefix
    public static func swiftPlatformTargetPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftPlatformTargetPrefix, value: \(value))
    }

    /// Swift Platform Target Prefix
    public static func swiftPlatformTargetPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftPlatformTargetPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Platform Target Prefix
    public static let swiftPlatformTargetPrefix: BuildSettingsKey = "SWIFT_PLATFORM_TARGET_PREFIX"
}

// MARK: Build Products Path
extension BuildSetting {

    /// Build Products Path
    ///
    /// The path at which all products will be placed when performing a build. Typically this path is not set per target, but is set per-project or per-user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static var buildProductsPath: BuildSetting { 
        BuildSetting(key: .buildProductsPath, value: "build")
    }

    /// Build Products Path
    ///
    /// The path at which all products will be placed when performing a build. Typically this path is not set per target, but is set per-project or per-user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static func buildProductsPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .buildProductsPath, value: \(value))
    }

    /// Build Products Path
    ///
    /// The path at which all products will be placed when performing a build. Typically this path is not set per target, but is set per-project or per-user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static func buildProductsPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildProductsPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Products Path
    ///
    /// The path at which all products will be placed when performing a build. Typically this path is not set per target, but is set per-project or per-user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static let buildProductsPath: BuildSettingsKey = "SYMROOT"
}

// MARK: System Dext Install Path
extension BuildSetting {

    /// System Dext Install Path
    public static var systemDextInstallPath: BuildSetting { 
        BuildSetting(key: .systemDextInstallPath, value: "$(SYSTEM_LIBRARY_DIR)/DriverExtensions")
    }

    /// System Dext Install Path
    public static func systemDextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .systemDextInstallPath, value: \(value))
    }

    /// System Dext Install Path
    public static func systemDextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .systemDextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// System Dext Install Path
    public static let systemDextInstallPath: BuildSettingsKey = "SYSTEM_DEXT_INSTALL_PATH"
}

// MARK: System Framework Search Paths
extension BuildSetting {

    /// System Framework Search Paths
    ///
    /// This is a list of paths to folders containing system frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to “Framework Search Paths”, except that the search paths are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn’t support the concept of system framework search paths, then the search paths are appended to any existing framework search paths defined in “Framework Search Paths”.
    public static func systemFrameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .systemFrameworkSearchPaths, value: .array(value))
    }

    /// System Framework Search Paths
    ///
    /// This is a list of paths to folders containing system frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to “Framework Search Paths”, except that the search paths are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn’t support the concept of system framework search paths, then the search paths are appended to any existing framework search paths defined in “Framework Search Paths”.
    public static func systemFrameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .systemFrameworkSearchPaths, inherit: key)
    }

    /// System Framework Search Paths
    ///
    /// This is a list of paths to folders containing system frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to “Framework Search Paths”, except that the search paths are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn’t support the concept of system framework search paths, then the search paths are appended to any existing framework search paths defined in “Framework Search Paths”.
    public static func systemFrameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .systemFrameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// System Framework Search Paths
    ///
    /// This is a list of paths to folders containing system frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to “Framework Search Paths”, except that the search paths are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn’t support the concept of system framework search paths, then the search paths are appended to any existing framework search paths defined in “Framework Search Paths”.
    public static let systemFrameworkSearchPaths: BuildSettingsKey = "SYSTEM_FRAMEWORK_SEARCH_PATHS"
}

// MARK: System Header Search Paths
extension BuildSetting {

    /// System Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported system header files when compiling C, Objective-C, C++, or Objective-C++. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to “Header Search Paths”, except that headers are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn’t support the concept of system header search paths, then the search paths are appended to any existing header search paths defined in “Header Search Paths”.
    public static func systemHeaderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .systemHeaderSearchPaths, value: .array(value))
    }

    /// System Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported system header files when compiling C, Objective-C, C++, or Objective-C++. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to “Header Search Paths”, except that headers are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn’t support the concept of system header search paths, then the search paths are appended to any existing header search paths defined in “Header Search Paths”.
    public static func systemHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .systemHeaderSearchPaths, inherit: key)
    }

    /// System Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported system header files when compiling C, Objective-C, C++, or Objective-C++. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to “Header Search Paths”, except that headers are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn’t support the concept of system header search paths, then the search paths are appended to any existing header search paths defined in “Header Search Paths”.
    public static func systemHeaderSearchPaths(_ value: String...) -> BuildSetting { 
        .systemHeaderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// System Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported system header files when compiling C, Objective-C, C++, or Objective-C++. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to “Header Search Paths”, except that headers are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn’t support the concept of system header search paths, then the search paths are appended to any existing header search paths defined in “Header Search Paths”.
    public static let systemHeaderSearchPaths: BuildSettingsKey = "SYSTEM_HEADER_SEARCH_PATHS"
}

// MARK: System Kext Install Path
extension BuildSetting {

    /// System Kext Install Path
    public static var systemKextInstallPath: BuildSetting { 
        BuildSetting(key: .systemKextInstallPath, value: "$(SYSTEM_LIBRARY_DIR)/Extensions")
    }

    /// System Kext Install Path
    public static func systemKextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .systemKextInstallPath, value: \(value))
    }

    /// System Kext Install Path
    public static func systemKextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .systemKextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// System Kext Install Path
    public static let systemKextInstallPath: BuildSettingsKey = "SYSTEM_KEXT_INSTALL_PATH"
}

// MARK: Text-Based InstallAPI Verification Mode
extension BuildSetting {

    /// Text-Based InstallAPI Verification Mode
    ///
    /// Selects the level of warnings and errors to report when building `Text-Based InstallAPI`.
    public static var textBasedInstallapiVerificationMode: BuildSetting { 
        .textBasedInstallapiVerificationMode(.errorsonly) 
    }

    /// Text-Based InstallAPI Verification Mode
    ///
    /// Selects the level of warnings and errors to report when building `Text-Based InstallAPI`.
    public static func textBasedInstallapiVerificationMode(_ value: TextBasedInstallapiVerificationMode) -> BuildSetting { 
        BuildSetting(key: .textBasedInstallapiVerificationMode, value: \(value))
    }

    /// Text-Based InstallAPI Verification Mode
    ///
    /// Selects the level of warnings and errors to report when building `Text-Based InstallAPI`.
    public static func textBasedInstallapiVerificationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .textBasedInstallapiVerificationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Text-Based InstallAPI Verification Mode
    ///
    /// Selects the level of warnings and errors to report when building `Text-Based InstallAPI`.
    public static let textBasedInstallapiVerificationMode: BuildSettingsKey = "TAPI_VERIFY_MODE"
}

public enum TextBasedInstallapiVerificationMode: String, Hashable, Codable, CustomStringConvertible {
    case errorsonly = "ErrorsOnly"
    case pedantic = "Pedantic"
    case errorsandwarnings = "ErrorsAndWarnings"

    public var description: String {
        rawValue
    }
}

// MARK: Target Build Dir
extension BuildSetting {

    /// Target Build Dir
    ///
    /// Identifies the root of the directory hierarchy that contains the product’s files (no intermediate build files). Run Script build phases that operate on product files of the target that defines them should use the value of this build setting, but Run Script build phases that operate on product files of other targets should use `BUILT_PRODUCTS_DIR` instead.
    public static var targetBuildDir: BuildSetting { 
        BuildSetting(key: .targetBuildDir, value: "$(CONFIGURATION_BUILD_DIR)$(TARGET_BUILD_SUBPATH)")
    }

    /// Target Build Dir
    ///
    /// Identifies the root of the directory hierarchy that contains the product’s files (no intermediate build files). Run Script build phases that operate on product files of the target that defines them should use the value of this build setting, but Run Script build phases that operate on product files of other targets should use `BUILT_PRODUCTS_DIR` instead.
    public static func targetBuildDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .targetBuildDir, value: \(value))
    }

    /// Target Build Dir
    ///
    /// Identifies the root of the directory hierarchy that contains the product’s files (no intermediate build files). Run Script build phases that operate on product files of the target that defines them should use the value of this build setting, but Run Script build phases that operate on product files of other targets should use `BUILT_PRODUCTS_DIR` instead.
    public static func targetBuildDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .targetBuildDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Target Build Dir
    ///
    /// Identifies the root of the directory hierarchy that contains the product’s files (no intermediate build files). Run Script build phases that operate on product files of the target that defines them should use the value of this build setting, but Run Script build phases that operate on product files of other targets should use `BUILT_PRODUCTS_DIR` instead.
    public static let targetBuildDir: BuildSettingsKey = "TARGET_BUILD_DIR"
}

// MARK: Target Build Subpath
extension BuildSetting {

    /// Target Build Subpath
    public static func targetBuildSubpath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .targetBuildSubpath, value: \(value))
    }

    /// Target Build Subpath
    public static func targetBuildSubpath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .targetBuildSubpath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Target Build Subpath
    public static let targetBuildSubpath: BuildSettingsKey = "TARGET_BUILD_SUBPATH"
}

// MARK: Target Name
extension BuildSetting {

    /// Target Name
    ///
    /// The name of the current target.
    public static func targetName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .targetName, value: \(value))
    }

    /// Target Name
    ///
    /// The name of the current target.
    public static func targetName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .targetName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Target Name
    ///
    /// The name of the current target.
    public static let targetName: BuildSettingsKey = "TARGET_NAME"
}

// MARK: Target Temp Dir
extension BuildSetting {

    /// Target Temp Dir
    ///
    /// Identifies the directory containing the target’s intermediate build files. Run Script build phases should place intermediate files at the location indicated by `DERIVED_FILE_DIR`, not the directory identified by this build setting.
    public static var targetTempDir: BuildSetting { 
        BuildSetting(key: .targetTempDir, value: "$(CONFIGURATION_TEMP_DIR)/$(TARGET_NAME).build")
    }

    /// Target Temp Dir
    ///
    /// Identifies the directory containing the target’s intermediate build files. Run Script build phases should place intermediate files at the location indicated by `DERIVED_FILE_DIR`, not the directory identified by this build setting.
    public static func targetTempDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .targetTempDir, value: \(value))
    }

    /// Target Temp Dir
    ///
    /// Identifies the directory containing the target’s intermediate build files. Run Script build phases should place intermediate files at the location indicated by `DERIVED_FILE_DIR`, not the directory identified by this build setting.
    public static func targetTempDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .targetTempDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Target Temp Dir
    ///
    /// Identifies the directory containing the target’s intermediate build files. Run Script build phases should place intermediate files at the location indicated by `DERIVED_FILE_DIR`, not the directory identified by this build setting.
    public static let targetTempDir: BuildSettingsKey = "TARGET_TEMP_DIR"
}

// MARK: Temp Dir
extension BuildSetting {

    /// Temp Dir
    public static var tempDir: BuildSetting { 
        .tempDir(inherit: .targetTempDir) 
    }

    /// Temp Dir
    public static func tempDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tempDir, value: \(value))
    }

    /// Temp Dir
    public static func tempDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tempDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Temp Dir
    public static let tempDir: BuildSettingsKey = "TEMP_DIR"
}

// MARK: Temp Files Dir
extension BuildSetting {

    /// Temp Files Dir
    public static var tempFilesDir: BuildSetting { 
        .tempFilesDir(inherit: .tempFileDir) 
    }

    /// Temp Files Dir
    public static func tempFilesDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tempFilesDir, value: \(value))
    }

    /// Temp Files Dir
    public static func tempFilesDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tempFilesDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Temp Files Dir
    public static let tempFilesDir: BuildSettingsKey = "TEMP_FILES_DIR"
}

// MARK: Temp File Dir
extension BuildSetting {

    /// Temp File Dir
    public static var tempFileDir: BuildSetting { 
        .tempFileDir(inherit: .targetTempDir) 
    }

    /// Temp File Dir
    public static func tempFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tempFileDir, value: \(value))
    }

    /// Temp File Dir
    public static func tempFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tempFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Temp File Dir
    public static let tempFileDir: BuildSettingsKey = "TEMP_FILE_DIR"
}

// MARK: Temp Root
extension BuildSetting {

    /// Temp Root
    public static var tempRoot: BuildSetting { 
        .tempRoot(inherit: .intermediateBuildFilesPath) 
    }

    /// Temp Root
    public static func tempRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tempRoot, value: \(value))
    }

    /// Temp Root
    public static func tempRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tempRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Temp Root
    public static let tempRoot: BuildSettingsKey = "TEMP_ROOT"
}

// MARK: Test Host
extension BuildSetting {

    /// Test Host
    ///
    /// Path to the executable into which a bundle of tests is injected. Only specify this setting if testing an application or other executable.
    public static func testHost(_ value: String) -> BuildSetting { 
        BuildSetting(key: .testHost, value: \(value))
    }

    /// Test Host
    ///
    /// Path to the executable into which a bundle of tests is injected. Only specify this setting if testing an application or other executable.
    public static func testHost(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .testHost, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Test Host
    ///
    /// Path to the executable into which a bundle of tests is injected. Only specify this setting if testing an application or other executable.
    public static let testHost: BuildSettingsKey = "TEST_HOST"
}

// MARK: Toolchains
extension BuildSetting {

    /// Toolchains
    public static func toolchains(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .toolchains, value: .array(value))
    }

    /// Toolchains
    public static func toolchains(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .toolchains, inherit: key)
    }

    /// Toolchains
    public static func toolchains(_ value: String...) -> BuildSetting { 
        .toolchains(value)
    }
}

extension BuildSettingsKey {

    /// Toolchains
    public static let toolchains: BuildSettingsKey = "TOOLCHAINS"
}

// MARK: Treat missing baselines as test failures
extension BuildSetting {

    /// Treat missing baselines as test failures
    ///
    /// When running tests that measure performance via `XCTestCase`, report missing baselines as test failures.
    public static var treatMissingBaselinesAsTestFailures: BuildSetting { 
        BuildSetting(key: .treatMissingBaselinesAsTestFailures, value: "NO")
    }

    /// Treat missing baselines as test failures
    ///
    /// When running tests that measure performance via `XCTestCase`, report missing baselines as test failures.
    public static func treatMissingBaselinesAsTestFailures(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatMissingBaselinesAsTestFailures, value: value.asText)
    }

    /// Treat missing baselines as test failures
    ///
    /// When running tests that measure performance via `XCTestCase`, report missing baselines as test failures.
    public static func treatMissingBaselinesAsTestFailures(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatMissingBaselinesAsTestFailures, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat missing baselines as test failures
    ///
    /// When running tests that measure performance via `XCTestCase`, report missing baselines as test failures.
    public static let treatMissingBaselinesAsTestFailures: BuildSettingsKey = "TREAT_MISSING_BASELINES_AS_TEST_FAILURES"
}

// MARK: Unexported Symbols File
extension BuildSetting {

    /// Unexported Symbols File
    ///
    /// A project-relative path to a file that lists the symbols not to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static func unexportedSymbolsFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .unexportedSymbolsFile, value: \(value))
    }

    /// Unexported Symbols File
    ///
    /// A project-relative path to a file that lists the symbols not to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static func unexportedSymbolsFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unexportedSymbolsFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unexported Symbols File
    ///
    /// A project-relative path to a file that lists the symbols not to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static let unexportedSymbolsFile: BuildSettingsKey = "UNEXPORTED_SYMBOLS_FILE"
}

// MARK: User
extension BuildSetting {

    /// User
    public static func user(_ value: String) -> BuildSetting { 
        BuildSetting(key: .user, value: \(value))
    }

    /// User
    public static func user(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .user, inherit: key)
    }
}

extension BuildSettingsKey {

    /// User
    public static let user: BuildSettingsKey = "USER"
}

// MARK: User Header Search Paths
extension BuildSetting {

    /// User Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported user header files (those headers listed in quotes) when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. See [Always Search User Paths (Deprecated) (ALWAYS_SEARCH_USER_PATHS)](itcaec37c2a6.html# devc34d7d3e9) for more details on how this setting is used. If the compiler doesn’t support the concept of user headers, then the search paths are prepended to the any existing header search paths defined in [Header Search Paths (HEADER_SEARCH_PATHS)](itcaec37c2a6.html# dev3c9f85d97).
    public static func userHeaderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .userHeaderSearchPaths, value: .array(value))
    }

    /// User Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported user header files (those headers listed in quotes) when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. See [Always Search User Paths (Deprecated) (ALWAYS_SEARCH_USER_PATHS)](itcaec37c2a6.html# devc34d7d3e9) for more details on how this setting is used. If the compiler doesn’t support the concept of user headers, then the search paths are prepended to the any existing header search paths defined in [Header Search Paths (HEADER_SEARCH_PATHS)](itcaec37c2a6.html# dev3c9f85d97).
    public static func userHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .userHeaderSearchPaths, inherit: key)
    }

    /// User Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported user header files (those headers listed in quotes) when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. See [Always Search User Paths (Deprecated) (ALWAYS_SEARCH_USER_PATHS)](itcaec37c2a6.html# devc34d7d3e9) for more details on how this setting is used. If the compiler doesn’t support the concept of user headers, then the search paths are prepended to the any existing header search paths defined in [Header Search Paths (HEADER_SEARCH_PATHS)](itcaec37c2a6.html# dev3c9f85d97).
    public static func userHeaderSearchPaths(_ value: String...) -> BuildSetting { 
        .userHeaderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// User Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported user header files (those headers listed in quotes) when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. See [Always Search User Paths (Deprecated) (ALWAYS_SEARCH_USER_PATHS)](itcaec37c2a6.html# devc34d7d3e9) for more details on how this setting is used. If the compiler doesn’t support the concept of user headers, then the search paths are prepended to the any existing header search paths defined in [Header Search Paths (HEADER_SEARCH_PATHS)](itcaec37c2a6.html# dev3c9f85d97).
    public static let userHeaderSearchPaths: BuildSettingsKey = "USER_HEADER_SEARCH_PATHS"
}

// MARK: Use Header Maps
extension BuildSetting {

    /// Use Header Maps
    ///
    /// Enable the use of **Header Maps**, which provide the compiler with a mapping from textual header names to their locations, bypassing the normal compiler header search path mechanisms. This allows source code to include headers from various locations in the file system without needing to update the header search path build settings.
    public static var useHeaderMaps: BuildSetting { 
        BuildSetting(key: .useHeaderMaps, value: "YES")
    }

    /// Use Header Maps
    ///
    /// Enable the use of **Header Maps**, which provide the compiler with a mapping from textual header names to their locations, bypassing the normal compiler header search path mechanisms. This allows source code to include headers from various locations in the file system without needing to update the header search path build settings.
    public static func useHeaderMaps(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useHeaderMaps, value: value.asText)
    }

    /// Use Header Maps
    ///
    /// Enable the use of **Header Maps**, which provide the compiler with a mapping from textual header names to their locations, bypassing the normal compiler header search path mechanisms. This allows source code to include headers from various locations in the file system without needing to update the header search path build settings.
    public static func useHeaderMaps(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useHeaderMaps, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Header Maps
    ///
    /// Enable the use of **Header Maps**, which provide the compiler with a mapping from textual header names to their locations, bypassing the normal compiler header search path mechanisms. This allows source code to include headers from various locations in the file system without needing to update the header search path build settings.
    public static let useHeaderMaps: BuildSettingsKey = "USE_HEADERMAP"
}

// MARK: Use Header Symlinks
extension BuildSetting {

    /// Use Header Symlinks
    public static var useHeaderSymlinks: BuildSetting { 
        BuildSetting(key: .useHeaderSymlinks, value: "NO")
    }

    /// Use Header Symlinks
    public static func useHeaderSymlinks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useHeaderSymlinks, value: value.asText)
    }

    /// Use Header Symlinks
    public static func useHeaderSymlinks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useHeaderSymlinks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Header Symlinks
    public static let useHeaderSymlinks: BuildSettingsKey = "USE_HEADER_SYMLINKS"
}

// MARK: Use Llvm Target Triples
extension BuildSetting {

    /// Use Llvm Target Triples
    public static var useLlvmTargetTriples: BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriples, value: "YES")
    }

    /// Use Llvm Target Triples
    public static func useLlvmTargetTriples(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriples, value: value.asText)
    }

    /// Use Llvm Target Triples
    public static func useLlvmTargetTriples(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useLlvmTargetTriples, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Llvm Target Triples
    public static let useLlvmTargetTriples: BuildSettingsKey = "USE_LLVM_TARGET_TRIPLES"
}

// MARK: Use Llvm Target Triples For Clang
extension BuildSetting {

    /// Use Llvm Target Triples For Clang
    public static var useLlvmTargetTriplesForClang: BuildSetting { 
        .useLlvmTargetTriplesForClang(inherit: .useLlvmTargetTriples) 
    }

    /// Use Llvm Target Triples For Clang
    public static func useLlvmTargetTriplesForClang(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriplesForClang, value: value.asText)
    }

    /// Use Llvm Target Triples For Clang
    public static func useLlvmTargetTriplesForClang(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useLlvmTargetTriplesForClang, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Llvm Target Triples For Clang
    public static let useLlvmTargetTriplesForClang: BuildSettingsKey = "USE_LLVM_TARGET_TRIPLES_FOR_CLANG"
}

// MARK: Use Llvm Target Triples For Ld
extension BuildSetting {

    /// Use Llvm Target Triples For Ld
    public static var useLlvmTargetTriplesForLd: BuildSetting { 
        .useLlvmTargetTriplesForLd(inherit: .useLlvmTargetTriples) 
    }

    /// Use Llvm Target Triples For Ld
    public static func useLlvmTargetTriplesForLd(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriplesForLd, value: value.asText)
    }

    /// Use Llvm Target Triples For Ld
    public static func useLlvmTargetTriplesForLd(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useLlvmTargetTriplesForLd, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Llvm Target Triples For Ld
    public static let useLlvmTargetTriplesForLd: BuildSettingsKey = "USE_LLVM_TARGET_TRIPLES_FOR_LD"
}

// MARK: Use Llvm Target Triples For Tapi
extension BuildSetting {

    /// Use Llvm Target Triples For Tapi
    public static var useLlvmTargetTriplesForTapi: BuildSetting { 
        .useLlvmTargetTriplesForTapi(inherit: .useLlvmTargetTriples) 
    }

    /// Use Llvm Target Triples For Tapi
    public static func useLlvmTargetTriplesForTapi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriplesForTapi, value: value.asText)
    }

    /// Use Llvm Target Triples For Tapi
    public static func useLlvmTargetTriplesForTapi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useLlvmTargetTriplesForTapi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Llvm Target Triples For Tapi
    public static let useLlvmTargetTriplesForTapi: BuildSettingsKey = "USE_LLVM_TARGET_TRIPLES_FOR_TAPI"
}

// MARK: Validate Workspace
extension BuildSetting {

    /// Validate Workspace
    ///
    /// If enabled, perform validation checks on the workspace configuration as part of the build process.
    public static var validateWorkspace: BuildSetting { 
        .validateWorkspace(.no) 
    }

    /// Validate Workspace
    ///
    /// If enabled, perform validation checks on the workspace configuration as part of the build process.
    public static func validateWorkspace(_ value: ValidateWorkspace) -> BuildSetting { 
        BuildSetting(key: .validateWorkspace, value: \(value))
    }

    /// Validate Workspace
    ///
    /// If enabled, perform validation checks on the workspace configuration as part of the build process.
    public static func validateWorkspace(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validateWorkspace, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Validate Workspace
    ///
    /// If enabled, perform validation checks on the workspace configuration as part of the build process.
    public static let validateWorkspace: BuildSettingsKey = "VALIDATE_WORKSPACE"
}

public enum ValidateWorkspace: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Validate Workspace - Ignored Frameworks
extension BuildSetting {

    /// Validate Workspace - Ignored Frameworks
    ///
    /// List of framework names for which to suppress deprecation warnings and missing framework errors in the workspace validator.
    public static func validateWorkspaceIgnoredFrameworks(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .validateWorkspaceIgnoredFrameworks, value: .array(value))
    }

    /// Validate Workspace - Ignored Frameworks
    ///
    /// List of framework names for which to suppress deprecation warnings and missing framework errors in the workspace validator.
    public static func validateWorkspaceIgnoredFrameworks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validateWorkspaceIgnoredFrameworks, inherit: key)
    }

    /// Validate Workspace - Ignored Frameworks
    ///
    /// List of framework names for which to suppress deprecation warnings and missing framework errors in the workspace validator.
    public static func validateWorkspaceIgnoredFrameworks(_ value: String...) -> BuildSetting { 
        .validateWorkspaceIgnoredFrameworks(value)
    }
}

extension BuildSettingsKey {

    /// Validate Workspace - Ignored Frameworks
    ///
    /// List of framework names for which to suppress deprecation warnings and missing framework errors in the workspace validator.
    public static let validateWorkspaceIgnoredFrameworks: BuildSettingsKey = "VALIDATE_WORKSPACE_SKIPPED_SDK_FRAMEWORKS"
}

// MARK: Valid Architectures
extension BuildSetting {

    /// Valid Architectures
    ///
    /// A space-separated list of architectures for which the target should actually be built. For each target, this is intersected with the list specified in [Architectures (ARCHS)](itcaec37c2a6.html# devf0a9d5aca), and the resulting set is built. This allows individual targets to opt out of building for particular architectures. If the resulting set of architectures is empty, no executable will be produced.
    public static func validArchitectures(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .validArchitectures, value: .array(value))
    }

    /// Valid Architectures
    ///
    /// A space-separated list of architectures for which the target should actually be built. For each target, this is intersected with the list specified in [Architectures (ARCHS)](itcaec37c2a6.html# devf0a9d5aca), and the resulting set is built. This allows individual targets to opt out of building for particular architectures. If the resulting set of architectures is empty, no executable will be produced.
    public static func validArchitectures(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validArchitectures, inherit: key)
    }

    /// Valid Architectures
    ///
    /// A space-separated list of architectures for which the target should actually be built. For each target, this is intersected with the list specified in [Architectures (ARCHS)](itcaec37c2a6.html# devf0a9d5aca), and the resulting set is built. This allows individual targets to opt out of building for particular architectures. If the resulting set of architectures is empty, no executable will be produced.
    public static func validArchitectures(_ value: String...) -> BuildSetting { 
        .validArchitectures(value)
    }
}

extension BuildSettingsKey {

    /// Valid Architectures
    ///
    /// A space-separated list of architectures for which the target should actually be built. For each target, this is intersected with the list specified in [Architectures (ARCHS)](itcaec37c2a6.html# devf0a9d5aca), and the resulting set is built. This allows individual targets to opt out of building for particular architectures. If the resulting set of architectures is empty, no executable will be produced.
    public static let validArchitectures: BuildSettingsKey = "VALID_ARCHS"
}

// MARK: Versioning System
extension BuildSetting {

    /// Versioning System
    ///
    /// Selects the process used for version-stamping generated files.
    public static func versioningSystem(_ value: VersioningSystem) -> BuildSetting { 
        BuildSetting(key: .versioningSystem, value: \(value))
    }

    /// Versioning System
    ///
    /// Selects the process used for version-stamping generated files.
    public static func versioningSystem(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningSystem, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versioning System
    ///
    /// Selects the process used for version-stamping generated files.
    public static let versioningSystem: BuildSettingsKey = "VERSIONING_SYSTEM"
}

public enum VersioningSystem: String, Hashable, Codable, CustomStringConvertible {
    case appleGeneric = "apple-generic"

    public var description: String {
        rawValue
    }
}

// MARK: Versions Folder Path
extension BuildSetting {

    /// Versions Folder Path
    public static func versionsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versionsFolderPath, value: \(value))
    }

    /// Versions Folder Path
    public static func versionsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versionsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versions Folder Path
    public static let versionsFolderPath: BuildSettingsKey = "VERSIONS_FOLDER_PATH"
}

// MARK: Versioning Username
extension BuildSetting {

    /// Versioning Username
    ///
    /// This defines a reference to the user performing a build to be included in the generated Apple Generic Versioning stub. Defaults to the value of the `USER` environment variable.
    public static var versioningUsername: BuildSetting { 
        .versioningUsername(inherit: .user) 
    }

    /// Versioning Username
    ///
    /// This defines a reference to the user performing a build to be included in the generated Apple Generic Versioning stub. Defaults to the value of the `USER` environment variable.
    public static func versioningUsername(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versioningUsername, value: \(value))
    }

    /// Versioning Username
    ///
    /// This defines a reference to the user performing a build to be included in the generated Apple Generic Versioning stub. Defaults to the value of the `USER` environment variable.
    public static func versioningUsername(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningUsername, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versioning Username
    ///
    /// This defines a reference to the user performing a build to be included in the generated Apple Generic Versioning stub. Defaults to the value of the `USER` environment variable.
    public static let versioningUsername: BuildSettingsKey = "VERSION_INFO_BUILDER"
}

// MARK: Generated Versioning Variables
extension BuildSetting {

    /// Generated Versioning Variables
    ///
    /// This defines a prefix string for the version info symbol declaration in the generated Apple Generic Versioning stub. This can be used, for example, to add an optional `export` keyword to the version symbol declaration. This should rarely be changed.
    public static func generatedVersioningVariables(_ value: String) -> BuildSetting { 
        BuildSetting(key: .generatedVersioningVariables, value: \(value))
    }

    /// Generated Versioning Variables
    ///
    /// This defines a prefix string for the version info symbol declaration in the generated Apple Generic Versioning stub. This can be used, for example, to add an optional `export` keyword to the version symbol declaration. This should rarely be changed.
    public static func generatedVersioningVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatedVersioningVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generated Versioning Variables
    ///
    /// This defines a prefix string for the version info symbol declaration in the generated Apple Generic Versioning stub. This can be used, for example, to add an optional `export` keyword to the version symbol declaration. This should rarely be changed.
    public static let generatedVersioningVariables: BuildSettingsKey = "VERSION_INFO_EXPORT_DECL"
}

// MARK: Generated Versioning Source Filename
extension BuildSetting {

    /// Generated Versioning Source Filename
    ///
    /// Used to specify a name for the source file that will be generated by Apple Generic Versioning and compiled into your product. By default, this is set to `$(PRODUCT_NAME)_vers.c`.
    public static var generatedVersioningSourceFilename: BuildSetting { 
        BuildSetting(key: .generatedVersioningSourceFilename, value: "$(PRODUCT_NAME)_vers.c")
    }

    /// Generated Versioning Source Filename
    ///
    /// Used to specify a name for the source file that will be generated by Apple Generic Versioning and compiled into your product. By default, this is set to `$(PRODUCT_NAME)_vers.c`.
    public static func generatedVersioningSourceFilename(_ value: String) -> BuildSetting { 
        BuildSetting(key: .generatedVersioningSourceFilename, value: \(value))
    }

    /// Generated Versioning Source Filename
    ///
    /// Used to specify a name for the source file that will be generated by Apple Generic Versioning and compiled into your product. By default, this is set to `$(PRODUCT_NAME)_vers.c`.
    public static func generatedVersioningSourceFilename(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatedVersioningSourceFilename, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generated Versioning Source Filename
    ///
    /// Used to specify a name for the source file that will be generated by Apple Generic Versioning and compiled into your product. By default, this is set to `$(PRODUCT_NAME)_vers.c`.
    public static let generatedVersioningSourceFilename: BuildSettingsKey = "VERSION_INFO_FILE"
}

// MARK: Versioning Name Prefix
extension BuildSetting {

    /// Versioning Name Prefix
    ///
    /// Used as a prefix for the name of the version info symbol in the generated versioning source file. If you prefix your exported symbols you will probably want to set this to the same prefix.
    public static func versioningNamePrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versioningNamePrefix, value: \(value))
    }

    /// Versioning Name Prefix
    ///
    /// Used as a prefix for the name of the version info symbol in the generated versioning source file. If you prefix your exported symbols you will probably want to set this to the same prefix.
    public static func versioningNamePrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningNamePrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versioning Name Prefix
    ///
    /// Used as a prefix for the name of the version info symbol in the generated versioning source file. If you prefix your exported symbols you will probably want to set this to the same prefix.
    public static let versioningNamePrefix: BuildSettingsKey = "VERSION_INFO_PREFIX"
}

// MARK: Versioning Name Suffix
extension BuildSetting {

    /// Versioning Name Suffix
    ///
    /// Used as a suffix for the name of the version info symbol in the generated versioning source file. This is rarely used.
    public static func versioningNameSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versioningNameSuffix, value: \(value))
    }

    /// Versioning Name Suffix
    ///
    /// Used as a suffix for the name of the version info symbol in the generated versioning source file. This is rarely used.
    public static func versioningNameSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningNameSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versioning Name Suffix
    ///
    /// Used as a suffix for the name of the version info symbol in the generated versioning source file. This is rarely used.
    public static let versioningNameSuffix: BuildSettingsKey = "VERSION_INFO_SUFFIX"
}

// MARK: Warning Linker Flags
extension BuildSetting {

    /// Warning Linker Flags
    ///
    /// These flags are passed with linker invocations, and by default give the `-no_arch_warnings` flag to the linker to avoid many warnings being generated during multi-architecture builds.
    public static func warningLinkerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .warningLinkerFlags, value: .array(value))
    }

    /// Warning Linker Flags
    ///
    /// These flags are passed with linker invocations, and by default give the `-no_arch_warnings` flag to the linker to avoid many warnings being generated during multi-architecture builds.
    public static func warningLinkerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .warningLinkerFlags, inherit: key)
    }

    /// Warning Linker Flags
    ///
    /// These flags are passed with linker invocations, and by default give the `-no_arch_warnings` flag to the linker to avoid many warnings being generated during multi-architecture builds.
    public static func warningLinkerFlags(_ value: String...) -> BuildSetting { 
        .warningLinkerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Warning Linker Flags
    ///
    /// These flags are passed with linker invocations, and by default give the `-no_arch_warnings` flag to the linker to avoid many warnings being generated during multi-architecture builds.
    public static let warningLinkerFlags: BuildSettingsKey = "WARNING_LDFLAGS"
}

// MARK: Wrapper Extension
extension BuildSetting {

    /// Wrapper Extension
    ///
    /// The extension used for product wrappers, which has a default value based on the product type.
    public static func wrapperExtension(_ value: String) -> BuildSetting { 
        BuildSetting(key: .wrapperExtension, value: \(value))
    }

    /// Wrapper Extension
    ///
    /// The extension used for product wrappers, which has a default value based on the product type.
    public static func wrapperExtension(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapperExtension, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Wrapper Extension
    ///
    /// The extension used for product wrappers, which has a default value based on the product type.
    public static let wrapperExtension: BuildSettingsKey = "WRAPPER_EXTENSION"
}

// MARK: Wrap Asset Packs In Separate Directories
extension BuildSetting {

    /// Wrap Asset Packs In Separate Directories
    public static var wrapAssetPacksInSeparateDirectories: BuildSetting { 
        BuildSetting(key: .wrapAssetPacksInSeparateDirectories, value: "NO")
    }

    /// Wrap Asset Packs In Separate Directories
    public static func wrapAssetPacksInSeparateDirectories(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .wrapAssetPacksInSeparateDirectories, value: value.asText)
    }

    /// Wrap Asset Packs In Separate Directories
    public static func wrapAssetPacksInSeparateDirectories(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapAssetPacksInSeparateDirectories, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Wrap Asset Packs In Separate Directories
    public static let wrapAssetPacksInSeparateDirectories: BuildSettingsKey = "WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES"
}

// MARK: Xcode Developer Dir Path
extension BuildSetting {

    /// Xcode Developer Dir Path
    public static func xcodeDeveloperDirPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .xcodeDeveloperDirPath, value: \(value))
    }

    /// Xcode Developer Dir Path
    public static func xcodeDeveloperDirPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .xcodeDeveloperDirPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Xcode Developer Dir Path
    public static let xcodeDeveloperDirPath: BuildSettingsKey = "XCODE_DEVELOPER_DIR_PATH"
}

// MARK: Always Use Separate Headermaps
extension BuildSetting {

    /// Always Use Separate Headermaps
    public static var alwaysUseSeparateHeadermaps: BuildSetting { 
        BuildSetting(key: .alwaysUseSeparateHeadermaps, value: "NO")
    }

    /// Always Use Separate Headermaps
    public static func alwaysUseSeparateHeadermaps(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .alwaysUseSeparateHeadermaps, value: value.asText)
    }

    /// Always Use Separate Headermaps
    public static func alwaysUseSeparateHeadermaps(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alwaysUseSeparateHeadermaps, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Always Use Separate Headermaps
    public static let alwaysUseSeparateHeadermaps: BuildSettingsKey = "ALWAYS_USE_SEPARATE_HEADERMAPS"
}

// MARK: Cchroot
extension BuildSetting {

    /// Cchroot
    public static var cchroot: BuildSetting { 
        BuildSetting(key: .cchroot, value: "$(CACHE_ROOT)")
    }

    /// Cchroot
    public static func cchroot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cchroot, value: \(value))
    }

    /// Cchroot
    public static func cchroot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cchroot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cchroot
    public static let cchroot: BuildSettingsKey = "CCHROOT"
}

// MARK: Chmod
extension BuildSetting {

    /// Chmod
    public static var chmod: BuildSetting { 
        BuildSetting(key: .chmod, value: "/bin/chmod")
    }

    /// Chmod
    public static func chmod(_ value: String) -> BuildSetting { 
        BuildSetting(key: .chmod, value: \(value))
    }

    /// Chmod
    public static func chmod(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .chmod, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Chmod
    public static let chmod: BuildSettingsKey = "CHMOD"
}

// MARK: Chown
extension BuildSetting {

    /// Chown
    public static var chown: BuildSetting { 
        BuildSetting(key: .chown, value: "/usr/sbin/chown")
    }

    /// Chown
    public static func chown(_ value: String) -> BuildSetting { 
        BuildSetting(key: .chown, value: \(value))
    }

    /// Chown
    public static func chown(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .chown, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Chown
    public static let chown: BuildSettingsKey = "CHOWN"
}

// MARK: Clean Precomps
extension BuildSetting {

    /// Clean Precomps
    public static var cleanPrecomps: BuildSetting { 
        BuildSetting(key: .cleanPrecomps, value: "YES")
    }

    /// Clean Precomps
    public static func cleanPrecomps(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .cleanPrecomps, value: value.asText)
    }

    /// Clean Precomps
    public static func cleanPrecomps(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cleanPrecomps, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clean Precomps
    public static let cleanPrecomps: BuildSettingsKey = "CLEAN_PRECOMPS"
}

// MARK: Codesigning Folder Path
extension BuildSetting {

    /// Codesigning Folder Path
    public static var codesigningFolderPath: BuildSetting { 
        BuildSetting(key: .codesigningFolderPath, value: "$(TARGET_BUILD_DIR)/$(FULL_PRODUCT_NAME)")
    }

    /// Codesigning Folder Path
    public static func codesigningFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .codesigningFolderPath, value: \(value))
    }

    /// Codesigning Folder Path
    public static func codesigningFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codesigningFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Codesigning Folder Path
    public static let codesigningFolderPath: BuildSettingsKey = "CODESIGNING_FOLDER_PATH"
}

// MARK: Combine Hidpi Images
extension BuildSetting {

    /// Combine Hidpi Images
    public static var combineHidpiImages: BuildSetting { 
        BuildSetting(key: .combineHidpiImages, value: "NO")
    }

    /// Combine Hidpi Images
    public static func combineHidpiImages(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .combineHidpiImages, value: value.asText)
    }

    /// Combine Hidpi Images
    public static func combineHidpiImages(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .combineHidpiImages, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Combine Hidpi Images
    public static let combineHidpiImages: BuildSettingsKey = "COMBINE_HIDPI_IMAGES"
}

// MARK: Composite Sdk Dirs
extension BuildSetting {

    /// Composite Sdk Dirs
    public static var compositeSdkDirs: BuildSetting { 
        BuildSetting(key: .compositeSdkDirs, value: "$(OBJROOT)/CompositeSDKs")
    }

    /// Composite Sdk Dirs
    public static func compositeSdkDirs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .compositeSdkDirs, value: .array(value))
    }

    /// Composite Sdk Dirs
    public static func compositeSdkDirs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compositeSdkDirs, inherit: key)
    }

    /// Composite Sdk Dirs
    public static func compositeSdkDirs(_ value: String...) -> BuildSetting { 
        .compositeSdkDirs(value)
    }
}

extension BuildSettingsKey {

    /// Composite Sdk Dirs
    public static let compositeSdkDirs: BuildSettingsKey = "COMPOSITE_SDK_DIRS"
}

// MARK: Contents Folder Path
extension BuildSetting {

    /// Contents Folder Path
    ///
    /// Specifies the directory inside the generated bundle that contains the product’s files.
    public static func contentsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .contentsFolderPath, value: \(value))
    }

    /// Contents Folder Path
    ///
    /// Specifies the directory inside the generated bundle that contains the product’s files.
    public static func contentsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .contentsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Contents Folder Path
    ///
    /// Specifies the directory inside the generated bundle that contains the product’s files.
    public static let contentsFolderPath: BuildSettingsKey = "CONTENTS_FOLDER_PATH"
}

// MARK: Copy Resources From Static Frameworks
extension BuildSetting {

    /// Copy Resources From Static Frameworks
    public static var copyResourcesFromStaticFrameworks: BuildSetting { 
        BuildSetting(key: .copyResourcesFromStaticFrameworks, value: "YES")
    }

    /// Copy Resources From Static Frameworks
    public static func copyResourcesFromStaticFrameworks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .copyResourcesFromStaticFrameworks, value: value.asText)
    }

    /// Copy Resources From Static Frameworks
    public static func copyResourcesFromStaticFrameworks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .copyResourcesFromStaticFrameworks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Copy Resources From Static Frameworks
    public static let copyResourcesFromStaticFrameworks: BuildSettingsKey = "COPY_RESOURCES_FROM_STATIC_FRAMEWORKS"
}

// MARK: Cp
extension BuildSetting {

    /// Cp
    public static var cp: BuildSetting { 
        BuildSetting(key: .cp, value: "/bin/cp")
    }

    /// Cp
    public static func cp(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cp, value: \(value))
    }

    /// Cp
    public static func cp(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cp, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cp
    public static let cp: BuildSettingsKey = "CP"
}

// MARK: Current Arch
extension BuildSetting {

    /// Current Arch
    ///
    /// The name of the active architecture being processed.
    public static var currentArch: BuildSetting { 
        BuildSetting(key: .currentArch, value: "$(arch)")
    }

    /// Current Arch
    ///
    /// The name of the active architecture being processed.
    public static func currentArch(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentArch, value: \(value))
    }

    /// Current Arch
    ///
    /// The name of the active architecture being processed.
    public static func currentArch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentArch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Current Arch
    ///
    /// The name of the active architecture being processed.
    public static let currentArch: BuildSettingsKey = "CURRENT_ARCH"
}

// MARK: Current Variant
extension BuildSetting {

    /// Current Variant
    ///
    /// The name of the active variant being processed.
    public static var currentVariant: BuildSetting { 
        BuildSetting(key: .currentVariant, value: "$(variant)")
    }

    /// Current Variant
    ///
    /// The name of the active variant being processed.
    public static func currentVariant(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentVariant, value: \(value))
    }

    /// Current Variant
    ///
    /// The name of the active variant being processed.
    public static func currentVariant(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentVariant, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Current Variant
    ///
    /// The name of the active variant being processed.
    public static let currentVariant: BuildSettingsKey = "CURRENT_VARIANT"
}

// MARK: Derived Files Dir
extension BuildSetting {

    /// Derived Files Dir
    public static var derivedFilesDir: BuildSetting { 
        .derivedFilesDir(inherit: .derivedFileDir) 
    }

    /// Derived Files Dir
    public static func derivedFilesDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .derivedFilesDir, value: \(value))
    }

    /// Derived Files Dir
    public static func derivedFilesDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .derivedFilesDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Derived Files Dir
    public static let derivedFilesDir: BuildSettingsKey = "DERIVED_FILES_DIR"
}

// MARK: Derived Paths
extension BuildSetting {

    /// Derived Paths
    public static func derivedPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .derivedPaths, value: .array(value))
    }

    /// Derived Paths
    public static func derivedPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .derivedPaths, inherit: key)
    }

    /// Derived Paths
    public static func derivedPaths(_ value: String...) -> BuildSetting { 
        .derivedPaths(value)
    }
}

extension BuildSettingsKey {

    /// Derived Paths
    public static let derivedPaths: BuildSettingsKey = "DERIVED_PATHS"
}

// MARK: Documentation Folder Path
extension BuildSetting {

    /// Documentation Folder Path
    ///
    /// Identifies the directory that contains the bundle’s documentation files.
    public static func documentationFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .documentationFolderPath, value: \(value))
    }

    /// Documentation Folder Path
    ///
    /// Identifies the directory that contains the bundle’s documentation files.
    public static func documentationFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .documentationFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Documentation Folder Path
    ///
    /// Identifies the directory that contains the bundle’s documentation files.
    public static let documentationFolderPath: BuildSettingsKey = "DOCUMENTATION_FOLDER_PATH"
}

// MARK: Executables Folder Path
extension BuildSetting {

    /// Executables Folder Path
    ///
    /// Identifies the directory that contains additional binary files.
    public static func executablesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executablesFolderPath, value: \(value))
    }

    /// Executables Folder Path
    ///
    /// Identifies the directory that contains additional binary files.
    public static func executablesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executablesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executables Folder Path
    ///
    /// Identifies the directory that contains additional binary files.
    public static let executablesFolderPath: BuildSettingsKey = "EXECUTABLES_FOLDER_PATH"
}

// MARK: Executable Folder Path
extension BuildSetting {

    /// Executable Folder Path
    ///
    /// Identifies the directory that contains the binary the target builds.
    public static func executableFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableFolderPath, value: \(value))
    }

    /// Executable Folder Path
    ///
    /// Identifies the directory that contains the binary the target builds.
    public static func executableFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executable Folder Path
    ///
    /// Identifies the directory that contains the binary the target builds.
    public static let executableFolderPath: BuildSettingsKey = "EXECUTABLE_FOLDER_PATH"
}

// MARK: Executable Name
extension BuildSetting {

    /// Executable Name
    ///
    /// Specifies the name of the binary the target produces.
    public static func executableName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableName, value: \(value))
    }

    /// Executable Name
    ///
    /// Specifies the name of the binary the target produces.
    public static func executableName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executable Name
    ///
    /// Specifies the name of the binary the target produces.
    public static let executableName: BuildSettingsKey = "EXECUTABLE_NAME"
}

// MARK: Executable Path
extension BuildSetting {

    /// Executable Path
    ///
    /// Specifies the path to the binary the target produces within its bundle.
    public static func executablePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executablePath, value: \(value))
    }

    /// Executable Path
    ///
    /// Specifies the path to the binary the target produces within its bundle.
    public static func executablePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executablePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executable Path
    ///
    /// Specifies the path to the binary the target produces within its bundle.
    public static let executablePath: BuildSettingsKey = "EXECUTABLE_PATH"
}

// MARK: Executable Suffix
extension BuildSetting {

    /// Executable Suffix
    ///
    /// Specifies the suffix of the binary filename, including the character that separates the extension from the rest of the bundle name.
    public static func executableSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableSuffix, value: \(value))
    }

    /// Executable Suffix
    ///
    /// Specifies the suffix of the binary filename, including the character that separates the extension from the rest of the bundle name.
    public static func executableSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executable Suffix
    ///
    /// Specifies the suffix of the binary filename, including the character that separates the extension from the rest of the bundle name.
    public static let executableSuffix: BuildSettingsKey = "EXECUTABLE_SUFFIX"
}

// MARK: Executable Variant Suffix
extension BuildSetting {

    /// Executable Variant Suffix
    public static func executableVariantSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableVariantSuffix, value: \(value))
    }

    /// Executable Variant Suffix
    public static func executableVariantSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableVariantSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executable Variant Suffix
    public static let executableVariantSuffix: BuildSettingsKey = "EXECUTABLE_VARIANT_SUFFIX"
}

// MARK: Fixed Files Dir
extension BuildSetting {

    /// Fixed Files Dir
    public static var fixedFilesDir: BuildSetting { 
        BuildSetting(key: .fixedFilesDir, value: "$(TARGET_TEMP_DIR)/FixedFiles")
    }

    /// Fixed Files Dir
    public static func fixedFilesDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .fixedFilesDir, value: \(value))
    }

    /// Fixed Files Dir
    public static func fixedFilesDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fixedFilesDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Fixed Files Dir
    public static let fixedFilesDir: BuildSettingsKey = "FIXED_FILES_DIR"
}

// MARK: Frameworks Folder Path
extension BuildSetting {

    /// Frameworks Folder Path
    ///
    /// Specifies the directory that contains the product’s embedded frameworks.
    public static func frameworksFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .frameworksFolderPath, value: \(value))
    }

    /// Frameworks Folder Path
    ///
    /// Specifies the directory that contains the product’s embedded frameworks.
    public static func frameworksFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .frameworksFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Frameworks Folder Path
    ///
    /// Specifies the directory that contains the product’s embedded frameworks.
    public static let frameworksFolderPath: BuildSettingsKey = "FRAMEWORKS_FOLDER_PATH"
}

// MARK: Gcc Pfe File C Dialects
extension BuildSetting {

    /// Gcc Pfe File C Dialects
    public static var gccPfeFileCDialects: BuildSetting { 
        BuildSetting(key: .gccPfeFileCDialects, value: "c objective-c c++ objective-c++")
    }

    /// Gcc Pfe File C Dialects
    public static func gccPfeFileCDialects(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .gccPfeFileCDialects, value: .array(value))
    }

    /// Gcc Pfe File C Dialects
    public static func gccPfeFileCDialects(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccPfeFileCDialects, inherit: key)
    }

    /// Gcc Pfe File C Dialects
    public static func gccPfeFileCDialects(_ value: String...) -> BuildSetting { 
        .gccPfeFileCDialects(value)
    }
}

extension BuildSettingsKey {

    /// Gcc Pfe File C Dialects
    public static let gccPfeFileCDialects: BuildSettingsKey = "GCC_PFE_FILE_C_DIALECTS"
}

// MARK: GCC Precompile Prefix Header
extension BuildSetting {

    /// GCC Precompile Prefix Header
    ///
    /// Generates a precompiled header for the prefix header, which should reduce overall build times. Precompiling the prefix header will be most effective if the contents of the prefix header or any file it includes change rarely. If the contents of the prefix header or any file it includes change frequently, there may be a negative impact to overall build time.
    public static var gccPrecompilePrefixHeader: BuildSetting { 
        .gccPrecompilePrefixHeader(inherit: .precompilePrefixHeader) 
    }

    /// GCC Precompile Prefix Header
    ///
    /// Generates a precompiled header for the prefix header, which should reduce overall build times. Precompiling the prefix header will be most effective if the contents of the prefix header or any file it includes change rarely. If the contents of the prefix header or any file it includes change frequently, there may be a negative impact to overall build time.
    public static func gccPrecompilePrefixHeader(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .gccPrecompilePrefixHeader, value: value.asText)
    }

    /// GCC Precompile Prefix Header
    ///
    /// Generates a precompiled header for the prefix header, which should reduce overall build times. Precompiling the prefix header will be most effective if the contents of the prefix header or any file it includes change rarely. If the contents of the prefix header or any file it includes change frequently, there may be a negative impact to overall build time.
    public static func gccPrecompilePrefixHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccPrecompilePrefixHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC Precompile Prefix Header
    ///
    /// Generates a precompiled header for the prefix header, which should reduce overall build times. Precompiling the prefix header will be most effective if the contents of the prefix header or any file it includes change rarely. If the contents of the prefix header or any file it includes change frequently, there may be a negative impact to overall build time.
    public static let gccPrecompilePrefixHeader: BuildSettingsKey = "GCC_PRECOMPILE_PREFIX_HEADER"
}

// MARK: GCC Prefix Header
extension BuildSetting {

    /// GCC Prefix Header
    ///
    /// Implicitly include the named header. The path given should either be a project relative path or an absolute path.
    public static var gccPrefixHeader: BuildSetting { 
        .gccPrefixHeader(inherit: .prefixHeader) 
    }

    /// GCC Prefix Header
    ///
    /// Implicitly include the named header. The path given should either be a project relative path or an absolute path.
    public static func gccPrefixHeader(_ value: String) -> BuildSetting { 
        BuildSetting(key: .gccPrefixHeader, value: \(value))
    }

    /// GCC Prefix Header
    ///
    /// Implicitly include the named header. The path given should either be a project relative path or an absolute path.
    public static func gccPrefixHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccPrefixHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC Prefix Header
    ///
    /// Implicitly include the named header. The path given should either be a project relative path or an absolute path.
    public static let gccPrefixHeader: BuildSettingsKey = "GCC_PREFIX_HEADER"
}

// MARK: Treat Warnings as Errors
extension BuildSetting {

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors.
    public static var treatWarningsAsErrors: BuildSetting { 
        BuildSetting(key: .treatWarningsAsErrors, value: "NO")
    }

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors.
    public static func treatWarningsAsErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatWarningsAsErrors, value: value.asText)
    }

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors.
    public static func treatWarningsAsErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatWarningsAsErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors.
    public static let treatWarningsAsErrors: BuildSettingsKey = "GCC_TREAT_WARNINGS_AS_ERRORS"
}

// MARK: Gcc Version Identifier
extension BuildSetting {

    /// Gcc Version Identifier
    public static var gccVersionIdentifier: BuildSetting { 
        BuildSetting(key: .gccVersionIdentifier, value: "$(GCC_VERSION:identifier)")
    }

    /// Gcc Version Identifier
    public static func gccVersionIdentifier(_ value: String) -> BuildSetting { 
        BuildSetting(key: .gccVersionIdentifier, value: \(value))
    }

    /// Gcc Version Identifier
    public static func gccVersionIdentifier(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccVersionIdentifier, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Gcc Version Identifier
    public static let gccVersionIdentifier: BuildSettingsKey = "GCC_VERSION_IDENTIFIER"
}

// MARK: Global Cflags
extension BuildSetting {

    /// Global Cflags
    public static func globalCflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .globalCflags, value: .array(value))
    }

    /// Global Cflags
    public static func globalCflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .globalCflags, inherit: key)
    }

    /// Global Cflags
    public static func globalCflags(_ value: String...) -> BuildSetting { 
        .globalCflags(value)
    }
}

extension BuildSettingsKey {

    /// Global Cflags
    public static let globalCflags: BuildSettingsKey = "GLOBAL_CFLAGS"
}

// MARK: Iconv
extension BuildSetting {

    /// Iconv
    public static var iconv: BuildSetting { 
        BuildSetting(key: .iconv, value: "/usr/bin/iconv")
    }

    /// Iconv
    public static func iconv(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iconv, value: \(value))
    }

    /// Iconv
    public static func iconv(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iconv, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Iconv
    public static let iconv: BuildSettingsKey = "ICONV"
}

// MARK: Infoplist Path
extension BuildSetting {

    /// Infoplist Path
    ///
    /// Specifies the path to the bundle’s information property list file.
    public static func infoplistPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .infoplistPath, value: \(value))
    }

    /// Infoplist Path
    ///
    /// Specifies the path to the bundle’s information property list file.
    public static func infoplistPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoplistPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infoplist Path
    ///
    /// Specifies the path to the bundle’s information property list file.
    public static let infoplistPath: BuildSettingsKey = "INFOPLIST_PATH"
}

// MARK: Infostrings Path
extension BuildSetting {

    /// Infostrings Path
    ///
    /// Specifies the file that contains the bundle’s localized strings file.
    public static func infostringsPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .infostringsPath, value: \(value))
    }

    /// Infostrings Path
    ///
    /// Specifies the file that contains the bundle’s localized strings file.
    public static func infostringsPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infostringsPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infostrings Path
    ///
    /// Specifies the file that contains the bundle’s localized strings file.
    public static let infostringsPath: BuildSettingsKey = "INFOSTRINGS_PATH"
}

// MARK: Javac Default Flags
extension BuildSetting {

    /// Javac Default Flags
    public static var javacDefaultFlags: BuildSetting { 
        BuildSetting(key: .javacDefaultFlags, value: "-J-Xms64m -J-XX:NewSize=4M -J-Dfile.encoding=UTF8")
    }

    /// Javac Default Flags
    public static func javacDefaultFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javacDefaultFlags, value: .array(value))
    }

    /// Javac Default Flags
    public static func javacDefaultFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javacDefaultFlags, inherit: key)
    }

    /// Javac Default Flags
    public static func javacDefaultFlags(_ value: String...) -> BuildSetting { 
        .javacDefaultFlags(value)
    }
}

extension BuildSettingsKey {

    /// Javac Default Flags
    public static let javacDefaultFlags: BuildSettingsKey = "JAVAC_DEFAULT_FLAGS"
}

// MARK: Java Folder Path
extension BuildSetting {

    /// Java Folder Path
    public static func javaFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaFolderPath, value: \(value))
    }

    /// Java Folder Path
    public static func javaFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Java Folder Path
    public static let javaFolderPath: BuildSettingsKey = "JAVA_FOLDER_PATH"
}

// MARK: Jikes Default Flags
extension BuildSetting {

    /// Jikes Default Flags
    public static var jikesDefaultFlags: BuildSetting { 
        BuildSetting(key: .jikesDefaultFlags, value: "+E +OLDCSO")
    }

    /// Jikes Default Flags
    public static func jikesDefaultFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .jikesDefaultFlags, value: .array(value))
    }

    /// Jikes Default Flags
    public static func jikesDefaultFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .jikesDefaultFlags, inherit: key)
    }

    /// Jikes Default Flags
    public static func jikesDefaultFlags(_ value: String...) -> BuildSetting { 
        .jikesDefaultFlags(value)
    }
}

extension BuildSettingsKey {

    /// Jikes Default Flags
    public static let jikesDefaultFlags: BuildSettingsKey = "JIKES_DEFAULT_FLAGS"
}

// MARK: Ld Flags
extension BuildSetting {

    /// Ld Flags
    public static func ldFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ldFlags, value: .array(value))
    }

    /// Ld Flags
    public static func ldFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldFlags, inherit: key)
    }

    /// Ld Flags
    public static func ldFlags(_ value: String...) -> BuildSetting { 
        .ldFlags(value)
    }
}

extension BuildSettingsKey {

    /// Ld Flags
    public static let ldFlags: BuildSettingsKey = "LD_FLAGS"
}

// MARK: Lex
extension BuildSetting {

    /// Lex
    public static var lex: BuildSetting { 
        BuildSetting(key: .lex, value: "lex")
    }

    /// Lex
    public static func lex(_ value: String) -> BuildSetting { 
        BuildSetting(key: .lex, value: \(value))
    }

    /// Lex
    public static func lex(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .lex, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Lex
    public static let lex: BuildSettingsKey = "LEX"
}

// MARK: Other Lex Flags
extension BuildSetting {

    /// Other Lex Flags
    ///
    /// Space-separated list of additional flags to pass to `lex`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `lex` flag.
    public static func otherLexFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherLexFlags, value: .array(value))
    }

    /// Other Lex Flags
    ///
    /// Space-separated list of additional flags to pass to `lex`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `lex` flag.
    public static func otherLexFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherLexFlags, inherit: key)
    }

    /// Other Lex Flags
    ///
    /// Space-separated list of additional flags to pass to `lex`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `lex` flag.
    public static func otherLexFlags(_ value: String...) -> BuildSetting { 
        .otherLexFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Lex Flags
    ///
    /// Space-separated list of additional flags to pass to `lex`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `lex` flag.
    public static let otherLexFlags: BuildSettingsKey = "LEXFLAGS"
}

// MARK: Linker Library Flags
extension BuildSetting {

    /// Linker Library Flags
    public static func linkerLibraryFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .linkerLibraryFlags, value: .array(value))
    }

    /// Linker Library Flags
    public static func linkerLibraryFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkerLibraryFlags, inherit: key)
    }

    /// Linker Library Flags
    public static func linkerLibraryFlags(_ value: String...) -> BuildSetting { 
        .linkerLibraryFlags(value)
    }
}

extension BuildSettingsKey {

    /// Linker Library Flags
    public static let linkerLibraryFlags: BuildSettingsKey = "LINKER_LIBRARY_FLAGS"
}

// MARK: Localized Resources Folder Path
extension BuildSetting {

    /// Localized Resources Folder Path
    public static func localizedResourcesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .localizedResourcesFolderPath, value: \(value))
    }

    /// Localized Resources Folder Path
    public static func localizedResourcesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .localizedResourcesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Localized Resources Folder Path
    public static let localizedResourcesFolderPath: BuildSettingsKey = "LOCALIZED_RESOURCES_FOLDER_PATH"
}

// MARK: Macos Creator
extension BuildSetting {

    /// Macos Creator
    public static func macosCreator(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macosCreator, value: \(value))
    }

    /// Macos Creator
    public static func macosCreator(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macosCreator, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Macos Creator
    public static let macosCreator: BuildSettingsKey = "MACOS_CREATOR"
}

// MARK: Macos Creator Arg
extension BuildSetting {

    /// Macos Creator Arg
    public static func macosCreatorArg(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macosCreatorArg, value: \(value))
    }

    /// Macos Creator Arg
    public static func macosCreatorArg(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macosCreatorArg, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Macos Creator Arg
    public static let macosCreatorArg: BuildSettingsKey = "MACOS_CREATOR_ARG"
}

// MARK: Macos Type
extension BuildSetting {

    /// Macos Type
    public static func macosType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macosType, value: \(value))
    }

    /// Macos Type
    public static func macosType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macosType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Macos Type
    public static let macosType: BuildSettingsKey = "MACOS_TYPE"
}

// MARK: Macos Type Arg
extension BuildSetting {

    /// Macos Type Arg
    public static func macosTypeArg(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macosTypeArg, value: \(value))
    }

    /// Macos Type Arg
    public static func macosTypeArg(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macosTypeArg, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Macos Type Arg
    public static let macosTypeArg: BuildSettingsKey = "MACOS_TYPE_ARG"
}

// MARK: Modules Folder Path
extension BuildSetting {

    /// Modules Folder Path
    ///
    /// Specifies the directory that contains the product’s Clang module maps and Swift module content.
    public static func modulesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .modulesFolderPath, value: \(value))
    }

    /// Modules Folder Path
    ///
    /// Specifies the directory that contains the product’s Clang module maps and Swift module content.
    public static func modulesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .modulesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Modules Folder Path
    ///
    /// Specifies the directory that contains the product’s Clang module maps and Swift module content.
    public static let modulesFolderPath: BuildSettingsKey = "MODULES_FOLDER_PATH"
}

// MARK: No Common
extension BuildSetting {

    /// No Common
    public static var noCommon: BuildSetting { 
        BuildSetting(key: .noCommon, value: "YES")
    }

    /// No Common
    public static func noCommon(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .noCommon, value: value.asText)
    }

    /// No Common
    public static func noCommon(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .noCommon, inherit: key)
    }
}

extension BuildSettingsKey {

    /// No Common
    public static let noCommon: BuildSettingsKey = "NO_COMMON"
}

// MARK: Optimization Cflags
extension BuildSetting {

    /// Optimization Cflags
    public static func optimizationCflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .optimizationCflags, value: .array(value))
    }

    /// Optimization Cflags
    public static func optimizationCflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimizationCflags, inherit: key)
    }

    /// Optimization Cflags
    public static func optimizationCflags(_ value: String...) -> BuildSetting { 
        .optimizationCflags(value)
    }
}

extension BuildSettingsKey {

    /// Optimization Cflags
    public static let optimizationCflags: BuildSettingsKey = "OPTIMIZATION_CFLAGS"
}

// MARK: Osac
extension BuildSetting {

    /// Osac
    public static var osac: BuildSetting { 
        BuildSetting(key: .osac, value: "/usr/bin/osacompile")
    }

    /// Osac
    public static func osac(_ value: String) -> BuildSetting { 
        BuildSetting(key: .osac, value: \(value))
    }

    /// Osac
    public static func osac(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .osac, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Osac
    public static let osac: BuildSettingsKey = "OSAC"
}

// MARK: Other MiG Flags
extension BuildSetting {

    /// Other MiG Flags
    ///
    /// Space-separated list of additional flags to pass to `mig`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `mig` flag.
    public static func otherMigFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherMigFlags, value: .array(value))
    }

    /// Other MiG Flags
    ///
    /// Space-separated list of additional flags to pass to `mig`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `mig` flag.
    public static func otherMigFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherMigFlags, inherit: key)
    }

    /// Other MiG Flags
    ///
    /// Space-separated list of additional flags to pass to `mig`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `mig` flag.
    public static func otherMigFlags(_ value: String...) -> BuildSetting { 
        .otherMigFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other MiG Flags
    ///
    /// Space-separated list of additional flags to pass to `mig`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `mig` flag.
    public static let otherMigFlags: BuildSettingsKey = "OTHER_MIGFLAGS"
}

// MARK: Other Osaflags
extension BuildSetting {

    /// Other Osaflags
    public static func otherOsaflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherOsaflags, value: .array(value))
    }

    /// Other Osaflags
    public static func otherOsaflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherOsaflags, inherit: key)
    }

    /// Other Osaflags
    public static func otherOsaflags(_ value: String...) -> BuildSetting { 
        .otherOsaflags(value)
    }
}

extension BuildSettingsKey {

    /// Other Osaflags
    public static let otherOsaflags: BuildSettingsKey = "OTHER_OSAFLAGS"
}

// MARK: Other Precomp Cflags
extension BuildSetting {

    /// Other Precomp Cflags
    public static func otherPrecompCflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherPrecompCflags, value: .array(value))
    }

    /// Other Precomp Cflags
    public static func otherPrecompCflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherPrecompCflags, inherit: key)
    }

    /// Other Precomp Cflags
    public static func otherPrecompCflags(_ value: String...) -> BuildSetting { 
        .otherPrecompCflags(value)
    }
}

extension BuildSettingsKey {

    /// Other Precomp Cflags
    public static let otherPrecompCflags: BuildSettingsKey = "OTHER_PRECOMP_CFLAGS"
}

// MARK: Other Resmergerflags
extension BuildSetting {

    /// Other Resmergerflags
    public static func otherResmergerflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherResmergerflags, value: .array(value))
    }

    /// Other Resmergerflags
    public static func otherResmergerflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherResmergerflags, inherit: key)
    }

    /// Other Resmergerflags
    public static func otherResmergerflags(_ value: String...) -> BuildSetting { 
        .otherResmergerflags(value)
    }
}

extension BuildSettingsKey {

    /// Other Resmergerflags
    public static let otherResmergerflags: BuildSettingsKey = "OTHER_RESMERGERFLAGS"
}

// MARK: Other Rez Flags
extension BuildSetting {

    /// Other Rez Flags
    ///
    /// Space-separated list of additional flags to pass to the `Rez` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `Rez` flag.
    public static func otherRezFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherRezFlags, value: .array(value))
    }

    /// Other Rez Flags
    ///
    /// Space-separated list of additional flags to pass to the `Rez` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `Rez` flag.
    public static func otherRezFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherRezFlags, inherit: key)
    }

    /// Other Rez Flags
    ///
    /// Space-separated list of additional flags to pass to the `Rez` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `Rez` flag.
    public static func otherRezFlags(_ value: String...) -> BuildSetting { 
        .otherRezFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Rez Flags
    ///
    /// Space-separated list of additional flags to pass to the `Rez` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `Rez` flag.
    public static let otherRezFlags: BuildSettingsKey = "OTHER_REZFLAGS"
}

// MARK: Package Type
extension BuildSetting {

    /// Package Type
    ///
    /// Uniform type identifier. Identifies the type of the product the target builds. Some products may be made up of a single binary or archive. Others may comprise several files, which are grouped under a single directory. These container directories are known as **bundles**.
    public static func packageType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .packageType, value: \(value))
    }

    /// Package Type
    ///
    /// Uniform type identifier. Identifies the type of the product the target builds. Some products may be made up of a single binary or archive. Others may comprise several files, which are grouped under a single directory. These container directories are known as **bundles**.
    public static func packageType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .packageType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Package Type
    ///
    /// Uniform type identifier. Identifies the type of the product the target builds. Some products may be made up of a single binary or archive. Others may comprise several files, which are grouped under a single directory. These container directories are known as **bundles**.
    public static let packageType: BuildSettingsKey = "PACKAGE_TYPE"
}

// MARK: Pascal Strings
extension BuildSetting {

    /// Pascal Strings
    public static var pascalStrings: BuildSetting { 
        BuildSetting(key: .pascalStrings, value: "YES")
    }

    /// Pascal Strings
    public static func pascalStrings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pascalStrings, value: value.asText)
    }

    /// Pascal Strings
    public static func pascalStrings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pascalStrings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pascal Strings
    public static let pascalStrings: BuildSettingsKey = "PASCAL_STRINGS"
}

// MARK: Pbdevelopmentplist Path
extension BuildSetting {

    /// Pbdevelopmentplist Path
    public static func pbdevelopmentplistPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pbdevelopmentplistPath, value: \(value))
    }

    /// Pbdevelopmentplist Path
    public static func pbdevelopmentplistPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbdevelopmentplistPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pbdevelopmentplist Path
    public static let pbdevelopmentplistPath: BuildSettingsKey = "PBDEVELOPMENTPLIST_PATH"
}

// MARK: Pfe File C Dialects
extension BuildSetting {

    /// Pfe File C Dialects
    public static func pfeFileCDialects(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .pfeFileCDialects, value: .array(value))
    }

    /// Pfe File C Dialects
    public static func pfeFileCDialects(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pfeFileCDialects, inherit: key)
    }

    /// Pfe File C Dialects
    public static func pfeFileCDialects(_ value: String...) -> BuildSetting { 
        .pfeFileCDialects(value)
    }
}

extension BuildSettingsKey {

    /// Pfe File C Dialects
    public static let pfeFileCDialects: BuildSettingsKey = "PFE_FILE_C_DIALECTS"
}

// MARK: Pkginfo Path
extension BuildSetting {

    /// Pkginfo Path
    public static func pkginfoPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pkginfoPath, value: \(value))
    }

    /// Pkginfo Path
    public static func pkginfoPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pkginfoPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pkginfo Path
    public static let pkginfoPath: BuildSettingsKey = "PKGINFO_PATH"
}

// MARK: Plugins Folder Path
extension BuildSetting {

    /// Plugins Folder Path
    ///
    /// Specifies the directory that contains the product’s plugins.
    public static func pluginsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pluginsFolderPath, value: \(value))
    }

    /// Plugins Folder Path
    ///
    /// Specifies the directory that contains the product’s plugins.
    public static func pluginsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pluginsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Plugins Folder Path
    ///
    /// Specifies the directory that contains the product’s plugins.
    public static let pluginsFolderPath: BuildSettingsKey = "PLUGINS_FOLDER_PATH"
}

// MARK: Precompile Prefix Header
extension BuildSetting {

    /// Precompile Prefix Header
    public static func precompilePrefixHeader(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .precompilePrefixHeader, value: value.asText)
    }

    /// Precompile Prefix Header
    public static func precompilePrefixHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompilePrefixHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Precompile Prefix Header
    public static let precompilePrefixHeader: BuildSettingsKey = "PRECOMPILE_PREFIX_HEADER"
}

// MARK: Prefix Cflag Base
extension BuildSetting {

    /// Prefix Cflag Base
    public static func prefixCflagBase(_ value: String) -> BuildSetting { 
        BuildSetting(key: .prefixCflagBase, value: \(value))
    }

    /// Prefix Cflag Base
    public static func prefixCflagBase(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prefixCflagBase, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Prefix Cflag Base
    public static let prefixCflagBase: BuildSettingsKey = "PREFIX_CFLAG_BASE"
}

// MARK: Prefix Flags
extension BuildSetting {

    /// Prefix Flags
    public static func prefixFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .prefixFlags, value: .array(value))
    }

    /// Prefix Flags
    public static func prefixFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prefixFlags, inherit: key)
    }

    /// Prefix Flags
    public static func prefixFlags(_ value: String...) -> BuildSetting { 
        .prefixFlags(value)
    }
}

extension BuildSettingsKey {

    /// Prefix Flags
    public static let prefixFlags: BuildSettingsKey = "PREFIX_FLAGS"
}

// MARK: Prefix Header
extension BuildSetting {

    /// Prefix Header
    public static func prefixHeader(_ value: String) -> BuildSetting { 
        BuildSetting(key: .prefixHeader, value: \(value))
    }

    /// Prefix Header
    public static func prefixHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prefixHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Prefix Header
    public static let prefixHeader: BuildSettingsKey = "PREFIX_HEADER"
}

// MARK: Prefix Reference
extension BuildSetting {

    /// Prefix Reference
    public static func prefixReference(_ value: String) -> BuildSetting { 
        BuildSetting(key: .prefixReference, value: \(value))
    }

    /// Prefix Reference
    public static func prefixReference(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prefixReference, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Prefix Reference
    public static let prefixReference: BuildSettingsKey = "PREFIX_REFERENCE"
}

// MARK: Product Type
extension BuildSetting {

    /// Product Type
    public static func productType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .productType, value: \(value))
    }

    /// Product Type
    public static func productType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Product Type
    public static let productType: BuildSettingsKey = "PRODUCT_TYPE"
}

// MARK: Recursive Search Paths Follow Symlinks
extension BuildSetting {

    /// Recursive Search Paths Follow Symlinks
    public static var recursiveSearchPathsFollowSymlinks: BuildSetting { 
        BuildSetting(key: .recursiveSearchPathsFollowSymlinks, value: "YES")
    }

    /// Recursive Search Paths Follow Symlinks
    public static func recursiveSearchPathsFollowSymlinks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .recursiveSearchPathsFollowSymlinks, value: value.asText)
    }

    /// Recursive Search Paths Follow Symlinks
    public static func recursiveSearchPathsFollowSymlinks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .recursiveSearchPathsFollowSymlinks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Recursive Search Paths Follow Symlinks
    public static let recursiveSearchPathsFollowSymlinks: BuildSettingsKey = "RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS"
}

// MARK: Resource Rules Plist Path
extension BuildSetting {

    /// Resource Rules Plist Path
    public static func resourceRulesPlistPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .resourceRulesPlistPath, value: \(value))
    }

    /// Resource Rules Plist Path
    public static func resourceRulesPlistPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resourceRulesPlistPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Resource Rules Plist Path
    public static let resourceRulesPlistPath: BuildSettingsKey = "RESOURCE_RULES_PLIST_PATH"
}

// MARK: Retain Raw Binaries
extension BuildSetting {

    /// Retain Raw Binaries
    ///
    /// Specifies whether to keep copies of unstripped binaries available.
    public static var retainRawBinaries: BuildSetting { 
        BuildSetting(key: .retainRawBinaries, value: "$(INSTALLED_PRODUCT_ASIDES)")
    }

    /// Retain Raw Binaries
    ///
    /// Specifies whether to keep copies of unstripped binaries available.
    public static func retainRawBinaries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .retainRawBinaries, value: value.asText)
    }

    /// Retain Raw Binaries
    ///
    /// Specifies whether to keep copies of unstripped binaries available.
    public static func retainRawBinaries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .retainRawBinaries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Retain Raw Binaries
    ///
    /// Specifies whether to keep copies of unstripped binaries available.
    public static let retainRawBinaries: BuildSettingsKey = "RETAIN_RAW_BINARIES"
}

// MARK: Rez Collector Dir
extension BuildSetting {

    /// Rez Collector Dir
    ///
    /// Specifies the directory in which the collected Resource Manager resources generated by `ResMerger` are stored before they are added to the product.
    public static var rezCollectorDir: BuildSetting { 
        BuildSetting(key: .rezCollectorDir, value: "$(TARGET_TEMP_DIR)/ResourceManagerResources")
    }

    /// Rez Collector Dir
    ///
    /// Specifies the directory in which the collected Resource Manager resources generated by `ResMerger` are stored before they are added to the product.
    public static func rezCollectorDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .rezCollectorDir, value: \(value))
    }

    /// Rez Collector Dir
    ///
    /// Specifies the directory in which the collected Resource Manager resources generated by `ResMerger` are stored before they are added to the product.
    public static func rezCollectorDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezCollectorDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Rez Collector Dir
    ///
    /// Specifies the directory in which the collected Resource Manager resources generated by `ResMerger` are stored before they are added to the product.
    public static let rezCollectorDir: BuildSettingsKey = "REZ_COLLECTOR_DIR"
}

// MARK: Rez Objects Dir
extension BuildSetting {

    /// Rez Objects Dir
    ///
    /// Specifies the directory in which compiled Resource Manager resources generated by `Rez` are stored before they are collected using `ResMerger`.
    public static var rezObjectsDir: BuildSetting { 
        BuildSetting(key: .rezObjectsDir, value: "$(REZ_COLLECTOR_DIR)/Objects")
    }

    /// Rez Objects Dir
    ///
    /// Specifies the directory in which compiled Resource Manager resources generated by `Rez` are stored before they are collected using `ResMerger`.
    public static func rezObjectsDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .rezObjectsDir, value: \(value))
    }

    /// Rez Objects Dir
    ///
    /// Specifies the directory in which compiled Resource Manager resources generated by `Rez` are stored before they are collected using `ResMerger`.
    public static func rezObjectsDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezObjectsDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Rez Objects Dir
    ///
    /// Specifies the directory in which compiled Resource Manager resources generated by `Rez` are stored before they are collected using `ResMerger`.
    public static let rezObjectsDir: BuildSettingsKey = "REZ_OBJECTS_DIR"
}

// MARK: Scripts Folder Path
extension BuildSetting {

    /// Scripts Folder Path
    ///
    /// Specifies the directory that contains the product’s scripts.
    public static func scriptsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .scriptsFolderPath, value: \(value))
    }

    /// Scripts Folder Path
    ///
    /// Specifies the directory that contains the product’s scripts.
    public static func scriptsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .scriptsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Scripts Folder Path
    ///
    /// Specifies the directory that contains the product’s scripts.
    public static let scriptsFolderPath: BuildSettingsKey = "SCRIPTS_FOLDER_PATH"
}

// MARK: Sed
extension BuildSetting {

    /// Sed
    public static var sed: BuildSetting { 
        BuildSetting(key: .sed, value: "/usr/bin/sed")
    }

    /// Sed
    public static func sed(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sed, value: \(value))
    }

    /// Sed
    public static func sed(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sed, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Sed
    public static let sed: BuildSettingsKey = "SED"
}

// MARK: Set Dir Mode Owner Group
extension BuildSetting {

    /// Set Dir Mode Owner Group
    public static var setDirModeOwnerGroup: BuildSetting { 
        BuildSetting(key: .setDirModeOwnerGroup, value: "YES")
    }

    /// Set Dir Mode Owner Group
    public static func setDirModeOwnerGroup(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .setDirModeOwnerGroup, value: value.asText)
    }

    /// Set Dir Mode Owner Group
    public static func setDirModeOwnerGroup(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .setDirModeOwnerGroup, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Set Dir Mode Owner Group
    public static let setDirModeOwnerGroup: BuildSettingsKey = "SET_DIR_MODE_OWNER_GROUP"
}

// MARK: Set File Mode Owner Group
extension BuildSetting {

    /// Set File Mode Owner Group
    public static var setFileModeOwnerGroup: BuildSetting { 
        BuildSetting(key: .setFileModeOwnerGroup, value: "NO")
    }

    /// Set File Mode Owner Group
    public static func setFileModeOwnerGroup(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .setFileModeOwnerGroup, value: value.asText)
    }

    /// Set File Mode Owner Group
    public static func setFileModeOwnerGroup(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .setFileModeOwnerGroup, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Set File Mode Owner Group
    public static let setFileModeOwnerGroup: BuildSettingsKey = "SET_FILE_MODE_OWNER_GROUP"
}

// MARK: Shallow Bundle
extension BuildSetting {

    /// Shallow Bundle
    public static var shallowBundle: BuildSetting { 
        BuildSetting(key: .shallowBundle, value: "NO")
    }

    /// Shallow Bundle
    public static func shallowBundle(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .shallowBundle, value: value.asText)
    }

    /// Shallow Bundle
    public static func shallowBundle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .shallowBundle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Shallow Bundle
    public static let shallowBundle: BuildSettingsKey = "SHALLOW_BUNDLE"
}

// MARK: Shared Frameworks Folder Path
extension BuildSetting {

    /// Shared Frameworks Folder Path
    ///
    /// Specifies the directory that contains the product’s shared frameworks.
    public static func sharedFrameworksFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sharedFrameworksFolderPath, value: \(value))
    }

    /// Shared Frameworks Folder Path
    ///
    /// Specifies the directory that contains the product’s shared frameworks.
    public static func sharedFrameworksFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sharedFrameworksFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Shared Frameworks Folder Path
    ///
    /// Specifies the directory that contains the product’s shared frameworks.
    public static let sharedFrameworksFolderPath: BuildSettingsKey = "SHARED_FRAMEWORKS_FOLDER_PATH"
}

// MARK: Shared Support Folder Path
extension BuildSetting {

    /// Shared Support Folder Path
    public static func sharedSupportFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sharedSupportFolderPath, value: \(value))
    }

    /// Shared Support Folder Path
    public static func sharedSupportFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sharedSupportFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Shared Support Folder Path
    public static let sharedSupportFolderPath: BuildSettingsKey = "SHARED_SUPPORT_FOLDER_PATH"
}

// MARK: Symbol Header
extension BuildSetting {

    /// Symbol Header
    public static func symbolHeader(_ value: String) -> BuildSetting { 
        BuildSetting(key: .symbolHeader, value: \(value))
    }

    /// Symbol Header
    public static func symbolHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .symbolHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Symbol Header
    public static let symbolHeader: BuildSettingsKey = "SYMBOL_HEADER"
}

// MARK: Unlocalized Resources Folder Path
extension BuildSetting {

    /// Unlocalized Resources Folder Path
    ///
    /// Specifies the directory that contains the product’s unlocalized resources.
    public static func unlocalizedResourcesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .unlocalizedResourcesFolderPath, value: \(value))
    }

    /// Unlocalized Resources Folder Path
    ///
    /// Specifies the directory that contains the product’s unlocalized resources.
    public static func unlocalizedResourcesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unlocalizedResourcesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unlocalized Resources Folder Path
    ///
    /// Specifies the directory that contains the product’s unlocalized resources.
    public static let unlocalizedResourcesFolderPath: BuildSettingsKey = "UNLOCALIZED_RESOURCES_FOLDER_PATH"
}

// MARK: Unstripped Product
extension BuildSetting {

    /// Unstripped Product
    public static var unstrippedProduct: BuildSetting { 
        BuildSetting(key: .unstrippedProduct, value: "NO")
    }

    /// Unstripped Product
    public static func unstrippedProduct(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unstrippedProduct, value: value.asText)
    }

    /// Unstripped Product
    public static func unstrippedProduct(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unstrippedProduct, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unstripped Product
    public static let unstrippedProduct: BuildSettingsKey = "UNSTRIPPED_PRODUCT"
}

// MARK: Use Dynamic No Pic
extension BuildSetting {

    /// Use Dynamic No Pic
    public static var useDynamicNoPic: BuildSetting { 
        BuildSetting(key: .useDynamicNoPic, value: "YES")
    }

    /// Use Dynamic No Pic
    public static func useDynamicNoPic(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useDynamicNoPic, value: value.asText)
    }

    /// Use Dynamic No Pic
    public static func useDynamicNoPic(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useDynamicNoPic, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Dynamic No Pic
    public static let useDynamicNoPic: BuildSettingsKey = "USE_DYNAMIC_NO_PIC"
}

// MARK: Validate Built Product
extension BuildSetting {

    /// Validate Built Product
    ///
    /// If enabled, perform validation checks on the product as part of the build process.
    public static var validateBuiltProduct: BuildSetting { 
        BuildSetting(key: .validateBuiltProduct, value: "NO")
    }

    /// Validate Built Product
    ///
    /// If enabled, perform validation checks on the product as part of the build process.
    public static func validateBuiltProduct(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .validateBuiltProduct, value: value.asText)
    }

    /// Validate Built Product
    ///
    /// If enabled, perform validation checks on the product as part of the build process.
    public static func validateBuiltProduct(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validateBuiltProduct, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Validate Built Product
    ///
    /// If enabled, perform validation checks on the product as part of the build process.
    public static let validateBuiltProduct: BuildSettingsKey = "VALIDATE_PRODUCT"
}

// MARK: Verbose Pbxcp
extension BuildSetting {

    /// Verbose Pbxcp
    ///
    /// Specifies whether the target’s Copy Files build phases generate additional information when copying files.
    public static var verbosePbxcp: BuildSetting { 
        BuildSetting(key: .verbosePbxcp, value: "NO")
    }

    /// Verbose Pbxcp
    ///
    /// Specifies whether the target’s Copy Files build phases generate additional information when copying files.
    public static func verbosePbxcp(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .verbosePbxcp, value: value.asText)
    }

    /// Verbose Pbxcp
    ///
    /// Specifies whether the target’s Copy Files build phases generate additional information when copying files.
    public static func verbosePbxcp(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .verbosePbxcp, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Verbose Pbxcp
    ///
    /// Specifies whether the target’s Copy Files build phases generate additional information when copying files.
    public static let verbosePbxcp: BuildSettingsKey = "VERBOSE_PBXCP"
}

// MARK: Versioning Stub
extension BuildSetting {

    /// Versioning Stub
    public static func versioningStub(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versioningStub, value: \(value))
    }

    /// Versioning Stub
    public static func versioningStub(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningStub, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versioning Stub
    public static let versioningStub: BuildSettingsKey = "VERSIONING_STUB"
}

// MARK: Versionplist Path
extension BuildSetting {

    /// Versionplist Path
    public static func versionplistPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versionplistPath, value: \(value))
    }

    /// Versionplist Path
    public static func versionplistPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versionplistPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versionplist Path
    public static let versionplistPath: BuildSettingsKey = "VERSIONPLIST_PATH"
}

// MARK: Version Info String
extension BuildSetting {

    /// Version Info String
    public static var versionInfoString: BuildSetting { 
        BuildSetting(key: .versionInfoString, value: "&quot;@(#)PROGRAM:$(PRODUCT_NAME) PROJECT:$(PROJECT_NAME)-$(CURRENT_PROJECT_VERSION)&quot;")
    }

    /// Version Info String
    public static func versionInfoString(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versionInfoString, value: \(value))
    }

    /// Version Info String
    public static func versionInfoString(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versionInfoString, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Version Info String
    public static let versionInfoString: BuildSettingsKey = "VERSION_INFO_STRING"
}

// MARK: Wrapper Name
extension BuildSetting {

    /// Wrapper Name
    ///
    /// Specifies the filename, including the appropriate extension, of the product bundle.
    public static func wrapperName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .wrapperName, value: \(value))
    }

    /// Wrapper Name
    ///
    /// Specifies the filename, including the appropriate extension, of the product bundle.
    public static func wrapperName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapperName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Wrapper Name
    ///
    /// Specifies the filename, including the appropriate extension, of the product bundle.
    public static let wrapperName: BuildSettingsKey = "WRAPPER_NAME"
}

// MARK: Wrapper Prefix
extension BuildSetting {

    /// Wrapper Prefix
    public static func wrapperPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .wrapperPrefix, value: \(value))
    }

    /// Wrapper Prefix
    public static func wrapperPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapperPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Wrapper Prefix
    public static let wrapperPrefix: BuildSettingsKey = "WRAPPER_PREFIX"
}

// MARK: Wrapper Suffix
extension BuildSetting {

    /// Wrapper Suffix
    ///
    /// Specifies the suffix of the product bundle name, including the character that separates the extension from the rest of the bundle name.
    public static func wrapperSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .wrapperSuffix, value: \(value))
    }

    /// Wrapper Suffix
    ///
    /// Specifies the suffix of the product bundle name, including the character that separates the extension from the rest of the bundle name.
    public static func wrapperSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapperSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Wrapper Suffix
    ///
    /// Specifies the suffix of the product bundle name, including the character that separates the extension from the rest of the bundle name.
    public static let wrapperSuffix: BuildSettingsKey = "WRAPPER_SUFFIX"
}

// MARK: Xpcservices Folder Path
extension BuildSetting {

    /// Xpcservices Folder Path
    public static var xpcservicesFolderPath: BuildSetting { 
        BuildSetting(key: .xpcservicesFolderPath, value: "$(CONTENTS_FOLDER_PATH)/XPCServices")
    }

    /// Xpcservices Folder Path
    public static func xpcservicesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .xpcservicesFolderPath, value: \(value))
    }

    /// Xpcservices Folder Path
    public static func xpcservicesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .xpcservicesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Xpcservices Folder Path
    public static let xpcservicesFolderPath: BuildSettingsKey = "XPCSERVICES_FOLDER_PATH"
}

// MARK: Yacc
extension BuildSetting {

    /// Yacc
    public static var yacc: BuildSetting { 
        BuildSetting(key: .yacc, value: "yacc")
    }

    /// Yacc
    public static func yacc(_ value: String) -> BuildSetting { 
        BuildSetting(key: .yacc, value: \(value))
    }

    /// Yacc
    public static func yacc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .yacc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Yacc
    public static let yacc: BuildSettingsKey = "YACC"
}

// MARK: Other Yacc Flags
extension BuildSetting {

    /// Other Yacc Flags
    ///
    /// Space-separated list of additional flags to pass to `yacc`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `yacc` flag.
    public static func otherYaccFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherYaccFlags, value: .array(value))
    }

    /// Other Yacc Flags
    ///
    /// Space-separated list of additional flags to pass to `yacc`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `yacc` flag.
    public static func otherYaccFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherYaccFlags, inherit: key)
    }

    /// Other Yacc Flags
    ///
    /// Space-separated list of additional flags to pass to `yacc`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `yacc` flag.
    public static func otherYaccFlags(_ value: String...) -> BuildSetting { 
        .otherYaccFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Yacc Flags
    ///
    /// Space-separated list of additional flags to pass to `yacc`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `yacc` flag.
    public static let otherYaccFlags: BuildSettingsKey = "YACCFLAGS"
}

// MARK: All Other Ldflags
extension BuildSetting {

    /// All Other Ldflags
    public static var allOtherLdflags: BuildSetting { 
        BuildSetting(key: .allOtherLdflags, value: "$(LD_FLAGS) $(SECTORDER_FLAGS) $(OTHER_LDFLAGS) $(OTHER_LDFLAGS_$(variant)) $(OTHER_LDFLAGS_$(arch)) $(OTHER_LDFLAGS_$(variant)_$(arch)) $(PRODUCT_SPECIFIC_LDFLAGS)")
    }

    /// All Other Ldflags
    public static func allOtherLdflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .allOtherLdflags, value: .array(value))
    }

    /// All Other Ldflags
    public static func allOtherLdflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .allOtherLdflags, inherit: key)
    }

    /// All Other Ldflags
    public static func allOtherLdflags(_ value: String...) -> BuildSetting { 
        .allOtherLdflags(value)
    }
}

extension BuildSettingsKey {

    /// All Other Ldflags
    public static let allOtherLdflags: BuildSettingsKey = "ALL_OTHER_LDFLAGS"
}

// MARK: Alternate Linker
extension BuildSetting {

    /// Alternate Linker
    public static func alternateLinker(_ value: String) -> BuildSetting { 
        BuildSetting(key: .alternateLinker, value: \(value))
    }

    /// Alternate Linker
    public static func alternateLinker(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternateLinker, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Alternate Linker
    public static let alternateLinker: BuildSettingsKey = "ALTERNATE_LINKER"
}

// MARK: Clang Arc Migrate Dir
extension BuildSetting {

    /// Clang Arc Migrate Dir
    public static func clangArcMigrateDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangArcMigrateDir, value: \(value))
    }

    /// Clang Arc Migrate Dir
    public static func clangArcMigrateDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangArcMigrateDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Arc Migrate Dir
    public static let clangArcMigrateDir: BuildSettingsKey = "CLANG_ARC_MIGRATE_DIR"
}

// MARK: Clang Arc Migrate Precheck
extension BuildSetting {

    /// Clang Arc Migrate Precheck
    public static var clangArcMigratePrecheck: BuildSetting { 
        .clangArcMigratePrecheck(.donothing) 
    }

    /// Clang Arc Migrate Precheck
    public static func clangArcMigratePrecheck(_ value: ClangArcMigratePrecheck) -> BuildSetting { 
        BuildSetting(key: .clangArcMigratePrecheck, value: \(value))
    }

    /// Clang Arc Migrate Precheck
    public static func clangArcMigratePrecheck(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangArcMigratePrecheck, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Arc Migrate Precheck
    public static let clangArcMigratePrecheck: BuildSettingsKey = "CLANG_ARC_MIGRATE_PRECHECK"
}

public enum ClangArcMigratePrecheck: String, Hashable, Codable, CustomStringConvertible {
    case precheck = "precheck"
    case donothing = "donothing"

    public var description: String {
        rawValue
    }
}

// MARK: Ld Additional Deployment Target Flags
extension BuildSetting {

    /// Ld Additional Deployment Target Flags
    public static func ldAdditionalDeploymentTargetFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ldAdditionalDeploymentTargetFlags, value: .array(value))
    }

    /// Ld Additional Deployment Target Flags
    public static func ldAdditionalDeploymentTargetFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldAdditionalDeploymentTargetFlags, inherit: key)
    }

    /// Ld Additional Deployment Target Flags
    public static func ldAdditionalDeploymentTargetFlags(_ value: String...) -> BuildSetting { 
        .ldAdditionalDeploymentTargetFlags(value)
    }
}

extension BuildSettingsKey {

    /// Ld Additional Deployment Target Flags
    public static let ldAdditionalDeploymentTargetFlags: BuildSettingsKey = "LD_ADDITIONAL_DEPLOYMENT_TARGET_FLAGS"
}

// MARK: Ld Bitcode Generation Mode
extension BuildSetting {

    /// Ld Bitcode Generation Mode
    public static var ldBitcodeGenerationMode: BuildSetting { 
        .ldBitcodeGenerationMode(inherit: .bitcodeGenerationMode) 
    }

    /// Ld Bitcode Generation Mode
    public static func ldBitcodeGenerationMode(_ value: LdBitcodeGenerationMode) -> BuildSetting { 
        BuildSetting(key: .ldBitcodeGenerationMode, value: \(value))
    }

    /// Ld Bitcode Generation Mode
    public static func ldBitcodeGenerationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldBitcodeGenerationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Bitcode Generation Mode
    public static let ldBitcodeGenerationMode: BuildSettingsKey = "LD_BITCODE_GENERATION_MODE"
}

public enum LdBitcodeGenerationMode: String, Hashable, Codable, CustomStringConvertible {
    case bitcode = "bitcode"
    case marker = "marker"

    public var description: String {
        rawValue
    }
}

// MARK: Ld Debug Variant
extension BuildSetting {

    /// Ld Debug Variant
    public static var ldDebugVariant: BuildSetting { 
        BuildSetting(key: .ldDebugVariant, value: "YES")
    }

    /// Ld Debug Variant
    public static func ldDebugVariant(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldDebugVariant, value: value.asText)
    }

    /// Ld Debug Variant
    public static func ldDebugVariant(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldDebugVariant, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Debug Variant
    public static let ldDebugVariant: BuildSettingsKey = "LD_DEBUG_VARIANT"
}

// MARK: Ld Deployment Target
extension BuildSetting {

    /// Ld Deployment Target
    public static var ldDeploymentTarget: BuildSetting { 
        BuildSetting(key: .ldDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// Ld Deployment Target
    public static func ldDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ldDeploymentTarget, value: \(value))
    }

    /// Ld Deployment Target
    public static func ldDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Deployment Target
    public static let ldDeploymentTarget: BuildSettingsKey = "LD_DEPLOYMENT_TARGET"
}

// MARK: Ld Dont Run Deduplication
extension BuildSetting {

    /// Ld Dont Run Deduplication
    public static var ldDontRunDeduplication: BuildSetting { 
        BuildSetting(key: .ldDontRunDeduplication, value: "YES")
    }

    /// Ld Dont Run Deduplication
    public static func ldDontRunDeduplication(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldDontRunDeduplication, value: value.asText)
    }

    /// Ld Dont Run Deduplication
    public static func ldDontRunDeduplication(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldDontRunDeduplication, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Dont Run Deduplication
    public static let ldDontRunDeduplication: BuildSettingsKey = "LD_DONT_RUN_DEDUPLICATION"
}

// MARK: Ld Export Global Symbols
extension BuildSetting {

    /// Ld Export Global Symbols
    public static var ldExportGlobalSymbols: BuildSetting { 
        BuildSetting(key: .ldExportGlobalSymbols, value: "NO")
    }

    /// Ld Export Global Symbols
    public static func ldExportGlobalSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldExportGlobalSymbols, value: value.asText)
    }

    /// Ld Export Global Symbols
    public static func ldExportGlobalSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldExportGlobalSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Export Global Symbols
    public static let ldExportGlobalSymbols: BuildSettingsKey = "LD_EXPORT_GLOBAL_SYMBOLS"
}

// MARK: Ld Final Output File
extension BuildSetting {

    /// Ld Final Output File
    public static var ldFinalOutputFile: BuildSetting { 
        BuildSetting(key: .ldFinalOutputFile, value: "$(INSTALL_PATH)/$(EXECUTABLE_PATH)")
    }

    /// Ld Final Output File
    public static func ldFinalOutputFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ldFinalOutputFile, value: \(value))
    }

    /// Ld Final Output File
    public static func ldFinalOutputFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldFinalOutputFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Final Output File
    public static let ldFinalOutputFile: BuildSettingsKey = "LD_FINAL_OUTPUT_FILE"
}

// MARK: Ld Generate Bitcode Symbol Map
extension BuildSetting {

    /// Ld Generate Bitcode Symbol Map
    public static var ldGenerateBitcodeSymbolMap: BuildSetting { 
        .ldGenerateBitcodeSymbolMap(inherit: .hideBitcodeSymbols) 
    }

    /// Ld Generate Bitcode Symbol Map
    public static func ldGenerateBitcodeSymbolMap(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldGenerateBitcodeSymbolMap, value: value.asText)
    }

    /// Ld Generate Bitcode Symbol Map
    public static func ldGenerateBitcodeSymbolMap(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldGenerateBitcodeSymbolMap, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Generate Bitcode Symbol Map
    public static let ldGenerateBitcodeSymbolMap: BuildSettingsKey = "LD_GENERATE_BITCODE_SYMBOL_MAP"
}

// MARK: Ld Hide Bitcode Symbols
extension BuildSetting {

    /// Ld Hide Bitcode Symbols
    public static var ldHideBitcodeSymbols: BuildSetting { 
        .ldHideBitcodeSymbols(inherit: .hideBitcodeSymbols) 
    }

    /// Ld Hide Bitcode Symbols
    public static func ldHideBitcodeSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldHideBitcodeSymbols, value: value.asText)
    }

    /// Ld Hide Bitcode Symbols
    public static func ldHideBitcodeSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldHideBitcodeSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Hide Bitcode Symbols
    public static let ldHideBitcodeSymbols: BuildSettingsKey = "LD_HIDE_BITCODE_SYMBOLS"
}

// MARK: Ld Lto Object File
extension BuildSetting {

    /// Ld Lto Object File
    public static var ldLtoObjectFile: BuildSetting { 
        BuildSetting(key: .ldLtoObjectFile, value: "$(OBJECT_FILE_DIR_$(CURRENT_VARIANT))/$(CURRENT_ARCH)/$(PRODUCT_NAME)_lto.o")
    }

    /// Ld Lto Object File
    public static func ldLtoObjectFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ldLtoObjectFile, value: \(value))
    }

    /// Ld Lto Object File
    public static func ldLtoObjectFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldLtoObjectFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Lto Object File
    public static let ldLtoObjectFile: BuildSettingsKey = "LD_LTO_OBJECT_FILE"
}

// MARK: Ld Objc Abi Version
extension BuildSetting {

    /// Ld Objc Abi Version
    public static var ldObjcAbiVersion: BuildSetting { 
        BuildSetting(key: .ldObjcAbiVersion, value: "$(OBJC_ABI_VERSION)")
    }

    /// Ld Objc Abi Version
    public static func ldObjcAbiVersion(_ value: LdObjcAbiVersion) -> BuildSetting { 
        BuildSetting(key: .ldObjcAbiVersion, value: \(value))
    }

    /// Ld Objc Abi Version
    public static func ldObjcAbiVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldObjcAbiVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Objc Abi Version
    public static let ldObjcAbiVersion: BuildSettingsKey = "LD_OBJC_ABI_VERSION"
}

public enum LdObjcAbiVersion: String, Hashable, Codable, CustomStringConvertible {
    case _1 = "1"
    case _2 = "2"

    public var description: String {
        rawValue
    }
}

// MARK: Ld Target Triple Archs
extension BuildSetting {

    /// Ld Target Triple Archs
    public static var ldTargetTripleArchs: BuildSetting { 
        .ldTargetTripleArchs(inherit: .currentArch) 
    }

    /// Ld Target Triple Archs
    public static func ldTargetTripleArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ldTargetTripleArchs, value: .array(value))
    }

    /// Ld Target Triple Archs
    public static func ldTargetTripleArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldTargetTripleArchs, inherit: key)
    }

    /// Ld Target Triple Archs
    public static func ldTargetTripleArchs(_ value: String...) -> BuildSetting { 
        .ldTargetTripleArchs(value)
    }
}

extension BuildSettingsKey {

    /// Ld Target Triple Archs
    public static let ldTargetTripleArchs: BuildSettingsKey = "LD_TARGET_TRIPLE_ARCHS"
}

// MARK: Ld Target Triple Variants
extension BuildSetting {

    /// Ld Target Triple Variants
    public static func ldTargetTripleVariants(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ldTargetTripleVariants, value: .array(value))
    }

    /// Ld Target Triple Variants
    public static func ldTargetTripleVariants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldTargetTripleVariants, inherit: key)
    }

    /// Ld Target Triple Variants
    public static func ldTargetTripleVariants(_ value: String...) -> BuildSetting { 
        .ldTargetTripleVariants(value)
    }
}

extension BuildSettingsKey {

    /// Ld Target Triple Variants
    public static let ldTargetTripleVariants: BuildSettingsKey = "LD_TARGET_TRIPLE_VARIANTS"
}

// MARK: Ld Thread Sanitizer
extension BuildSetting {

    /// Ld Thread Sanitizer
    public static var ldThreadSanitizer: BuildSetting { 
        BuildSetting(key: .ldThreadSanitizer, value: "$(ENABLE_THREAD_SANITIZER)")
    }

    /// Ld Thread Sanitizer
    public static func ldThreadSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldThreadSanitizer, value: value.asText)
    }

    /// Ld Thread Sanitizer
    public static func ldThreadSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldThreadSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Thread Sanitizer
    public static let ldThreadSanitizer: BuildSettingsKey = "LD_THREAD_SANITIZER"
}

// MARK: Ld Verify Bitcode
extension BuildSetting {

    /// Ld Verify Bitcode
    public static var ldVerifyBitcode: BuildSetting { 
        BuildSetting(key: .ldVerifyBitcode, value: "YES")
    }

    /// Ld Verify Bitcode
    public static func ldVerifyBitcode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldVerifyBitcode, value: value.asText)
    }

    /// Ld Verify Bitcode
    public static func ldVerifyBitcode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldVerifyBitcode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Verify Bitcode
    public static let ldVerifyBitcode: BuildSettingsKey = "LD_VERIFY_BITCODE"
}

// MARK: Other Ldrflags
extension BuildSetting {

    /// Other Ldrflags
    public static var otherLdrflags: BuildSetting { 
        .otherLdrflags(inherit: .otherLinkerFlags) 
    }

    /// Other Ldrflags
    public static func otherLdrflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherLdrflags, value: .array(value))
    }

    /// Other Ldrflags
    public static func otherLdrflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherLdrflags, inherit: key)
    }

    /// Other Ldrflags
    public static func otherLdrflags(_ value: String...) -> BuildSetting { 
        .otherLdrflags(value)
    }
}

extension BuildSettingsKey {

    /// Other Ldrflags
    public static let otherLdrflags: BuildSettingsKey = "OTHER_LDRFLAGS"
}

// MARK: Product Type Framework Search Paths
extension BuildSetting {

    /// Product Type Framework Search Paths
    public static func productTypeFrameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .productTypeFrameworkSearchPaths, value: .array(value))
    }

    /// Product Type Framework Search Paths
    public static func productTypeFrameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productTypeFrameworkSearchPaths, inherit: key)
    }

    /// Product Type Framework Search Paths
    public static func productTypeFrameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .productTypeFrameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Product Type Framework Search Paths
    public static let productTypeFrameworkSearchPaths: BuildSettingsKey = "PRODUCT_TYPE_FRAMEWORK_SEARCH_PATHS"
}

// MARK: Product Type Library Search Paths
extension BuildSetting {

    /// Product Type Library Search Paths
    public static func productTypeLibrarySearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .productTypeLibrarySearchPaths, value: .array(value))
    }

    /// Product Type Library Search Paths
    public static func productTypeLibrarySearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productTypeLibrarySearchPaths, inherit: key)
    }

    /// Product Type Library Search Paths
    public static func productTypeLibrarySearchPaths(_ value: String...) -> BuildSetting { 
        .productTypeLibrarySearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Product Type Library Search Paths
    public static let productTypeLibrarySearchPaths: BuildSettingsKey = "PRODUCT_TYPE_LIBRARY_SEARCH_PATHS"
}

// MARK: All Other Libtoolflags
extension BuildSetting {

    /// All Other Libtoolflags
    public static var allOtherLibtoolflags: BuildSetting { 
        BuildSetting(key: .allOtherLibtoolflags, value: "$(OTHER_LIBTOOLFLAGS) $(OTHER_LIBTOOLFLAGS_$(variant)) $(OTHER_LIBTOOLFLAGS_$(arch)) $(OTHER_LIBTOOLFLAGS_$(variant)_$(arch)) $(PRODUCT_SPECIFIC_LIBTOOLFLAGS)")
    }

    /// All Other Libtoolflags
    public static func allOtherLibtoolflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .allOtherLibtoolflags, value: .array(value))
    }

    /// All Other Libtoolflags
    public static func allOtherLibtoolflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .allOtherLibtoolflags, inherit: key)
    }

    /// All Other Libtoolflags
    public static func allOtherLibtoolflags(_ value: String...) -> BuildSetting { 
        .allOtherLibtoolflags(value)
    }
}

extension BuildSettingsKey {

    /// All Other Libtoolflags
    public static let allOtherLibtoolflags: BuildSettingsKey = "ALL_OTHER_LIBTOOLFLAGS"
}

// MARK: Libtool
extension BuildSetting {

    /// Libtool
    public static var libtool: BuildSetting { 
        BuildSetting(key: .libtool, value: "libtool")
    }

    /// Libtool
    public static func libtool(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libtool, value: \(value))
    }

    /// Libtool
    public static func libtool(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libtool, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Libtool
    public static let libtool: BuildSettingsKey = "LIBTOOL"
}

// MARK: Libtool Dependency Info File
extension BuildSetting {

    /// Libtool Dependency Info File
    public static var libtoolDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .libtoolDependencyInfoFile, value: "$(OBJECT_FILE_DIR_$(CURRENT_VARIANT))/$(CURRENT_ARCH)/$(PRODUCT_NAME)_libtool_dependency_info.dat")
    }

    /// Libtool Dependency Info File
    public static func libtoolDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libtoolDependencyInfoFile, value: \(value))
    }

    /// Libtool Dependency Info File
    public static func libtoolDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libtoolDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Libtool Dependency Info File
    public static let libtoolDependencyInfoFile: BuildSettingsKey = "LIBTOOL_DEPENDENCY_INFO_FILE"
}

// MARK: Libtool Deployment Target
extension BuildSetting {

    /// Libtool Deployment Target
    public static var libtoolDeploymentTarget: BuildSetting { 
        BuildSetting(key: .libtoolDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// Libtool Deployment Target
    public static func libtoolDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libtoolDeploymentTarget, value: \(value))
    }

    /// Libtool Deployment Target
    public static func libtoolDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libtoolDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Libtool Deployment Target
    public static let libtoolDeploymentTarget: BuildSettingsKey = "LIBTOOL_DEPLOYMENT_TARGET"
}

// MARK: Libtool Deterministic Mode
extension BuildSetting {

    /// Libtool Deterministic Mode
    public static var libtoolDeterministicMode: BuildSetting { 
        BuildSetting(key: .libtoolDeterministicMode, value: "YES")
    }

    /// Libtool Deterministic Mode
    public static func libtoolDeterministicMode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .libtoolDeterministicMode, value: value.asText)
    }

    /// Libtool Deterministic Mode
    public static func libtoolDeterministicMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libtoolDeterministicMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Libtool Deterministic Mode
    public static let libtoolDeterministicMode: BuildSettingsKey = "LIBTOOL_DETERMINISTIC_MODE"
}

// MARK: Code Sign Keychain
extension BuildSetting {

    /// Code Sign Keychain
    public static func codeSignKeychain(_ value: String) -> BuildSetting { 
        BuildSetting(key: .codeSignKeychain, value: \(value))
    }

    /// Code Sign Keychain
    public static func codeSignKeychain(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSignKeychain, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Sign Keychain
    public static let codeSignKeychain: BuildSettingsKey = "CODE_SIGN_KEYCHAIN"
}

// MARK: Provisioning Profile
extension BuildSetting {

    /// Provisioning Profile
    public static func provisioningProfile(_ value: ProvisioningProfile) -> BuildSetting { 
        BuildSetting(key: .provisioningProfile, value: \(value))
    }

    /// Provisioning Profile
    public static func provisioningProfile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .provisioningProfile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Provisioning Profile
    public static let provisioningProfile: BuildSettingsKey = "PROVISIONING_PROFILE"
}

// MARK: Provisioning Profile Destination Path
extension BuildSetting {

    /// Provisioning Profile Destination Path
    public static var provisioningProfileDestinationPath: BuildSetting { 
        BuildSetting(key: .provisioningProfileDestinationPath, value: "$(TARGET_BUILD_DIR)/$(CONTENTS_FOLDER_PATH)")
    }

    /// Provisioning Profile Destination Path
    public static func provisioningProfileDestinationPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .provisioningProfileDestinationPath, value: \(value))
    }

    /// Provisioning Profile Destination Path
    public static func provisioningProfileDestinationPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .provisioningProfileDestinationPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Provisioning Profile Destination Path
    public static let provisioningProfileDestinationPath: BuildSettingsKey = "PROVISIONING_PROFILE_DESTINATION_PATH"
}

// MARK: Pbxcp Bitcode Strip Mode
extension BuildSetting {

    /// Pbxcp Bitcode Strip Mode
    public static func pbxcpBitcodeStripMode(_ value: PbxcpBitcodeStripMode) -> BuildSetting { 
        BuildSetting(key: .pbxcpBitcodeStripMode, value: \(value))
    }

    /// Pbxcp Bitcode Strip Mode
    public static func pbxcpBitcodeStripMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpBitcodeStripMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pbxcp Bitcode Strip Mode
    public static let pbxcpBitcodeStripMode: BuildSettingsKey = "PBXCP_BITCODE_STRIP_MODE"
}

public enum PbxcpBitcodeStripMode: String, Hashable, Codable, CustomStringConvertible {
    case none = "none"
    case all = "all"
    case replaceWithMarker = "replace-with-marker"

    public var description: String {
        rawValue
    }
}

// MARK: Pbxcp Bitcode Strip Tool
extension BuildSetting {

    /// Pbxcp Bitcode Strip Tool
    public static func pbxcpBitcodeStripTool(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pbxcpBitcodeStripTool, value: \(value))
    }

    /// Pbxcp Bitcode Strip Tool
    public static func pbxcpBitcodeStripTool(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpBitcodeStripTool, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pbxcp Bitcode Strip Tool
    public static let pbxcpBitcodeStripTool: BuildSettingsKey = "PBXCP_BITCODE_STRIP_TOOL"
}

// MARK: Pbxcp Ignore Missing Inputs
extension BuildSetting {

    /// Pbxcp Ignore Missing Inputs
    public static var pbxcpIgnoreMissingInputs: BuildSetting { 
        BuildSetting(key: .pbxcpIgnoreMissingInputs, value: "NO")
    }

    /// Pbxcp Ignore Missing Inputs
    public static func pbxcpIgnoreMissingInputs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pbxcpIgnoreMissingInputs, value: value.asText)
    }

    /// Pbxcp Ignore Missing Inputs
    public static func pbxcpIgnoreMissingInputs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpIgnoreMissingInputs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pbxcp Ignore Missing Inputs
    public static let pbxcpIgnoreMissingInputs: BuildSettingsKey = "PBXCP_IGNORE_MISSING_INPUTS"
}

// MARK: Pbxcp Strip Bitcode
extension BuildSetting {

    /// Pbxcp Strip Bitcode
    public static var pbxcpStripBitcode: BuildSetting { 
        BuildSetting(key: .pbxcpStripBitcode, value: "NO")
    }

    /// Pbxcp Strip Bitcode
    public static func pbxcpStripBitcode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pbxcpStripBitcode, value: value.asText)
    }

    /// Pbxcp Strip Bitcode
    public static func pbxcpStripBitcode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpStripBitcode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pbxcp Strip Bitcode
    public static let pbxcpStripBitcode: BuildSettingsKey = "PBXCP_STRIP_BITCODE"
}

// MARK: Pbxcp Strip Tool
extension BuildSetting {

    /// Pbxcp Strip Tool
    public static func pbxcpStripTool(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pbxcpStripTool, value: \(value))
    }

    /// Pbxcp Strip Tool
    public static func pbxcpStripTool(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpStripTool, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pbxcp Strip Tool
    public static let pbxcpStripTool: BuildSettingsKey = "PBXCP_STRIP_TOOL"
}

// MARK: Remove Header Directories
extension BuildSetting {

    /// Remove Header Directories
    public static var removeHeaderDirectories: BuildSetting { 
        BuildSetting(key: .removeHeaderDirectories, value: "NO")
    }

    /// Remove Header Directories
    public static func removeHeaderDirectories(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeHeaderDirectories, value: value.asText)
    }

    /// Remove Header Directories
    public static func removeHeaderDirectories(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeHeaderDirectories, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Remove Header Directories
    public static let removeHeaderDirectories: BuildSettingsKey = "REMOVE_HEADER_DIRECTORIES"
}

// MARK: Per Style Build Directories
extension BuildSetting {

    /// Per Style Build Directories
    public static var perStyleBuildDirectories: BuildSetting { 
        BuildSetting(key: .perStyleBuildDirectories, value: "YES")
    }

    /// Per Style Build Directories
    public static func perStyleBuildDirectories(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .perStyleBuildDirectories, value: value.asText)
    }

    /// Per Style Build Directories
    public static func perStyleBuildDirectories(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .perStyleBuildDirectories, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Per Style Build Directories
    public static let perStyleBuildDirectories: BuildSettingsKey = "PER_STYLE_BUILD_DIRECTORIES"
}

// MARK: Tapi Application Extension Api Only
extension BuildSetting {

    /// Tapi Application Extension Api Only
    public static var tapiApplicationExtensionApiOnly: BuildSetting { 
        .tapiApplicationExtensionApiOnly(inherit: .requireOnlyAppExtensionSafeApi) 
    }

    /// Tapi Application Extension Api Only
    public static func tapiApplicationExtensionApiOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiApplicationExtensionApiOnly, value: value.asText)
    }

    /// Tapi Application Extension Api Only
    public static func tapiApplicationExtensionApiOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiApplicationExtensionApiOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Application Extension Api Only
    public static let tapiApplicationExtensionApiOnly: BuildSettingsKey = "TAPI_APPLICATION_EXTENSION_API_ONLY"
}

// MARK: Tapi Archs
extension BuildSetting {

    /// Tapi Archs
    public static var tapiArchs: BuildSetting { 
        .tapiArchs(inherit: .architectures) 
    }

    /// Tapi Archs
    public static func tapiArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiArchs, value: .array(value))
    }

    /// Tapi Archs
    public static func tapiArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiArchs, inherit: key)
    }

    /// Tapi Archs
    public static func tapiArchs(_ value: String...) -> BuildSetting { 
        .tapiArchs(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Archs
    public static let tapiArchs: BuildSettingsKey = "TAPI_ARCHS"
}

// MARK: Tapi Deployment Target
extension BuildSetting {

    /// Tapi Deployment Target
    public static var tapiDeploymentTarget: BuildSetting { 
        BuildSetting(key: .tapiDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// Tapi Deployment Target
    public static func tapiDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiDeploymentTarget, value: \(value))
    }

    /// Tapi Deployment Target
    public static func tapiDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Deployment Target
    public static let tapiDeploymentTarget: BuildSettingsKey = "TAPI_DEPLOYMENT_TARGET"
}

// MARK: Tapi Dylib Allowable Clients
extension BuildSetting {

    /// Tapi Dylib Allowable Clients
    public static var tapiDylibAllowableClients: BuildSetting { 
        .tapiDylibAllowableClients(inherit: .dynamicLibraryAllowableClients) 
    }

    /// Tapi Dylib Allowable Clients
    public static func tapiDylibAllowableClients(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiDylibAllowableClients, value: .array(value))
    }

    /// Tapi Dylib Allowable Clients
    public static func tapiDylibAllowableClients(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDylibAllowableClients, inherit: key)
    }

    /// Tapi Dylib Allowable Clients
    public static func tapiDylibAllowableClients(_ value: String...) -> BuildSetting { 
        .tapiDylibAllowableClients(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Dylib Allowable Clients
    public static let tapiDylibAllowableClients: BuildSettingsKey = "TAPI_DYLIB_ALLOWABLE_CLIENTS"
}

// MARK: Tapi Dylib Compatibility Version
extension BuildSetting {

    /// Tapi Dylib Compatibility Version
    public static var tapiDylibCompatibilityVersion: BuildSetting { 
        .tapiDylibCompatibilityVersion(inherit: .compatibilityVersion) 
    }

    /// Tapi Dylib Compatibility Version
    public static func tapiDylibCompatibilityVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiDylibCompatibilityVersion, value: \(value))
    }

    /// Tapi Dylib Compatibility Version
    public static func tapiDylibCompatibilityVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDylibCompatibilityVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Dylib Compatibility Version
    public static let tapiDylibCompatibilityVersion: BuildSettingsKey = "TAPI_DYLIB_COMPATIBILITY_VERSION"
}

// MARK: Tapi Dylib Current Version
extension BuildSetting {

    /// Tapi Dylib Current Version
    public static var tapiDylibCurrentVersion: BuildSetting { 
        .tapiDylibCurrentVersion(inherit: .currentLibraryVersion) 
    }

    /// Tapi Dylib Current Version
    public static func tapiDylibCurrentVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiDylibCurrentVersion, value: \(value))
    }

    /// Tapi Dylib Current Version
    public static func tapiDylibCurrentVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDylibCurrentVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Dylib Current Version
    public static let tapiDylibCurrentVersion: BuildSettingsKey = "TAPI_DYLIB_CURRENT_VERSION"
}

// MARK: Tapi Dylib Install Name
extension BuildSetting {

    /// Tapi Dylib Install Name
    public static var tapiDylibInstallName: BuildSetting { 
        .tapiDylibInstallName(inherit: .dynamicLibraryInstallName) 
    }

    /// Tapi Dylib Install Name
    public static func tapiDylibInstallName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiDylibInstallName, value: \(value))
    }

    /// Tapi Dylib Install Name
    public static func tapiDylibInstallName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDylibInstallName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Dylib Install Name
    public static let tapiDylibInstallName: BuildSettingsKey = "TAPI_DYLIB_INSTALL_NAME"
}

// MARK: Tapi Emit Profiling Symbols
extension BuildSetting {

    /// Tapi Emit Profiling Symbols
    public static var tapiEmitProfilingSymbols: BuildSetting { 
        BuildSetting(key: .tapiEmitProfilingSymbols, value: "YES")
    }

    /// Tapi Emit Profiling Symbols
    public static func tapiEmitProfilingSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiEmitProfilingSymbols, value: value.asText)
    }

    /// Tapi Emit Profiling Symbols
    public static func tapiEmitProfilingSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiEmitProfilingSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Emit Profiling Symbols
    public static let tapiEmitProfilingSymbols: BuildSettingsKey = "TAPI_EMIT_PROFILING_SYMBOLS"
}

// MARK: Tapi Enable Modules
extension BuildSetting {

    /// Tapi Enable Modules
    public static var tapiEnableModules: BuildSetting { 
        BuildSetting(key: .tapiEnableModules, value: "NO")
    }

    /// Tapi Enable Modules
    public static func tapiEnableModules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiEnableModules, value: value.asText)
    }

    /// Tapi Enable Modules
    public static func tapiEnableModules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiEnableModules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Enable Modules
    public static let tapiEnableModules: BuildSettingsKey = "TAPI_ENABLE_MODULES"
}

// MARK: Tapi Enable Verification Mode
extension BuildSetting {

    /// Tapi Enable Verification Mode
    public static var tapiEnableVerificationMode: BuildSetting { 
        BuildSetting(key: .tapiEnableVerificationMode, value: "YES")
    }

    /// Tapi Enable Verification Mode
    public static func tapiEnableVerificationMode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiEnableVerificationMode, value: value.asText)
    }

    /// Tapi Enable Verification Mode
    public static func tapiEnableVerificationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiEnableVerificationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Enable Verification Mode
    public static let tapiEnableVerificationMode: BuildSettingsKey = "TAPI_ENABLE_VERIFICATION_MODE"
}

// MARK: Tapi Framework Search Paths
extension BuildSetting {

    /// Tapi Framework Search Paths
    public static var tapiFrameworkSearchPaths: BuildSetting { 
        .tapiFrameworkSearchPaths(inherit: .frameworkSearchPaths) 
    }

    /// Tapi Framework Search Paths
    public static func tapiFrameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiFrameworkSearchPaths, value: .array(value))
    }

    /// Tapi Framework Search Paths
    public static func tapiFrameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiFrameworkSearchPaths, inherit: key)
    }

    /// Tapi Framework Search Paths
    public static func tapiFrameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .tapiFrameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Framework Search Paths
    public static let tapiFrameworkSearchPaths: BuildSettingsKey = "TAPI_FRAMEWORK_SEARCH_PATHS"
}

// MARK: Tapi Header Search Paths
extension BuildSetting {

    /// Tapi Header Search Paths
    public static var tapiHeaderSearchPaths: BuildSetting { 
        .tapiHeaderSearchPaths(inherit: .headerSearchPaths) 
    }

    /// Tapi Header Search Paths
    public static func tapiHeaderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiHeaderSearchPaths, value: .array(value))
    }

    /// Tapi Header Search Paths
    public static func tapiHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiHeaderSearchPaths, inherit: key)
    }

    /// Tapi Header Search Paths
    public static func tapiHeaderSearchPaths(_ value: String...) -> BuildSetting { 
        .tapiHeaderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Header Search Paths
    public static let tapiHeaderSearchPaths: BuildSettingsKey = "TAPI_HEADER_SEARCH_PATHS"
}

// MARK: Tapi Inputs
extension BuildSetting {

    /// Tapi Inputs
    public static func tapiInputs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiInputs, value: .array(value))
    }

    /// Tapi Inputs
    public static func tapiInputs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiInputs, inherit: key)
    }

    /// Tapi Inputs
    public static func tapiInputs(_ value: String...) -> BuildSetting { 
        .tapiInputs(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Inputs
    public static let tapiInputs: BuildSettingsKey = "TAPI_INPUTS"
}

// MARK: Tapi Library Search Paths
extension BuildSetting {

    /// Tapi Library Search Paths
    public static var tapiLibrarySearchPaths: BuildSetting { 
        .tapiLibrarySearchPaths(inherit: .librarySearchPaths) 
    }

    /// Tapi Library Search Paths
    public static func tapiLibrarySearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiLibrarySearchPaths, value: .array(value))
    }

    /// Tapi Library Search Paths
    public static func tapiLibrarySearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiLibrarySearchPaths, inherit: key)
    }

    /// Tapi Library Search Paths
    public static func tapiLibrarySearchPaths(_ value: String...) -> BuildSetting { 
        .tapiLibrarySearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Library Search Paths
    public static let tapiLibrarySearchPaths: BuildSettingsKey = "TAPI_LIBRARY_SEARCH_PATHS"
}

// MARK: Tapi Modules Validate System Headers
extension BuildSetting {

    /// Tapi Modules Validate System Headers
    public static var tapiModulesValidateSystemHeaders: BuildSetting { 
        .tapiModulesValidateSystemHeaders(inherit: .clangModulesValidateSystemHeaders) 
    }

    /// Tapi Modules Validate System Headers
    public static func tapiModulesValidateSystemHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiModulesValidateSystemHeaders, value: value.asText)
    }

    /// Tapi Modules Validate System Headers
    public static func tapiModulesValidateSystemHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiModulesValidateSystemHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Modules Validate System Headers
    public static let tapiModulesValidateSystemHeaders: BuildSettingsKey = "TAPI_MODULES_VALIDATE_SYSTEM_HEADERS"
}

// MARK: Tapi Module Cache Path
extension BuildSetting {

    /// Tapi Module Cache Path
    public static var tapiModuleCachePath: BuildSetting { 
        .tapiModuleCachePath(inherit: .clangModuleCachePath) 
    }

    /// Tapi Module Cache Path
    public static func tapiModuleCachePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiModuleCachePath, value: \(value))
    }

    /// Tapi Module Cache Path
    public static func tapiModuleCachePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiModuleCachePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Module Cache Path
    public static let tapiModuleCachePath: BuildSettingsKey = "TAPI_MODULE_CACHE_PATH"
}

// MARK: Tapi Preprocessor Definitions
extension BuildSetting {

    /// Tapi Preprocessor Definitions
    public static var tapiPreprocessorDefinitions: BuildSetting { 
        BuildSetting(key: .tapiPreprocessorDefinitions, value: "$(GCC_PREPROCESSOR_DEFINITIONS) $(GCC_PREPROCESSOR_DEFINITIONS_NOT_USED_IN_PRECOMPS)")
    }

    /// Tapi Preprocessor Definitions
    public static func tapiPreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiPreprocessorDefinitions, value: .array(value))
    }

    /// Tapi Preprocessor Definitions
    public static func tapiPreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiPreprocessorDefinitions, inherit: key)
    }

    /// Tapi Preprocessor Definitions
    public static func tapiPreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .tapiPreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Preprocessor Definitions
    public static let tapiPreprocessorDefinitions: BuildSettingsKey = "TAPI_PREPROCESSOR_DEFINITIONS"
}

// MARK: Tapi Product Type
extension BuildSetting {

    /// Tapi Product Type
    public static var tapiProductType: BuildSetting { 
        .tapiProductType(inherit: .productType) 
    }

    /// Tapi Product Type
    public static func tapiProductType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiProductType, value: \(value))
    }

    /// Tapi Product Type
    public static func tapiProductType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiProductType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Product Type
    public static let tapiProductType: BuildSettingsKey = "TAPI_PRODUCT_TYPE"
}

// MARK: Tapi Reexported Framework Install Names
extension BuildSetting {

    /// Tapi Reexported Framework Install Names
    public static var tapiReexportedFrameworkInstallNames: BuildSetting { 
        .tapiReexportedFrameworkInstallNames(inherit: .reexportedFrameworkInstallNames) 
    }

    /// Tapi Reexported Framework Install Names
    public static func tapiReexportedFrameworkInstallNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedFrameworkInstallNames, value: .array(value))
    }

    /// Tapi Reexported Framework Install Names
    public static func tapiReexportedFrameworkInstallNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedFrameworkInstallNames, inherit: key)
    }

    /// Tapi Reexported Framework Install Names
    public static func tapiReexportedFrameworkInstallNames(_ value: String...) -> BuildSetting { 
        .tapiReexportedFrameworkInstallNames(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Reexported Framework Install Names
    public static let tapiReexportedFrameworkInstallNames: BuildSettingsKey = "TAPI_REEXPORTED_FRAMEWORK_INSTALL_NAMES"
}

// MARK: Tapi Reexported Framework Names
extension BuildSetting {

    /// Tapi Reexported Framework Names
    public static var tapiReexportedFrameworkNames: BuildSetting { 
        .tapiReexportedFrameworkNames(inherit: .reExportedFrameworkNames) 
    }

    /// Tapi Reexported Framework Names
    public static func tapiReexportedFrameworkNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedFrameworkNames, value: .array(value))
    }

    /// Tapi Reexported Framework Names
    public static func tapiReexportedFrameworkNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedFrameworkNames, inherit: key)
    }

    /// Tapi Reexported Framework Names
    public static func tapiReexportedFrameworkNames(_ value: String...) -> BuildSetting { 
        .tapiReexportedFrameworkNames(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Reexported Framework Names
    public static let tapiReexportedFrameworkNames: BuildSettingsKey = "TAPI_REEXPORTED_FRAMEWORK_NAMES"
}

// MARK: Tapi Reexported Library Install Names
extension BuildSetting {

    /// Tapi Reexported Library Install Names
    public static var tapiReexportedLibraryInstallNames: BuildSetting { 
        .tapiReexportedLibraryInstallNames(inherit: .reexportedLibraryInstallNames) 
    }

    /// Tapi Reexported Library Install Names
    public static func tapiReexportedLibraryInstallNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedLibraryInstallNames, value: .array(value))
    }

    /// Tapi Reexported Library Install Names
    public static func tapiReexportedLibraryInstallNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedLibraryInstallNames, inherit: key)
    }

    /// Tapi Reexported Library Install Names
    public static func tapiReexportedLibraryInstallNames(_ value: String...) -> BuildSetting { 
        .tapiReexportedLibraryInstallNames(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Reexported Library Install Names
    public static let tapiReexportedLibraryInstallNames: BuildSettingsKey = "TAPI_REEXPORTED_LIBRARY_INSTALL_NAMES"
}

// MARK: Tapi Reexported Library Names
extension BuildSetting {

    /// Tapi Reexported Library Names
    public static var tapiReexportedLibraryNames: BuildSetting { 
        .tapiReexportedLibraryNames(inherit: .reExportedLibraryNames) 
    }

    /// Tapi Reexported Library Names
    public static func tapiReexportedLibraryNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedLibraryNames, value: .array(value))
    }

    /// Tapi Reexported Library Names
    public static func tapiReexportedLibraryNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedLibraryNames, inherit: key)
    }

    /// Tapi Reexported Library Names
    public static func tapiReexportedLibraryNames(_ value: String...) -> BuildSetting { 
        .tapiReexportedLibraryNames(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Reexported Library Names
    public static let tapiReexportedLibraryNames: BuildSettingsKey = "TAPI_REEXPORTED_LIBRARY_NAMES"
}

// MARK: Tapi Reexported Library Paths
extension BuildSetting {

    /// Tapi Reexported Library Paths
    public static var tapiReexportedLibraryPaths: BuildSetting { 
        .tapiReexportedLibraryPaths(inherit: .reExportedLibraryPaths) 
    }

    /// Tapi Reexported Library Paths
    public static func tapiReexportedLibraryPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedLibraryPaths, value: .array(value))
    }

    /// Tapi Reexported Library Paths
    public static func tapiReexportedLibraryPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedLibraryPaths, inherit: key)
    }

    /// Tapi Reexported Library Paths
    public static func tapiReexportedLibraryPaths(_ value: String...) -> BuildSetting { 
        .tapiReexportedLibraryPaths(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Reexported Library Paths
    public static let tapiReexportedLibraryPaths: BuildSettingsKey = "TAPI_REEXPORTED_LIBRARY_PATHS"
}

// MARK: Tapi System Framework Search Paths
extension BuildSetting {

    /// Tapi System Framework Search Paths
    public static var tapiSystemFrameworkSearchPaths: BuildSetting { 
        .tapiSystemFrameworkSearchPaths(inherit: .systemFrameworkSearchPaths) 
    }

    /// Tapi System Framework Search Paths
    public static func tapiSystemFrameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiSystemFrameworkSearchPaths, value: .array(value))
    }

    /// Tapi System Framework Search Paths
    public static func tapiSystemFrameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiSystemFrameworkSearchPaths, inherit: key)
    }

    /// Tapi System Framework Search Paths
    public static func tapiSystemFrameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .tapiSystemFrameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Tapi System Framework Search Paths
    public static let tapiSystemFrameworkSearchPaths: BuildSettingsKey = "TAPI_SYSTEM_FRAMEWORK_SEARCH_PATHS"
}

// MARK: Tapi System Header Search Paths
extension BuildSetting {

    /// Tapi System Header Search Paths
    public static var tapiSystemHeaderSearchPaths: BuildSetting { 
        .tapiSystemHeaderSearchPaths(inherit: .systemHeaderSearchPaths) 
    }

    /// Tapi System Header Search Paths
    public static func tapiSystemHeaderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiSystemHeaderSearchPaths, value: .array(value))
    }

    /// Tapi System Header Search Paths
    public static func tapiSystemHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiSystemHeaderSearchPaths, inherit: key)
    }

    /// Tapi System Header Search Paths
    public static func tapiSystemHeaderSearchPaths(_ value: String...) -> BuildSetting { 
        .tapiSystemHeaderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Tapi System Header Search Paths
    public static let tapiSystemHeaderSearchPaths: BuildSettingsKey = "TAPI_SYSTEM_HEADER_SEARCH_PATHS"
}

// MARK: Tapi Target Triple Archs
extension BuildSetting {

    /// Tapi Target Triple Archs
    public static var tapiTargetTripleArchs: BuildSetting { 
        .tapiTargetTripleArchs(inherit: .architectures) 
    }

    /// Tapi Target Triple Archs
    public static func tapiTargetTripleArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiTargetTripleArchs, value: .array(value))
    }

    /// Tapi Target Triple Archs
    public static func tapiTargetTripleArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiTargetTripleArchs, inherit: key)
    }

    /// Tapi Target Triple Archs
    public static func tapiTargetTripleArchs(_ value: String...) -> BuildSetting { 
        .tapiTargetTripleArchs(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Target Triple Archs
    public static let tapiTargetTripleArchs: BuildSettingsKey = "TAPI_TARGET_TRIPLE_ARCHS"
}

// MARK: Tapi Target Triple Variants
extension BuildSetting {

    /// Tapi Target Triple Variants
    public static func tapiTargetTripleVariants(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiTargetTripleVariants, value: .array(value))
    }

    /// Tapi Target Triple Variants
    public static func tapiTargetTripleVariants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiTargetTripleVariants, inherit: key)
    }

    /// Tapi Target Triple Variants
    public static func tapiTargetTripleVariants(_ value: String...) -> BuildSetting { 
        .tapiTargetTripleVariants(value)
    }
}

extension BuildSettingsKey {

    /// Tapi Target Triple Variants
    public static let tapiTargetTripleVariants: BuildSettingsKey = "TAPI_TARGET_TRIPLE_VARIANTS"
}

// MARK: Tapi Verify Against
extension BuildSetting {

    /// Tapi Verify Against
    public static var tapiVerifyAgainst: BuildSetting { 
        BuildSetting(key: .tapiVerifyAgainst, value: "$(BuiltBinaryPath)")
    }

    /// Tapi Verify Against
    public static func tapiVerifyAgainst(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiVerifyAgainst, value: \(value))
    }

    /// Tapi Verify Against
    public static func tapiVerifyAgainst(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiVerifyAgainst, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Tapi Verify Against
    public static let tapiVerifyAgainst: BuildSettingsKey = "TAPI_VERIFY_AGAINST"
}

// MARK: Always Embed Swift Standard Libraries
extension BuildSetting {

    /// Always Embed Swift Standard Libraries
    ///
    /// Always embed the Swift standard libraries in the target’s products, even if the target does not contain any Swift code. For example, this should be enabled if the target is embedding other products which contain Swift, or if it is a test target which does not contain Swift but which is testing a product which does. This setting only applies to wrapped products, not to standalone binary products.
    public static var alwaysEmbedSwiftStandardLibraries: BuildSetting { 
        .alwaysEmbedSwiftStandardLibraries(inherit: .embeddedContentContainsSwift) 
    }

    /// Always Embed Swift Standard Libraries
    ///
    /// Always embed the Swift standard libraries in the target’s products, even if the target does not contain any Swift code. For example, this should be enabled if the target is embedding other products which contain Swift, or if it is a test target which does not contain Swift but which is testing a product which does. This setting only applies to wrapped products, not to standalone binary products.
    public static func alwaysEmbedSwiftStandardLibraries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .alwaysEmbedSwiftStandardLibraries, value: value.asText)
    }

    /// Always Embed Swift Standard Libraries
    ///
    /// Always embed the Swift standard libraries in the target’s products, even if the target does not contain any Swift code. For example, this should be enabled if the target is embedding other products which contain Swift, or if it is a test target which does not contain Swift but which is testing a product which does. This setting only applies to wrapped products, not to standalone binary products.
    public static func alwaysEmbedSwiftStandardLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alwaysEmbedSwiftStandardLibraries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Always Embed Swift Standard Libraries
    ///
    /// Always embed the Swift standard libraries in the target’s products, even if the target does not contain any Swift code. For example, this should be enabled if the target is embedding other products which contain Swift, or if it is a test target which does not contain Swift but which is testing a product which does. This setting only applies to wrapped products, not to standalone binary products.
    public static let alwaysEmbedSwiftStandardLibraries: BuildSettingsKey = "ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES"
}

// MARK: Embedded Content Contains Swift
extension BuildSetting {

    /// Embedded Content Contains Swift
    public static var embeddedContentContainsSwift: BuildSetting { 
        BuildSetting(key: .embeddedContentContainsSwift, value: "NO")
    }

    /// Embedded Content Contains Swift
    public static func embeddedContentContainsSwift(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .embeddedContentContainsSwift, value: value.asText)
    }

    /// Embedded Content Contains Swift
    public static func embeddedContentContainsSwift(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .embeddedContentContainsSwift, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Embedded Content Contains Swift
    public static let embeddedContentContainsSwift: BuildSettingsKey = "EMBEDDED_CONTENT_CONTAINS_SWIFT"
}

// MARK: Developer Dir
extension BuildSetting {

    /// Developer Dir
    public static func developerDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .developerDir, value: \(value))
    }

    /// Developer Dir
    public static func developerDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .developerDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Developer Dir
    public static let developerDir: BuildSettingsKey = "DEVELOPER_DIR"
}

// MARK: Other Swift Stdlib Tool Flags
extension BuildSetting {

    /// Other Swift Stdlib Tool Flags
    public static func otherSwiftStdlibToolFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherSwiftStdlibToolFlags, value: .array(value))
    }

    /// Other Swift Stdlib Tool Flags
    public static func otherSwiftStdlibToolFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherSwiftStdlibToolFlags, inherit: key)
    }

    /// Other Swift Stdlib Tool Flags
    public static func otherSwiftStdlibToolFlags(_ value: String...) -> BuildSetting { 
        .otherSwiftStdlibToolFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Swift Stdlib Tool Flags
    public static let otherSwiftStdlibToolFlags: BuildSettingsKey = "OTHER_SWIFT_STDLIB_TOOL_FLAGS"
}

// MARK: Product Type Swift Stdlib Tool Flags
extension BuildSetting {

    /// Product Type Swift Stdlib Tool Flags
    public static func productTypeSwiftStdlibToolFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .productTypeSwiftStdlibToolFlags, value: .array(value))
    }

    /// Product Type Swift Stdlib Tool Flags
    public static func productTypeSwiftStdlibToolFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productTypeSwiftStdlibToolFlags, inherit: key)
    }

    /// Product Type Swift Stdlib Tool Flags
    public static func productTypeSwiftStdlibToolFlags(_ value: String...) -> BuildSetting { 
        .productTypeSwiftStdlibToolFlags(value)
    }
}

extension BuildSettingsKey {

    /// Product Type Swift Stdlib Tool Flags
    public static let productTypeSwiftStdlibToolFlags: BuildSettingsKey = "PRODUCT_TYPE_SWIFT_STDLIB_TOOL_FLAGS"
}

// MARK: Swift Stdlib Tool Action
extension BuildSetting {

    /// Swift Stdlib Tool Action
    public static func swiftStdlibToolAction(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolAction, value: \(value))
    }

    /// Swift Stdlib Tool Action
    public static func swiftStdlibToolAction(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolAction, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Action
    public static let swiftStdlibToolAction: BuildSettingsKey = "SWIFT_STDLIB_TOOL_ACTION"
}

// MARK: Swift Stdlib Tool Code Sign Identity
extension BuildSetting {

    /// Swift Stdlib Tool Code Sign Identity
    public static var swiftStdlibToolCodeSignIdentity: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolCodeSignIdentity, value: "$(EXPANDED_CODE_SIGN_IDENTITY)")
    }

    /// Swift Stdlib Tool Code Sign Identity
    public static func swiftStdlibToolCodeSignIdentity(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolCodeSignIdentity, value: \(value))
    }

    /// Swift Stdlib Tool Code Sign Identity
    public static func swiftStdlibToolCodeSignIdentity(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolCodeSignIdentity, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Code Sign Identity
    public static let swiftStdlibToolCodeSignIdentity: BuildSettingsKey = "SWIFT_STDLIB_TOOL_CODE_SIGN_IDENTITY"
}

// MARK: Swift Stdlib Tool Destination Dir
extension BuildSetting {

    /// Swift Stdlib Tool Destination Dir
    public static var swiftStdlibToolDestinationDir: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolDestinationDir, value: "$(TARGET_BUILD_DIR)/$(FRAMEWORKS_FOLDER_PATH)")
    }

    /// Swift Stdlib Tool Destination Dir
    public static func swiftStdlibToolDestinationDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolDestinationDir, value: \(value))
    }

    /// Swift Stdlib Tool Destination Dir
    public static func swiftStdlibToolDestinationDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolDestinationDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Destination Dir
    public static let swiftStdlibToolDestinationDir: BuildSettingsKey = "SWIFT_STDLIB_TOOL_DESTINATION_DIR"
}

// MARK: Swift Stdlib Tool Executable To Scan
extension BuildSetting {

    /// Swift Stdlib Tool Executable To Scan
    public static var swiftStdlibToolExecutableToScan: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolExecutableToScan, value: "$(InputPath)")
    }

    /// Swift Stdlib Tool Executable To Scan
    public static func swiftStdlibToolExecutableToScan(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolExecutableToScan, value: \(value))
    }

    /// Swift Stdlib Tool Executable To Scan
    public static func swiftStdlibToolExecutableToScan(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolExecutableToScan, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Executable To Scan
    public static let swiftStdlibToolExecutableToScan: BuildSettingsKey = "SWIFT_STDLIB_TOOL_EXECUTABLE_TO_SCAN"
}

// MARK: Swift Stdlib Tool Folders To Scan
extension BuildSetting {

    /// Swift Stdlib Tool Folders To Scan
    public static func swiftStdlibToolFoldersToScan(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolFoldersToScan, value: .array(value))
    }

    /// Swift Stdlib Tool Folders To Scan
    public static func swiftStdlibToolFoldersToScan(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolFoldersToScan, inherit: key)
    }

    /// Swift Stdlib Tool Folders To Scan
    public static func swiftStdlibToolFoldersToScan(_ value: String...) -> BuildSetting { 
        .swiftStdlibToolFoldersToScan(value)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Folders To Scan
    public static let swiftStdlibToolFoldersToScan: BuildSettingsKey = "SWIFT_STDLIB_TOOL_FOLDERS_TO_SCAN"
}

// MARK: Swift Stdlib Tool Keychain
extension BuildSetting {

    /// Swift Stdlib Tool Keychain
    public static var swiftStdlibToolKeychain: BuildSetting { 
        .swiftStdlibToolKeychain(inherit: .codeSignKeychain) 
    }

    /// Swift Stdlib Tool Keychain
    public static func swiftStdlibToolKeychain(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolKeychain, value: \(value))
    }

    /// Swift Stdlib Tool Keychain
    public static func swiftStdlibToolKeychain(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolKeychain, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Keychain
    public static let swiftStdlibToolKeychain: BuildSettingsKey = "SWIFT_STDLIB_TOOL_KEYCHAIN"
}

// MARK: Swift Stdlib Tool Other Code Sign Flags
extension BuildSetting {

    /// Swift Stdlib Tool Other Code Sign Flags
    public static var swiftStdlibToolOtherCodeSignFlags: BuildSetting { 
        .swiftStdlibToolOtherCodeSignFlags(inherit: .otherCodeSigningFlags) 
    }

    /// Swift Stdlib Tool Other Code Sign Flags
    public static func swiftStdlibToolOtherCodeSignFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolOtherCodeSignFlags, value: .array(value))
    }

    /// Swift Stdlib Tool Other Code Sign Flags
    public static func swiftStdlibToolOtherCodeSignFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolOtherCodeSignFlags, inherit: key)
    }

    /// Swift Stdlib Tool Other Code Sign Flags
    public static func swiftStdlibToolOtherCodeSignFlags(_ value: String...) -> BuildSetting { 
        .swiftStdlibToolOtherCodeSignFlags(value)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Other Code Sign Flags
    public static let swiftStdlibToolOtherCodeSignFlags: BuildSettingsKey = "SWIFT_STDLIB_TOOL_OTHER_CODE_SIGN_FLAGS"
}

// MARK: Swift Stdlib Tool Source Libraries
extension BuildSetting {

    /// Swift Stdlib Tool Source Libraries
    public static var swiftStdlibToolSourceLibraries: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolSourceLibraries, value: "$(SWIFT_LIBRARY_PATH)")
    }

    /// Swift Stdlib Tool Source Libraries
    public static func swiftStdlibToolSourceLibraries(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolSourceLibraries, value: \(value))
    }

    /// Swift Stdlib Tool Source Libraries
    public static func swiftStdlibToolSourceLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolSourceLibraries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Source Libraries
    public static let swiftStdlibToolSourceLibraries: BuildSettingsKey = "SWIFT_STDLIB_TOOL_SOURCE_LIBRARIES"
}

// MARK: Swift Stdlib Tool Strip Bitcode
extension BuildSetting {

    /// Swift Stdlib Tool Strip Bitcode
    public static var swiftStdlibToolStripBitcode: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolStripBitcode, value: "YES")
    }

    /// Swift Stdlib Tool Strip Bitcode
    public static func swiftStdlibToolStripBitcode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolStripBitcode, value: value.asText)
    }

    /// Swift Stdlib Tool Strip Bitcode
    public static func swiftStdlibToolStripBitcode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolStripBitcode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Strip Bitcode
    public static let swiftStdlibToolStripBitcode: BuildSettingsKey = "SWIFT_STDLIB_TOOL_STRIP_BITCODE"
}

// MARK: Swift Stdlib Tool Toolchains
extension BuildSetting {

    /// Swift Stdlib Tool Toolchains
    public static var swiftStdlibToolToolchains: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolToolchains, value: "$(EFFECTIVE_TOOLCHAINS_DIRS)")
    }

    /// Swift Stdlib Tool Toolchains
    public static func swiftStdlibToolToolchains(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolToolchains, value: .array(value))
    }

    /// Swift Stdlib Tool Toolchains
    public static func swiftStdlibToolToolchains(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolToolchains, inherit: key)
    }

    /// Swift Stdlib Tool Toolchains
    public static func swiftStdlibToolToolchains(_ value: String...) -> BuildSetting { 
        .swiftStdlibToolToolchains(value)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Toolchains
    public static let swiftStdlibToolToolchains: BuildSettingsKey = "SWIFT_STDLIB_TOOL_TOOLCHAINS"
}

// MARK: Swift Stdlib Tool Unsigned Destination Dir
extension BuildSetting {

    /// Swift Stdlib Tool Unsigned Destination Dir
    public static func swiftStdlibToolUnsignedDestinationDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolUnsignedDestinationDir, value: \(value))
    }

    /// Swift Stdlib Tool Unsigned Destination Dir
    public static func swiftStdlibToolUnsignedDestinationDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolUnsignedDestinationDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Unsigned Destination Dir
    public static let swiftStdlibToolUnsignedDestinationDir: BuildSettingsKey = "SWIFT_STDLIB_TOOL_UNSIGNED_DESTINATION_DIR"
}

// MARK: Swift Stdlib Tool Verbosity
extension BuildSetting {

    /// Swift Stdlib Tool Verbosity
    public static var swiftStdlibToolVerbosity: BuildSetting { 
        .swiftStdlibToolVerbosity(.verbose) 
    }

    /// Swift Stdlib Tool Verbosity
    public static func swiftStdlibToolVerbosity(_ value: SwiftStdlibToolVerbosity) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolVerbosity, value: \(value))
    }

    /// Swift Stdlib Tool Verbosity
    public static func swiftStdlibToolVerbosity(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolVerbosity, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Stdlib Tool Verbosity
    public static let swiftStdlibToolVerbosity: BuildSettingsKey = "SWIFT_STDLIB_TOOL_VERBOSITY"
}

public enum SwiftStdlibToolVerbosity: String, Hashable, Codable, CustomStringConvertible {
    case verbose = "verbose"
    case extraVerbose = "extra-verbose"
    case none = "none"

    public var description: String {
        rawValue
    }
}

// MARK: Cpp Other Preprocessor Flags
extension BuildSetting {

    /// Cpp Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when using the standalone C Preprocessor rule.
    public static func cppOtherPreprocessorFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .cppOtherPreprocessorFlags, value: .array(value))
    }

    /// Cpp Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when using the standalone C Preprocessor rule.
    public static func cppOtherPreprocessorFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppOtherPreprocessorFlags, inherit: key)
    }

    /// Cpp Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when using the standalone C Preprocessor rule.
    public static func cppOtherPreprocessorFlags(_ value: String...) -> BuildSetting { 
        .cppOtherPreprocessorFlags(value)
    }
}

extension BuildSettingsKey {

    /// Cpp Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when using the standalone C Preprocessor rule.
    public static let cppOtherPreprocessorFlags: BuildSettingsKey = "CPP_OTHER_PREPROCESSOR_FLAGS"
}

// MARK: Cpp Prefix File
extension BuildSetting {

    /// Cpp Prefix File
    ///
    /// Implicitly include the given file when preprocessing using the standalone C Preprocessor rule. The path given should either be a project relative path or an absolute path.
    public static func cppPrefixFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppPrefixFile, value: \(value))
    }

    /// Cpp Prefix File
    ///
    /// Implicitly include the given file when preprocessing using the standalone C Preprocessor rule. The path given should either be a project relative path or an absolute path.
    public static func cppPrefixFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppPrefixFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Prefix File
    ///
    /// Implicitly include the given file when preprocessing using the standalone C Preprocessor rule. The path given should either be a project relative path or an absolute path.
    public static let cppPrefixFile: BuildSettingsKey = "CPP_PREFIX_HEADER"
}

// MARK: Cpp Preprocessor Definitions
extension BuildSetting {

    /// Cpp Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing using the standalone C Preprocessor rule.
    public static func cppPreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .cppPreprocessorDefinitions, value: .array(value))
    }

    /// Cpp Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing using the standalone C Preprocessor rule.
    public static func cppPreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppPreprocessorDefinitions, inherit: key)
    }

    /// Cpp Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing using the standalone C Preprocessor rule.
    public static func cppPreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .cppPreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// Cpp Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing using the standalone C Preprocessor rule.
    public static let cppPreprocessorDefinitions: BuildSettingsKey = "CPP_PREPROCESSOR_DEFINITIONS"
}

// MARK: Clang
extension BuildSetting {

    /// Clang
    public static var clang: BuildSetting { 
        BuildSetting(key: .clang, value: "clang")
    }

    /// Clang
    public static func clang(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clang, value: \(value))
    }

    /// Clang
    public static func clang(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clang, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang
    public static let clang: BuildSettingsKey = "CLANG"
}

// MARK: Clang Address Sanitizer
extension BuildSetting {

    /// Clang Address Sanitizer
    public static func clangAddressSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAddressSanitizer, value: value.asText)
    }

    /// Clang Address Sanitizer
    public static func clangAddressSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAddressSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Address Sanitizer
    public static let clangAddressSanitizer: BuildSettingsKey = "CLANG_ADDRESS_SANITIZER"
}

// MARK: Clang Address Sanitizer Allow Error Recovery
extension BuildSetting {

    /// Clang Address Sanitizer Allow Error Recovery
    public static var clangAddressSanitizerAllowErrorRecovery: BuildSetting { 
        BuildSetting(key: .clangAddressSanitizerAllowErrorRecovery, value: "$(ENABLE_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY)")
    }

    /// Clang Address Sanitizer Allow Error Recovery
    public static func clangAddressSanitizerAllowErrorRecovery(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAddressSanitizerAllowErrorRecovery, value: value.asText)
    }

    /// Clang Address Sanitizer Allow Error Recovery
    public static func clangAddressSanitizerAllowErrorRecovery(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAddressSanitizerAllowErrorRecovery, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Address Sanitizer Allow Error Recovery
    public static let clangAddressSanitizerAllowErrorRecovery: BuildSettingsKey = "CLANG_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY"
}

// MARK: Enable C++ Container Overflow Checks
extension BuildSetting {

    /// Enable C++ Container Overflow Checks
    ///
    /// Check for C++ container overflow when Address Sanitizer is enabled. This check requires the entire application to be built with Address Sanitizer. If not, it may report false positives.
    public static var enableCppContainerOverflowChecks: BuildSetting { 
        BuildSetting(key: .enableCppContainerOverflowChecks, value: "NO")
    }

    /// Enable C++ Container Overflow Checks
    ///
    /// Check for C++ container overflow when Address Sanitizer is enabled. This check requires the entire application to be built with Address Sanitizer. If not, it may report false positives.
    public static func enableCppContainerOverflowChecks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableCppContainerOverflowChecks, value: value.asText)
    }

    /// Enable C++ Container Overflow Checks
    ///
    /// Check for C++ container overflow when Address Sanitizer is enabled. This check requires the entire application to be built with Address Sanitizer. If not, it may report false positives.
    public static func enableCppContainerOverflowChecks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableCppContainerOverflowChecks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable C++ Container Overflow Checks
    ///
    /// Check for C++ container overflow when Address Sanitizer is enabled. This check requires the entire application to be built with Address Sanitizer. If not, it may report false positives.
    public static let enableCppContainerOverflowChecks: BuildSettingsKey = "CLANG_ADDRESS_SANITIZER_CONTAINER_OVERFLOW"
}

// MARK: Clang Address Sanitizer Use After Scope
extension BuildSetting {

    /// Clang Address Sanitizer Use After Scope
    public static var clangAddressSanitizerUseAfterScope: BuildSetting { 
        BuildSetting(key: .clangAddressSanitizerUseAfterScope, value: "NO")
    }

    /// Clang Address Sanitizer Use After Scope
    public static func clangAddressSanitizerUseAfterScope(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAddressSanitizerUseAfterScope, value: value.asText)
    }

    /// Clang Address Sanitizer Use After Scope
    public static func clangAddressSanitizerUseAfterScope(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAddressSanitizerUseAfterScope, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Address Sanitizer Use After Scope
    public static let clangAddressSanitizerUseAfterScope: BuildSettingsKey = "CLANG_ADDRESS_SANITIZER_USE_AFTER_SCOPE"
}

// MARK: Allow Non-modular Includes In Framework Modules
extension BuildSetting {

    /// Allow Non-modular Includes In Framework Modules
    ///
    /// Enabling this setting allows non-modular includes to be used from within framework modules. This is inherently unsafe, as such headers might cause duplicate definitions when used by any client that imports both the framework and the non-modular includes.
    public static var allowNonModularIncludesInFrameworkModules: BuildSetting { 
        BuildSetting(key: .allowNonModularIncludesInFrameworkModules, value: "NO")
    }

    /// Allow Non-modular Includes In Framework Modules
    ///
    /// Enabling this setting allows non-modular includes to be used from within framework modules. This is inherently unsafe, as such headers might cause duplicate definitions when used by any client that imports both the framework and the non-modular includes.
    public static func allowNonModularIncludesInFrameworkModules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .allowNonModularIncludesInFrameworkModules, value: value.asText)
    }

    /// Allow Non-modular Includes In Framework Modules
    ///
    /// Enabling this setting allows non-modular includes to be used from within framework modules. This is inherently unsafe, as such headers might cause duplicate definitions when used by any client that imports both the framework and the non-modular includes.
    public static func allowNonModularIncludesInFrameworkModules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .allowNonModularIncludesInFrameworkModules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Allow Non-modular Includes In Framework Modules
    ///
    /// Enabling this setting allows non-modular includes to be used from within framework modules. This is inherently unsafe, as such headers might cause duplicate definitions when used by any client that imports both the framework and the non-modular includes.
    public static let allowNonModularIncludesInFrameworkModules: BuildSettingsKey = "CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES"
}

// MARK: Clang Analyzer Alternate Edges
extension BuildSetting {

    /// Clang Analyzer Alternate Edges
    public static var clangAnalyzerAlternateEdges: BuildSetting { 
        BuildSetting(key: .clangAnalyzerAlternateEdges, value: "YES")
    }

    /// Clang Analyzer Alternate Edges
    public static func clangAnalyzerAlternateEdges(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerAlternateEdges, value: value.asText)
    }

    /// Clang Analyzer Alternate Edges
    public static func clangAnalyzerAlternateEdges(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerAlternateEdges, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Alternate Edges
    public static let clangAnalyzerAlternateEdges: BuildSettingsKey = "CLANG_ANALYZER_ALTERNATE_EDGES"
}

// MARK: Dead Stores
extension BuildSetting {

    /// Dead Stores
    ///
    /// Check for values stored to variables and never read again.
    public static var deadStores: BuildSetting { 
        BuildSetting(key: .deadStores, value: "YES")
    }

    /// Dead Stores
    ///
    /// Check for values stored to variables and never read again.
    public static func deadStores(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deadStores, value: value.asText)
    }

    /// Dead Stores
    ///
    /// Check for values stored to variables and never read again.
    public static func deadStores(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deadStores, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dead Stores
    ///
    /// Check for values stored to variables and never read again.
    public static let deadStores: BuildSettingsKey = "CLANG_ANALYZER_DEADCODE_DEADSTORES"
}

// MARK: Clang Analyzer Defines
extension BuildSetting {

    /// Clang Analyzer Defines
    public static var clangAnalyzerDefines: BuildSetting { 
        BuildSetting(key: .clangAnalyzerDefines, value: "-D__clang_analyzer__")
    }

    /// Clang Analyzer Defines
    public static func clangAnalyzerDefines(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerDefines, value: \(value))
    }

    /// Clang Analyzer Defines
    public static func clangAnalyzerDefines(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerDefines, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Defines
    public static let clangAnalyzerDefines: BuildSettingsKey = "CLANG_ANALYZER_DEFINES"
}

// MARK: Clang Analyzer Divide By Zero
extension BuildSetting {

    /// Clang Analyzer Divide By Zero
    public static var clangAnalyzerDivideByZero: BuildSetting { 
        BuildSetting(key: .clangAnalyzerDivideByZero, value: "YES")
    }

    /// Clang Analyzer Divide By Zero
    public static func clangAnalyzerDivideByZero(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerDivideByZero, value: value.asText)
    }

    /// Clang Analyzer Divide By Zero
    public static func clangAnalyzerDivideByZero(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerDivideByZero, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Divide By Zero
    public static let clangAnalyzerDivideByZero: BuildSettingsKey = "CLANG_ANALYZER_DIVIDE_BY_ZERO"
}

// MARK: Clang Analyzer Exec
extension BuildSetting {

    /// Clang Analyzer Exec
    public static var clangAnalyzerExec: BuildSetting { 
        BuildSetting(key: .clangAnalyzerExec, value: "clang")
    }

    /// Clang Analyzer Exec
    public static func clangAnalyzerExec(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerExec, value: \(value))
    }

    /// Clang Analyzer Exec
    public static func clangAnalyzerExec(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerExec, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Exec
    public static let clangAnalyzerExec: BuildSettingsKey = "CLANG_ANALYZER_EXEC"
}

// MARK: Misuse of Grand Central Dispatch
extension BuildSetting {

    /// Misuse of Grand Central Dispatch
    ///
    /// Check for misuses of the Grand Central Dispatch API.
    public static var misuseOfGrandCentralDispatch: BuildSetting { 
        BuildSetting(key: .misuseOfGrandCentralDispatch, value: "YES")
    }

    /// Misuse of Grand Central Dispatch
    ///
    /// Check for misuses of the Grand Central Dispatch API.
    public static func misuseOfGrandCentralDispatch(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .misuseOfGrandCentralDispatch, value: value.asText)
    }

    /// Misuse of Grand Central Dispatch
    ///
    /// Check for misuses of the Grand Central Dispatch API.
    public static func misuseOfGrandCentralDispatch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfGrandCentralDispatch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of Grand Central Dispatch
    ///
    /// Check for misuses of the Grand Central Dispatch API.
    public static let misuseOfGrandCentralDispatch: BuildSettingsKey = "CLANG_ANALYZER_GCD"
}

// MARK: Performance Anti-Patterns with Grand Central Dispatch
extension BuildSetting {

    /// Performance Anti-Patterns with Grand Central Dispatch
    ///
    /// Check for Grand Central Dispatch idioms that may lead to poor performance.
    public static var performanceAntiPatternsWithGrandCentralDispatch: BuildSetting { 
        BuildSetting(key: .performanceAntiPatternsWithGrandCentralDispatch, value: "NO")
    }

    /// Performance Anti-Patterns with Grand Central Dispatch
    ///
    /// Check for Grand Central Dispatch idioms that may lead to poor performance.
    public static func performanceAntiPatternsWithGrandCentralDispatch(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .performanceAntiPatternsWithGrandCentralDispatch, value: value.asText)
    }

    /// Performance Anti-Patterns with Grand Central Dispatch
    ///
    /// Check for Grand Central Dispatch idioms that may lead to poor performance.
    public static func performanceAntiPatternsWithGrandCentralDispatch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .performanceAntiPatternsWithGrandCentralDispatch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Performance Anti-Patterns with Grand Central Dispatch
    ///
    /// Check for Grand Central Dispatch idioms that may lead to poor performance.
    public static let performanceAntiPatternsWithGrandCentralDispatch: BuildSettingsKey = "CLANG_ANALYZER_GCD_PERFORMANCE"
}

// MARK: Violation of IOKit and libkern Reference Counting Rules
extension BuildSetting {

    /// Violation of IOKit and libkern Reference Counting Rules
    ///
    /// Finds leaks and overreleases associated with objects inheriting from OSObject
    public static var violationOfIokitAndLibkernReferenceCountingRules: BuildSetting { 
        BuildSetting(key: .violationOfIokitAndLibkernReferenceCountingRules, value: "YES")
    }

    /// Violation of IOKit and libkern Reference Counting Rules
    ///
    /// Finds leaks and overreleases associated with objects inheriting from OSObject
    public static func violationOfIokitAndLibkernReferenceCountingRules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .violationOfIokitAndLibkernReferenceCountingRules, value: value.asText)
    }

    /// Violation of IOKit and libkern Reference Counting Rules
    ///
    /// Finds leaks and overreleases associated with objects inheriting from OSObject
    public static func violationOfIokitAndLibkernReferenceCountingRules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .violationOfIokitAndLibkernReferenceCountingRules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Violation of IOKit and libkern Reference Counting Rules
    ///
    /// Finds leaks and overreleases associated with objects inheriting from OSObject
    public static let violationOfIokitAndLibkernReferenceCountingRules: BuildSettingsKey = "CLANG_ANALYZER_LIBKERN_RETAIN_COUNT"
}

// MARK: Missing Localization Context Comment
extension BuildSetting {

    /// Missing Localization Context Comment
    ///
    /// Warn when a call to an `NSLocalizedString()` macro is missing a context comment for the localizer.
    public static var missingLocalizationContextComment: BuildSetting { 
        BuildSetting(key: .missingLocalizationContextComment, value: "NO")
    }

    /// Missing Localization Context Comment
    ///
    /// Warn when a call to an `NSLocalizedString()` macro is missing a context comment for the localizer.
    public static func missingLocalizationContextComment(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingLocalizationContextComment, value: value.asText)
    }

    /// Missing Localization Context Comment
    ///
    /// Warn when a call to an `NSLocalizedString()` macro is missing a context comment for the localizer.
    public static func missingLocalizationContextComment(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingLocalizationContextComment, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Localization Context Comment
    ///
    /// Warn when a call to an `NSLocalizedString()` macro is missing a context comment for the localizer.
    public static let missingLocalizationContextComment: BuildSettingsKey = "CLANG_ANALYZER_LOCALIZABILITY_EMPTY_CONTEXT"
}

// MARK: Missing Localizability
extension BuildSetting {

    /// Missing Localizability
    ///
    /// Warn when a nonlocalized string is passed to a user interface method expecting a localized string.
    public static var missingLocalizability: BuildSetting { 
        BuildSetting(key: .missingLocalizability, value: "NO")
    }

    /// Missing Localizability
    ///
    /// Warn when a nonlocalized string is passed to a user interface method expecting a localized string.
    public static func missingLocalizability(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingLocalizability, value: value.asText)
    }

    /// Missing Localizability
    ///
    /// Warn when a nonlocalized string is passed to a user interface method expecting a localized string.
    public static func missingLocalizability(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingLocalizability, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Localizability
    ///
    /// Warn when a nonlocalized string is passed to a user interface method expecting a localized string.
    public static let missingLocalizability: BuildSettingsKey = "CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED"
}

// MARK: Clang Analyzer Malloc
extension BuildSetting {

    /// Clang Analyzer Malloc
    public static var clangAnalyzerMalloc: BuildSetting { 
        BuildSetting(key: .clangAnalyzerMalloc, value: "YES")
    }

    /// Clang Analyzer Malloc
    public static func clangAnalyzerMalloc(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerMalloc, value: value.asText)
    }

    /// Clang Analyzer Malloc
    public static func clangAnalyzerMalloc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerMalloc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Malloc
    public static let clangAnalyzerMalloc: BuildSettingsKey = "CLANG_ANALYZER_MALLOC"
}

// MARK: Improper Memory Management
extension BuildSetting {

    /// Improper Memory Management
    ///
    /// Warn about memory leaks, use-after-free, and other API misuses.
    public static var improperMemoryManagement: BuildSetting { 
        .improperMemoryManagement(inherit: .clangAnalyzerMalloc) 
    }

    /// Improper Memory Management
    ///
    /// Warn about memory leaks, use-after-free, and other API misuses.
    public static func improperMemoryManagement(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .improperMemoryManagement, value: value.asText)
    }

    /// Improper Memory Management
    ///
    /// Warn about memory leaks, use-after-free, and other API misuses.
    public static func improperMemoryManagement(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .improperMemoryManagement, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Improper Memory Management
    ///
    /// Warn about memory leaks, use-after-free, and other API misuses.
    public static let improperMemoryManagement: BuildSettingsKey = "CLANG_ANALYZER_MEMORY_MANAGEMENT"
}

// MARK: Violation of Mach Interface Generator Conventions
extension BuildSetting {

    /// Violation of Mach Interface Generator Conventions
    ///
    /// Warn when a MIG routine violates memory management conventions.
    public static var violationOfMachInterfaceGeneratorConventions: BuildSetting { 
        BuildSetting(key: .violationOfMachInterfaceGeneratorConventions, value: "YES")
    }

    /// Violation of Mach Interface Generator Conventions
    ///
    /// Warn when a MIG routine violates memory management conventions.
    public static func violationOfMachInterfaceGeneratorConventions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .violationOfMachInterfaceGeneratorConventions, value: value.asText)
    }

    /// Violation of Mach Interface Generator Conventions
    ///
    /// Warn when a MIG routine violates memory management conventions.
    public static func violationOfMachInterfaceGeneratorConventions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .violationOfMachInterfaceGeneratorConventions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Violation of Mach Interface Generator Conventions
    ///
    /// Warn when a MIG routine violates memory management conventions.
    public static let violationOfMachInterfaceGeneratorConventions: BuildSettingsKey = "CLANG_ANALYZER_MIG_CONVENTIONS"
}

// MARK: Misuse of 'nonnull'
extension BuildSetting {

    /// Misuse of 'nonnull'
    ///
    /// Check for misuses of `nonnull` parameter and return types.
    public static var misuseOfNonnull: BuildSetting { 
        .misuseOfNonnull(.yesNonaggressive) 
    }

    /// Misuse of 'nonnull'
    ///
    /// Check for misuses of `nonnull` parameter and return types.
    public static func misuseOfNonnull(_ value: MisuseOfNonnull) -> BuildSetting { 
        BuildSetting(key: .misuseOfNonnull, value: \(value))
    }

    /// Misuse of 'nonnull'
    ///
    /// Check for misuses of `nonnull` parameter and return types.
    public static func misuseOfNonnull(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfNonnull, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of 'nonnull'
    ///
    /// Check for misuses of `nonnull` parameter and return types.
    public static let misuseOfNonnull: BuildSettingsKey = "CLANG_ANALYZER_NONNULL"
}

public enum MisuseOfNonnull: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesNonaggressive = "YES_NONAGGRESSIVE"

    public var description: String {
        rawValue
    }
}

// MARK: Clang Analyzer Null Dereference
extension BuildSetting {

    /// Clang Analyzer Null Dereference
    public static var clangAnalyzerNullDereference: BuildSetting { 
        BuildSetting(key: .clangAnalyzerNullDereference, value: "YES")
    }

    /// Clang Analyzer Null Dereference
    public static func clangAnalyzerNullDereference(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerNullDereference, value: value.asText)
    }

    /// Clang Analyzer Null Dereference
    public static func clangAnalyzerNullDereference(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerNullDereference, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Null Dereference
    public static let clangAnalyzerNullDereference: BuildSettingsKey = "CLANG_ANALYZER_NULL_DEREFERENCE"
}

// MARK: Suspicious Conversions of NSNumber and CFNumberRef
extension BuildSetting {

    /// Suspicious Conversions of NSNumber and CFNumberRef
    ///
    /// Warn when a number object, such as an instance of `NSNumber`, `CFNumberRef`, `OSNumber`, or `OSBoolean` is compared or converted to a primitive value instead of another object.
    public static var suspiciousConversionsOfNsnumberAndCfnumberref: BuildSetting { 
        .suspiciousConversionsOfNsnumberAndCfnumberref(.yes) 
    }

    /// Suspicious Conversions of NSNumber and CFNumberRef
    ///
    /// Warn when a number object, such as an instance of `NSNumber`, `CFNumberRef`, `OSNumber`, or `OSBoolean` is compared or converted to a primitive value instead of another object.
    public static func suspiciousConversionsOfNsnumberAndCfnumberref(_ value: SuspiciousConversionsOfNsnumberAndCfnumberref) -> BuildSetting { 
        BuildSetting(key: .suspiciousConversionsOfNsnumberAndCfnumberref, value: \(value))
    }

    /// Suspicious Conversions of NSNumber and CFNumberRef
    ///
    /// Warn when a number object, such as an instance of `NSNumber`, `CFNumberRef`, `OSNumber`, or `OSBoolean` is compared or converted to a primitive value instead of another object.
    public static func suspiciousConversionsOfNsnumberAndCfnumberref(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousConversionsOfNsnumberAndCfnumberref, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Conversions of NSNumber and CFNumberRef
    ///
    /// Warn when a number object, such as an instance of `NSNumber`, `CFNumberRef`, `OSNumber`, or `OSBoolean` is compared or converted to a primitive value instead of another object.
    public static let suspiciousConversionsOfNsnumberAndCfnumberref: BuildSettingsKey = "CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION"
}

public enum SuspiciousConversionsOfNsnumberAndCfnumberref: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesAggressive = "YES_AGGRESSIVE"

    public var description: String {
        rawValue
    }
}

// MARK: @synchronized with nil mutex
extension BuildSetting {

    /// @synchronized with nil mutex
    ///
    /// Warn on `nil` pointers used as mutexes for `@synchronized`.
    public static var SynchronizedWithNilMutex: BuildSetting { 
        BuildSetting(key: .SynchronizedWithNilMutex, value: "YES")
    }

    /// @synchronized with nil mutex
    ///
    /// Warn on `nil` pointers used as mutexes for `@synchronized`.
    public static func SynchronizedWithNilMutex(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .SynchronizedWithNilMutex, value: value.asText)
    }

    /// @synchronized with nil mutex
    ///
    /// Warn on `nil` pointers used as mutexes for `@synchronized`.
    public static func SynchronizedWithNilMutex(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .SynchronizedWithNilMutex, inherit: key)
    }
}

extension BuildSettingsKey {

    /// @synchronized with nil mutex
    ///
    /// Warn on `nil` pointers used as mutexes for `@synchronized`.
    public static let SynchronizedWithNilMutex: BuildSettingsKey = "CLANG_ANALYZER_OBJC_ATSYNC"
}

// MARK: Misuse of Collections API
extension BuildSetting {

    /// Misuse of Collections API
    ///
    /// Warn if `CF` collections are created with non-pointer-size values. Check if `NS` collections are initialized with non-Objective-C type elements.
    public static var misuseOfCollectionsApi: BuildSetting { 
        BuildSetting(key: .misuseOfCollectionsApi, value: "YES")
    }

    /// Misuse of Collections API
    ///
    /// Warn if `CF` collections are created with non-pointer-size values. Check if `NS` collections are initialized with non-Objective-C type elements.
    public static func misuseOfCollectionsApi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .misuseOfCollectionsApi, value: value.asText)
    }

    /// Misuse of Collections API
    ///
    /// Warn if `CF` collections are created with non-pointer-size values. Check if `NS` collections are initialized with non-Objective-C type elements.
    public static func misuseOfCollectionsApi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfCollectionsApi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of Collections API
    ///
    /// Warn if `CF` collections are created with non-pointer-size values. Check if `NS` collections are initialized with non-Objective-C type elements.
    public static let misuseOfCollectionsApi: BuildSettingsKey = "CLANG_ANALYZER_OBJC_COLLECTIONS"
}

// MARK: Improper Instance Cleanup in '-dealloc'
extension BuildSetting {

    /// Improper Instance Cleanup in '-dealloc'
    ///
    /// Warn when an instance is improperly cleaned up in `-dealloc`.
    public static var improperInstanceCleanupInDealloc: BuildSetting { 
        BuildSetting(key: .improperInstanceCleanupInDealloc, value: "YES")
    }

    /// Improper Instance Cleanup in '-dealloc'
    ///
    /// Warn when an instance is improperly cleaned up in `-dealloc`.
    public static func improperInstanceCleanupInDealloc(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .improperInstanceCleanupInDealloc, value: value.asText)
    }

    /// Improper Instance Cleanup in '-dealloc'
    ///
    /// Warn when an instance is improperly cleaned up in `-dealloc`.
    public static func improperInstanceCleanupInDealloc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .improperInstanceCleanupInDealloc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Improper Instance Cleanup in '-dealloc'
    ///
    /// Warn when an instance is improperly cleaned up in `-dealloc`.
    public static let improperInstanceCleanupInDealloc: BuildSettingsKey = "CLANG_ANALYZER_OBJC_DEALLOC"
}

// MARK: Misuse of Objective-C generics
extension BuildSetting {

    /// Misuse of Objective-C generics
    ///
    /// Warn if a specialized generic type is converted to an incompatible type.
    public static var misuseOfObjectiveCGenerics: BuildSetting { 
        BuildSetting(key: .misuseOfObjectiveCGenerics, value: "YES")
    }

    /// Misuse of Objective-C generics
    ///
    /// Warn if a specialized generic type is converted to an incompatible type.
    public static func misuseOfObjectiveCGenerics(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .misuseOfObjectiveCGenerics, value: value.asText)
    }

    /// Misuse of Objective-C generics
    ///
    /// Warn if a specialized generic type is converted to an incompatible type.
    public static func misuseOfObjectiveCGenerics(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfObjectiveCGenerics, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of Objective-C generics
    ///
    /// Warn if a specialized generic type is converted to an incompatible type.
    public static let misuseOfObjectiveCGenerics: BuildSettingsKey = "CLANG_ANALYZER_OBJC_GENERICS"
}

// MARK: Method Signatures Mismatch
extension BuildSetting {

    /// Method Signatures Mismatch
    ///
    /// Warn about Objective-C method signatures with type incompatibilities.
    public static var methodSignaturesMismatch: BuildSetting { 
        BuildSetting(key: .methodSignaturesMismatch, value: "YES")
    }

    /// Method Signatures Mismatch
    ///
    /// Warn about Objective-C method signatures with type incompatibilities.
    public static func methodSignaturesMismatch(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .methodSignaturesMismatch, value: value.asText)
    }

    /// Method Signatures Mismatch
    ///
    /// Warn about Objective-C method signatures with type incompatibilities.
    public static func methodSignaturesMismatch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .methodSignaturesMismatch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Method Signatures Mismatch
    ///
    /// Warn about Objective-C method signatures with type incompatibilities.
    public static let methodSignaturesMismatch: BuildSettingsKey = "CLANG_ANALYZER_OBJC_INCOMP_METHOD_TYPES"
}

// MARK: Improper Handling of CFError and NSError
extension BuildSetting {

    /// Improper Handling of CFError and NSError
    ///
    /// Warn if functions accepting `CFErrorRef` or `NSError` cannot indicate that an error occurred.
    public static var improperHandlingOfCferrorAndNserror: BuildSetting { 
        BuildSetting(key: .improperHandlingOfCferrorAndNserror, value: "YES")
    }

    /// Improper Handling of CFError and NSError
    ///
    /// Warn if functions accepting `CFErrorRef` or `NSError` cannot indicate that an error occurred.
    public static func improperHandlingOfCferrorAndNserror(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .improperHandlingOfCferrorAndNserror, value: value.asText)
    }

    /// Improper Handling of CFError and NSError
    ///
    /// Warn if functions accepting `CFErrorRef` or `NSError` cannot indicate that an error occurred.
    public static func improperHandlingOfCferrorAndNserror(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .improperHandlingOfCferrorAndNserror, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Improper Handling of CFError and NSError
    ///
    /// Warn if functions accepting `CFErrorRef` or `NSError` cannot indicate that an error occurred.
    public static let improperHandlingOfCferrorAndNserror: BuildSettingsKey = "CLANG_ANALYZER_OBJC_NSCFERROR"
}

// MARK: Violation of Reference Counting Rules
extension BuildSetting {

    /// Violation of Reference Counting Rules
    ///
    /// Warn on leaks and improper reference count management.
    public static var violationOfReferenceCountingRules: BuildSetting { 
        BuildSetting(key: .violationOfReferenceCountingRules, value: "YES")
    }

    /// Violation of Reference Counting Rules
    ///
    /// Warn on leaks and improper reference count management.
    public static func violationOfReferenceCountingRules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .violationOfReferenceCountingRules, value: value.asText)
    }

    /// Violation of Reference Counting Rules
    ///
    /// Warn on leaks and improper reference count management.
    public static func violationOfReferenceCountingRules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .violationOfReferenceCountingRules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Violation of Reference Counting Rules
    ///
    /// Warn on leaks and improper reference count management.
    public static let violationOfReferenceCountingRules: BuildSettingsKey = "CLANG_ANALYZER_OBJC_RETAIN_COUNT"
}

// MARK: Violation of 'self = `super init`' Rule
extension BuildSetting {

    /// Violation of 'self = `super init`' Rule
    ///
    /// Check that `super init` is properly called within an Objective-C initialization method.
    public static var violationOfSelfSuperInitRule: BuildSetting { 
        BuildSetting(key: .violationOfSelfSuperInitRule, value: "YES")
    }

    /// Violation of 'self = `super init`' Rule
    ///
    /// Check that `super init` is properly called within an Objective-C initialization method.
    public static func violationOfSelfSuperInitRule(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .violationOfSelfSuperInitRule, value: value.asText)
    }

    /// Violation of 'self = `super init`' Rule
    ///
    /// Check that `super init` is properly called within an Objective-C initialization method.
    public static func violationOfSelfSuperInitRule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .violationOfSelfSuperInitRule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Violation of 'self = `super init`' Rule
    ///
    /// Check that `super init` is properly called within an Objective-C initialization method.
    public static let violationOfSelfSuperInitRule: BuildSettingsKey = "CLANG_ANALYZER_OBJC_SELF_INIT"
}

// MARK: Unused Ivars
extension BuildSetting {

    /// Unused Ivars
    ///
    /// Warn about private ivars that are never used.
    public static var unusedIvars: BuildSetting { 
        BuildSetting(key: .unusedIvars, value: "YES")
    }

    /// Unused Ivars
    ///
    /// Warn about private ivars that are never used.
    public static func unusedIvars(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedIvars, value: value.asText)
    }

    /// Unused Ivars
    ///
    /// Warn about private ivars that are never used.
    public static func unusedIvars(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedIvars, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Ivars
    ///
    /// Warn about private ivars that are never used.
    public static let unusedIvars: BuildSettingsKey = "CLANG_ANALYZER_OBJC_UNUSED_IVARS"
}

// MARK: Clang Analyzer Other Checkers
extension BuildSetting {

    /// Clang Analyzer Other Checkers
    public static func clangAnalyzerOtherCheckers(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerOtherCheckers, value: .array(value))
    }

    /// Clang Analyzer Other Checkers
    public static func clangAnalyzerOtherCheckers(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerOtherCheckers, inherit: key)
    }

    /// Clang Analyzer Other Checkers
    public static func clangAnalyzerOtherCheckers(_ value: String...) -> BuildSetting { 
        .clangAnalyzerOtherCheckers(value)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Other Checkers
    public static let clangAnalyzerOtherCheckers: BuildSettingsKey = "CLANG_ANALYZER_OTHER_CHECKERS"
}

// MARK: Clang Analyzer Other Flags
extension BuildSetting {

    /// Clang Analyzer Other Flags
    public static func clangAnalyzerOtherFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerOtherFlags, value: .array(value))
    }

    /// Clang Analyzer Other Flags
    public static func clangAnalyzerOtherFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerOtherFlags, inherit: key)
    }

    /// Clang Analyzer Other Flags
    public static func clangAnalyzerOtherFlags(_ value: String...) -> BuildSetting { 
        .clangAnalyzerOtherFlags(value)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Other Flags
    public static let clangAnalyzerOtherFlags: BuildSettingsKey = "CLANG_ANALYZER_OTHER_FLAGS"
}

// MARK: Clang Analyzer Output
extension BuildSetting {

    /// Clang Analyzer Output
    public static var clangAnalyzerOutput: BuildSetting { 
        .clangAnalyzerOutput(.plistMultiFile) 
    }

    /// Clang Analyzer Output
    public static func clangAnalyzerOutput(_ value: ClangAnalyzerOutput) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerOutput, value: \(value))
    }

    /// Clang Analyzer Output
    public static func clangAnalyzerOutput(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerOutput, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Output
    public static let clangAnalyzerOutput: BuildSettingsKey = "CLANG_ANALYZER_OUTPUT"
}

public enum ClangAnalyzerOutput: String, Hashable, Codable, CustomStringConvertible {
    case plistMultiFile = "plist-multi-file"
    case `default` = "default"

    public var description: String {
        rawValue
    }
}

// MARK: Clang Analyzer Output Dir
extension BuildSetting {

    /// Clang Analyzer Output Dir
    public static var clangAnalyzerOutputDir: BuildSetting { 
        .clangAnalyzerOutputDir(inherit: .tempDir) 
    }

    /// Clang Analyzer Output Dir
    public static func clangAnalyzerOutputDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerOutputDir, value: \(value))
    }

    /// Clang Analyzer Output Dir
    public static func clangAnalyzerOutputDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerOutputDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Output Dir
    public static let clangAnalyzerOutputDir: BuildSettingsKey = "CLANG_ANALYZER_OUTPUT_DIR"
}

// MARK: Clang Analyzer Report Main Source File
extension BuildSetting {

    /// Clang Analyzer Report Main Source File
    public static var clangAnalyzerReportMainSourceFile: BuildSetting { 
        BuildSetting(key: .clangAnalyzerReportMainSourceFile, value: "YES")
    }

    /// Clang Analyzer Report Main Source File
    public static func clangAnalyzerReportMainSourceFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerReportMainSourceFile, value: value.asText)
    }

    /// Clang Analyzer Report Main Source File
    public static func clangAnalyzerReportMainSourceFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerReportMainSourceFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Analyzer Report Main Source File
    public static let clangAnalyzerReportMainSourceFile: BuildSettingsKey = "CLANG_ANALYZER_REPORT_MAIN_SOURCE_FILE"
}

// MARK: *EXPERIMENTAL* Buffer overflows
extension BuildSetting {

    /// *EXPERIMENTAL* Buffer overflows
    ///
    /// Check for potential buffer overflows.
    public static var ExperimentalBufferOverflows: BuildSetting { 
        BuildSetting(key: .ExperimentalBufferOverflows, value: "NO")
    }

    /// *EXPERIMENTAL* Buffer overflows
    ///
    /// Check for potential buffer overflows.
    public static func ExperimentalBufferOverflows(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ExperimentalBufferOverflows, value: value.asText)
    }

    /// *EXPERIMENTAL* Buffer overflows
    ///
    /// Check for potential buffer overflows.
    public static func ExperimentalBufferOverflows(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ExperimentalBufferOverflows, inherit: key)
    }
}

extension BuildSettingsKey {

    /// *EXPERIMENTAL* Buffer overflows
    ///
    /// Check for potential buffer overflows.
    public static let ExperimentalBufferOverflows: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_BUFFER_OVERFLOW_EXPERIMENTAL"
}

// MARK: Floating Point Value Used as Loop Counter
extension BuildSetting {

    /// Floating Point Value Used as Loop Counter
    ///
    /// Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP).
    public static var floatingPointValueUsedAsLoopCounter: BuildSetting { 
        BuildSetting(key: .floatingPointValueUsedAsLoopCounter, value: "NO")
    }

    /// Floating Point Value Used as Loop Counter
    ///
    /// Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP).
    public static func floatingPointValueUsedAsLoopCounter(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .floatingPointValueUsedAsLoopCounter, value: value.asText)
    }

    /// Floating Point Value Used as Loop Counter
    ///
    /// Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP).
    public static func floatingPointValueUsedAsLoopCounter(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .floatingPointValueUsedAsLoopCounter, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Floating Point Value Used as Loop Counter
    ///
    /// Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP).
    public static let floatingPointValueUsedAsLoopCounter: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_FLOATLOOPCOUNTER"
}

// MARK: Use of 'getpw', 'gets' (Buffer Overflow)
extension BuildSetting {

    /// Use of 'getpw', 'gets' (Buffer Overflow)
    ///
    /// Warn on uses of `getpw` and `gets`. The functions are dangerous as they may trigger a buffer overflow.
    public static var useOfGetpwGetsBufferOverflow: BuildSetting { 
        BuildSetting(key: .useOfGetpwGetsBufferOverflow, value: "YES")
    }

    /// Use of 'getpw', 'gets' (Buffer Overflow)
    ///
    /// Warn on uses of `getpw` and `gets`. The functions are dangerous as they may trigger a buffer overflow.
    public static func useOfGetpwGetsBufferOverflow(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfGetpwGetsBufferOverflow, value: value.asText)
    }

    /// Use of 'getpw', 'gets' (Buffer Overflow)
    ///
    /// Warn on uses of `getpw` and `gets`. The functions are dangerous as they may trigger a buffer overflow.
    public static func useOfGetpwGetsBufferOverflow(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfGetpwGetsBufferOverflow, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'getpw', 'gets' (Buffer Overflow)
    ///
    /// Warn on uses of `getpw` and `gets`. The functions are dangerous as they may trigger a buffer overflow.
    public static let useOfGetpwGetsBufferOverflow: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_GETPW_GETS"
}

// MARK: Use of 'mktemp' or Predictable 'mktemps'
extension BuildSetting {

    /// Use of 'mktemp' or Predictable 'mktemps'
    ///
    /// Warn on uses of `mktemp`, which produces predictable temporary files. It is obsoleted by `mktemps`. Warn when `mkstemp` is passed fewer than 6 `X`’s in the format string.
    public static var useOfMktempOrPredictableMktemps: BuildSetting { 
        BuildSetting(key: .useOfMktempOrPredictableMktemps, value: "YES")
    }

    /// Use of 'mktemp' or Predictable 'mktemps'
    ///
    /// Warn on uses of `mktemp`, which produces predictable temporary files. It is obsoleted by `mktemps`. Warn when `mkstemp` is passed fewer than 6 `X`’s in the format string.
    public static func useOfMktempOrPredictableMktemps(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfMktempOrPredictableMktemps, value: value.asText)
    }

    /// Use of 'mktemp' or Predictable 'mktemps'
    ///
    /// Warn on uses of `mktemp`, which produces predictable temporary files. It is obsoleted by `mktemps`. Warn when `mkstemp` is passed fewer than 6 `X`’s in the format string.
    public static func useOfMktempOrPredictableMktemps(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfMktempOrPredictableMktemps, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'mktemp' or Predictable 'mktemps'
    ///
    /// Warn on uses of `mktemp`, which produces predictable temporary files. It is obsoleted by `mktemps`. Warn when `mkstemp` is passed fewer than 6 `X`’s in the format string.
    public static let useOfMktempOrPredictableMktemps: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_MKSTEMP"
}

// MARK: Use of 'rand' Functions
extension BuildSetting {

    /// Use of 'rand' Functions
    ///
    /// Warn on uses of `rand`, `random`, and related functions, which produce predictable random number sequences. Use `arc4random` instead.
    public static var useOfRandFunctions: BuildSetting { 
        BuildSetting(key: .useOfRandFunctions, value: "NO")
    }

    /// Use of 'rand' Functions
    ///
    /// Warn on uses of `rand`, `random`, and related functions, which produce predictable random number sequences. Use `arc4random` instead.
    public static func useOfRandFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfRandFunctions, value: value.asText)
    }

    /// Use of 'rand' Functions
    ///
    /// Warn on uses of `rand`, `random`, and related functions, which produce predictable random number sequences. Use `arc4random` instead.
    public static func useOfRandFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfRandFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'rand' Functions
    ///
    /// Warn on uses of `rand`, `random`, and related functions, which produce predictable random number sequences. Use `arc4random` instead.
    public static let useOfRandFunctions: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_RAND"
}

// MARK: Use of 'strcpy' and 'strcat'
extension BuildSetting {

    /// Use of 'strcpy' and 'strcat'
    ///
    /// Warn on uses of the `strcpy` and `strcat` functions, which can result in buffer overflows. Use `strlcpy` or `strlcat` instead.
    public static var useOfStrcpyAndStrcat: BuildSetting { 
        BuildSetting(key: .useOfStrcpyAndStrcat, value: "NO")
    }

    /// Use of 'strcpy' and 'strcat'
    ///
    /// Warn on uses of the `strcpy` and `strcat` functions, which can result in buffer overflows. Use `strlcpy` or `strlcat` instead.
    public static func useOfStrcpyAndStrcat(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfStrcpyAndStrcat, value: value.asText)
    }

    /// Use of 'strcpy' and 'strcat'
    ///
    /// Warn on uses of the `strcpy` and `strcat` functions, which can result in buffer overflows. Use `strlcpy` or `strlcat` instead.
    public static func useOfStrcpyAndStrcat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfStrcpyAndStrcat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'strcpy' and 'strcat'
    ///
    /// Warn on uses of the `strcpy` and `strcat` functions, which can result in buffer overflows. Use `strlcpy` or `strlcat` instead.
    public static let useOfStrcpyAndStrcat: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_STRCPY"
}

// MARK: Unchecked Return Values
extension BuildSetting {

    /// Unchecked Return Values
    ///
    /// Warn on uses of sensitive functions whose return values must be always checked.
    public static var uncheckedReturnValues: BuildSetting { 
        BuildSetting(key: .uncheckedReturnValues, value: "YES")
    }

    /// Unchecked Return Values
    ///
    /// Warn on uses of sensitive functions whose return values must be always checked.
    public static func uncheckedReturnValues(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .uncheckedReturnValues, value: value.asText)
    }

    /// Unchecked Return Values
    ///
    /// Warn on uses of sensitive functions whose return values must be always checked.
    public static func uncheckedReturnValues(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .uncheckedReturnValues, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unchecked Return Values
    ///
    /// Warn on uses of sensitive functions whose return values must be always checked.
    public static let uncheckedReturnValues: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_UNCHECKEDRETURN"
}

// MARK: Use of 'vfork'
extension BuildSetting {

    /// Use of 'vfork'
    ///
    /// Warn on uses of the `vfork` function, which is inherently insecure. Use the safer `posix_spawn` function instead.
    public static var useOfVfork: BuildSetting { 
        BuildSetting(key: .useOfVfork, value: "YES")
    }

    /// Use of 'vfork'
    ///
    /// Warn on uses of the `vfork` function, which is inherently insecure. Use the safer `posix_spawn` function instead.
    public static func useOfVfork(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfVfork, value: value.asText)
    }

    /// Use of 'vfork'
    ///
    /// Warn on uses of the `vfork` function, which is inherently insecure. Use the safer `posix_spawn` function instead.
    public static func useOfVfork(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfVfork, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'vfork'
    ///
    /// Warn on uses of the `vfork` function, which is inherently insecure. Use the safer `posix_spawn` function instead.
    public static let useOfVfork: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_VFORK"
}

// MARK: Misuse of Keychain Services API
extension BuildSetting {

    /// Misuse of Keychain Services API
    ///
    /// Check for leaks of keychain attribute lists and data buffers returned by the Keychain Services API.
    public static var misuseOfKeychainServicesApi: BuildSetting { 
        BuildSetting(key: .misuseOfKeychainServicesApi, value: "YES")
    }

    /// Misuse of Keychain Services API
    ///
    /// Check for leaks of keychain attribute lists and data buffers returned by the Keychain Services API.
    public static func misuseOfKeychainServicesApi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .misuseOfKeychainServicesApi, value: value.asText)
    }

    /// Misuse of Keychain Services API
    ///
    /// Check for leaks of keychain attribute lists and data buffers returned by the Keychain Services API.
    public static func misuseOfKeychainServicesApi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfKeychainServicesApi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of Keychain Services API
    ///
    /// Check for leaks of keychain attribute lists and data buffers returned by the Keychain Services API.
    public static let misuseOfKeychainServicesApi: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_KEYCHAIN_API"
}

// MARK: Use-After-Move Errors in C++
extension BuildSetting {

    /// Use-After-Move Errors in C++
    ///
    /// Warn when a C++ object is used after it has been moved from.
    public static var useAfterMoveErrorsInCpp: BuildSetting { 
        .useAfterMoveErrorsInCpp(.yesAggressive) 
    }

    /// Use-After-Move Errors in C++
    ///
    /// Warn when a C++ object is used after it has been moved from.
    public static func useAfterMoveErrorsInCpp(_ value: UseAfterMoveErrorsInCpp) -> BuildSetting { 
        BuildSetting(key: .useAfterMoveErrorsInCpp, value: \(value))
    }

    /// Use-After-Move Errors in C++
    ///
    /// Warn when a C++ object is used after it has been moved from.
    public static func useAfterMoveErrorsInCpp(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useAfterMoveErrorsInCpp, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use-After-Move Errors in C++
    ///
    /// Warn when a C++ object is used after it has been moved from.
    public static let useAfterMoveErrorsInCpp: BuildSettingsKey = "CLANG_ANALYZER_USE_AFTER_MOVE"
}

public enum UseAfterMoveErrorsInCpp: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesAggressive = "YES_AGGRESSIVE"

    public var description: String {
        rawValue
    }
}

// MARK: Clang Arc Migrate Emit Error
extension BuildSetting {

    /// Clang Arc Migrate Emit Error
    public static var clangArcMigrateEmitError: BuildSetting { 
        BuildSetting(key: .clangArcMigrateEmitError, value: "NO")
    }

    /// Clang Arc Migrate Emit Error
    public static func clangArcMigrateEmitError(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangArcMigrateEmitError, value: value.asText)
    }

    /// Clang Arc Migrate Emit Error
    public static func clangArcMigrateEmitError(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangArcMigrateEmitError, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Arc Migrate Emit Error
    public static let clangArcMigrateEmitError: BuildSettingsKey = "CLANG_ARC_MIGRATE_EMIT_ERROR"
}

// MARK: Clang Arc Migrate Report Output
extension BuildSetting {

    /// Clang Arc Migrate Report Output
    public static func clangArcMigrateReportOutput(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangArcMigrateReportOutput, value: \(value))
    }

    /// Clang Arc Migrate Report Output
    public static func clangArcMigrateReportOutput(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangArcMigrateReportOutput, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Arc Migrate Report Output
    public static let clangArcMigrateReportOutput: BuildSettingsKey = "CLANG_ARC_MIGRATE_REPORT_OUTPUT"
}

// MARK: Clang Bitcode Generation Mode
extension BuildSetting {

    /// Clang Bitcode Generation Mode
    public static var clangBitcodeGenerationMode: BuildSetting { 
        .clangBitcodeGenerationMode(inherit: .bitcodeGenerationMode) 
    }

    /// Clang Bitcode Generation Mode
    public static func clangBitcodeGenerationMode(_ value: ClangBitcodeGenerationMode) -> BuildSetting { 
        BuildSetting(key: .clangBitcodeGenerationMode, value: \(value))
    }

    /// Clang Bitcode Generation Mode
    public static func clangBitcodeGenerationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangBitcodeGenerationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Bitcode Generation Mode
    public static let clangBitcodeGenerationMode: BuildSettingsKey = "CLANG_BITCODE_GENERATION_MODE"
}

public enum ClangBitcodeGenerationMode: String, Hashable, Codable, CustomStringConvertible {
    case none = "none"
    case marker = "marker"
    case bitcode = "bitcode"

    public var description: String {
        rawValue
    }
}

// MARK: Clang Color Diagnostics
extension BuildSetting {

    /// Clang Color Diagnostics
    public static var clangColorDiagnostics: BuildSetting { 
        .clangColorDiagnostics(inherit: .colorDiagnostics) 
    }

    /// Clang Color Diagnostics
    public static func clangColorDiagnostics(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangColorDiagnostics, value: value.asText)
    }

    /// Clang Color Diagnostics
    public static func clangColorDiagnostics(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangColorDiagnostics, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Color Diagnostics
    public static let clangColorDiagnostics: BuildSettingsKey = "CLANG_COLOR_DIAGNOSTICS"
}

// MARK: Clang Coverage Mapping
extension BuildSetting {

    /// Clang Coverage Mapping
    public static var clangCoverageMapping: BuildSetting { 
        BuildSetting(key: .clangCoverageMapping, value: "NO")
    }

    /// Clang Coverage Mapping
    public static func clangCoverageMapping(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangCoverageMapping, value: value.asText)
    }

    /// Clang Coverage Mapping
    public static func clangCoverageMapping(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangCoverageMapping, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Coverage Mapping
    public static let clangCoverageMapping: BuildSettingsKey = "CLANG_COVERAGE_MAPPING"
}

// MARK: Clang Coverage Mapping Linker Args
extension BuildSetting {

    /// Clang Coverage Mapping Linker Args
    public static var clangCoverageMappingLinkerArgs: BuildSetting { 
        .clangCoverageMappingLinkerArgs(inherit: .clangCoverageMapping) 
    }

    /// Clang Coverage Mapping Linker Args
    public static func clangCoverageMappingLinkerArgs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangCoverageMappingLinkerArgs, value: value.asText)
    }

    /// Clang Coverage Mapping Linker Args
    public static func clangCoverageMappingLinkerArgs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangCoverageMappingLinkerArgs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Coverage Mapping Linker Args
    public static let clangCoverageMappingLinkerArgs: BuildSettingsKey = "CLANG_COVERAGE_MAPPING_LINKER_ARGS"
}

// MARK: C++ Language Dialect
extension BuildSetting {

    /// C++ Language Dialect
    ///
    /// Choose a standard or non-standard C++ language dialect. Options include:
    public static var cppLanguageDialect: BuildSetting { 
        .cppLanguageDialect(.compilerDefault) 
    }

    /// C++ Language Dialect
    ///
    /// Choose a standard or non-standard C++ language dialect. Options include:
    public static func cppLanguageDialect(_ value: CppLanguageDialect) -> BuildSetting { 
        BuildSetting(key: .cppLanguageDialect, value: \(value))
    }

    /// C++ Language Dialect
    ///
    /// Choose a standard or non-standard C++ language dialect. Options include:
    public static func cppLanguageDialect(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppLanguageDialect, inherit: key)
    }
}

extension BuildSettingsKey {

    /// C++ Language Dialect
    ///
    /// Choose a standard or non-standard C++ language dialect. Options include:
    public static let cppLanguageDialect: BuildSettingsKey = "CLANG_CXX_LANGUAGE_STANDARD"
}

public enum CppLanguageDialect: String, Hashable, Codable, CustomStringConvertible {
    case cpp98 = "c++98"
    case gnupp0x = "gnu++0x"
    case gnupp14 = "gnu++14"
    case cpp17 = "c++17"
    case cpp0x = "c++0x"
    case compilerDefault = "compiler-default"
    case gnupp17 = "gnu++17"
    case gnupp98 = "gnu++98"
    case cpp14 = "c++14"

    public var description: String {
        rawValue
    }
}

// MARK: C++ Standard Library
extension BuildSetting {

    /// C++ Standard Library
    public static var cppStandardLibrary: BuildSetting { 
        .cppStandardLibrary(.compilerDefault) 
    }

    /// C++ Standard Library
    public static func cppStandardLibrary(_ value: CppStandardLibrary) -> BuildSetting { 
        BuildSetting(key: .cppStandardLibrary, value: \(value))
    }

    /// C++ Standard Library
    public static func cppStandardLibrary(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppStandardLibrary, inherit: key)
    }
}

extension BuildSettingsKey {

    /// C++ Standard Library
    public static let cppStandardLibrary: BuildSettingsKey = "CLANG_CXX_LIBRARY"
}

public enum CppStandardLibrary: String, Hashable, Codable, CustomStringConvertible {
    case compilerDefault = "compiler-default"
    case libstdcpp = "libstdc++"
    case libcpp = "libc++"

    public var description: String {
        rawValue
    }
}

// MARK: Debug Information Level
extension BuildSetting {

    /// Debug Information Level
    ///
    /// Toggles the amount of debug information emitted when debug symbols are enabled. This can impact the size of the generated debug information, which may matter in some cases for large projects, such as when using LTO.
    public static var debugInformationLevel: BuildSetting { 
        .debugInformationLevel(.default) 
    }

    /// Debug Information Level
    ///
    /// Toggles the amount of debug information emitted when debug symbols are enabled. This can impact the size of the generated debug information, which may matter in some cases for large projects, such as when using LTO.
    public static func debugInformationLevel(_ value: DebugInformationLevel) -> BuildSetting { 
        BuildSetting(key: .debugInformationLevel, value: \(value))
    }

    /// Debug Information Level
    ///
    /// Toggles the amount of debug information emitted when debug symbols are enabled. This can impact the size of the generated debug information, which may matter in some cases for large projects, such as when using LTO.
    public static func debugInformationLevel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .debugInformationLevel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Debug Information Level
    ///
    /// Toggles the amount of debug information emitted when debug symbols are enabled. This can impact the size of the generated debug information, which may matter in some cases for large projects, such as when using LTO.
    public static let debugInformationLevel: BuildSettingsKey = "CLANG_DEBUG_INFORMATION_LEVEL"
}

public enum DebugInformationLevel: String, Hashable, Codable, CustomStringConvertible {
    case `default` = "default"
    case lineTablesOnly = "line-tables-only"

    public var description: String {
        rawValue
    }
}

// MARK: Clang Debug Modules
extension BuildSetting {

    /// Clang Debug Modules
    public static var clangDebugModules: BuildSetting { 
        .clangDebugModules(inherit: .enableClangModuleDebugging) 
    }

    /// Clang Debug Modules
    public static func clangDebugModules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangDebugModules, value: value.asText)
    }

    /// Clang Debug Modules
    public static func clangDebugModules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangDebugModules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Debug Modules
    public static let clangDebugModules: BuildSettingsKey = "CLANG_DEBUG_MODULES"
}

// MARK: Clang Enable App Extension
extension BuildSetting {

    /// Clang Enable App Extension
    public static var clangEnableAppExtension: BuildSetting { 
        .clangEnableAppExtension(inherit: .requireOnlyAppExtensionSafeApi) 
    }

    /// Clang Enable App Extension
    public static func clangEnableAppExtension(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangEnableAppExtension, value: value.asText)
    }

    /// Clang Enable App Extension
    public static func clangEnableAppExtension(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangEnableAppExtension, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Enable App Extension
    public static let clangEnableAppExtension: BuildSettingsKey = "CLANG_ENABLE_APP_EXTENSION"
}

// MARK: Enable Code Coverage Support
extension BuildSetting {

    /// Enable Code Coverage Support
    ///
    /// Enables building with code coverage instrumentation. This is only used when the build has code coverage enabled, which is typically done via the Xcode scheme settings.
    public static var enableCodeCoverageSupport: BuildSetting { 
        BuildSetting(key: .enableCodeCoverageSupport, value: "YES")
    }

    /// Enable Code Coverage Support
    ///
    /// Enables building with code coverage instrumentation. This is only used when the build has code coverage enabled, which is typically done via the Xcode scheme settings.
    public static func enableCodeCoverageSupport(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableCodeCoverageSupport, value: value.asText)
    }

    /// Enable Code Coverage Support
    ///
    /// Enables building with code coverage instrumentation. This is only used when the build has code coverage enabled, which is typically done via the Xcode scheme settings.
    public static func enableCodeCoverageSupport(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableCodeCoverageSupport, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Code Coverage Support
    ///
    /// Enables building with code coverage instrumentation. This is only used when the build has code coverage enabled, which is typically done via the Xcode scheme settings.
    public static let enableCodeCoverageSupport: BuildSettingsKey = "CLANG_ENABLE_CODE_COVERAGE"
}

// MARK: Destroy Static Objects
extension BuildSetting {

    /// Destroy Static Objects
    ///
    /// Controls whether variables with static or thread storage duration should have their exit-time destructors run.
    public static var destroyStaticObjects: BuildSetting { 
        BuildSetting(key: .destroyStaticObjects, value: "YES")
    }

    /// Destroy Static Objects
    ///
    /// Controls whether variables with static or thread storage duration should have their exit-time destructors run.
    public static func destroyStaticObjects(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .destroyStaticObjects, value: value.asText)
    }

    /// Destroy Static Objects
    ///
    /// Controls whether variables with static or thread storage duration should have their exit-time destructors run.
    public static func destroyStaticObjects(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .destroyStaticObjects, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Destroy Static Objects
    ///
    /// Controls whether variables with static or thread storage duration should have their exit-time destructors run.
    public static let destroyStaticObjects: BuildSettingsKey = "CLANG_ENABLE_CPP_STATIC_DESTRUCTORS"
}

// MARK: Enable Modules (C and Objective-C)
extension BuildSetting {

    /// Enable Modules (C and Objective-C)
    ///
    /// Enables the use of modules for system APIs. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static var enableModulesCAndObjectiveC: BuildSetting { 
        BuildSetting(key: .enableModulesCAndObjectiveC, value: "NO")
    }

    /// Enable Modules (C and Objective-C)
    ///
    /// Enables the use of modules for system APIs. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static func enableModulesCAndObjectiveC(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableModulesCAndObjectiveC, value: value.asText)
    }

    /// Enable Modules (C and Objective-C)
    ///
    /// Enables the use of modules for system APIs. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static func enableModulesCAndObjectiveC(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableModulesCAndObjectiveC, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Modules (C and Objective-C)
    ///
    /// Enables the use of modules for system APIs. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static let enableModulesCAndObjectiveC: BuildSettingsKey = "CLANG_ENABLE_MODULES"
}

// MARK: Enable Clang Module Debugging
extension BuildSetting {

    /// Enable Clang Module Debugging
    ///
    /// When this setting is enabled, `clang` will use the shared debug info available in `clang` modules and precompiled headers. This results in smaller build artifacts, faster compile times, and more complete debug info. This setting should only be disabled when building static libraries with debug info for distribution.
    public static var enableClangModuleDebugging: BuildSetting { 
        BuildSetting(key: .enableClangModuleDebugging, value: "YES")
    }

    /// Enable Clang Module Debugging
    ///
    /// When this setting is enabled, `clang` will use the shared debug info available in `clang` modules and precompiled headers. This results in smaller build artifacts, faster compile times, and more complete debug info. This setting should only be disabled when building static libraries with debug info for distribution.
    public static func enableClangModuleDebugging(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableClangModuleDebugging, value: value.asText)
    }

    /// Enable Clang Module Debugging
    ///
    /// When this setting is enabled, `clang` will use the shared debug info available in `clang` modules and precompiled headers. This results in smaller build artifacts, faster compile times, and more complete debug info. This setting should only be disabled when building static libraries with debug info for distribution.
    public static func enableClangModuleDebugging(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableClangModuleDebugging, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Clang Module Debugging
    ///
    /// When this setting is enabled, `clang` will use the shared debug info available in `clang` modules and precompiled headers. This results in smaller build artifacts, faster compile times, and more complete debug info. This setting should only be disabled when building static libraries with debug info for distribution.
    public static let enableClangModuleDebugging: BuildSettingsKey = "CLANG_ENABLE_MODULE_DEBUGGING"
}

// MARK: Clang Enable Module Implementation Of
extension BuildSetting {

    /// Clang Enable Module Implementation Of
    public static var clangEnableModuleImplementationOf: BuildSetting { 
        BuildSetting(key: .clangEnableModuleImplementationOf, value: "YES")
    }

    /// Clang Enable Module Implementation Of
    public static func clangEnableModuleImplementationOf(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangEnableModuleImplementationOf, value: value.asText)
    }

    /// Clang Enable Module Implementation Of
    public static func clangEnableModuleImplementationOf(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangEnableModuleImplementationOf, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Enable Module Implementation Of
    public static let clangEnableModuleImplementationOf: BuildSettingsKey = "CLANG_ENABLE_MODULE_IMPLEMENTATION_OF"
}

// MARK: Objective-C Automatic Reference Counting
extension BuildSetting {

    /// Objective-C Automatic Reference Counting
    ///
    /// Compiles reference-counted Objective-C code (when garbage collection is not enabled) to use Automatic Reference Counting. Code compiled using automated reference counting is compatible with other code (such as frameworks) compiled using either manual reference counting (for example, traditional `retain` and `release` messages) or automated reference counting. Using this mode is currently incompatible with compiling code to use Objective-C Garbage Collection.
    public static var objectiveCAutomaticReferenceCounting: BuildSetting { 
        BuildSetting(key: .objectiveCAutomaticReferenceCounting, value: "NO")
    }

    /// Objective-C Automatic Reference Counting
    ///
    /// Compiles reference-counted Objective-C code (when garbage collection is not enabled) to use Automatic Reference Counting. Code compiled using automated reference counting is compatible with other code (such as frameworks) compiled using either manual reference counting (for example, traditional `retain` and `release` messages) or automated reference counting. Using this mode is currently incompatible with compiling code to use Objective-C Garbage Collection.
    public static func objectiveCAutomaticReferenceCounting(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .objectiveCAutomaticReferenceCounting, value: value.asText)
    }

    /// Objective-C Automatic Reference Counting
    ///
    /// Compiles reference-counted Objective-C code (when garbage collection is not enabled) to use Automatic Reference Counting. Code compiled using automated reference counting is compatible with other code (such as frameworks) compiled using either manual reference counting (for example, traditional `retain` and `release` messages) or automated reference counting. Using this mode is currently incompatible with compiling code to use Objective-C Garbage Collection.
    public static func objectiveCAutomaticReferenceCounting(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objectiveCAutomaticReferenceCounting, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Objective-C Automatic Reference Counting
    ///
    /// Compiles reference-counted Objective-C code (when garbage collection is not enabled) to use Automatic Reference Counting. Code compiled using automated reference counting is compatible with other code (such as frameworks) compiled using either manual reference counting (for example, traditional `retain` and `release` messages) or automated reference counting. Using this mode is currently incompatible with compiling code to use Objective-C Garbage Collection.
    public static let objectiveCAutomaticReferenceCounting: BuildSettingsKey = "CLANG_ENABLE_OBJC_ARC"
}

// MARK: Weak References in Manual Retain Release
extension BuildSetting {

    /// Weak References in Manual Retain Release
    ///
    /// Compiles Objective-C code to enable weak references for code compiled with manual retain release (MRR) semantics.
    public static var weakReferencesInManualRetainRelease: BuildSetting { 
        BuildSetting(key: .weakReferencesInManualRetainRelease, value: "NO")
    }

    /// Weak References in Manual Retain Release
    ///
    /// Compiles Objective-C code to enable weak references for code compiled with manual retain release (MRR) semantics.
    public static func weakReferencesInManualRetainRelease(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .weakReferencesInManualRetainRelease, value: value.asText)
    }

    /// Weak References in Manual Retain Release
    ///
    /// Compiles Objective-C code to enable weak references for code compiled with manual retain release (MRR) semantics.
    public static func weakReferencesInManualRetainRelease(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .weakReferencesInManualRetainRelease, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Weak References in Manual Retain Release
    ///
    /// Compiles Objective-C code to enable weak references for code compiled with manual retain release (MRR) semantics.
    public static let weakReferencesInManualRetainRelease: BuildSettingsKey = "CLANG_ENABLE_OBJC_WEAK"
}

// MARK: Clang Index Store Enable
extension BuildSetting {

    /// Clang Index Store Enable
    public static func clangIndexStoreEnable(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangIndexStoreEnable, value: value.asText)
    }

    /// Clang Index Store Enable
    public static func clangIndexStoreEnable(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangIndexStoreEnable, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Index Store Enable
    public static let clangIndexStoreEnable: BuildSettingsKey = "CLANG_INDEX_STORE_ENABLE"
}

// MARK: Clang Index Store Path
extension BuildSetting {

    /// Clang Index Store Path
    public static var clangIndexStorePath: BuildSetting { 
        BuildSetting(key: .clangIndexStorePath, value: "$(INDEX_DATA_STORE_DIR)")
    }

    /// Clang Index Store Path
    public static func clangIndexStorePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangIndexStorePath, value: \(value))
    }

    /// Clang Index Store Path
    public static func clangIndexStorePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangIndexStorePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Index Store Path
    public static let clangIndexStorePath: BuildSettingsKey = "CLANG_INDEX_STORE_PATH"
}

// MARK: Clang Instrument For Optimization Profiling
extension BuildSetting {

    /// Clang Instrument For Optimization Profiling
    public static var clangInstrumentForOptimizationProfiling: BuildSetting { 
        BuildSetting(key: .clangInstrumentForOptimizationProfiling, value: "NO")
    }

    /// Clang Instrument For Optimization Profiling
    public static func clangInstrumentForOptimizationProfiling(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangInstrumentForOptimizationProfiling, value: value.asText)
    }

    /// Clang Instrument For Optimization Profiling
    public static func clangInstrumentForOptimizationProfiling(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangInstrumentForOptimizationProfiling, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Instrument For Optimization Profiling
    public static let clangInstrumentForOptimizationProfiling: BuildSettingsKey = "CLANG_INSTRUMENT_FOR_OPTIMIZATION_PROFILING"
}

// MARK: Implicitly Link Objective-C Runtime Support
extension BuildSetting {

    /// Implicitly Link Objective-C Runtime Support
    ///
    /// When linking a target using Objective-C code, implicitly link in Foundation (and if deploying back to an older OS) a backwards compatibility library to allow newer language features to run on an OS where the runtime support is not natively available. Most targets that use Objective-C should use this, although there are rare cases where a target should opt out of this behavior.
    public static var implicitlyLinkObjectiveCRuntimeSupport: BuildSetting { 
        BuildSetting(key: .implicitlyLinkObjectiveCRuntimeSupport, value: "YES")
    }

    /// Implicitly Link Objective-C Runtime Support
    ///
    /// When linking a target using Objective-C code, implicitly link in Foundation (and if deploying back to an older OS) a backwards compatibility library to allow newer language features to run on an OS where the runtime support is not natively available. Most targets that use Objective-C should use this, although there are rare cases where a target should opt out of this behavior.
    public static func implicitlyLinkObjectiveCRuntimeSupport(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitlyLinkObjectiveCRuntimeSupport, value: value.asText)
    }

    /// Implicitly Link Objective-C Runtime Support
    ///
    /// When linking a target using Objective-C code, implicitly link in Foundation (and if deploying back to an older OS) a backwards compatibility library to allow newer language features to run on an OS where the runtime support is not natively available. Most targets that use Objective-C should use this, although there are rare cases where a target should opt out of this behavior.
    public static func implicitlyLinkObjectiveCRuntimeSupport(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitlyLinkObjectiveCRuntimeSupport, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicitly Link Objective-C Runtime Support
    ///
    /// When linking a target using Objective-C code, implicitly link in Foundation (and if deploying back to an older OS) a backwards compatibility library to allow newer language features to run on an OS where the runtime support is not natively available. Most targets that use Objective-C should use this, although there are rare cases where a target should opt out of this behavior.
    public static let implicitlyLinkObjectiveCRuntimeSupport: BuildSettingsKey = "CLANG_LINK_OBJC_RUNTIME"
}

// MARK: Clang Macro Backtrace Limit
extension BuildSetting {

    /// Clang Macro Backtrace Limit
    public static var clangMacroBacktraceLimit: BuildSetting { 
        BuildSetting(key: .clangMacroBacktraceLimit, value: "0")
    }

    /// Clang Macro Backtrace Limit
    public static func clangMacroBacktraceLimit(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangMacroBacktraceLimit, value: \(value))
    }

    /// Clang Macro Backtrace Limit
    public static func clangMacroBacktraceLimit(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangMacroBacktraceLimit, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Macro Backtrace Limit
    public static let clangMacroBacktraceLimit: BuildSettingsKey = "CLANG_MACRO_BACKTRACE_LIMIT"
}

// MARK: Add attribute annotations
extension BuildSetting {

    /// Add attribute annotations
    ///
    /// Add attribute annotations to properties and methods.
    public static var addAttributeAnnotations: BuildSetting { 
        BuildSetting(key: .addAttributeAnnotations, value: "YES")
    }

    /// Add attribute annotations
    ///
    /// Add attribute annotations to properties and methods.
    public static func addAttributeAnnotations(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .addAttributeAnnotations, value: value.asText)
    }

    /// Add attribute annotations
    ///
    /// Add attribute annotations to properties and methods.
    public static func addAttributeAnnotations(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .addAttributeAnnotations, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Add attribute annotations
    ///
    /// Add attribute annotations to properties and methods.
    public static let addAttributeAnnotations: BuildSettingsKey = "CLANG_MIGRATOR_ANNOTATIONS"
}

// MARK: Infer instancetype for method result type
extension BuildSetting {

    /// Infer instancetype for method result type
    ///
    /// Infer `instancetype` for method result type instead of `id`.
    public static var inferInstancetypeForMethodResultType: BuildSetting { 
        BuildSetting(key: .inferInstancetypeForMethodResultType, value: "YES")
    }

    /// Infer instancetype for method result type
    ///
    /// Infer `instancetype` for method result type instead of `id`.
    public static func inferInstancetypeForMethodResultType(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferInstancetypeForMethodResultType, value: value.asText)
    }

    /// Infer instancetype for method result type
    ///
    /// Infer `instancetype` for method result type instead of `id`.
    public static func inferInstancetypeForMethodResultType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferInstancetypeForMethodResultType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer instancetype for method result type
    ///
    /// Infer `instancetype` for method result type instead of `id`.
    public static let inferInstancetypeForMethodResultType: BuildSettingsKey = "CLANG_MIGRATOR_INSTANCE_TYPE"
}

// MARK: Use NS_ENUM/NS_OPTIONS macros
extension BuildSetting {

    /// Use NS_ENUM/NS_OPTIONS macros
    ///
    /// Use `NS_ENUM`/`NS_OPTIONS` macros for enumerators.
    public static var useNsEnumNsOptionsMacros: BuildSetting { 
        BuildSetting(key: .useNsEnumNsOptionsMacros, value: "YES")
    }

    /// Use NS_ENUM/NS_OPTIONS macros
    ///
    /// Use `NS_ENUM`/`NS_OPTIONS` macros for enumerators.
    public static func useNsEnumNsOptionsMacros(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useNsEnumNsOptionsMacros, value: value.asText)
    }

    /// Use NS_ENUM/NS_OPTIONS macros
    ///
    /// Use `NS_ENUM`/`NS_OPTIONS` macros for enumerators.
    public static func useNsEnumNsOptionsMacros(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useNsEnumNsOptionsMacros, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use NS_ENUM/NS_OPTIONS macros
    ///
    /// Use `NS_ENUM`/`NS_OPTIONS` macros for enumerators.
    public static let useNsEnumNsOptionsMacros: BuildSettingsKey = "CLANG_MIGRATOR_NSENUM_MACROS"
}

// MARK: Infer designated initializer methods
extension BuildSetting {

    /// Infer designated initializer methods
    ///
    /// Infer `NS_DESIGNATED_INITIALIZER` for designated initializer methods.
    public static var inferDesignatedInitializerMethods: BuildSetting { 
        BuildSetting(key: .inferDesignatedInitializerMethods, value: "YES")
    }

    /// Infer designated initializer methods
    ///
    /// Infer `NS_DESIGNATED_INITIALIZER` for designated initializer methods.
    public static func inferDesignatedInitializerMethods(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferDesignatedInitializerMethods, value: value.asText)
    }

    /// Infer designated initializer methods
    ///
    /// Infer `NS_DESIGNATED_INITIALIZER` for designated initializer methods.
    public static func inferDesignatedInitializerMethods(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferDesignatedInitializerMethods, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer designated initializer methods
    ///
    /// Infer `NS_DESIGNATED_INITIALIZER` for designated initializer methods.
    public static let inferDesignatedInitializerMethods: BuildSettingsKey = "CLANG_MIGRATOR_OBJC_DESIGNATED_INIT"
}

// MARK: ObjC literals
extension BuildSetting {

    /// ObjC literals
    ///
    /// Enable migration to modern ObjC literals syntax.
    public static var objcLiterals: BuildSetting { 
        BuildSetting(key: .objcLiterals, value: "YES")
    }

    /// ObjC literals
    ///
    /// Enable migration to modern ObjC literals syntax.
    public static func objcLiterals(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .objcLiterals, value: value.asText)
    }

    /// ObjC literals
    ///
    /// Enable migration to modern ObjC literals syntax.
    public static func objcLiterals(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objcLiterals, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ObjC literals
    ///
    /// Enable migration to modern ObjC literals syntax.
    public static let objcLiterals: BuildSettingsKey = "CLANG_MIGRATOR_OBJC_LITERALS"
}

// MARK: ObjC subscripting
extension BuildSetting {

    /// ObjC subscripting
    ///
    /// Enable migration to modern ObjC subscripting syntax.
    public static var objcSubscripting: BuildSetting { 
        BuildSetting(key: .objcSubscripting, value: "YES")
    }

    /// ObjC subscripting
    ///
    /// Enable migration to modern ObjC subscripting syntax.
    public static func objcSubscripting(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .objcSubscripting, value: value.asText)
    }

    /// ObjC subscripting
    ///
    /// Enable migration to modern ObjC subscripting syntax.
    public static func objcSubscripting(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objcSubscripting, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ObjC subscripting
    ///
    /// Enable migration to modern ObjC subscripting syntax.
    public static let objcSubscripting: BuildSettingsKey = "CLANG_MIGRATOR_OBJC_SUBSCRIPTING"
}

// MARK: Atomicity of inferred properties
extension BuildSetting {

    /// Atomicity of inferred properties
    ///
    /// Choose the atomicity of the inferred properties.
    public static var atomicityOfInferredProperties: BuildSetting { 
        .atomicityOfInferredProperties(.nsNonatomicIosonly) 
    }

    /// Atomicity of inferred properties
    ///
    /// Choose the atomicity of the inferred properties.
    public static func atomicityOfInferredProperties(_ value: AtomicityOfInferredProperties) -> BuildSetting { 
        BuildSetting(key: .atomicityOfInferredProperties, value: \(value))
    }

    /// Atomicity of inferred properties
    ///
    /// Choose the atomicity of the inferred properties.
    public static func atomicityOfInferredProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .atomicityOfInferredProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Atomicity of inferred properties
    ///
    /// Choose the atomicity of the inferred properties.
    public static let atomicityOfInferredProperties: BuildSettingsKey = "CLANG_MIGRATOR_PROPERTY_ATOMICITY"
}

public enum AtomicityOfInferredProperties: String, Hashable, Codable, CustomStringConvertible {
    case nonatomic = "nonatomic"
    case nsNonatomicIosonly = "NS_NONATOMIC_IOSONLY"
    case atomic = "atomic"

    public var description: String {
        rawValue
    }
}

// MARK: ObjC property-dot syntax
extension BuildSetting {

    /// ObjC property-dot syntax
    ///
    /// Enable migration of setter/getter messages to property-dot syntax.
    public static var objcPropertyDotSyntax: BuildSetting { 
        BuildSetting(key: .objcPropertyDotSyntax, value: "YES")
    }

    /// ObjC property-dot syntax
    ///
    /// Enable migration of setter/getter messages to property-dot syntax.
    public static func objcPropertyDotSyntax(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .objcPropertyDotSyntax, value: value.asText)
    }

    /// ObjC property-dot syntax
    ///
    /// Enable migration of setter/getter messages to property-dot syntax.
    public static func objcPropertyDotSyntax(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objcPropertyDotSyntax, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ObjC property-dot syntax
    ///
    /// Enable migration of setter/getter messages to property-dot syntax.
    public static let objcPropertyDotSyntax: BuildSettingsKey = "CLANG_MIGRATOR_PROPERTY_DOT_SYNTAX"
}

// MARK: Infer protocol conformance
extension BuildSetting {

    /// Infer protocol conformance
    ///
    /// Infer protocol conformance from the interface methods.
    public static var inferProtocolConformance: BuildSetting { 
        BuildSetting(key: .inferProtocolConformance, value: "NO")
    }

    /// Infer protocol conformance
    ///
    /// Infer protocol conformance from the interface methods.
    public static func inferProtocolConformance(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferProtocolConformance, value: value.asText)
    }

    /// Infer protocol conformance
    ///
    /// Infer protocol conformance from the interface methods.
    public static func inferProtocolConformance(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferProtocolConformance, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer protocol conformance
    ///
    /// Infer protocol conformance from the interface methods.
    public static let inferProtocolConformance: BuildSettingsKey = "CLANG_MIGRATOR_PROTOCOL_CONFORMANCE"
}

// MARK: Only modify public headers
extension BuildSetting {

    /// Only modify public headers
    ///
    /// Only modify public headers of a target.
    public static var onlyModifyPublicHeaders: BuildSetting { 
        BuildSetting(key: .onlyModifyPublicHeaders, value: "YES")
    }

    /// Only modify public headers
    ///
    /// Only modify public headers of a target.
    public static func onlyModifyPublicHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .onlyModifyPublicHeaders, value: value.asText)
    }

    /// Only modify public headers
    ///
    /// Only modify public headers of a target.
    public static func onlyModifyPublicHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .onlyModifyPublicHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Only modify public headers
    ///
    /// Only modify public headers of a target.
    public static let onlyModifyPublicHeaders: BuildSettingsKey = "CLANG_MIGRATOR_PUBLIC_HEADERS_ONLY"
}

// MARK: Infer readonly properties
extension BuildSetting {

    /// Infer readonly properties
    ///
    /// Infer readonly properties from getter methods.
    public static var inferReadonlyProperties: BuildSetting { 
        BuildSetting(key: .inferReadonlyProperties, value: "YES")
    }

    /// Infer readonly properties
    ///
    /// Infer readonly properties from getter methods.
    public static func inferReadonlyProperties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferReadonlyProperties, value: value.asText)
    }

    /// Infer readonly properties
    ///
    /// Infer readonly properties from getter methods.
    public static func inferReadonlyProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferReadonlyProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer readonly properties
    ///
    /// Infer readonly properties from getter methods.
    public static let inferReadonlyProperties: BuildSettingsKey = "CLANG_MIGRATOR_READONLY_PROPERTY"
}

// MARK: Infer readwrite properties
extension BuildSetting {

    /// Infer readwrite properties
    ///
    /// Infer readwrite properties from a getter and setter method.
    public static var inferReadwriteProperties: BuildSetting { 
        BuildSetting(key: .inferReadwriteProperties, value: "YES")
    }

    /// Infer readwrite properties
    ///
    /// Infer readwrite properties from a getter and setter method.
    public static func inferReadwriteProperties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferReadwriteProperties, value: value.asText)
    }

    /// Infer readwrite properties
    ///
    /// Infer readwrite properties from a getter and setter method.
    public static func inferReadwriteProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferReadwriteProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer readwrite properties
    ///
    /// Infer readwrite properties from a getter and setter method.
    public static let inferReadwriteProperties: BuildSettingsKey = "CLANG_MIGRATOR_READWRITE_PROPERTY"
}

// MARK: Link Frameworks Automatically
extension BuildSetting {

    /// Link Frameworks Automatically
    ///
    /// Automatically link SDK frameworks that are referenced using `#import` or `#include`. This feature requires also enabling support for modules. This build setting only applies to C-family languages.
    public static var linkFrameworksAutomatically: BuildSetting { 
        BuildSetting(key: .linkFrameworksAutomatically, value: "YES")
    }

    /// Link Frameworks Automatically
    ///
    /// Automatically link SDK frameworks that are referenced using `#import` or `#include`. This feature requires also enabling support for modules. This build setting only applies to C-family languages.
    public static func linkFrameworksAutomatically(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .linkFrameworksAutomatically, value: value.asText)
    }

    /// Link Frameworks Automatically
    ///
    /// Automatically link SDK frameworks that are referenced using `#import` or `#include`. This feature requires also enabling support for modules. This build setting only applies to C-family languages.
    public static func linkFrameworksAutomatically(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkFrameworksAutomatically, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Link Frameworks Automatically
    ///
    /// Automatically link SDK frameworks that are referenced using `#import` or `#include`. This feature requires also enabling support for modules. This build setting only applies to C-family languages.
    public static let linkFrameworksAutomatically: BuildSettingsKey = "CLANG_MODULES_AUTOLINK"
}

// MARK: Clang Modules Build Session File
extension BuildSetting {

    /// Clang Modules Build Session File
    public static func clangModulesBuildSessionFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangModulesBuildSessionFile, value: \(value))
    }

    /// Clang Modules Build Session File
    public static func clangModulesBuildSessionFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesBuildSessionFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Modules Build Session File
    public static let clangModulesBuildSessionFile: BuildSettingsKey = "CLANG_MODULES_BUILD_SESSION_FILE"
}

// MARK: Disable Private Modules Warnings
extension BuildSetting {

    /// Disable Private Modules Warnings
    ///
    /// Disable warnings related to the recommended use of private module naming. This only makes sense when support for modules is enabled.
    public static var disablePrivateModulesWarnings: BuildSetting { 
        BuildSetting(key: .disablePrivateModulesWarnings, value: "NO")
    }

    /// Disable Private Modules Warnings
    ///
    /// Disable warnings related to the recommended use of private module naming. This only makes sense when support for modules is enabled.
    public static func disablePrivateModulesWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .disablePrivateModulesWarnings, value: value.asText)
    }

    /// Disable Private Modules Warnings
    ///
    /// Disable warnings related to the recommended use of private module naming. This only makes sense when support for modules is enabled.
    public static func disablePrivateModulesWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .disablePrivateModulesWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Disable Private Modules Warnings
    ///
    /// Disable warnings related to the recommended use of private module naming. This only makes sense when support for modules is enabled.
    public static let disablePrivateModulesWarnings: BuildSettingsKey = "CLANG_MODULES_DISABLE_PRIVATE_WARNING"
}

// MARK: Clang Modules Ignore Macros
extension BuildSetting {

    /// Clang Modules Ignore Macros
    public static var clangModulesIgnoreMacros: BuildSetting { 
        .clangModulesIgnoreMacros(inherit: .preprocessorMacrosNotUsedInPrecompiledHeaders) 
    }

    /// Clang Modules Ignore Macros
    public static func clangModulesIgnoreMacros(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangModulesIgnoreMacros, value: .array(value))
    }

    /// Clang Modules Ignore Macros
    public static func clangModulesIgnoreMacros(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesIgnoreMacros, inherit: key)
    }

    /// Clang Modules Ignore Macros
    public static func clangModulesIgnoreMacros(_ value: String...) -> BuildSetting { 
        .clangModulesIgnoreMacros(value)
    }
}

extension BuildSettingsKey {

    /// Clang Modules Ignore Macros
    public static let clangModulesIgnoreMacros: BuildSettingsKey = "CLANG_MODULES_IGNORE_MACROS"
}

// MARK: Clang Modules Prune After
extension BuildSetting {

    /// Clang Modules Prune After
    public static var clangModulesPruneAfter: BuildSetting { 
        BuildSetting(key: .clangModulesPruneAfter, value: "345600")
    }

    /// Clang Modules Prune After
    public static func clangModulesPruneAfter(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangModulesPruneAfter, value: \(value))
    }

    /// Clang Modules Prune After
    public static func clangModulesPruneAfter(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesPruneAfter, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Modules Prune After
    public static let clangModulesPruneAfter: BuildSettingsKey = "CLANG_MODULES_PRUNE_AFTER"
}

// MARK: Clang Modules Prune Interval
extension BuildSetting {

    /// Clang Modules Prune Interval
    public static var clangModulesPruneInterval: BuildSetting { 
        BuildSetting(key: .clangModulesPruneInterval, value: "86400")
    }

    /// Clang Modules Prune Interval
    public static func clangModulesPruneInterval(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangModulesPruneInterval, value: \(value))
    }

    /// Clang Modules Prune Interval
    public static func clangModulesPruneInterval(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesPruneInterval, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Modules Prune Interval
    public static let clangModulesPruneInterval: BuildSettingsKey = "CLANG_MODULES_PRUNE_INTERVAL"
}

// MARK: Clang Modules Validate System Headers
extension BuildSetting {

    /// Clang Modules Validate System Headers
    public static var clangModulesValidateSystemHeaders: BuildSetting { 
        BuildSetting(key: .clangModulesValidateSystemHeaders, value: "NO")
    }

    /// Clang Modules Validate System Headers
    public static func clangModulesValidateSystemHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangModulesValidateSystemHeaders, value: value.asText)
    }

    /// Clang Modules Validate System Headers
    public static func clangModulesValidateSystemHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesValidateSystemHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Modules Validate System Headers
    public static let clangModulesValidateSystemHeaders: BuildSettingsKey = "CLANG_MODULES_VALIDATE_SYSTEM_HEADERS"
}

// MARK: Clang Module Cache Path
extension BuildSetting {

    /// Clang Module Cache Path
    public static func clangModuleCachePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangModuleCachePath, value: \(value))
    }

    /// Clang Module Cache Path
    public static func clangModuleCachePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModuleCachePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Module Cache Path
    public static let clangModuleCachePath: BuildSettingsKey = "CLANG_MODULE_CACHE_PATH"
}

// MARK: Clang Module Lsv
extension BuildSetting {

    /// Clang Module Lsv
    public static var clangModuleLsv: BuildSetting { 
        BuildSetting(key: .clangModuleLsv, value: "NO")
    }

    /// Clang Module Lsv
    public static func clangModuleLsv(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangModuleLsv, value: value.asText)
    }

    /// Clang Module Lsv
    public static func clangModuleLsv(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModuleLsv, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Module Lsv
    public static let clangModuleLsv: BuildSettingsKey = "CLANG_MODULE_LSV"
}

// MARK: Clang Objc Migrate Dir
extension BuildSetting {

    /// Clang Objc Migrate Dir
    public static func clangObjcMigrateDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangObjcMigrateDir, value: \(value))
    }

    /// Clang Objc Migrate Dir
    public static func clangObjcMigrateDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangObjcMigrateDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Objc Migrate Dir
    public static let clangObjcMigrateDir: BuildSettingsKey = "CLANG_OBJC_MIGRATE_DIR"
}

// MARK: Optimization Profile File
extension BuildSetting {

    /// Optimization Profile File
    ///
    /// The path to the file of the profile data to use when [Use Optimization Profile (CLANG_USE_OPTIMIZATION_PROFILE)](itcaec37c2a6.html# devb3d935f24) is enabled.
    public static var optimizationProfileFile: BuildSetting { 
        BuildSetting(key: .optimizationProfileFile, value: "$(SRCROOT)/OptimizationProfiles/$(PROJECT_NAME).profdata")
    }

    /// Optimization Profile File
    ///
    /// The path to the file of the profile data to use when [Use Optimization Profile (CLANG_USE_OPTIMIZATION_PROFILE)](itcaec37c2a6.html# devb3d935f24) is enabled.
    public static func optimizationProfileFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .optimizationProfileFile, value: \(value))
    }

    /// Optimization Profile File
    ///
    /// The path to the file of the profile data to use when [Use Optimization Profile (CLANG_USE_OPTIMIZATION_PROFILE)](itcaec37c2a6.html# devb3d935f24) is enabled.
    public static func optimizationProfileFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimizationProfileFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Optimization Profile File
    ///
    /// The path to the file of the profile data to use when [Use Optimization Profile (CLANG_USE_OPTIMIZATION_PROFILE)](itcaec37c2a6.html# devb3d935f24) is enabled.
    public static let optimizationProfileFile: BuildSettingsKey = "CLANG_OPTIMIZATION_PROFILE_FILE"
}

// MARK: Clang Retain Comments From System Headers
extension BuildSetting {

    /// Clang Retain Comments From System Headers
    public static var clangRetainCommentsFromSystemHeaders: BuildSetting { 
        BuildSetting(key: .clangRetainCommentsFromSystemHeaders, value: "NO")
    }

    /// Clang Retain Comments From System Headers
    public static func clangRetainCommentsFromSystemHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangRetainCommentsFromSystemHeaders, value: value.asText)
    }

    /// Clang Retain Comments From System Headers
    public static func clangRetainCommentsFromSystemHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangRetainCommentsFromSystemHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Retain Comments From System Headers
    public static let clangRetainCommentsFromSystemHeaders: BuildSettingsKey = "CLANG_RETAIN_COMMENTS_FROM_SYSTEM_HEADERS"
}

// MARK: Mode of Analysis for 'Build'
extension BuildSetting {

    /// Mode of Analysis for 'Build'
    ///
    /// The depth the static analyzer uses during the Build action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static var modeOfAnalysisForBuild: BuildSetting { 
        .modeOfAnalysisForBuild(.shallow) 
    }

    /// Mode of Analysis for 'Build'
    ///
    /// The depth the static analyzer uses during the Build action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static func modeOfAnalysisForBuild(_ value: ModeOfAnalysisForBuild) -> BuildSetting { 
        BuildSetting(key: .modeOfAnalysisForBuild, value: \(value))
    }

    /// Mode of Analysis for 'Build'
    ///
    /// The depth the static analyzer uses during the Build action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static func modeOfAnalysisForBuild(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .modeOfAnalysisForBuild, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mode of Analysis for 'Build'
    ///
    /// The depth the static analyzer uses during the Build action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static let modeOfAnalysisForBuild: BuildSettingsKey = "CLANG_STATIC_ANALYZER_MODE"
}

public enum ModeOfAnalysisForBuild: String, Hashable, Codable, CustomStringConvertible {
    case shallow = "shallow"
    case deep = "deep"

    public var description: String {
        rawValue
    }
}

// MARK: Mode of Analysis for 'Analyze'
extension BuildSetting {

    /// Mode of Analysis for 'Analyze'
    ///
    /// The depth the static analyzer uses during the Analyze action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static var modeOfAnalysisForAnalyze: BuildSetting { 
        .modeOfAnalysisForAnalyze(.deep) 
    }

    /// Mode of Analysis for 'Analyze'
    ///
    /// The depth the static analyzer uses during the Analyze action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static func modeOfAnalysisForAnalyze(_ value: ModeOfAnalysisForAnalyze) -> BuildSetting { 
        BuildSetting(key: .modeOfAnalysisForAnalyze, value: \(value))
    }

    /// Mode of Analysis for 'Analyze'
    ///
    /// The depth the static analyzer uses during the Analyze action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static func modeOfAnalysisForAnalyze(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .modeOfAnalysisForAnalyze, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mode of Analysis for 'Analyze'
    ///
    /// The depth the static analyzer uses during the Analyze action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static let modeOfAnalysisForAnalyze: BuildSettingsKey = "CLANG_STATIC_ANALYZER_MODE_ON_ANALYZE_ACTION"
}

public enum ModeOfAnalysisForAnalyze: String, Hashable, Codable, CustomStringConvertible {
    case shallow = "shallow"
    case deep = "deep"

    public var description: String {
        rawValue
    }
}

// MARK: Clang Target Triple Archs
extension BuildSetting {

    /// Clang Target Triple Archs
    public static var clangTargetTripleArchs: BuildSetting { 
        .clangTargetTripleArchs(inherit: .currentArch) 
    }

    /// Clang Target Triple Archs
    public static func clangTargetTripleArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangTargetTripleArchs, value: .array(value))
    }

    /// Clang Target Triple Archs
    public static func clangTargetTripleArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangTargetTripleArchs, inherit: key)
    }

    /// Clang Target Triple Archs
    public static func clangTargetTripleArchs(_ value: String...) -> BuildSetting { 
        .clangTargetTripleArchs(value)
    }
}

extension BuildSettingsKey {

    /// Clang Target Triple Archs
    public static let clangTargetTripleArchs: BuildSettingsKey = "CLANG_TARGET_TRIPLE_ARCHS"
}

// MARK: Clang Target Triple Variants
extension BuildSetting {

    /// Clang Target Triple Variants
    public static func clangTargetTripleVariants(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangTargetTripleVariants, value: .array(value))
    }

    /// Clang Target Triple Variants
    public static func clangTargetTripleVariants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangTargetTripleVariants, inherit: key)
    }

    /// Clang Target Triple Variants
    public static func clangTargetTripleVariants(_ value: String...) -> BuildSetting { 
        .clangTargetTripleVariants(value)
    }
}

extension BuildSettingsKey {

    /// Clang Target Triple Variants
    public static let clangTargetTripleVariants: BuildSettingsKey = "CLANG_TARGET_TRIPLE_VARIANTS"
}

// MARK: Clang Thread Sanitizer
extension BuildSetting {

    /// Clang Thread Sanitizer
    public static func clangThreadSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangThreadSanitizer, value: value.asText)
    }

    /// Clang Thread Sanitizer
    public static func clangThreadSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangThreadSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Thread Sanitizer
    public static let clangThreadSanitizer: BuildSettingsKey = "CLANG_THREAD_SANITIZER"
}

// MARK: Clang Toolchain Flags
extension BuildSetting {

    /// Clang Toolchain Flags
    public static func clangToolchainFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangToolchainFlags, value: .array(value))
    }

    /// Clang Toolchain Flags
    public static func clangToolchainFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangToolchainFlags, inherit: key)
    }

    /// Clang Toolchain Flags
    public static func clangToolchainFlags(_ value: String...) -> BuildSetting { 
        .clangToolchainFlags(value)
    }
}

extension BuildSettingsKey {

    /// Clang Toolchain Flags
    public static let clangToolchainFlags: BuildSettingsKey = "CLANG_TOOLCHAIN_FLAGS"
}

// MARK: Trivial automatic variable initialization
extension BuildSetting {

    /// Trivial automatic variable initialization
    ///
    /// Specify whether stack variables should be uninitialized, which can cause inadvertent information disclosure when uninitialized stack variables are used, or whether they should be pattern-initialized.
    public static var trivialAutomaticVariableInitialization: BuildSetting { 
        .trivialAutomaticVariableInitialization(.uninitialized) 
    }

    /// Trivial automatic variable initialization
    ///
    /// Specify whether stack variables should be uninitialized, which can cause inadvertent information disclosure when uninitialized stack variables are used, or whether they should be pattern-initialized.
    public static func trivialAutomaticVariableInitialization(_ value: TrivialAutomaticVariableInitialization) -> BuildSetting { 
        BuildSetting(key: .trivialAutomaticVariableInitialization, value: \(value))
    }

    /// Trivial automatic variable initialization
    ///
    /// Specify whether stack variables should be uninitialized, which can cause inadvertent information disclosure when uninitialized stack variables are used, or whether they should be pattern-initialized.
    public static func trivialAutomaticVariableInitialization(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .trivialAutomaticVariableInitialization, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Trivial automatic variable initialization
    ///
    /// Specify whether stack variables should be uninitialized, which can cause inadvertent information disclosure when uninitialized stack variables are used, or whether they should be pattern-initialized.
    public static let trivialAutomaticVariableInitialization: BuildSettingsKey = "CLANG_TRIVIAL_AUTO_VAR_INIT"
}

public enum TrivialAutomaticVariableInitialization: String, Hashable, Codable, CustomStringConvertible {
    case pattern = "pattern"
    case uninitialized = "uninitialized"

    public var description: String {
        rawValue
    }
}

// MARK: Clang Undefined Behavior Sanitizer
extension BuildSetting {

    /// Clang Undefined Behavior Sanitizer
    public static func clangUndefinedBehaviorSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangUndefinedBehaviorSanitizer, value: value.asText)
    }

    /// Clang Undefined Behavior Sanitizer
    public static func clangUndefinedBehaviorSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangUndefinedBehaviorSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Undefined Behavior Sanitizer
    public static let clangUndefinedBehaviorSanitizer: BuildSettingsKey = "CLANG_UNDEFINED_BEHAVIOR_SANITIZER"
}

// MARK: Enable Extra Integer Checks
extension BuildSetting {

    /// Enable Extra Integer Checks
    ///
    /// Check for unsigned integer overflow, in addition to checks for signed integer overflow.
    public static var enableExtraIntegerChecks: BuildSetting { 
        BuildSetting(key: .enableExtraIntegerChecks, value: "NO")
    }

    /// Enable Extra Integer Checks
    ///
    /// Check for unsigned integer overflow, in addition to checks for signed integer overflow.
    public static func enableExtraIntegerChecks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableExtraIntegerChecks, value: value.asText)
    }

    /// Enable Extra Integer Checks
    ///
    /// Check for unsigned integer overflow, in addition to checks for signed integer overflow.
    public static func enableExtraIntegerChecks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableExtraIntegerChecks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Extra Integer Checks
    ///
    /// Check for unsigned integer overflow, in addition to checks for signed integer overflow.
    public static let enableExtraIntegerChecks: BuildSettingsKey = "CLANG_UNDEFINED_BEHAVIOR_SANITIZER_INTEGER"
}

// MARK: Enable Nullability Annotation Checks
extension BuildSetting {

    /// Enable Nullability Annotation Checks
    ///
    /// Check for violations of nullability annotations in function calls, return statements, and assignments.
    public static var enableNullabilityAnnotationChecks: BuildSetting { 
        BuildSetting(key: .enableNullabilityAnnotationChecks, value: "NO")
    }

    /// Enable Nullability Annotation Checks
    ///
    /// Check for violations of nullability annotations in function calls, return statements, and assignments.
    public static func enableNullabilityAnnotationChecks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableNullabilityAnnotationChecks, value: value.asText)
    }

    /// Enable Nullability Annotation Checks
    ///
    /// Check for violations of nullability annotations in function calls, return statements, and assignments.
    public static func enableNullabilityAnnotationChecks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableNullabilityAnnotationChecks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Nullability Annotation Checks
    ///
    /// Check for violations of nullability annotations in function calls, return statements, and assignments.
    public static let enableNullabilityAnnotationChecks: BuildSettingsKey = "CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY"
}

// MARK: Use Optimization Profile
extension BuildSetting {

    /// Use Optimization Profile
    ///
    /// When this setting is enabled, `clang` will use the optimization profile collected for a target when building it.
    public static var useOptimizationProfile: BuildSetting { 
        BuildSetting(key: .useOptimizationProfile, value: "NO")
    }

    /// Use Optimization Profile
    ///
    /// When this setting is enabled, `clang` will use the optimization profile collected for a target when building it.
    public static func useOptimizationProfile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOptimizationProfile, value: value.asText)
    }

    /// Use Optimization Profile
    ///
    /// When this setting is enabled, `clang` will use the optimization profile collected for a target when building it.
    public static func useOptimizationProfile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOptimizationProfile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Optimization Profile
    ///
    /// When this setting is enabled, `clang` will use the optimization profile collected for a target when building it.
    public static let useOptimizationProfile: BuildSettingsKey = "CLANG_USE_OPTIMIZATION_PROFILE"
}

// MARK: Out-of-Range Enum Assignments
extension BuildSetting {

    /// Out-of-Range Enum Assignments
    ///
    /// Warn about assigning integer constants to enum values that are out of the range of the enumerated type.
    public static var outOfRangeEnumAssignments: BuildSetting { 
        BuildSetting(key: .outOfRangeEnumAssignments, value: "NO")
    }

    /// Out-of-Range Enum Assignments
    ///
    /// Warn about assigning integer constants to enum values that are out of the range of the enumerated type.
    public static func outOfRangeEnumAssignments(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .outOfRangeEnumAssignments, value: value.asText)
    }

    /// Out-of-Range Enum Assignments
    ///
    /// Warn about assigning integer constants to enum values that are out of the range of the enumerated type.
    public static func outOfRangeEnumAssignments(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .outOfRangeEnumAssignments, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Out-of-Range Enum Assignments
    ///
    /// Warn about assigning integer constants to enum values that are out of the range of the enumerated type.
    public static let outOfRangeEnumAssignments: BuildSettingsKey = "CLANG_WARN_ASSIGN_ENUM"
}

// MARK: Usage of implicit sequentially-consistent atomics
extension BuildSetting {

    /// Usage of implicit sequentially-consistent atomics
    ///
    /// Warns when an atomic is used with an implicitly sequentially-consistent memory order, instead of explicitly specifying memory order.
    public static var usageOfImplicitSequentiallyConsistentAtomics: BuildSetting { 
        BuildSetting(key: .usageOfImplicitSequentiallyConsistentAtomics, value: "NO")
    }

    /// Usage of implicit sequentially-consistent atomics
    ///
    /// Warns when an atomic is used with an implicitly sequentially-consistent memory order, instead of explicitly specifying memory order.
    public static func usageOfImplicitSequentiallyConsistentAtomics(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .usageOfImplicitSequentiallyConsistentAtomics, value: value.asText)
    }

    /// Usage of implicit sequentially-consistent atomics
    ///
    /// Warns when an atomic is used with an implicitly sequentially-consistent memory order, instead of explicitly specifying memory order.
    public static func usageOfImplicitSequentiallyConsistentAtomics(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .usageOfImplicitSequentiallyConsistentAtomics, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Usage of implicit sequentially-consistent atomics
    ///
    /// Warns when an atomic is used with an implicitly sequentially-consistent memory order, instead of explicitly specifying memory order.
    public static let usageOfImplicitSequentiallyConsistentAtomics: BuildSettingsKey = "CLANG_WARN_ATOMIC_IMPLICIT_SEQ_CST"
}

// MARK: Block Capture of Autoreleasing
extension BuildSetting {

    /// Block Capture of Autoreleasing
    ///
    /// Warn about block captures of implicitly autoreleasing parameters.
    public static var blockCaptureOfAutoreleasing: BuildSetting { 
        .blockCaptureOfAutoreleasing(.no) 
    }

    /// Block Capture of Autoreleasing
    ///
    /// Warn about block captures of implicitly autoreleasing parameters.
    public static func blockCaptureOfAutoreleasing(_ value: BlockCaptureOfAutoreleasing) -> BuildSetting { 
        BuildSetting(key: .blockCaptureOfAutoreleasing, value: \(value))
    }

    /// Block Capture of Autoreleasing
    ///
    /// Warn about block captures of implicitly autoreleasing parameters.
    public static func blockCaptureOfAutoreleasing(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .blockCaptureOfAutoreleasing, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Block Capture of Autoreleasing
    ///
    /// Warn about block captures of implicitly autoreleasing parameters.
    public static let blockCaptureOfAutoreleasing: BuildSettingsKey = "CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING"
}

public enum BlockCaptureOfAutoreleasing: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yesError = "YES_ERROR"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Implicit Boolean Conversions
extension BuildSetting {

    /// Implicit Boolean Conversions
    ///
    /// Warn about implicit conversions to boolean values that are suspicious. For example, writing `if (foo)` where `foo` is the name a function will trigger a warning.
    public static var implicitBooleanConversions: BuildSetting { 
        .implicitBooleanConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Boolean Conversions
    ///
    /// Warn about implicit conversions to boolean values that are suspicious. For example, writing `if (foo)` where `foo` is the name a function will trigger a warning.
    public static func implicitBooleanConversions(_ value: ImplicitBooleanConversions) -> BuildSetting { 
        BuildSetting(key: .implicitBooleanConversions, value: \(value))
    }

    /// Implicit Boolean Conversions
    ///
    /// Warn about implicit conversions to boolean values that are suspicious. For example, writing `if (foo)` where `foo` is the name a function will trigger a warning.
    public static func implicitBooleanConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitBooleanConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Boolean Conversions
    ///
    /// Warn about implicit conversions to boolean values that are suspicious. For example, writing `if (foo)` where `foo` is the name a function will trigger a warning.
    public static let implicitBooleanConversions: BuildSettingsKey = "CLANG_WARN_BOOL_CONVERSION"
}

public enum ImplicitBooleanConversions: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yesError = "YES_ERROR"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Suspicious Commas
extension BuildSetting {

    /// Suspicious Commas
    ///
    /// Warn about suspicious uses of the comma operator.
    public static var suspiciousCommas: BuildSetting { 
        .suspiciousCommas(.no) 
    }

    /// Suspicious Commas
    ///
    /// Warn about suspicious uses of the comma operator.
    public static func suspiciousCommas(_ value: SuspiciousCommas) -> BuildSetting { 
        BuildSetting(key: .suspiciousCommas, value: \(value))
    }

    /// Suspicious Commas
    ///
    /// Warn about suspicious uses of the comma operator.
    public static func suspiciousCommas(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousCommas, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Commas
    ///
    /// Warn about suspicious uses of the comma operator.
    public static let suspiciousCommas: BuildSettingsKey = "CLANG_WARN_COMMA"
}

public enum SuspiciousCommas: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yesError = "YES_ERROR"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Implicit Constant Conversions
extension BuildSetting {

    /// Implicit Constant Conversions
    ///
    /// Warn about implicit conversions of constant values that cause the constant value to change, either through a loss of precision, or entirely in its meaning.
    public static var implicitConstantConversions: BuildSetting { 
        .implicitConstantConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Constant Conversions
    ///
    /// Warn about implicit conversions of constant values that cause the constant value to change, either through a loss of precision, or entirely in its meaning.
    public static func implicitConstantConversions(_ value: ImplicitConstantConversions) -> BuildSetting { 
        BuildSetting(key: .implicitConstantConversions, value: \(value))
    }

    /// Implicit Constant Conversions
    ///
    /// Warn about implicit conversions of constant values that cause the constant value to change, either through a loss of precision, or entirely in its meaning.
    public static func implicitConstantConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitConstantConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Constant Conversions
    ///
    /// Warn about implicit conversions of constant values that cause the constant value to change, either through a loss of precision, or entirely in its meaning.
    public static let implicitConstantConversions: BuildSettingsKey = "CLANG_WARN_CONSTANT_CONVERSION"
}

public enum ImplicitConstantConversions: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Deleting Instance of Polymorphic Class with No Virtual Destructor
extension BuildSetting {

    /// Deleting Instance of Polymorphic Class with No Virtual Destructor
    ///
    /// Warn when deleting an instance of a polymorphic class with virtual functions but without a virtual destructor.
    public static var deletingInstanceOfPolymorphicClassWithNoVirtualDestructor: BuildSetting { 
        .deletingInstanceOfPolymorphicClassWithNoVirtualDestructor(.yes) 
    }

    /// Deleting Instance of Polymorphic Class with No Virtual Destructor
    ///
    /// Warn when deleting an instance of a polymorphic class with virtual functions but without a virtual destructor.
    public static func deletingInstanceOfPolymorphicClassWithNoVirtualDestructor(_ value: DeletingInstanceOfPolymorphicClassWithNoVirtualDestructor) -> BuildSetting { 
        BuildSetting(key: .deletingInstanceOfPolymorphicClassWithNoVirtualDestructor, value: \(value))
    }

    /// Deleting Instance of Polymorphic Class with No Virtual Destructor
    ///
    /// Warn when deleting an instance of a polymorphic class with virtual functions but without a virtual destructor.
    public static func deletingInstanceOfPolymorphicClassWithNoVirtualDestructor(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deletingInstanceOfPolymorphicClassWithNoVirtualDestructor, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Deleting Instance of Polymorphic Class with No Virtual Destructor
    ///
    /// Warn when deleting an instance of a polymorphic class with virtual functions but without a virtual destructor.
    public static let deletingInstanceOfPolymorphicClassWithNoVirtualDestructor: BuildSettingsKey = "CLANG_WARN_DELETE_NON_VIRTUAL_DTOR"
}

public enum DeletingInstanceOfPolymorphicClassWithNoVirtualDestructor: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}

// MARK: Overriding Deprecated Objective-C Methods
extension BuildSetting {

    /// Overriding Deprecated Objective-C Methods
    ///
    /// Warn if an Objective-C class either subclasses a deprecated class or overrides a method that has been marked deprecated or unavailable.
    public static var overridingDeprecatedObjectiveCMethods: BuildSetting { 
        BuildSetting(key: .overridingDeprecatedObjectiveCMethods, value: "NO")
    }

    /// Overriding Deprecated Objective-C Methods
    ///
    /// Warn if an Objective-C class either subclasses a deprecated class or overrides a method that has been marked deprecated or unavailable.
    public static func overridingDeprecatedObjectiveCMethods(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .overridingDeprecatedObjectiveCMethods, value: value.asText)
    }

    /// Overriding Deprecated Objective-C Methods
    ///
    /// Warn if an Objective-C class either subclasses a deprecated class or overrides a method that has been marked deprecated or unavailable.
    public static func overridingDeprecatedObjectiveCMethods(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .overridingDeprecatedObjectiveCMethods, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Overriding Deprecated Objective-C Methods
    ///
    /// Warn if an Objective-C class either subclasses a deprecated class or overrides a method that has been marked deprecated or unavailable.
    public static let overridingDeprecatedObjectiveCMethods: BuildSettingsKey = "CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS"
}

// MARK: Direct usage of 'isa'
extension BuildSetting {

    /// Direct usage of 'isa'
    ///
    /// Warn about direct accesses to the Objective-C `isa` pointer instead of using a runtime API.
    public static var directUsageOfIsa: BuildSetting { 
        .directUsageOfIsa(.yes) 
    }

    /// Direct usage of 'isa'
    ///
    /// Warn about direct accesses to the Objective-C `isa` pointer instead of using a runtime API.
    public static func directUsageOfIsa(_ value: DirectUsageOfIsa) -> BuildSetting { 
        BuildSetting(key: .directUsageOfIsa, value: \(value))
    }

    /// Direct usage of 'isa'
    ///
    /// Warn about direct accesses to the Objective-C `isa` pointer instead of using a runtime API.
    public static func directUsageOfIsa(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .directUsageOfIsa, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Direct usage of 'isa'
    ///
    /// Warn about direct accesses to the Objective-C `isa` pointer instead of using a runtime API.
    public static let directUsageOfIsa: BuildSettingsKey = "CLANG_WARN_DIRECT_OBJC_ISA_USAGE"
}

public enum DirectUsageOfIsa: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Documentation Comments
extension BuildSetting {

    /// Documentation Comments
    ///
    /// Warns about issues in documentation comments (`doxygen`-style) such as missing or incorrect documentation tags.
    public static var documentationComments: BuildSetting { 
        BuildSetting(key: .documentationComments, value: "NO")
    }

    /// Documentation Comments
    ///
    /// Warns about issues in documentation comments (`doxygen`-style) such as missing or incorrect documentation tags.
    public static func documentationComments(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .documentationComments, value: value.asText)
    }

    /// Documentation Comments
    ///
    /// Warns about issues in documentation comments (`doxygen`-style) such as missing or incorrect documentation tags.
    public static func documentationComments(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .documentationComments, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Documentation Comments
    ///
    /// Warns about issues in documentation comments (`doxygen`-style) such as missing or incorrect documentation tags.
    public static let documentationComments: BuildSettingsKey = "CLANG_WARN_DOCUMENTATION_COMMENTS"
}

// MARK: Empty Loop Bodies
extension BuildSetting {

    /// Empty Loop Bodies
    ///
    /// Warn about loop bodies that are suspiciously empty.
    public static var emptyLoopBodies: BuildSetting { 
        BuildSetting(key: .emptyLoopBodies, value: "NO")
    }

    /// Empty Loop Bodies
    ///
    /// Warn about loop bodies that are suspiciously empty.
    public static func emptyLoopBodies(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .emptyLoopBodies, value: value.asText)
    }

    /// Empty Loop Bodies
    ///
    /// Warn about loop bodies that are suspiciously empty.
    public static func emptyLoopBodies(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .emptyLoopBodies, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Empty Loop Bodies
    ///
    /// Warn about loop bodies that are suspiciously empty.
    public static let emptyLoopBodies: BuildSettingsKey = "CLANG_WARN_EMPTY_BODY"
}

// MARK: Implicit Enum Conversions
extension BuildSetting {

    /// Implicit Enum Conversions
    ///
    /// Warn about implicit conversions between different kinds of enum values. For example, this can catch issues when using the wrong enum flag as an argument to a function or method.
    public static var implicitEnumConversions: BuildSetting { 
        .implicitEnumConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Enum Conversions
    ///
    /// Warn about implicit conversions between different kinds of enum values. For example, this can catch issues when using the wrong enum flag as an argument to a function or method.
    public static func implicitEnumConversions(_ value: ImplicitEnumConversions) -> BuildSetting { 
        BuildSetting(key: .implicitEnumConversions, value: \(value))
    }

    /// Implicit Enum Conversions
    ///
    /// Warn about implicit conversions between different kinds of enum values. For example, this can catch issues when using the wrong enum flag as an argument to a function or method.
    public static func implicitEnumConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitEnumConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Enum Conversions
    ///
    /// Warn about implicit conversions between different kinds of enum values. For example, this can catch issues when using the wrong enum flag as an argument to a function or method.
    public static let implicitEnumConversions: BuildSettingsKey = "CLANG_WARN_ENUM_CONVERSION"
}

public enum ImplicitEnumConversions: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Implicit Float Conversions
extension BuildSetting {

    /// Implicit Float Conversions
    ///
    /// Warn about implicit conversions that turn floating-point numbers into integers.
    public static var implicitFloatConversions: BuildSetting { 
        .implicitFloatConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Float Conversions
    ///
    /// Warn about implicit conversions that turn floating-point numbers into integers.
    public static func implicitFloatConversions(_ value: ImplicitFloatConversions) -> BuildSetting { 
        BuildSetting(key: .implicitFloatConversions, value: \(value))
    }

    /// Implicit Float Conversions
    ///
    /// Warn about implicit conversions that turn floating-point numbers into integers.
    public static func implicitFloatConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitFloatConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Float Conversions
    ///
    /// Warn about implicit conversions that turn floating-point numbers into integers.
    public static let implicitFloatConversions: BuildSettingsKey = "CLANG_WARN_FLOAT_CONVERSION"
}

public enum ImplicitFloatConversions: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Clang Warn Framework Include Private From Public
extension BuildSetting {

    /// Clang Warn Framework Include Private From Public
    public static var clangWarnFrameworkIncludePrivateFromPublic: BuildSetting { 
        BuildSetting(key: .clangWarnFrameworkIncludePrivateFromPublic, value: "NO")
    }

    /// Clang Warn Framework Include Private From Public
    public static func clangWarnFrameworkIncludePrivateFromPublic(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangWarnFrameworkIncludePrivateFromPublic, value: value.asText)
    }

    /// Clang Warn Framework Include Private From Public
    public static func clangWarnFrameworkIncludePrivateFromPublic(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangWarnFrameworkIncludePrivateFromPublic, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Warn Framework Include Private From Public
    public static let clangWarnFrameworkIncludePrivateFromPublic: BuildSettingsKey = "CLANG_WARN_FRAMEWORK_INCLUDE_PRIVATE_FROM_PUBLIC"
}

// MARK: Implicit Signedness Conversions
extension BuildSetting {

    /// Implicit Signedness Conversions
    ///
    /// Warn about implicit integer conversions that change the signedness of an integer value.
    public static var implicitSignednessConversions: BuildSetting { 
        .implicitSignednessConversions(.no) 
    }

    /// Implicit Signedness Conversions
    ///
    /// Warn about implicit integer conversions that change the signedness of an integer value.
    public static func implicitSignednessConversions(_ value: ImplicitSignednessConversions) -> BuildSetting { 
        BuildSetting(key: .implicitSignednessConversions, value: \(value))
    }

    /// Implicit Signedness Conversions
    ///
    /// Warn about implicit integer conversions that change the signedness of an integer value.
    public static func implicitSignednessConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitSignednessConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Signedness Conversions
    ///
    /// Warn about implicit integer conversions that change the signedness of an integer value.
    public static let implicitSignednessConversions: BuildSettingsKey = "CLANG_WARN_IMPLICIT_SIGN_CONVERSION"
}

public enum ImplicitSignednessConversions: String, Hashable, Codable, CustomStringConvertible {
    case yesError = "YES_ERROR"
    case no = "NO"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Infinite Recursion
extension BuildSetting {

    /// Infinite Recursion
    ///
    /// Warn if all paths through a function call itself.
    public static var infiniteRecursion: BuildSetting { 
        BuildSetting(key: .infiniteRecursion, value: "NO")
    }

    /// Infinite Recursion
    ///
    /// Warn if all paths through a function call itself.
    public static func infiniteRecursion(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .infiniteRecursion, value: value.asText)
    }

    /// Infinite Recursion
    ///
    /// Warn if all paths through a function call itself.
    public static func infiniteRecursion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infiniteRecursion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infinite Recursion
    ///
    /// Warn if all paths through a function call itself.
    public static let infiniteRecursion: BuildSettingsKey = "CLANG_WARN_INFINITE_RECURSION"
}

// MARK: Implicit Integer to Pointer Conversions
extension BuildSetting {

    /// Implicit Integer to Pointer Conversions
    ///
    /// Warn about implicit conversions between pointers and integers. For example, this can catch issues when one incorrectly intermixes using `NSNumber*`’s and raw integers.
    public static var implicitIntegerToPointerConversions: BuildSetting { 
        .implicitIntegerToPointerConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Integer to Pointer Conversions
    ///
    /// Warn about implicit conversions between pointers and integers. For example, this can catch issues when one incorrectly intermixes using `NSNumber*`’s and raw integers.
    public static func implicitIntegerToPointerConversions(_ value: ImplicitIntegerToPointerConversions) -> BuildSetting { 
        BuildSetting(key: .implicitIntegerToPointerConversions, value: \(value))
    }

    /// Implicit Integer to Pointer Conversions
    ///
    /// Warn about implicit conversions between pointers and integers. For example, this can catch issues when one incorrectly intermixes using `NSNumber*`’s and raw integers.
    public static func implicitIntegerToPointerConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitIntegerToPointerConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Integer to Pointer Conversions
    ///
    /// Warn about implicit conversions between pointers and integers. For example, this can catch issues when one incorrectly intermixes using `NSNumber*`’s and raw integers.
    public static let implicitIntegerToPointerConversions: BuildSettingsKey = "CLANG_WARN_INT_CONVERSION"
}

public enum ImplicitIntegerToPointerConversions: String, Hashable, Codable, CustomStringConvertible {
    case yesError = "YES_ERROR"
    case no = "NO"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Missing Noescape Annotation
extension BuildSetting {

    /// Missing Noescape Annotation
    ///
    /// Warn about noescape annotations that are missing in a method’s signature.
    public static var missingNoescapeAnnotation: BuildSetting { 
        .missingNoescapeAnnotation(.yes) 
    }

    /// Missing Noescape Annotation
    ///
    /// Warn about noescape annotations that are missing in a method’s signature.
    public static func missingNoescapeAnnotation(_ value: MissingNoescapeAnnotation) -> BuildSetting { 
        BuildSetting(key: .missingNoescapeAnnotation, value: \(value))
    }

    /// Missing Noescape Annotation
    ///
    /// Warn about noescape annotations that are missing in a method’s signature.
    public static func missingNoescapeAnnotation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingNoescapeAnnotation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Noescape Annotation
    ///
    /// Warn about noescape annotations that are missing in a method’s signature.
    public static let missingNoescapeAnnotation: BuildSettingsKey = "CLANG_WARN_MISSING_NOESCAPE"
}

public enum MissingNoescapeAnnotation: String, Hashable, Codable, CustomStringConvertible {
    case yesError = "YES_ERROR"
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}

// MARK: Implicit Non-Literal Null Conversions
extension BuildSetting {

    /// Implicit Non-Literal Null Conversions
    ///
    /// Warn about non-literal expressions that evaluate to zero being treated as a null pointer.
    public static var implicitNonLiteralNullConversions: BuildSetting { 
        .implicitNonLiteralNullConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Non-Literal Null Conversions
    ///
    /// Warn about non-literal expressions that evaluate to zero being treated as a null pointer.
    public static func implicitNonLiteralNullConversions(_ value: ImplicitNonLiteralNullConversions) -> BuildSetting { 
        BuildSetting(key: .implicitNonLiteralNullConversions, value: \(value))
    }

    /// Implicit Non-Literal Null Conversions
    ///
    /// Warn about non-literal expressions that evaluate to zero being treated as a null pointer.
    public static func implicitNonLiteralNullConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitNonLiteralNullConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Non-Literal Null Conversions
    ///
    /// Warn about non-literal expressions that evaluate to zero being treated as a null pointer.
    public static let implicitNonLiteralNullConversions: BuildSettingsKey = "CLANG_WARN_NON_LITERAL_NULL_CONVERSION"
}

public enum ImplicitNonLiteralNullConversions: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Incorrect Uses of Nullable Values
extension BuildSetting {

    /// Incorrect Uses of Nullable Values
    ///
    /// Warns when a nullable expression is used somewhere it’s not allowed, such as when passed as a `_Nonnull` parameter.
    public static var incorrectUsesOfNullableValues: BuildSetting { 
        BuildSetting(key: .incorrectUsesOfNullableValues, value: "NO")
    }

    /// Incorrect Uses of Nullable Values
    ///
    /// Warns when a nullable expression is used somewhere it’s not allowed, such as when passed as a `_Nonnull` parameter.
    public static func incorrectUsesOfNullableValues(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .incorrectUsesOfNullableValues, value: value.asText)
    }

    /// Incorrect Uses of Nullable Values
    ///
    /// Warns when a nullable expression is used somewhere it’s not allowed, such as when passed as a `_Nonnull` parameter.
    public static func incorrectUsesOfNullableValues(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .incorrectUsesOfNullableValues, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Incorrect Uses of Nullable Values
    ///
    /// Warns when a nullable expression is used somewhere it’s not allowed, such as when passed as a `_Nonnull` parameter.
    public static let incorrectUsesOfNullableValues: BuildSettingsKey = "CLANG_WARN_NULLABLE_TO_NONNULL_CONVERSION"
}

// MARK: Implicit ownership types on out parameters
extension BuildSetting {

    /// Implicit ownership types on out parameters
    ///
    /// Warn about implicit ownership types on Objective-C object references as out parameters. For example, declaring a parameter with type `NSObject**` will produce a warning because the compiler will assume that the out parameter’s ownership type is `__autoreleasing`.
    public static var implicitOwnershipTypesOnOutParameters: BuildSetting { 
        BuildSetting(key: .implicitOwnershipTypesOnOutParameters, value: "NO")
    }

    /// Implicit ownership types on out parameters
    ///
    /// Warn about implicit ownership types on Objective-C object references as out parameters. For example, declaring a parameter with type `NSObject**` will produce a warning because the compiler will assume that the out parameter’s ownership type is `__autoreleasing`.
    public static func implicitOwnershipTypesOnOutParameters(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitOwnershipTypesOnOutParameters, value: value.asText)
    }

    /// Implicit ownership types on out parameters
    ///
    /// Warn about implicit ownership types on Objective-C object references as out parameters. For example, declaring a parameter with type `NSObject**` will produce a warning because the compiler will assume that the out parameter’s ownership type is `__autoreleasing`.
    public static func implicitOwnershipTypesOnOutParameters(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitOwnershipTypesOnOutParameters, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit ownership types on out parameters
    ///
    /// Warn about implicit ownership types on Objective-C object references as out parameters. For example, declaring a parameter with type `NSObject**` will produce a warning because the compiler will assume that the out parameter’s ownership type is `__autoreleasing`.
    public static let implicitOwnershipTypesOnOutParameters: BuildSettingsKey = "CLANG_WARN_OBJC_EXPLICIT_OWNERSHIP_TYPE"
}

// MARK: Implicit Atomic Objective-C Properties
extension BuildSetting {

    /// Implicit Atomic Objective-C Properties
    ///
    /// Warn about `@property` declarations that are implicitly atomic.
    public static var implicitAtomicObjectiveCProperties: BuildSetting { 
        BuildSetting(key: .implicitAtomicObjectiveCProperties, value: "NO")
    }

    /// Implicit Atomic Objective-C Properties
    ///
    /// Warn about `@property` declarations that are implicitly atomic.
    public static func implicitAtomicObjectiveCProperties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitAtomicObjectiveCProperties, value: value.asText)
    }

    /// Implicit Atomic Objective-C Properties
    ///
    /// Warn about `@property` declarations that are implicitly atomic.
    public static func implicitAtomicObjectiveCProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitAtomicObjectiveCProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Atomic Objective-C Properties
    ///
    /// Warn about `@property` declarations that are implicitly atomic.
    public static let implicitAtomicObjectiveCProperties: BuildSettingsKey = "CLANG_WARN_OBJC_IMPLICIT_ATOMIC_PROPERTIES"
}

// MARK: Implicit retain of 'self' within blocks
extension BuildSetting {

    /// Implicit retain of 'self' within blocks
    ///
    /// Warn about implicit retains of `self` within blocks, which can create a retain-cycle.
    public static var implicitRetainOfSelfWithinBlocks: BuildSetting { 
        BuildSetting(key: .implicitRetainOfSelfWithinBlocks, value: "NO")
    }

    /// Implicit retain of 'self' within blocks
    ///
    /// Warn about implicit retains of `self` within blocks, which can create a retain-cycle.
    public static func implicitRetainOfSelfWithinBlocks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitRetainOfSelfWithinBlocks, value: value.asText)
    }

    /// Implicit retain of 'self' within blocks
    ///
    /// Warn about implicit retains of `self` within blocks, which can create a retain-cycle.
    public static func implicitRetainOfSelfWithinBlocks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitRetainOfSelfWithinBlocks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit retain of 'self' within blocks
    ///
    /// Warn about implicit retains of `self` within blocks, which can create a retain-cycle.
    public static let implicitRetainOfSelfWithinBlocks: BuildSettingsKey = "CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF"
}

// MARK: Interface Declarations of Instance Variables
extension BuildSetting {

    /// Interface Declarations of Instance Variables
    ///
    /// Warn about instance variable declarations in `@interface`.
    public static var interfaceDeclarationsOfInstanceVariables: BuildSetting { 
        .interfaceDeclarationsOfInstanceVariables(.no) 
    }

    /// Interface Declarations of Instance Variables
    ///
    /// Warn about instance variable declarations in `@interface`.
    public static func interfaceDeclarationsOfInstanceVariables(_ value: InterfaceDeclarationsOfInstanceVariables) -> BuildSetting { 
        BuildSetting(key: .interfaceDeclarationsOfInstanceVariables, value: \(value))
    }

    /// Interface Declarations of Instance Variables
    ///
    /// Warn about instance variable declarations in `@interface`.
    public static func interfaceDeclarationsOfInstanceVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .interfaceDeclarationsOfInstanceVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Interface Declarations of Instance Variables
    ///
    /// Warn about instance variable declarations in `@interface`.
    public static let interfaceDeclarationsOfInstanceVariables: BuildSettingsKey = "CLANG_WARN_OBJC_INTERFACE_IVARS"
}

public enum InterfaceDeclarationsOfInstanceVariables: String, Hashable, Codable, CustomStringConvertible {
    case yesError = "YES_ERROR"
    case no = "NO"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Implicit Objective-C Literal Conversions
extension BuildSetting {

    /// Implicit Objective-C Literal Conversions
    ///
    /// Warn about implicit conversions from Objective-C literals to values of incompatible type.
    public static var implicitObjectiveCLiteralConversions: BuildSetting { 
        .implicitObjectiveCLiteralConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Objective-C Literal Conversions
    ///
    /// Warn about implicit conversions from Objective-C literals to values of incompatible type.
    public static func implicitObjectiveCLiteralConversions(_ value: ImplicitObjectiveCLiteralConversions) -> BuildSetting { 
        BuildSetting(key: .implicitObjectiveCLiteralConversions, value: \(value))
    }

    /// Implicit Objective-C Literal Conversions
    ///
    /// Warn about implicit conversions from Objective-C literals to values of incompatible type.
    public static func implicitObjectiveCLiteralConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitObjectiveCLiteralConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Objective-C Literal Conversions
    ///
    /// Warn about implicit conversions from Objective-C literals to values of incompatible type.
    public static let implicitObjectiveCLiteralConversions: BuildSettingsKey = "CLANG_WARN_OBJC_LITERAL_CONVERSION"
}

public enum ImplicitObjectiveCLiteralConversions: String, Hashable, Codable, CustomStringConvertible {
    case yesError = "YES_ERROR"
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}

// MARK: Implicit Synthesized Properties
extension BuildSetting {

    /// Implicit Synthesized Properties
    ///
    /// Starting in Xcode 4.4, Apple Clang will implicitly synthesize properties that are not explicitly synthesized using `@synthesize`. This setting warns about such implicit behavior, even though the property is still synthesized. This is essentially a backwards compatibility warning, or for those who wish to continue to explicitly use `@synthesize`.
    public static var implicitSynthesizedProperties: BuildSetting { 
        BuildSetting(key: .implicitSynthesizedProperties, value: "NO")
    }

    /// Implicit Synthesized Properties
    ///
    /// Starting in Xcode 4.4, Apple Clang will implicitly synthesize properties that are not explicitly synthesized using `@synthesize`. This setting warns about such implicit behavior, even though the property is still synthesized. This is essentially a backwards compatibility warning, or for those who wish to continue to explicitly use `@synthesize`.
    public static func implicitSynthesizedProperties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitSynthesizedProperties, value: value.asText)
    }

    /// Implicit Synthesized Properties
    ///
    /// Starting in Xcode 4.4, Apple Clang will implicitly synthesize properties that are not explicitly synthesized using `@synthesize`. This setting warns about such implicit behavior, even though the property is still synthesized. This is essentially a backwards compatibility warning, or for those who wish to continue to explicitly use `@synthesize`.
    public static func implicitSynthesizedProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitSynthesizedProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Synthesized Properties
    ///
    /// Starting in Xcode 4.4, Apple Clang will implicitly synthesize properties that are not explicitly synthesized using `@synthesize`. This setting warns about such implicit behavior, even though the property is still synthesized. This is essentially a backwards compatibility warning, or for those who wish to continue to explicitly use `@synthesize`.
    public static let implicitSynthesizedProperties: BuildSettingsKey = "CLANG_WARN_OBJC_MISSING_PROPERTY_SYNTHESIS"
}

// MARK: Repeatedly using a __weak reference
extension BuildSetting {

    /// Repeatedly using a __weak reference
    ///
    /// Warn about repeatedly using a weak reference without assigning the weak reference to a strong reference. This is often symptomatic of a race condition where the weak reference can become `nil` between accesses, resulting in unexpected behavior. Assigning to temporary strong reference ensures the object stays alive during the related accesses.
    public static var repeatedlyUsingAWeakReference: BuildSetting { 
        .repeatedlyUsingAWeakReference(.no) 
    }

    /// Repeatedly using a __weak reference
    ///
    /// Warn about repeatedly using a weak reference without assigning the weak reference to a strong reference. This is often symptomatic of a race condition where the weak reference can become `nil` between accesses, resulting in unexpected behavior. Assigning to temporary strong reference ensures the object stays alive during the related accesses.
    public static func repeatedlyUsingAWeakReference(_ value: RepeatedlyUsingAWeakReference) -> BuildSetting { 
        BuildSetting(key: .repeatedlyUsingAWeakReference, value: \(value))
    }

    /// Repeatedly using a __weak reference
    ///
    /// Warn about repeatedly using a weak reference without assigning the weak reference to a strong reference. This is often symptomatic of a race condition where the weak reference can become `nil` between accesses, resulting in unexpected behavior. Assigning to temporary strong reference ensures the object stays alive during the related accesses.
    public static func repeatedlyUsingAWeakReference(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .repeatedlyUsingAWeakReference, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Repeatedly using a __weak reference
    ///
    /// Warn about repeatedly using a weak reference without assigning the weak reference to a strong reference. This is often symptomatic of a race condition where the weak reference can become `nil` between accesses, resulting in unexpected behavior. Assigning to temporary strong reference ensures the object stays alive during the related accesses.
    public static let repeatedlyUsingAWeakReference: BuildSettingsKey = "CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK"
}

public enum RepeatedlyUsingAWeakReference: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yesAggressive = "YES_AGGRESSIVE"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Unintentional Root Class
extension BuildSetting {

    /// Unintentional Root Class
    ///
    /// Warn about classes that unintentionally do not subclass a root class, such as `NSObject`.
    public static var unintentionalRootClass: BuildSetting { 
        .unintentionalRootClass(.yes) 
    }

    /// Unintentional Root Class
    ///
    /// Warn about classes that unintentionally do not subclass a root class, such as `NSObject`.
    public static func unintentionalRootClass(_ value: UnintentionalRootClass) -> BuildSetting { 
        BuildSetting(key: .unintentionalRootClass, value: \(value))
    }

    /// Unintentional Root Class
    ///
    /// Warn about classes that unintentionally do not subclass a root class, such as `NSObject`.
    public static func unintentionalRootClass(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unintentionalRootClass, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unintentional Root Class
    ///
    /// Warn about classes that unintentionally do not subclass a root class, such as `NSObject`.
    public static let unintentionalRootClass: BuildSettingsKey = "CLANG_WARN_OBJC_ROOT_CLASS"
}

public enum UnintentionalRootClass: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Suspicious Pragma Pack
extension BuildSetting {

    /// Suspicious Pragma Pack
    ///
    /// Warn when a translation unit is missing terminating ‘#pragma pack (pop)’ directives or when the ‘#pragma pack’ state immediately after an #include is different from the state immediately before.
    public static var suspiciousPragmaPack: BuildSetting { 
        .suspiciousPragmaPack(.yes) 
    }

    /// Suspicious Pragma Pack
    ///
    /// Warn when a translation unit is missing terminating ‘#pragma pack (pop)’ directives or when the ‘#pragma pack’ state immediately after an #include is different from the state immediately before.
    public static func suspiciousPragmaPack(_ value: SuspiciousPragmaPack) -> BuildSetting { 
        BuildSetting(key: .suspiciousPragmaPack, value: \(value))
    }

    /// Suspicious Pragma Pack
    ///
    /// Warn when a translation unit is missing terminating ‘#pragma pack (pop)’ directives or when the ‘#pragma pack’ state immediately after an #include is different from the state immediately before.
    public static func suspiciousPragmaPack(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousPragmaPack, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Pragma Pack
    ///
    /// Warn when a translation unit is missing terminating ‘#pragma pack (pop)’ directives or when the ‘#pragma pack’ state immediately after an #include is different from the state immediately before.
    public static let suspiciousPragmaPack: BuildSettingsKey = "CLANG_WARN_PRAGMA_PACK"
}

public enum SuspiciousPragmaPack: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Outdated Private Module Map
extension BuildSetting {

    /// Outdated Private Module Map
    ///
    /// Warn about private modules that do not use the recommended private module layout.
    public static var outdatedPrivateModuleMap: BuildSetting { 
        BuildSetting(key: .outdatedPrivateModuleMap, value: "YES")
    }

    /// Outdated Private Module Map
    ///
    /// Warn about private modules that do not use the recommended private module layout.
    public static func outdatedPrivateModuleMap(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .outdatedPrivateModuleMap, value: value.asText)
    }

    /// Outdated Private Module Map
    ///
    /// Warn about private modules that do not use the recommended private module layout.
    public static func outdatedPrivateModuleMap(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .outdatedPrivateModuleMap, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Outdated Private Module Map
    ///
    /// Warn about private modules that do not use the recommended private module layout.
    public static let outdatedPrivateModuleMap: BuildSettingsKey = "CLANG_WARN_PRIVATE_MODULE"
}

// MARK: Quoted Include In Framework Header
extension BuildSetting {

    /// Quoted Include In Framework Header
    ///
    /// Warns when a quoted include is used instead of a framework style include in a framework header.
    public static var quotedIncludeInFrameworkHeader: BuildSetting { 
        .quotedIncludeInFrameworkHeader(.no) 
    }

    /// Quoted Include In Framework Header
    ///
    /// Warns when a quoted include is used instead of a framework style include in a framework header.
    public static func quotedIncludeInFrameworkHeader(_ value: QuotedIncludeInFrameworkHeader) -> BuildSetting { 
        BuildSetting(key: .quotedIncludeInFrameworkHeader, value: \(value))
    }

    /// Quoted Include In Framework Header
    ///
    /// Warns when a quoted include is used instead of a framework style include in a framework header.
    public static func quotedIncludeInFrameworkHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .quotedIncludeInFrameworkHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Quoted Include In Framework Header
    ///
    /// Warns when a quoted include is used instead of a framework style include in a framework header.
    public static let quotedIncludeInFrameworkHeader: BuildSettingsKey = "CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER"
}

public enum QuotedIncludeInFrameworkHeader: String, Hashable, Codable, CustomStringConvertible {
    case yesError = "YES_ERROR"
    case no = "NO"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Range-based For Loops
extension BuildSetting {

    /// Range-based For Loops
    ///
    /// Warn about ranged-based for loops.
    public static var rangeBasedForLoops: BuildSetting { 
        BuildSetting(key: .rangeBasedForLoops, value: "NO")
    }

    /// Range-based For Loops
    ///
    /// Warn about ranged-based for loops.
    public static func rangeBasedForLoops(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .rangeBasedForLoops, value: value.asText)
    }

    /// Range-based For Loops
    ///
    /// Warn about ranged-based for loops.
    public static func rangeBasedForLoops(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rangeBasedForLoops, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Range-based For Loops
    ///
    /// Warn about ranged-based for loops.
    public static let rangeBasedForLoops: BuildSettingsKey = "CLANG_WARN_RANGE_LOOP_ANALYSIS"
}

// MARK: Semicolon Before Method Body
extension BuildSetting {

    /// Semicolon Before Method Body
    ///
    /// Warn about ignored semicolon between a method implementation’s signature and body.
    public static var semicolonBeforeMethodBody: BuildSetting { 
        BuildSetting(key: .semicolonBeforeMethodBody, value: "NO")
    }

    /// Semicolon Before Method Body
    ///
    /// Warn about ignored semicolon between a method implementation’s signature and body.
    public static func semicolonBeforeMethodBody(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .semicolonBeforeMethodBody, value: value.asText)
    }

    /// Semicolon Before Method Body
    ///
    /// Warn about ignored semicolon between a method implementation’s signature and body.
    public static func semicolonBeforeMethodBody(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .semicolonBeforeMethodBody, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Semicolon Before Method Body
    ///
    /// Warn about ignored semicolon between a method implementation’s signature and body.
    public static let semicolonBeforeMethodBody: BuildSettingsKey = "CLANG_WARN_SEMICOLON_BEFORE_METHOD_BODY"
}

// MARK: Strict Prototypes
extension BuildSetting {

    /// Strict Prototypes
    ///
    /// Warn about non-prototype declarations.
    public static var strictPrototypes: BuildSetting { 
        .strictPrototypes(.no) 
    }

    /// Strict Prototypes
    ///
    /// Warn about non-prototype declarations.
    public static func strictPrototypes(_ value: StrictPrototypes) -> BuildSetting { 
        BuildSetting(key: .strictPrototypes, value: \(value))
    }

    /// Strict Prototypes
    ///
    /// Warn about non-prototype declarations.
    public static func strictPrototypes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .strictPrototypes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strict Prototypes
    ///
    /// Warn about non-prototype declarations.
    public static let strictPrototypes: BuildSettingsKey = "CLANG_WARN_STRICT_PROTOTYPES"
}

public enum StrictPrototypes: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}

// MARK: Suspicious Implicit Conversions
extension BuildSetting {

    /// Suspicious Implicit Conversions
    ///
    /// Warn about various implicit conversions that can lose information or are otherwise suspicious.
    public static var suspiciousImplicitConversions: BuildSetting { 
        .suspiciousImplicitConversions(.no) 
    }

    /// Suspicious Implicit Conversions
    ///
    /// Warn about various implicit conversions that can lose information or are otherwise suspicious.
    public static func suspiciousImplicitConversions(_ value: SuspiciousImplicitConversions) -> BuildSetting { 
        BuildSetting(key: .suspiciousImplicitConversions, value: \(value))
    }

    /// Suspicious Implicit Conversions
    ///
    /// Warn about various implicit conversions that can lose information or are otherwise suspicious.
    public static func suspiciousImplicitConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousImplicitConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Implicit Conversions
    ///
    /// Warn about various implicit conversions that can lose information or are otherwise suspicious.
    public static let suspiciousImplicitConversions: BuildSettingsKey = "CLANG_WARN_SUSPICIOUS_IMPLICIT_CONVERSION"
}

public enum SuspiciousImplicitConversions: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Suspicious Moves
extension BuildSetting {

    /// Suspicious Moves
    ///
    /// Warn about suspicious uses of `std::move`.
    public static var suspiciousMoves: BuildSetting { 
        BuildSetting(key: .suspiciousMoves, value: "NO")
    }

    /// Suspicious Moves
    ///
    /// Warn about suspicious uses of `std::move`.
    public static func suspiciousMoves(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suspiciousMoves, value: value.asText)
    }

    /// Suspicious Moves
    ///
    /// Warn about suspicious uses of `std::move`.
    public static func suspiciousMoves(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousMoves, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Moves
    ///
    /// Warn about suspicious uses of `std::move`.
    public static let suspiciousMoves: BuildSettingsKey = "CLANG_WARN_SUSPICIOUS_MOVE"
}

// MARK: Unguarded availability
extension BuildSetting {

    /// Unguarded availability
    ///
    /// Warn if an API that is newer than the deployment target is used without “if (@available(…))” guards.
    public static var unguardedAvailability: BuildSetting { 
        .unguardedAvailability(.yes) 
    }

    /// Unguarded availability
    ///
    /// Warn if an API that is newer than the deployment target is used without “if (@available(…))” guards.
    public static func unguardedAvailability(_ value: UnguardedAvailability) -> BuildSetting { 
        BuildSetting(key: .unguardedAvailability, value: \(value))
    }

    /// Unguarded availability
    ///
    /// Warn if an API that is newer than the deployment target is used without “if (@available(…))” guards.
    public static func unguardedAvailability(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unguardedAvailability, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unguarded availability
    ///
    /// Warn if an API that is newer than the deployment target is used without “if (@available(…))” guards.
    public static let unguardedAvailability: BuildSettingsKey = "CLANG_WARN_UNGUARDED_AVAILABILITY"
}

public enum UnguardedAvailability: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesAggressive = "YES_AGGRESSIVE"

    public var description: String {
        rawValue
    }
}

// MARK: Unreachable Code
extension BuildSetting {

    /// Unreachable Code
    ///
    /// Warns about potentially unreachable code.
    public static var unreachableCode: BuildSetting { 
        .unreachableCode(.no) 
    }

    /// Unreachable Code
    ///
    /// Warns about potentially unreachable code.
    public static func unreachableCode(_ value: UnreachableCode) -> BuildSetting { 
        BuildSetting(key: .unreachableCode, value: \(value))
    }

    /// Unreachable Code
    ///
    /// Warns about potentially unreachable code.
    public static func unreachableCode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unreachableCode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unreachable Code
    ///
    /// Warns about potentially unreachable code.
    public static let unreachableCode: BuildSettingsKey = "CLANG_WARN_UNREACHABLE_CODE"
}

public enum UnreachableCode: String, Hashable, Codable, CustomStringConvertible {
    case yesAggressive = "YES_AGGRESSIVE"
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}

// MARK: Ambiguous C++ Parsing Situation
extension BuildSetting {

    /// Ambiguous C++ Parsing Situation
    ///
    /// Warn about a parsing ambiguity between a variable declaration and a function-style cast.
    public static var ambiguousCppParsingSituation: BuildSetting { 
        .ambiguousCppParsingSituation(.yes) 
    }

    /// Ambiguous C++ Parsing Situation
    ///
    /// Warn about a parsing ambiguity between a variable declaration and a function-style cast.
    public static func ambiguousCppParsingSituation(_ value: AmbiguousCppParsingSituation) -> BuildSetting { 
        BuildSetting(key: .ambiguousCppParsingSituation, value: \(value))
    }

    /// Ambiguous C++ Parsing Situation
    ///
    /// Warn about a parsing ambiguity between a variable declaration and a function-style cast.
    public static func ambiguousCppParsingSituation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ambiguousCppParsingSituation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ambiguous C++ Parsing Situation
    ///
    /// Warn about a parsing ambiguity between a variable declaration and a function-style cast.
    public static let ambiguousCppParsingSituation: BuildSettingsKey = "CLANG_WARN_VEXING_PARSE"
}

public enum AmbiguousCppParsingSituation: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}

// MARK: Using __bridge Casts Outside of ARC
extension BuildSetting {

    /// Using __bridge Casts Outside of ARC
    ///
    /// Warn about using `__bridge` casts when not using ARC, where they have no effect.
    public static var usingBridgeCastsOutsideOfArc: BuildSetting { 
        BuildSetting(key: .usingBridgeCastsOutsideOfArc, value: "YES")
    }

    /// Using __bridge Casts Outside of ARC
    ///
    /// Warn about using `__bridge` casts when not using ARC, where they have no effect.
    public static func usingBridgeCastsOutsideOfArc(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .usingBridgeCastsOutsideOfArc, value: value.asText)
    }

    /// Using __bridge Casts Outside of ARC
    ///
    /// Warn about using `__bridge` casts when not using ARC, where they have no effect.
    public static func usingBridgeCastsOutsideOfArc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .usingBridgeCastsOutsideOfArc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Using __bridge Casts Outside of ARC
    ///
    /// Warn about using `__bridge` casts when not using ARC, where they have no effect.
    public static let usingBridgeCastsOutsideOfArc: BuildSettingsKey = "CLANG_WARN__ARC_BRIDGE_CAST_NONARC"
}

// MARK: Duplicate Method Definitions
extension BuildSetting {

    /// Duplicate Method Definitions
    ///
    /// Warn about declaring the same method more than once within the same `@interface`.
    public static var duplicateMethodDefinitions: BuildSetting { 
        BuildSetting(key: .duplicateMethodDefinitions, value: "NO")
    }

    /// Duplicate Method Definitions
    ///
    /// Warn about declaring the same method more than once within the same `@interface`.
    public static func duplicateMethodDefinitions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .duplicateMethodDefinitions, value: value.asText)
    }

    /// Duplicate Method Definitions
    ///
    /// Warn about declaring the same method more than once within the same `@interface`.
    public static func duplicateMethodDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .duplicateMethodDefinitions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Duplicate Method Definitions
    ///
    /// Warn about declaring the same method more than once within the same `@interface`.
    public static let duplicateMethodDefinitions: BuildSettingsKey = "CLANG_WARN__DUPLICATE_METHOD_MATCH"
}

// MARK: Exit-Time C++ Destructors
extension BuildSetting {

    /// Exit-Time C++ Destructors
    ///
    /// Warn about destructors for C++ objects that are called when an application is terminating.
    public static var exitTimeCppDestructors: BuildSetting { 
        BuildSetting(key: .exitTimeCppDestructors, value: "NO")
    }

    /// Exit-Time C++ Destructors
    ///
    /// Warn about destructors for C++ objects that are called when an application is terminating.
    public static func exitTimeCppDestructors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .exitTimeCppDestructors, value: value.asText)
    }

    /// Exit-Time C++ Destructors
    ///
    /// Warn about destructors for C++ objects that are called when an application is terminating.
    public static func exitTimeCppDestructors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .exitTimeCppDestructors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Exit-Time C++ Destructors
    ///
    /// Warn about destructors for C++ objects that are called when an application is terminating.
    public static let exitTimeCppDestructors: BuildSettingsKey = "CLANG_WARN__EXIT_TIME_DESTRUCTORS"
}

// MARK: Cpp Headermap File
extension BuildSetting {

    /// Cpp Headermap File
    public static var cppHeadermapFile: BuildSetting { 
        BuildSetting(key: .cppHeadermapFile, value: "$(TEMP_DIR)/$(PRODUCT_NAME).hmap")
    }

    /// Cpp Headermap File
    public static func cppHeadermapFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFile, value: \(value))
    }

    /// Cpp Headermap File
    public static func cppHeadermapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Headermap File
    public static let cppHeadermapFile: BuildSettingsKey = "CPP_HEADERMAP_FILE"
}

// MARK: Cpp Headermap File For All Non Framework Target Headers
extension BuildSetting {

    /// Cpp Headermap File For All Non Framework Target Headers
    public static var cppHeadermapFileForAllNonFrameworkTargetHeaders: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForAllNonFrameworkTargetHeaders, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-all-non-framework-target-headers.hmap")
    }

    /// Cpp Headermap File For All Non Framework Target Headers
    public static func cppHeadermapFileForAllNonFrameworkTargetHeaders(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForAllNonFrameworkTargetHeaders, value: \(value))
    }

    /// Cpp Headermap File For All Non Framework Target Headers
    public static func cppHeadermapFileForAllNonFrameworkTargetHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForAllNonFrameworkTargetHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Headermap File For All Non Framework Target Headers
    public static let cppHeadermapFileForAllNonFrameworkTargetHeaders: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_ALL_NON_FRAMEWORK_TARGET_HEADERS"
}

// MARK: Cpp Headermap File For All Target Headers
extension BuildSetting {

    /// Cpp Headermap File For All Target Headers
    public static var cppHeadermapFileForAllTargetHeaders: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForAllTargetHeaders, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-all-target-headers.hmap")
    }

    /// Cpp Headermap File For All Target Headers
    public static func cppHeadermapFileForAllTargetHeaders(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForAllTargetHeaders, value: \(value))
    }

    /// Cpp Headermap File For All Target Headers
    public static func cppHeadermapFileForAllTargetHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForAllTargetHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Headermap File For All Target Headers
    public static let cppHeadermapFileForAllTargetHeaders: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_ALL_TARGET_HEADERS"
}

// MARK: Cpp Headermap File For Generated Files
extension BuildSetting {

    /// Cpp Headermap File For Generated Files
    public static var cppHeadermapFileForGeneratedFiles: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForGeneratedFiles, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-generated-files.hmap")
    }

    /// Cpp Headermap File For Generated Files
    public static func cppHeadermapFileForGeneratedFiles(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForGeneratedFiles, value: \(value))
    }

    /// Cpp Headermap File For Generated Files
    public static func cppHeadermapFileForGeneratedFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForGeneratedFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Headermap File For Generated Files
    public static let cppHeadermapFileForGeneratedFiles: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_GENERATED_FILES"
}

// MARK: Cpp Headermap File For Own Target Headers
extension BuildSetting {

    /// Cpp Headermap File For Own Target Headers
    public static var cppHeadermapFileForOwnTargetHeaders: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForOwnTargetHeaders, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-own-target-headers.hmap")
    }

    /// Cpp Headermap File For Own Target Headers
    public static func cppHeadermapFileForOwnTargetHeaders(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForOwnTargetHeaders, value: \(value))
    }

    /// Cpp Headermap File For Own Target Headers
    public static func cppHeadermapFileForOwnTargetHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForOwnTargetHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Headermap File For Own Target Headers
    public static let cppHeadermapFileForOwnTargetHeaders: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_OWN_TARGET_HEADERS"
}

// MARK: Cpp Headermap File For Project Files
extension BuildSetting {

    /// Cpp Headermap File For Project Files
    public static var cppHeadermapFileForProjectFiles: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForProjectFiles, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-project-headers.hmap")
    }

    /// Cpp Headermap File For Project Files
    public static func cppHeadermapFileForProjectFiles(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForProjectFiles, value: \(value))
    }

    /// Cpp Headermap File For Project Files
    public static func cppHeadermapFileForProjectFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForProjectFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Headermap File For Project Files
    public static let cppHeadermapFileForProjectFiles: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_PROJECT_FILES"
}

// MARK: Cpp Headermap Product Headers Vfs File
extension BuildSetting {

    /// Cpp Headermap Product Headers Vfs File
    public static var cppHeadermapProductHeadersVfsFile: BuildSetting { 
        BuildSetting(key: .cppHeadermapProductHeadersVfsFile, value: "$(PROJECT_TEMP_DIR)/all-product-headers.yaml")
    }

    /// Cpp Headermap Product Headers Vfs File
    public static func cppHeadermapProductHeadersVfsFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapProductHeadersVfsFile, value: \(value))
    }

    /// Cpp Headermap Product Headers Vfs File
    public static func cppHeadermapProductHeadersVfsFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapProductHeadersVfsFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Headermap Product Headers Vfs File
    public static let cppHeadermapProductHeadersVfsFile: BuildSettingsKey = "CPP_HEADERMAP_PRODUCT_HEADERS_VFS_FILE"
}

// MARK: Cpp Header Symlinks Dir
extension BuildSetting {

    /// Cpp Header Symlinks Dir
    public static var cppHeaderSymlinksDir: BuildSetting { 
        BuildSetting(key: .cppHeaderSymlinksDir, value: "$(TEMP_DIR)/$(PRODUCT_NAME).hdrs")
    }

    /// Cpp Header Symlinks Dir
    public static func cppHeaderSymlinksDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeaderSymlinksDir, value: \(value))
    }

    /// Cpp Header Symlinks Dir
    public static func cppHeaderSymlinksDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeaderSymlinksDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Header Symlinks Dir
    public static let cppHeaderSymlinksDir: BuildSettingsKey = "CPP_HEADER_SYMLINKS_DIR"
}

// MARK: Enable Apple Kext Code Generation
extension BuildSetting {

    /// Enable Apple Kext Code Generation
    public static var enableAppleKextCodeGeneration: BuildSetting { 
        BuildSetting(key: .enableAppleKextCodeGeneration, value: "NO")
    }

    /// Enable Apple Kext Code Generation
    public static func enableAppleKextCodeGeneration(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableAppleKextCodeGeneration, value: value.asText)
    }

    /// Enable Apple Kext Code Generation
    public static func enableAppleKextCodeGeneration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableAppleKextCodeGeneration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Apple Kext Code Generation
    public static let enableAppleKextCodeGeneration: BuildSettingsKey = "ENABLE_APPLE_KEXT_CODE_GENERATION"
}

// MARK: Enable Foundation Assertions
extension BuildSetting {

    /// Enable Foundation Assertions
    ///
    /// Controls whether assertion logic provided by `NSAssert` is included in the preprocessed source code or is elided during preprocessing. Disabling assertions can improve code performance.
    public static var enableFoundationAssertions: BuildSetting { 
        BuildSetting(key: .enableFoundationAssertions, value: "YES")
    }

    /// Enable Foundation Assertions
    ///
    /// Controls whether assertion logic provided by `NSAssert` is included in the preprocessed source code or is elided during preprocessing. Disabling assertions can improve code performance.
    public static func enableFoundationAssertions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableFoundationAssertions, value: value.asText)
    }

    /// Enable Foundation Assertions
    ///
    /// Controls whether assertion logic provided by `NSAssert` is included in the preprocessed source code or is elided during preprocessing. Disabling assertions can improve code performance.
    public static func enableFoundationAssertions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableFoundationAssertions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Foundation Assertions
    ///
    /// Controls whether assertion logic provided by `NSAssert` is included in the preprocessed source code or is elided during preprocessing. Disabling assertions can improve code performance.
    public static let enableFoundationAssertions: BuildSettingsKey = "ENABLE_NS_ASSERTIONS"
}

// MARK: Enable Strict Checking of objc_msgSend Calls
extension BuildSetting {

    /// Enable Strict Checking of objc_msgSend Calls
    ///
    /// Controls whether `objc_msgSend` calls must be cast to the appropriate function pointer type before being called.
    public static var enableStrictCheckingOfObjcMsgsendCalls: BuildSetting { 
        BuildSetting(key: .enableStrictCheckingOfObjcMsgsendCalls, value: "NO")
    }

    /// Enable Strict Checking of objc_msgSend Calls
    ///
    /// Controls whether `objc_msgSend` calls must be cast to the appropriate function pointer type before being called.
    public static func enableStrictCheckingOfObjcMsgsendCalls(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableStrictCheckingOfObjcMsgsendCalls, value: value.asText)
    }

    /// Enable Strict Checking of objc_msgSend Calls
    ///
    /// Controls whether `objc_msgSend` calls must be cast to the appropriate function pointer type before being called.
    public static func enableStrictCheckingOfObjcMsgsendCalls(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableStrictCheckingOfObjcMsgsendCalls, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Strict Checking of objc_msgSend Calls
    ///
    /// Controls whether `objc_msgSend` calls must be cast to the appropriate function pointer type before being called.
    public static let enableStrictCheckingOfObjcMsgsendCalls: BuildSettingsKey = "ENABLE_STRICT_OBJC_MSGSEND"
}

// MARK: 'char' Type Is Unsigned
extension BuildSetting {

    /// 'char' Type Is Unsigned
    ///
    /// Enabling this setting causes `char` to be unsigned by default, disabling it causes `char` to be signed by default.
    public static var CharTypeIsUnsigned: BuildSetting { 
        BuildSetting(key: .CharTypeIsUnsigned, value: "NO")
    }

    /// 'char' Type Is Unsigned
    ///
    /// Enabling this setting causes `char` to be unsigned by default, disabling it causes `char` to be signed by default.
    public static func CharTypeIsUnsigned(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .CharTypeIsUnsigned, value: value.asText)
    }

    /// 'char' Type Is Unsigned
    ///
    /// Enabling this setting causes `char` to be unsigned by default, disabling it causes `char` to be signed by default.
    public static func CharTypeIsUnsigned(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .CharTypeIsUnsigned, inherit: key)
    }
}

extension BuildSettingsKey {

    /// 'char' Type Is Unsigned
    ///
    /// Enabling this setting causes `char` to be unsigned by default, disabling it causes `char` to be signed by default.
    public static let CharTypeIsUnsigned: BuildSettingsKey = "GCC_CHAR_IS_UNSIGNED_CHAR"
}

// MARK: CodeWarrior/MS-Style Inline Assembly
extension BuildSetting {

    /// CodeWarrior/MS-Style Inline Assembly
    ///
    /// Enable the CodeWarrior/Microsoft syntax for inline assembly code in addition to the standard GCC syntax.
    public static var codewarriorMsStyleInlineAssembly: BuildSetting { 
        BuildSetting(key: .codewarriorMsStyleInlineAssembly, value: "YES")
    }

    /// CodeWarrior/MS-Style Inline Assembly
    ///
    /// Enable the CodeWarrior/Microsoft syntax for inline assembly code in addition to the standard GCC syntax.
    public static func codewarriorMsStyleInlineAssembly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .codewarriorMsStyleInlineAssembly, value: value.asText)
    }

    /// CodeWarrior/MS-Style Inline Assembly
    ///
    /// Enable the CodeWarrior/Microsoft syntax for inline assembly code in addition to the standard GCC syntax.
    public static func codewarriorMsStyleInlineAssembly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codewarriorMsStyleInlineAssembly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CodeWarrior/MS-Style Inline Assembly
    ///
    /// Enable the CodeWarrior/Microsoft syntax for inline assembly code in addition to the standard GCC syntax.
    public static let codewarriorMsStyleInlineAssembly: BuildSettingsKey = "GCC_CW_ASM_SYNTAX"
}

// MARK: GCC C Language Dialect
extension BuildSetting {

    /// GCC C Language Dialect
    ///
    /// Choose a standard or non-standard C language dialect.
    public static var gccCLanguageDialect: BuildSetting { 
        .gccCLanguageDialect(.compilerDefault) 
    }

    /// GCC C Language Dialect
    ///
    /// Choose a standard or non-standard C language dialect.
    public static func gccCLanguageDialect(_ value: GccCLanguageDialect) -> BuildSetting { 
        BuildSetting(key: .gccCLanguageDialect, value: \(value))
    }

    /// GCC C Language Dialect
    ///
    /// Choose a standard or non-standard C language dialect.
    public static func gccCLanguageDialect(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccCLanguageDialect, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC C Language Dialect
    ///
    /// Choose a standard or non-standard C language dialect.
    public static let gccCLanguageDialect: BuildSettingsKey = "GCC_C_LANGUAGE_STANDARD"
}

public enum GccCLanguageDialect: String, Hashable, Codable, CustomStringConvertible {
    case c99 = "c99"
    case c11 = "c11"
    case ansi = "ansi"
    case c89 = "c89"
    case gnu99 = "gnu99"
    case gnu89 = "gnu89"
    case compilerDefault = "compiler-default"
    case gnu11 = "gnu11"

    public var description: String {
        rawValue
    }
}

// MARK: Gcc Debug Information Format
extension BuildSetting {

    /// Gcc Debug Information Format
    public static var gccDebugInformationFormat: BuildSetting { 
        .gccDebugInformationFormat(inherit: .debugInformationFormat) 
    }

    /// Gcc Debug Information Format
    public static func gccDebugInformationFormat(_ value: GccDebugInformationFormat) -> BuildSetting { 
        BuildSetting(key: .gccDebugInformationFormat, value: \(value))
    }

    /// Gcc Debug Information Format
    public static func gccDebugInformationFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccDebugInformationFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Gcc Debug Information Format
    public static let gccDebugInformationFormat: BuildSettingsKey = "GCC_DEBUG_INFORMATION_FORMAT"
}

public enum GccDebugInformationFormat: String, Hashable, Codable, CustomStringConvertible {
    case dwarf = "dwarf"
    case dwarfWithDsym = "dwarf-with-dsym"

    public var description: String {
        rawValue
    }
}

// MARK: Generate Position-Dependent Code
extension BuildSetting {

    /// Generate Position-Dependent Code
    ///
    /// Faster function calls for applications. Not appropriate for shared libraries, which need to be position-independent.
    public static var generatePositionDependentCode: BuildSetting { 
        BuildSetting(key: .generatePositionDependentCode, value: "NO")
    }

    /// Generate Position-Dependent Code
    ///
    /// Faster function calls for applications. Not appropriate for shared libraries, which need to be position-independent.
    public static func generatePositionDependentCode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generatePositionDependentCode, value: value.asText)
    }

    /// Generate Position-Dependent Code
    ///
    /// Faster function calls for applications. Not appropriate for shared libraries, which need to be position-independent.
    public static func generatePositionDependentCode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatePositionDependentCode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Position-Dependent Code
    ///
    /// Faster function calls for applications. Not appropriate for shared libraries, which need to be position-independent.
    public static let generatePositionDependentCode: BuildSettingsKey = "GCC_DYNAMIC_NO_PIC"
}

// MARK: Allow 'asm', 'inline', 'typeof'
extension BuildSetting {

    /// Allow 'asm', 'inline', 'typeof'
    ///
    /// Controls whether `asm`, `inline`, and `typeof` are treated as keywords or whether they can be used as identifiers.
    public static var allowAsmInlineTypeof: BuildSetting { 
        BuildSetting(key: .allowAsmInlineTypeof, value: "YES")
    }

    /// Allow 'asm', 'inline', 'typeof'
    ///
    /// Controls whether `asm`, `inline`, and `typeof` are treated as keywords or whether they can be used as identifiers.
    public static func allowAsmInlineTypeof(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .allowAsmInlineTypeof, value: value.asText)
    }

    /// Allow 'asm', 'inline', 'typeof'
    ///
    /// Controls whether `asm`, `inline`, and `typeof` are treated as keywords or whether they can be used as identifiers.
    public static func allowAsmInlineTypeof(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .allowAsmInlineTypeof, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Allow 'asm', 'inline', 'typeof'
    ///
    /// Controls whether `asm`, `inline`, and `typeof` are treated as keywords or whether they can be used as identifiers.
    public static let allowAsmInlineTypeof: BuildSettingsKey = "GCC_ENABLE_ASM_KEYWORD"
}

// MARK: Recognize Builtin Functions
extension BuildSetting {

    /// Recognize Builtin Functions
    ///
    /// Controls whether builtin functions that do not begin with `__builtin_` as prefix are recognized. GCC normally generates special code to handle certain builtin functions more efficiently; for instance, calls to `alloca` may become single instructions that adjust the stack directly, and calls to `memcpy` may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a builtin function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with `-Wformat` for bad calls to `printf`, when `printf` is built in, and `strlen` is known not to modify global memory.
    public static var recognizeBuiltinFunctions: BuildSetting { 
        BuildSetting(key: .recognizeBuiltinFunctions, value: "YES")
    }

    /// Recognize Builtin Functions
    ///
    /// Controls whether builtin functions that do not begin with `__builtin_` as prefix are recognized. GCC normally generates special code to handle certain builtin functions more efficiently; for instance, calls to `alloca` may become single instructions that adjust the stack directly, and calls to `memcpy` may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a builtin function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with `-Wformat` for bad calls to `printf`, when `printf` is built in, and `strlen` is known not to modify global memory.
    public static func recognizeBuiltinFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .recognizeBuiltinFunctions, value: value.asText)
    }

    /// Recognize Builtin Functions
    ///
    /// Controls whether builtin functions that do not begin with `__builtin_` as prefix are recognized. GCC normally generates special code to handle certain builtin functions more efficiently; for instance, calls to `alloca` may become single instructions that adjust the stack directly, and calls to `memcpy` may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a builtin function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with `-Wformat` for bad calls to `printf`, when `printf` is built in, and `strlen` is known not to modify global memory.
    public static func recognizeBuiltinFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .recognizeBuiltinFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Recognize Builtin Functions
    ///
    /// Controls whether builtin functions that do not begin with `__builtin_` as prefix are recognized. GCC normally generates special code to handle certain builtin functions more efficiently; for instance, calls to `alloca` may become single instructions that adjust the stack directly, and calls to `memcpy` may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a builtin function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with `-Wformat` for bad calls to `printf`, when `printf` is built in, and `strlen` is known not to modify global memory.
    public static let recognizeBuiltinFunctions: BuildSettingsKey = "GCC_ENABLE_BUILTIN_FUNCTIONS"
}

// MARK: Enable C++ Exceptions
extension BuildSetting {

    /// Enable C++ Exceptions
    ///
    /// Enable C++ exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++.
    public static var enableCppExceptions: BuildSetting { 
        BuildSetting(key: .enableCppExceptions, value: "YES")
    }

    /// Enable C++ Exceptions
    ///
    /// Enable C++ exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++.
    public static func enableCppExceptions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableCppExceptions, value: value.asText)
    }

    /// Enable C++ Exceptions
    ///
    /// Enable C++ exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++.
    public static func enableCppExceptions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableCppExceptions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable C++ Exceptions
    ///
    /// Enable C++ exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++.
    public static let enableCppExceptions: BuildSettingsKey = "GCC_ENABLE_CPP_EXCEPTIONS"
}

// MARK: Enable C++ Runtime Types
extension BuildSetting {

    /// Enable C++ Runtime Types
    ///
    /// Enable generation of information about every class with virtual functions for use by the C++ runtime type identification features (`dynamic_cast` and `typeid`). If you don’t use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but it will generate it as needed.
    public static var enableCppRuntimeTypes: BuildSetting { 
        BuildSetting(key: .enableCppRuntimeTypes, value: "YES")
    }

    /// Enable C++ Runtime Types
    ///
    /// Enable generation of information about every class with virtual functions for use by the C++ runtime type identification features (`dynamic_cast` and `typeid`). If you don’t use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but it will generate it as needed.
    public static func enableCppRuntimeTypes(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableCppRuntimeTypes, value: value.asText)
    }

    /// Enable C++ Runtime Types
    ///
    /// Enable generation of information about every class with virtual functions for use by the C++ runtime type identification features (`dynamic_cast` and `typeid`). If you don’t use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but it will generate it as needed.
    public static func enableCppRuntimeTypes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableCppRuntimeTypes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable C++ Runtime Types
    ///
    /// Enable generation of information about every class with virtual functions for use by the C++ runtime type identification features (`dynamic_cast` and `typeid`). If you don’t use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but it will generate it as needed.
    public static let enableCppRuntimeTypes: BuildSettingsKey = "GCC_ENABLE_CPP_RTTI"
}

// MARK: Enable Exceptions
extension BuildSetting {

    /// Enable Exceptions
    ///
    /// Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ and Objective-C that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in other languages. You may also wish to disable this option if you are compiling older programs that don’t use exception handling.
    public static var enableExceptions: BuildSetting { 
        BuildSetting(key: .enableExceptions, value: "YES")
    }

    /// Enable Exceptions
    ///
    /// Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ and Objective-C that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in other languages. You may also wish to disable this option if you are compiling older programs that don’t use exception handling.
    public static func enableExceptions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableExceptions, value: value.asText)
    }

    /// Enable Exceptions
    ///
    /// Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ and Objective-C that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in other languages. You may also wish to disable this option if you are compiling older programs that don’t use exception handling.
    public static func enableExceptions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableExceptions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Exceptions
    ///
    /// Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ and Objective-C that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in other languages. You may also wish to disable this option if you are compiling older programs that don’t use exception handling.
    public static let enableExceptions: BuildSettingsKey = "GCC_ENABLE_EXCEPTIONS"
}

// MARK: Generate Floating Point Library Calls
extension BuildSetting {

    /// Generate Floating Point Library Calls
    ///
    /// Generate output containing library calls for floating point.
    public static var generateFloatingPointLibraryCalls: BuildSetting { 
        BuildSetting(key: .generateFloatingPointLibraryCalls, value: "NO")
    }

    /// Generate Floating Point Library Calls
    ///
    /// Generate output containing library calls for floating point.
    public static func generateFloatingPointLibraryCalls(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateFloatingPointLibraryCalls, value: value.asText)
    }

    /// Generate Floating Point Library Calls
    ///
    /// Generate output containing library calls for floating point.
    public static func generateFloatingPointLibraryCalls(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateFloatingPointLibraryCalls, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Floating Point Library Calls
    ///
    /// Generate output containing library calls for floating point.
    public static let generateFloatingPointLibraryCalls: BuildSettingsKey = "GCC_ENABLE_FLOATING_POINT_LIBRARY_CALLS"
}

// MARK: Kernel Development Mode
extension BuildSetting {

    /// Kernel Development Mode
    ///
    /// Activating this setting enables kernel development mode.
    public static var kernelDevelopmentMode: BuildSetting { 
        BuildSetting(key: .kernelDevelopmentMode, value: "NO")
    }

    /// Kernel Development Mode
    ///
    /// Activating this setting enables kernel development mode.
    public static func kernelDevelopmentMode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .kernelDevelopmentMode, value: value.asText)
    }

    /// Kernel Development Mode
    ///
    /// Activating this setting enables kernel development mode.
    public static func kernelDevelopmentMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .kernelDevelopmentMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Kernel Development Mode
    ///
    /// Activating this setting enables kernel development mode.
    public static let kernelDevelopmentMode: BuildSettingsKey = "GCC_ENABLE_KERNEL_DEVELOPMENT"
}

// MARK: Enable Objective-C Exceptions
extension BuildSetting {

    /// Enable Objective-C Exceptions
    ///
    /// This setting enables `@try`/`@catch`/`@throw` syntax for handling exceptions in Objective-C code. Only applies to Objective-C.
    public static var enableObjectiveCExceptions: BuildSetting { 
        BuildSetting(key: .enableObjectiveCExceptions, value: "YES")
    }

    /// Enable Objective-C Exceptions
    ///
    /// This setting enables `@try`/`@catch`/`@throw` syntax for handling exceptions in Objective-C code. Only applies to Objective-C.
    public static func enableObjectiveCExceptions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableObjectiveCExceptions, value: value.asText)
    }

    /// Enable Objective-C Exceptions
    ///
    /// This setting enables `@try`/`@catch`/`@throw` syntax for handling exceptions in Objective-C code. Only applies to Objective-C.
    public static func enableObjectiveCExceptions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableObjectiveCExceptions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Objective-C Exceptions
    ///
    /// This setting enables `@try`/`@catch`/`@throw` syntax for handling exceptions in Objective-C code. Only applies to Objective-C.
    public static let enableObjectiveCExceptions: BuildSettingsKey = "GCC_ENABLE_OBJC_EXCEPTIONS"
}

// MARK: Recognize Pascal Strings
extension BuildSetting {

    /// Recognize Pascal Strings
    ///
    /// Recognize and construct Pascal-style string literals. Its use in new code is discouraged. Pascal string literals take the form `"pstring"` . The special escape sequence `\p` denotes the Pascal length byte for the string, and will be replaced at compile time with the number of characters that follow. The `\p` may only appear at the beginning of a string literal, and may not appear in wide string literals or as an integral constant.
    public static var recognizePascalStrings: BuildSetting { 
        BuildSetting(key: .recognizePascalStrings, value: "YES")
    }

    /// Recognize Pascal Strings
    ///
    /// Recognize and construct Pascal-style string literals. Its use in new code is discouraged. Pascal string literals take the form `"pstring"` . The special escape sequence `\p` denotes the Pascal length byte for the string, and will be replaced at compile time with the number of characters that follow. The `\p` may only appear at the beginning of a string literal, and may not appear in wide string literals or as an integral constant.
    public static func recognizePascalStrings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .recognizePascalStrings, value: value.asText)
    }

    /// Recognize Pascal Strings
    ///
    /// Recognize and construct Pascal-style string literals. Its use in new code is discouraged. Pascal string literals take the form `"pstring"` . The special escape sequence `\p` denotes the Pascal length byte for the string, and will be replaced at compile time with the number of characters that follow. The `\p` may only appear at the beginning of a string literal, and may not appear in wide string literals or as an integral constant.
    public static func recognizePascalStrings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .recognizePascalStrings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Recognize Pascal Strings
    ///
    /// Recognize and construct Pascal-style string literals. Its use in new code is discouraged. Pascal string literals take the form `"pstring"` . The special escape sequence `\p` denotes the Pascal length byte for the string, and will be replaced at compile time with the number of characters that follow. The `\p` may only appear at the beginning of a string literal, and may not appear in wide string literals or as an integral constant.
    public static let recognizePascalStrings: BuildSettingsKey = "GCC_ENABLE_PASCAL_STRINGS"
}

// MARK: Enable Trigraphs
extension BuildSetting {

    /// Enable Trigraphs
    ///
    /// Controls whether or not trigraphs are permitted in the source code.
    public static var enableTrigraphs: BuildSetting { 
        BuildSetting(key: .enableTrigraphs, value: "NO")
    }

    /// Enable Trigraphs
    ///
    /// Controls whether or not trigraphs are permitted in the source code.
    public static func enableTrigraphs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTrigraphs, value: value.asText)
    }

    /// Enable Trigraphs
    ///
    /// Controls whether or not trigraphs are permitted in the source code.
    public static func enableTrigraphs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTrigraphs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Trigraphs
    ///
    /// Controls whether or not trigraphs are permitted in the source code.
    public static let enableTrigraphs: BuildSettingsKey = "GCC_ENABLE_TRIGRAPHS"
}

// MARK: Relax IEEE Compliance
extension BuildSetting {

    /// Relax IEEE Compliance
    ///
    /// Enables some floating point optimizations that are not IEEE754-compliant, but which usually work. Programs that require strict IEEE compliance may not work with this option.
    public static var relaxIeeeCompliance: BuildSetting { 
        BuildSetting(key: .relaxIeeeCompliance, value: "NO")
    }

    /// Relax IEEE Compliance
    ///
    /// Enables some floating point optimizations that are not IEEE754-compliant, but which usually work. Programs that require strict IEEE compliance may not work with this option.
    public static func relaxIeeeCompliance(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .relaxIeeeCompliance, value: value.asText)
    }

    /// Relax IEEE Compliance
    ///
    /// Enables some floating point optimizations that are not IEEE754-compliant, but which usually work. Programs that require strict IEEE compliance may not work with this option.
    public static func relaxIeeeCompliance(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .relaxIeeeCompliance, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Relax IEEE Compliance
    ///
    /// Enables some floating point optimizations that are not IEEE754-compliant, but which usually work. Programs that require strict IEEE compliance may not work with this option.
    public static let relaxIeeeCompliance: BuildSettingsKey = "GCC_FAST_MATH"
}

// MARK: Generate Debug Symbols
extension BuildSetting {

    /// Generate Debug Symbols
    ///
    /// Enables or disables generation of debug symbols. When debug symbols are enabled, the level of detail can be controlled by the [Debug Information Format (DEBUG_INFORMATION_FORMAT)](itcaec37c2a6.html# dev881878d77) setting.
    public static func generateDebugSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateDebugSymbols, value: value.asText)
    }

    /// Generate Debug Symbols
    ///
    /// Enables or disables generation of debug symbols. When debug symbols are enabled, the level of detail can be controlled by the [Debug Information Format (DEBUG_INFORMATION_FORMAT)](itcaec37c2a6.html# dev881878d77) setting.
    public static func generateDebugSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateDebugSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Debug Symbols
    ///
    /// Enables or disables generation of debug symbols. When debug symbols are enabled, the level of detail can be controlled by the [Debug Information Format (DEBUG_INFORMATION_FORMAT)](itcaec37c2a6.html# dev881878d77) setting.
    public static let generateDebugSymbols: BuildSettingsKey = "GCC_GENERATE_DEBUGGING_SYMBOLS"
}

// MARK: Generate Legacy Test Coverage Files
extension BuildSetting {

    /// Generate Legacy Test Coverage Files
    ///
    /// Activating this setting causes a `notes` file to be produced that the `gcov` code-coverage utility can use to show program coverage.
    public static var generateLegacyTestCoverageFiles: BuildSetting { 
        BuildSetting(key: .generateLegacyTestCoverageFiles, value: "NO")
    }

    /// Generate Legacy Test Coverage Files
    ///
    /// Activating this setting causes a `notes` file to be produced that the `gcov` code-coverage utility can use to show program coverage.
    public static func generateLegacyTestCoverageFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateLegacyTestCoverageFiles, value: value.asText)
    }

    /// Generate Legacy Test Coverage Files
    ///
    /// Activating this setting causes a `notes` file to be produced that the `gcov` code-coverage utility can use to show program coverage.
    public static func generateLegacyTestCoverageFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateLegacyTestCoverageFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Legacy Test Coverage Files
    ///
    /// Activating this setting causes a `notes` file to be produced that the `gcov` code-coverage utility can use to show program coverage.
    public static let generateLegacyTestCoverageFiles: BuildSettingsKey = "GCC_GENERATE_TEST_COVERAGE_FILES"
}

// MARK: Increase Sharing of Precompiled Headers
extension BuildSetting {

    /// Increase Sharing of Precompiled Headers
    ///
    /// Enabling this option will enable increased sharing of precompiled headers among targets that share the same prefix header and precompiled header directory. Xcode distinguishes between precompiled header (PCH) files by generating a hash value based on the command-line options to the compiler used to create the PCH. Enabling this option will exclude certain compiler options from that hash. Presently this option will exclude search path options (`-I`, `-iquote`, `-isystem`, `-F`, `-L`) from the hash. Enabling increased sharing of PCH files carries some risk—if two targets use the same prefix header but have different include paths that cause the prefix header to include different files when they are precompiled, then subtle problems may result because one target will use a PCH that was built using files included by the other target. In this case, this option must be turned off in order to enforce correctness.
    public static var increaseSharingOfPrecompiledHeaders: BuildSetting { 
        BuildSetting(key: .increaseSharingOfPrecompiledHeaders, value: "NO")
    }

    /// Increase Sharing of Precompiled Headers
    ///
    /// Enabling this option will enable increased sharing of precompiled headers among targets that share the same prefix header and precompiled header directory. Xcode distinguishes between precompiled header (PCH) files by generating a hash value based on the command-line options to the compiler used to create the PCH. Enabling this option will exclude certain compiler options from that hash. Presently this option will exclude search path options (`-I`, `-iquote`, `-isystem`, `-F`, `-L`) from the hash. Enabling increased sharing of PCH files carries some risk—if two targets use the same prefix header but have different include paths that cause the prefix header to include different files when they are precompiled, then subtle problems may result because one target will use a PCH that was built using files included by the other target. In this case, this option must be turned off in order to enforce correctness.
    public static func increaseSharingOfPrecompiledHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .increaseSharingOfPrecompiledHeaders, value: value.asText)
    }

    /// Increase Sharing of Precompiled Headers
    ///
    /// Enabling this option will enable increased sharing of precompiled headers among targets that share the same prefix header and precompiled header directory. Xcode distinguishes between precompiled header (PCH) files by generating a hash value based on the command-line options to the compiler used to create the PCH. Enabling this option will exclude certain compiler options from that hash. Presently this option will exclude search path options (`-I`, `-iquote`, `-isystem`, `-F`, `-L`) from the hash. Enabling increased sharing of PCH files carries some risk—if two targets use the same prefix header but have different include paths that cause the prefix header to include different files when they are precompiled, then subtle problems may result because one target will use a PCH that was built using files included by the other target. In this case, this option must be turned off in order to enforce correctness.
    public static func increaseSharingOfPrecompiledHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .increaseSharingOfPrecompiledHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Increase Sharing of Precompiled Headers
    ///
    /// Enabling this option will enable increased sharing of precompiled headers among targets that share the same prefix header and precompiled header directory. Xcode distinguishes between precompiled header (PCH) files by generating a hash value based on the command-line options to the compiler used to create the PCH. Enabling this option will exclude certain compiler options from that hash. Presently this option will exclude search path options (`-I`, `-iquote`, `-isystem`, `-F`, `-L`) from the hash. Enabling increased sharing of PCH files carries some risk—if two targets use the same prefix header but have different include paths that cause the prefix header to include different files when they are precompiled, then subtle problems may result because one target will use a PCH that was built using files included by the other target. In this case, this option must be turned off in order to enforce correctness.
    public static let increaseSharingOfPrecompiledHeaders: BuildSettingsKey = "GCC_INCREASE_PRECOMPILED_HEADER_SHARING"
}

// MARK: Inline Methods Hidden
extension BuildSetting {

    /// Inline Methods Hidden
    ///
    /// When enabled, out-of-line copies of inline methods are declared `private extern`.
    public static var inlineMethodsHidden: BuildSetting { 
        BuildSetting(key: .inlineMethodsHidden, value: "NO")
    }

    /// Inline Methods Hidden
    ///
    /// When enabled, out-of-line copies of inline methods are declared `private extern`.
    public static func inlineMethodsHidden(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inlineMethodsHidden, value: value.asText)
    }

    /// Inline Methods Hidden
    ///
    /// When enabled, out-of-line copies of inline methods are declared `private extern`.
    public static func inlineMethodsHidden(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inlineMethodsHidden, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Inline Methods Hidden
    ///
    /// When enabled, out-of-line copies of inline methods are declared `private extern`.
    public static let inlineMethodsHidden: BuildSettingsKey = "GCC_INLINES_ARE_PRIVATE_EXTERN"
}

// MARK: Compile Sources As
extension BuildSetting {

    /// Compile Sources As
    ///
    /// Specifies whether to compile each source file according to its file type, or whether to treat all source files in the target as if they are of a specific language.
    public static var compileSourcesAs: BuildSetting { 
        .compileSourcesAs(.automatic) 
    }

    /// Compile Sources As
    ///
    /// Specifies whether to compile each source file according to its file type, or whether to treat all source files in the target as if they are of a specific language.
    public static func compileSourcesAs(_ value: CompileSourcesAs) -> BuildSetting { 
        BuildSetting(key: .compileSourcesAs, value: \(value))
    }

    /// Compile Sources As
    ///
    /// Specifies whether to compile each source file according to its file type, or whether to treat all source files in the target as if they are of a specific language.
    public static func compileSourcesAs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compileSourcesAs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compile Sources As
    ///
    /// Specifies whether to compile each source file according to its file type, or whether to treat all source files in the target as if they are of a specific language.
    public static let compileSourcesAs: BuildSettingsKey = "GCC_INPUT_FILETYPE"
}

public enum CompileSourcesAs: String, Hashable, Codable, CustomStringConvertible {
    case sourcecodeCppObjcpp = "sourcecode.cpp.objcpp"
    case sourcecodeCC = "sourcecode.c.c"
    case automatic = "automatic"
    case sourcecodeCObjc = "sourcecode.c.objc"
    case sourcecodeCppCpp = "sourcecode.cpp.cpp"

    public var description: String {
        rawValue
    }
}

// MARK: Instrument Program Flow
extension BuildSetting {

    /// Instrument Program Flow
    ///
    /// Activating this setting indicates that code should be added so program flow arcs are instrumented.
    public static var instrumentProgramFlow: BuildSetting { 
        BuildSetting(key: .instrumentProgramFlow, value: "NO")
    }

    /// Instrument Program Flow
    ///
    /// Activating this setting indicates that code should be added so program flow arcs are instrumented.
    public static func instrumentProgramFlow(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .instrumentProgramFlow, value: value.asText)
    }

    /// Instrument Program Flow
    ///
    /// Activating this setting indicates that code should be added so program flow arcs are instrumented.
    public static func instrumentProgramFlow(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentProgramFlow, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Instrument Program Flow
    ///
    /// Activating this setting indicates that code should be added so program flow arcs are instrumented.
    public static let instrumentProgramFlow: BuildSettingsKey = "GCC_INSTRUMENT_PROGRAM_FLOW_ARCS"
}

// MARK: Enable Linking With Shared Libraries
extension BuildSetting {

    /// Enable Linking With Shared Libraries
    ///
    /// Enabling this option allows linking with the shared libraries. This is the default for most product types.
    public static var enableLinkingWithSharedLibraries: BuildSetting { 
        BuildSetting(key: .enableLinkingWithSharedLibraries, value: "YES")
    }

    /// Enable Linking With Shared Libraries
    ///
    /// Enabling this option allows linking with the shared libraries. This is the default for most product types.
    public static func enableLinkingWithSharedLibraries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableLinkingWithSharedLibraries, value: value.asText)
    }

    /// Enable Linking With Shared Libraries
    ///
    /// Enabling this option allows linking with the shared libraries. This is the default for most product types.
    public static func enableLinkingWithSharedLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableLinkingWithSharedLibraries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Linking With Shared Libraries
    ///
    /// Enabling this option allows linking with the shared libraries. This is the default for most product types.
    public static let enableLinkingWithSharedLibraries: BuildSettingsKey = "GCC_LINK_WITH_DYNAMIC_LIBRARIES"
}

// MARK: Gcc Macosx Version Min
extension BuildSetting {

    /// Gcc Macosx Version Min
    public static var gccMacosxVersionMin: BuildSetting { 
        BuildSetting(key: .gccMacosxVersionMin, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// Gcc Macosx Version Min
    public static func gccMacosxVersionMin(_ value: String) -> BuildSetting { 
        BuildSetting(key: .gccMacosxVersionMin, value: \(value))
    }

    /// Gcc Macosx Version Min
    public static func gccMacosxVersionMin(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccMacosxVersionMin, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Gcc Macosx Version Min
    public static let gccMacosxVersionMin: BuildSettingsKey = "GCC_MACOSX_VERSION_MIN"
}

// MARK: No Common Blocks
extension BuildSetting {

    /// No Common Blocks
    ///
    /// In C, allocate even uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without `extern`) in two different compilations, you will get an error when you link them.
    public static var noCommonBlocks: BuildSetting { 
        BuildSetting(key: .noCommonBlocks, value: "NO")
    }

    /// No Common Blocks
    ///
    /// In C, allocate even uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without `extern`) in two different compilations, you will get an error when you link them.
    public static func noCommonBlocks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .noCommonBlocks, value: value.asText)
    }

    /// No Common Blocks
    ///
    /// In C, allocate even uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without `extern`) in two different compilations, you will get an error when you link them.
    public static func noCommonBlocks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .noCommonBlocks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// No Common Blocks
    ///
    /// In C, allocate even uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without `extern`) in two different compilations, you will get an error when you link them.
    public static let noCommonBlocks: BuildSettingsKey = "GCC_NO_COMMON_BLOCKS"
}

// MARK: Gcc Objc Abi Version
extension BuildSetting {

    /// Gcc Objc Abi Version
    public static var gccObjcAbiVersion: BuildSetting { 
        BuildSetting(key: .gccObjcAbiVersion, value: "$(OBJC_ABI_VERSION)")
    }

    /// Gcc Objc Abi Version
    public static func gccObjcAbiVersion(_ value: GccObjcAbiVersion) -> BuildSetting { 
        BuildSetting(key: .gccObjcAbiVersion, value: \(value))
    }

    /// Gcc Objc Abi Version
    public static func gccObjcAbiVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccObjcAbiVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Gcc Objc Abi Version
    public static let gccObjcAbiVersion: BuildSettingsKey = "GCC_OBJC_ABI_VERSION"
}

public enum GccObjcAbiVersion: String, Hashable, Codable, CustomStringConvertible {
    case _1 = "1"
    case _2 = "2"

    public var description: String {
        rawValue
    }
}

// MARK: Gcc Objc Legacy Dispatch
extension BuildSetting {

    /// Gcc Objc Legacy Dispatch
    public static var gccObjcLegacyDispatch: BuildSetting { 
        BuildSetting(key: .gccObjcLegacyDispatch, value: "NO")
    }

    /// Gcc Objc Legacy Dispatch
    public static func gccObjcLegacyDispatch(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .gccObjcLegacyDispatch, value: value.asText)
    }

    /// Gcc Objc Legacy Dispatch
    public static func gccObjcLegacyDispatch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccObjcLegacyDispatch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Gcc Objc Legacy Dispatch
    public static let gccObjcLegacyDispatch: BuildSettingsKey = "GCC_OBJC_LEGACY_DISPATCH"
}

// MARK: Gcc Operation
extension BuildSetting {

    /// Gcc Operation
    public static var gccOperation: BuildSetting { 
        .gccOperation(.compile) 
    }

    /// Gcc Operation
    public static func gccOperation(_ value: GccOperation) -> BuildSetting { 
        BuildSetting(key: .gccOperation, value: \(value))
    }

    /// Gcc Operation
    public static func gccOperation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccOperation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Gcc Operation
    public static let gccOperation: BuildSettingsKey = "GCC_OPERATION"
}

public enum GccOperation: String, Hashable, Codable, CustomStringConvertible {
    case separateSymbols = "separate-symbols"
    case compile = "compile"
    case generatePreprocessed = "generate-preprocessed"
    case generateAssembler = "generate-assembler"
    case precompile = "precompile"

    public var description: String {
        rawValue
    }
}

// MARK: Optimization Level
extension BuildSetting {

    /// Optimization Level
    ///
    /// Specifies the degree to which the generated code is optimized for speed and binary size.
    public static var optimizationLevel: BuildSetting { 
        .optimizationLevel(.s) 
    }

    /// Optimization Level
    ///
    /// Specifies the degree to which the generated code is optimized for speed and binary size.
    public static func optimizationLevel(_ value: OptimizationLevel) -> BuildSetting { 
        BuildSetting(key: .optimizationLevel, value: \(value))
    }

    /// Optimization Level
    ///
    /// Specifies the degree to which the generated code is optimized for speed and binary size.
    public static func optimizationLevel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimizationLevel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Optimization Level
    ///
    /// Specifies the degree to which the generated code is optimized for speed and binary size.
    public static let optimizationLevel: BuildSettingsKey = "GCC_OPTIMIZATION_LEVEL"
}

public enum OptimizationLevel: String, Hashable, Codable, CustomStringConvertible {
    case _2 = "2"
    case s = "s"
    case z = "z"
    case fast = "fast"
    case _0 = "0"
    case _1 = "1"
    case _3 = "3"

    public var description: String {
        rawValue
    }
}

// MARK: Preprocessor Macros
extension BuildSetting {

    /// Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func preprocessorMacros(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorMacros, value: .array(value))
    }

    /// Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func preprocessorMacros(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorMacros, inherit: key)
    }

    /// Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func preprocessorMacros(_ value: String...) -> BuildSetting { 
        .preprocessorMacros(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static let preprocessorMacros: BuildSettingsKey = "GCC_PREPROCESSOR_DEFINITIONS"
}

// MARK: Preprocessor Macros Not Used In Precompiled Headers
extension BuildSetting {

    /// Preprocessor Macros Not Used In Precompiled Headers
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are not used when precompiling a prefix header file.
    public static func preprocessorMacrosNotUsedInPrecompiledHeaders(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorMacrosNotUsedInPrecompiledHeaders, value: .array(value))
    }

    /// Preprocessor Macros Not Used In Precompiled Headers
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are not used when precompiling a prefix header file.
    public static func preprocessorMacrosNotUsedInPrecompiledHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorMacrosNotUsedInPrecompiledHeaders, inherit: key)
    }

    /// Preprocessor Macros Not Used In Precompiled Headers
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are not used when precompiling a prefix header file.
    public static func preprocessorMacrosNotUsedInPrecompiledHeaders(_ value: String...) -> BuildSetting { 
        .preprocessorMacrosNotUsedInPrecompiledHeaders(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Macros Not Used In Precompiled Headers
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are not used when precompiling a prefix header file.
    public static let preprocessorMacrosNotUsedInPrecompiledHeaders: BuildSettingsKey = "GCC_PREPROCESSOR_DEFINITIONS_NOT_USED_IN_PRECOMPS"
}

// MARK: Gcc Product Type Preprocessor Definitions
extension BuildSetting {

    /// Gcc Product Type Preprocessor Definitions
    public static func gccProductTypePreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .gccProductTypePreprocessorDefinitions, value: .array(value))
    }

    /// Gcc Product Type Preprocessor Definitions
    public static func gccProductTypePreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccProductTypePreprocessorDefinitions, inherit: key)
    }

    /// Gcc Product Type Preprocessor Definitions
    public static func gccProductTypePreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .gccProductTypePreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// Gcc Product Type Preprocessor Definitions
    public static let gccProductTypePreprocessorDefinitions: BuildSettingsKey = "GCC_PRODUCT_TYPE_PREPROCESSOR_DEFINITIONS"
}

// MARK: Make Strings Read-Only
extension BuildSetting {

    /// Make Strings Read-Only
    ///
    /// Reuse string literals.
    public static var makeStringsReadOnly: BuildSetting { 
        BuildSetting(key: .makeStringsReadOnly, value: "YES")
    }

    /// Make Strings Read-Only
    ///
    /// Reuse string literals.
    public static func makeStringsReadOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .makeStringsReadOnly, value: value.asText)
    }

    /// Make Strings Read-Only
    ///
    /// Reuse string literals.
    public static func makeStringsReadOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .makeStringsReadOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Make Strings Read-Only
    ///
    /// Reuse string literals.
    public static let makeStringsReadOnly: BuildSettingsKey = "GCC_REUSE_STRINGS"
}

// MARK: Short Enumeration Constants
extension BuildSetting {

    /// Short Enumeration Constants
    ///
    /// Make enums only as large as needed for the range of possible values. This setting generates code that may not binary compatible with code generated without this setting or with macOS frameworks.
    public static var shortEnumerationConstants: BuildSetting { 
        BuildSetting(key: .shortEnumerationConstants, value: "NO")
    }

    /// Short Enumeration Constants
    ///
    /// Make enums only as large as needed for the range of possible values. This setting generates code that may not binary compatible with code generated without this setting or with macOS frameworks.
    public static func shortEnumerationConstants(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .shortEnumerationConstants, value: value.asText)
    }

    /// Short Enumeration Constants
    ///
    /// Make enums only as large as needed for the range of possible values. This setting generates code that may not binary compatible with code generated without this setting or with macOS frameworks.
    public static func shortEnumerationConstants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .shortEnumerationConstants, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Short Enumeration Constants
    ///
    /// Make enums only as large as needed for the range of possible values. This setting generates code that may not binary compatible with code generated without this setting or with macOS frameworks.
    public static let shortEnumerationConstants: BuildSettingsKey = "GCC_SHORT_ENUMS"
}

// MARK: Enforce Strict Aliasing
extension BuildSetting {

    /// Enforce Strict Aliasing
    ///
    /// Optimize code by making more aggressive assumptions about whether pointers can point to the same objects as other pointers. Programs that use pointers a lot may benefit from this, but programs that don’t strictly follow the ISO C rules about the type with which an object may be accessed may behave unexpectedly.
    public static var enforceStrictAliasing: BuildSetting { 
        BuildSetting(key: .enforceStrictAliasing, value: "YES")
    }

    /// Enforce Strict Aliasing
    ///
    /// Optimize code by making more aggressive assumptions about whether pointers can point to the same objects as other pointers. Programs that use pointers a lot may benefit from this, but programs that don’t strictly follow the ISO C rules about the type with which an object may be accessed may behave unexpectedly.
    public static func enforceStrictAliasing(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enforceStrictAliasing, value: value.asText)
    }

    /// Enforce Strict Aliasing
    ///
    /// Optimize code by making more aggressive assumptions about whether pointers can point to the same objects as other pointers. Programs that use pointers a lot may benefit from this, but programs that don’t strictly follow the ISO C rules about the type with which an object may be accessed may behave unexpectedly.
    public static func enforceStrictAliasing(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enforceStrictAliasing, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enforce Strict Aliasing
    ///
    /// Optimize code by making more aggressive assumptions about whether pointers can point to the same objects as other pointers. Programs that use pointers a lot may benefit from this, but programs that don’t strictly follow the ISO C rules about the type with which an object may be accessed may behave unexpectedly.
    public static let enforceStrictAliasing: BuildSettingsKey = "GCC_STRICT_ALIASING"
}

// MARK: Symbols Hidden by Default
extension BuildSetting {

    /// Symbols Hidden by Default
    ///
    /// When enabled, all symbols are declared `private extern` unless explicitly marked to be exported using ` **attribute** ((visibility(“default”)))` in code. If not enabled, all symbols are exported unless explicitly marked as `private extern`. See [Controlling Symbol Visibility](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html#//apple_ref/doc/uid/TP40001670-CJBGBHEJ) in [C++ Runtime Environment Programming Guide](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/CPPRuntimeEnv.html).
    public static var symbolsHiddenByDefault: BuildSetting { 
        BuildSetting(key: .symbolsHiddenByDefault, value: "NO")
    }

    /// Symbols Hidden by Default
    ///
    /// When enabled, all symbols are declared `private extern` unless explicitly marked to be exported using ` **attribute** ((visibility(“default”)))` in code. If not enabled, all symbols are exported unless explicitly marked as `private extern`. See [Controlling Symbol Visibility](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html#//apple_ref/doc/uid/TP40001670-CJBGBHEJ) in [C++ Runtime Environment Programming Guide](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/CPPRuntimeEnv.html).
    public static func symbolsHiddenByDefault(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .symbolsHiddenByDefault, value: value.asText)
    }

    /// Symbols Hidden by Default
    ///
    /// When enabled, all symbols are declared `private extern` unless explicitly marked to be exported using ` **attribute** ((visibility(“default”)))` in code. If not enabled, all symbols are exported unless explicitly marked as `private extern`. See [Controlling Symbol Visibility](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html#//apple_ref/doc/uid/TP40001670-CJBGBHEJ) in [C++ Runtime Environment Programming Guide](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/CPPRuntimeEnv.html).
    public static func symbolsHiddenByDefault(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .symbolsHiddenByDefault, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Symbols Hidden by Default
    ///
    /// When enabled, all symbols are declared `private extern` unless explicitly marked to be exported using ` **attribute** ((visibility(“default”)))` in code. If not enabled, all symbols are exported unless explicitly marked as `private extern`. See [Controlling Symbol Visibility](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html#//apple_ref/doc/uid/TP40001670-CJBGBHEJ) in [C++ Runtime Environment Programming Guide](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/CPPRuntimeEnv.html).
    public static let symbolsHiddenByDefault: BuildSettingsKey = "GCC_SYMBOLS_PRIVATE_EXTERN"
}

// MARK: Statics are Thread-Safe
extension BuildSetting {

    /// Statics are Thread-Safe
    ///
    /// Emits extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can disable this option to reduce code size slightly in code that doesn’t need to be thread-safe.
    public static var staticsAreThreadSafe: BuildSetting { 
        BuildSetting(key: .staticsAreThreadSafe, value: "YES")
    }

    /// Statics are Thread-Safe
    ///
    /// Emits extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can disable this option to reduce code size slightly in code that doesn’t need to be thread-safe.
    public static func staticsAreThreadSafe(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .staticsAreThreadSafe, value: value.asText)
    }

    /// Statics are Thread-Safe
    ///
    /// Emits extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can disable this option to reduce code size slightly in code that doesn’t need to be thread-safe.
    public static func staticsAreThreadSafe(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .staticsAreThreadSafe, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Statics are Thread-Safe
    ///
    /// Emits extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can disable this option to reduce code size slightly in code that doesn’t need to be thread-safe.
    public static let staticsAreThreadSafe: BuildSettingsKey = "GCC_THREADSAFE_STATICS"
}

// MARK: Treat Missing Function Prototypes as Errors
extension BuildSetting {

    /// Treat Missing Function Prototypes as Errors
    ///
    /// Causes warnings about missing function prototypes to be treated as errors. Only applies to C and Objective-C.
    public static var treatMissingFunctionPrototypesAsErrors: BuildSetting { 
        BuildSetting(key: .treatMissingFunctionPrototypesAsErrors, value: "NO")
    }

    /// Treat Missing Function Prototypes as Errors
    ///
    /// Causes warnings about missing function prototypes to be treated as errors. Only applies to C and Objective-C.
    public static func treatMissingFunctionPrototypesAsErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatMissingFunctionPrototypesAsErrors, value: value.asText)
    }

    /// Treat Missing Function Prototypes as Errors
    ///
    /// Causes warnings about missing function prototypes to be treated as errors. Only applies to C and Objective-C.
    public static func treatMissingFunctionPrototypesAsErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatMissingFunctionPrototypesAsErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat Missing Function Prototypes as Errors
    ///
    /// Causes warnings about missing function prototypes to be treated as errors. Only applies to C and Objective-C.
    public static let treatMissingFunctionPrototypesAsErrors: BuildSettingsKey = "GCC_TREAT_IMPLICIT_FUNCTION_DECLARATIONS_AS_ERRORS"
}

// MARK: Treat Incompatible Pointer Type Warnings as Errors
extension BuildSetting {

    /// Treat Incompatible Pointer Type Warnings as Errors
    ///
    /// Enabling this option causes warnings about incompatible pointer types to be treated as errors.
    public static var treatIncompatiblePointerTypeWarningsAsErrors: BuildSetting { 
        BuildSetting(key: .treatIncompatiblePointerTypeWarningsAsErrors, value: "NO")
    }

    /// Treat Incompatible Pointer Type Warnings as Errors
    ///
    /// Enabling this option causes warnings about incompatible pointer types to be treated as errors.
    public static func treatIncompatiblePointerTypeWarningsAsErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatIncompatiblePointerTypeWarningsAsErrors, value: value.asText)
    }

    /// Treat Incompatible Pointer Type Warnings as Errors
    ///
    /// Enabling this option causes warnings about incompatible pointer types to be treated as errors.
    public static func treatIncompatiblePointerTypeWarningsAsErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatIncompatiblePointerTypeWarningsAsErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat Incompatible Pointer Type Warnings as Errors
    ///
    /// Enabling this option causes warnings about incompatible pointer types to be treated as errors.
    public static let treatIncompatiblePointerTypeWarningsAsErrors: BuildSettingsKey = "GCC_TREAT_INCOMPATIBLE_POINTER_TYPE_WARNINGS_AS_ERRORS"
}

// MARK: Unroll Loops
extension BuildSetting {

    /// Unroll Loops
    ///
    /// Unrolls loops. Unrolling makes the code larger, but may make it faster by reducing the number of branches executed.
    public static var unrollLoops: BuildSetting { 
        BuildSetting(key: .unrollLoops, value: "NO")
    }

    /// Unroll Loops
    ///
    /// Unrolls loops. Unrolling makes the code larger, but may make it faster by reducing the number of branches executed.
    public static func unrollLoops(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unrollLoops, value: value.asText)
    }

    /// Unroll Loops
    ///
    /// Unrolls loops. Unrolling makes the code larger, but may make it faster by reducing the number of branches executed.
    public static func unrollLoops(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unrollLoops, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unroll Loops
    ///
    /// Unrolls loops. Unrolling makes the code larger, but may make it faster by reducing the number of branches executed.
    public static let unrollLoops: BuildSettingsKey = "GCC_UNROLL_LOOPS"
}

// MARK: Use Standard System Header Directory Searching
extension BuildSetting {

    /// Use Standard System Header Directory Searching
    ///
    /// Controls whether the standard system directories are searched for header files. When disabled, only the directories you have specified with `-I` options (and the directory of the current file, if appropriate) are searched.
    public static var useStandardSystemHeaderDirectorySearching: BuildSetting { 
        BuildSetting(key: .useStandardSystemHeaderDirectorySearching, value: "YES")
    }

    /// Use Standard System Header Directory Searching
    ///
    /// Controls whether the standard system directories are searched for header files. When disabled, only the directories you have specified with `-I` options (and the directory of the current file, if appropriate) are searched.
    public static func useStandardSystemHeaderDirectorySearching(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useStandardSystemHeaderDirectorySearching, value: value.asText)
    }

    /// Use Standard System Header Directory Searching
    ///
    /// Controls whether the standard system directories are searched for header files. When disabled, only the directories you have specified with `-I` options (and the directory of the current file, if appropriate) are searched.
    public static func useStandardSystemHeaderDirectorySearching(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useStandardSystemHeaderDirectorySearching, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Standard System Header Directory Searching
    ///
    /// Controls whether the standard system directories are searched for header files. When disabled, only the directories you have specified with `-I` options (and the directory of the current file, if appropriate) are searched.
    public static let useStandardSystemHeaderDirectorySearching: BuildSettingsKey = "GCC_USE_STANDARD_INCLUDE_SEARCHING"
}

// MARK: Deprecated Functions
extension BuildSetting {

    /// Deprecated Functions
    ///
    /// Warn about the use of deprecated functions, variables, and types (as indicated by the `deprecated` attribute).
    public static var deprecatedFunctions: BuildSetting { 
        BuildSetting(key: .deprecatedFunctions, value: "YES")
    }

    /// Deprecated Functions
    ///
    /// Warn about the use of deprecated functions, variables, and types (as indicated by the `deprecated` attribute).
    public static func deprecatedFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deprecatedFunctions, value: value.asText)
    }

    /// Deprecated Functions
    ///
    /// Warn about the use of deprecated functions, variables, and types (as indicated by the `deprecated` attribute).
    public static func deprecatedFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deprecatedFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Deprecated Functions
    ///
    /// Warn about the use of deprecated functions, variables, and types (as indicated by the `deprecated` attribute).
    public static let deprecatedFunctions: BuildSettingsKey = "GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS"
}

// MARK: Undefined Use of offsetof Macro
extension BuildSetting {

    /// Undefined Use of offsetof Macro
    ///
    /// Unchecking this setting will suppress warnings from applying the `offsetof` macro to a non-POD type. According to the 1998 ISO C++ standard, applying `offsetof` to a non-POD type is undefined. In existing C++ implementations, however, `offsetof` typically gives meaningful results even when applied to certain kinds of non-POD types, such as a simple struct that fails to be a POD type only by virtue of having a constructor. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it. The restrictions on `offsetof` may be relaxed in a future version of the C++ standard.
    public static var undefinedUseOfOffsetofMacro: BuildSetting { 
        BuildSetting(key: .undefinedUseOfOffsetofMacro, value: "YES")
    }

    /// Undefined Use of offsetof Macro
    ///
    /// Unchecking this setting will suppress warnings from applying the `offsetof` macro to a non-POD type. According to the 1998 ISO C++ standard, applying `offsetof` to a non-POD type is undefined. In existing C++ implementations, however, `offsetof` typically gives meaningful results even when applied to certain kinds of non-POD types, such as a simple struct that fails to be a POD type only by virtue of having a constructor. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it. The restrictions on `offsetof` may be relaxed in a future version of the C++ standard.
    public static func undefinedUseOfOffsetofMacro(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .undefinedUseOfOffsetofMacro, value: value.asText)
    }

    /// Undefined Use of offsetof Macro
    ///
    /// Unchecking this setting will suppress warnings from applying the `offsetof` macro to a non-POD type. According to the 1998 ISO C++ standard, applying `offsetof` to a non-POD type is undefined. In existing C++ implementations, however, `offsetof` typically gives meaningful results even when applied to certain kinds of non-POD types, such as a simple struct that fails to be a POD type only by virtue of having a constructor. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it. The restrictions on `offsetof` may be relaxed in a future version of the C++ standard.
    public static func undefinedUseOfOffsetofMacro(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .undefinedUseOfOffsetofMacro, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Undefined Use of offsetof Macro
    ///
    /// Unchecking this setting will suppress warnings from applying the `offsetof` macro to a non-POD type. According to the 1998 ISO C++ standard, applying `offsetof` to a non-POD type is undefined. In existing C++ implementations, however, `offsetof` typically gives meaningful results even when applied to certain kinds of non-POD types, such as a simple struct that fails to be a POD type only by virtue of having a constructor. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it. The restrictions on `offsetof` may be relaxed in a future version of the C++ standard.
    public static let undefinedUseOfOffsetofMacro: BuildSettingsKey = "GCC_WARN_ABOUT_INVALID_OFFSETOF_MACRO"
}

// MARK: Missing Fields in Structure Initializers
extension BuildSetting {

    /// Missing Fields in Structure Initializers
    ///
    /// Warn if a structure’s initializer has some fields missing. For example, the following code would cause such a warning because `x.h` is implicitly zero: `struct s { int f, g, h; };``struct s x = { 3, 4 };` This option does not warn about designated initializers, so the following modification would not trigger a warning: `struct s { int f, g, h; };``struct s x = { .f = 3, .g = 4 };`
    public static var missingFieldsInStructureInitializers: BuildSetting { 
        BuildSetting(key: .missingFieldsInStructureInitializers, value: "NO")
    }

    /// Missing Fields in Structure Initializers
    ///
    /// Warn if a structure’s initializer has some fields missing. For example, the following code would cause such a warning because `x.h` is implicitly zero: `struct s { int f, g, h; };``struct s x = { 3, 4 };` This option does not warn about designated initializers, so the following modification would not trigger a warning: `struct s { int f, g, h; };``struct s x = { .f = 3, .g = 4 };`
    public static func missingFieldsInStructureInitializers(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingFieldsInStructureInitializers, value: value.asText)
    }

    /// Missing Fields in Structure Initializers
    ///
    /// Warn if a structure’s initializer has some fields missing. For example, the following code would cause such a warning because `x.h` is implicitly zero: `struct s { int f, g, h; };``struct s x = { 3, 4 };` This option does not warn about designated initializers, so the following modification would not trigger a warning: `struct s { int f, g, h; };``struct s x = { .f = 3, .g = 4 };`
    public static func missingFieldsInStructureInitializers(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingFieldsInStructureInitializers, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Fields in Structure Initializers
    ///
    /// Warn if a structure’s initializer has some fields missing. For example, the following code would cause such a warning because `x.h` is implicitly zero: `struct s { int f, g, h; };``struct s x = { 3, 4 };` This option does not warn about designated initializers, so the following modification would not trigger a warning: `struct s { int f, g, h; };``struct s x = { .f = 3, .g = 4 };`
    public static let missingFieldsInStructureInitializers: BuildSettingsKey = "GCC_WARN_ABOUT_MISSING_FIELD_INITIALIZERS"
}

// MARK: Missing Newline At End Of File
extension BuildSetting {

    /// Missing Newline At End Of File
    ///
    /// Warn when a source file does not end with a newline.
    public static var missingNewlineAtEndOfFile: BuildSetting { 
        BuildSetting(key: .missingNewlineAtEndOfFile, value: "NO")
    }

    /// Missing Newline At End Of File
    ///
    /// Warn when a source file does not end with a newline.
    public static func missingNewlineAtEndOfFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingNewlineAtEndOfFile, value: value.asText)
    }

    /// Missing Newline At End Of File
    ///
    /// Warn when a source file does not end with a newline.
    public static func missingNewlineAtEndOfFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingNewlineAtEndOfFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Newline At End Of File
    ///
    /// Warn when a source file does not end with a newline.
    public static let missingNewlineAtEndOfFile: BuildSettingsKey = "GCC_WARN_ABOUT_MISSING_NEWLINE"
}

// MARK: Missing Function Prototypes
extension BuildSetting {

    /// Missing Function Prototypes
    ///
    /// Causes warnings to be emitted about missing prototypes.
    public static var missingFunctionPrototypes: BuildSetting { 
        BuildSetting(key: .missingFunctionPrototypes, value: "NO")
    }

    /// Missing Function Prototypes
    ///
    /// Causes warnings to be emitted about missing prototypes.
    public static func missingFunctionPrototypes(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingFunctionPrototypes, value: value.asText)
    }

    /// Missing Function Prototypes
    ///
    /// Causes warnings to be emitted about missing prototypes.
    public static func missingFunctionPrototypes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingFunctionPrototypes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Function Prototypes
    ///
    /// Causes warnings to be emitted about missing prototypes.
    public static let missingFunctionPrototypes: BuildSettingsKey = "GCC_WARN_ABOUT_MISSING_PROTOTYPES"
}

// MARK: Pointer Sign Comparison
extension BuildSetting {

    /// Pointer Sign Comparison
    ///
    /// Warn when pointers passed via arguments or assigned to a variable differ in sign.
    public static var pointerSignComparison: BuildSetting { 
        BuildSetting(key: .pointerSignComparison, value: "YES")
    }

    /// Pointer Sign Comparison
    ///
    /// Warn when pointers passed via arguments or assigned to a variable differ in sign.
    public static func pointerSignComparison(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pointerSignComparison, value: value.asText)
    }

    /// Pointer Sign Comparison
    ///
    /// Warn when pointers passed via arguments or assigned to a variable differ in sign.
    public static func pointerSignComparison(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pointerSignComparison, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pointer Sign Comparison
    ///
    /// Warn when pointers passed via arguments or assigned to a variable differ in sign.
    public static let pointerSignComparison: BuildSettingsKey = "GCC_WARN_ABOUT_POINTER_SIGNEDNESS"
}

// MARK: Mismatched Return Type
extension BuildSetting {

    /// Mismatched Return Type
    ///
    /// Causes warnings to be emitted when a function with a defined return type (not `void`) contains a return statement without a return-value or when it does not contain any return statements. Also emits a warning when a function with a void return type tries to return a value.
    public static var mismatchedReturnType: BuildSetting { 
        .mismatchedReturnType(.no) 
    }

    /// Mismatched Return Type
    ///
    /// Causes warnings to be emitted when a function with a defined return type (not `void`) contains a return statement without a return-value or when it does not contain any return statements. Also emits a warning when a function with a void return type tries to return a value.
    public static func mismatchedReturnType(_ value: MismatchedReturnType) -> BuildSetting { 
        BuildSetting(key: .mismatchedReturnType, value: \(value))
    }

    /// Mismatched Return Type
    ///
    /// Causes warnings to be emitted when a function with a defined return type (not `void`) contains a return statement without a return-value or when it does not contain any return statements. Also emits a warning when a function with a void return type tries to return a value.
    public static func mismatchedReturnType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mismatchedReturnType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mismatched Return Type
    ///
    /// Causes warnings to be emitted when a function with a defined return type (not `void`) contains a return statement without a return-value or when it does not contain any return statements. Also emits a warning when a function with a void return type tries to return a value.
    public static let mismatchedReturnType: BuildSettingsKey = "GCC_WARN_ABOUT_RETURN_TYPE"
}

public enum MismatchedReturnType: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yesError = "YES_ERROR"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Incomplete Objective-C Protocols
extension BuildSetting {

    /// Incomplete Objective-C Protocols
    ///
    /// Warn if methods required by a protocol are not implemented in the class adopting it. Only applies to Objective-C.
    public static var incompleteObjectiveCProtocols: BuildSetting { 
        BuildSetting(key: .incompleteObjectiveCProtocols, value: "YES")
    }

    /// Incomplete Objective-C Protocols
    ///
    /// Warn if methods required by a protocol are not implemented in the class adopting it. Only applies to Objective-C.
    public static func incompleteObjectiveCProtocols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .incompleteObjectiveCProtocols, value: value.asText)
    }

    /// Incomplete Objective-C Protocols
    ///
    /// Warn if methods required by a protocol are not implemented in the class adopting it. Only applies to Objective-C.
    public static func incompleteObjectiveCProtocols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .incompleteObjectiveCProtocols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Incomplete Objective-C Protocols
    ///
    /// Warn if methods required by a protocol are not implemented in the class adopting it. Only applies to Objective-C.
    public static let incompleteObjectiveCProtocols: BuildSettingsKey = "GCC_WARN_ALLOW_INCOMPLETE_PROTOCOL"
}

// MARK: Check Switch Statements
extension BuildSetting {

    /// Check Switch Statements
    ///
    /// Warn whenever a switch statement has an index of enumeral type and lacks a case for one or more of the named codes of that enumeration. The presence of a default label prevents this warning. Case labels outside the enumeration range also provoke warnings when this option is used.
    public static var checkSwitchStatements: BuildSetting { 
        BuildSetting(key: .checkSwitchStatements, value: "YES")
    }

    /// Check Switch Statements
    ///
    /// Warn whenever a switch statement has an index of enumeral type and lacks a case for one or more of the named codes of that enumeration. The presence of a default label prevents this warning. Case labels outside the enumeration range also provoke warnings when this option is used.
    public static func checkSwitchStatements(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .checkSwitchStatements, value: value.asText)
    }

    /// Check Switch Statements
    ///
    /// Warn whenever a switch statement has an index of enumeral type and lacks a case for one or more of the named codes of that enumeration. The presence of a default label prevents this warning. Case labels outside the enumeration range also provoke warnings when this option is used.
    public static func checkSwitchStatements(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .checkSwitchStatements, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Check Switch Statements
    ///
    /// Warn whenever a switch statement has an index of enumeral type and lacks a case for one or more of the named codes of that enumeration. The presence of a default label prevents this warning. Case labels outside the enumeration range also provoke warnings when this option is used.
    public static let checkSwitchStatements: BuildSettingsKey = "GCC_WARN_CHECK_SWITCH_STATEMENTS"
}

// MARK: Four Character Literals
extension BuildSetting {

    /// Four Character Literals
    ///
    /// Warn about four-char literals (for example, macOS-style `OSTypes`: `'APPL'`).
    public static var fourCharacterLiterals: BuildSetting { 
        BuildSetting(key: .fourCharacterLiterals, value: "NO")
    }

    /// Four Character Literals
    ///
    /// Warn about four-char literals (for example, macOS-style `OSTypes`: `'APPL'`).
    public static func fourCharacterLiterals(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .fourCharacterLiterals, value: value.asText)
    }

    /// Four Character Literals
    ///
    /// Warn about four-char literals (for example, macOS-style `OSTypes`: `'APPL'`).
    public static func fourCharacterLiterals(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fourCharacterLiterals, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Four Character Literals
    ///
    /// Warn about four-char literals (for example, macOS-style `OSTypes`: `'APPL'`).
    public static let fourCharacterLiterals: BuildSettingsKey = "GCC_WARN_FOUR_CHARACTER_CONSTANTS"
}

// MARK: Overloaded Virtual Functions
extension BuildSetting {

    /// Overloaded Virtual Functions
    ///
    /// Warn when a function declaration hides virtual functions from a base class. For example, in the following example, the `A` class version of `f()` is hidden in `B`. `struct A {`` virtual void f();``};``struct B: public A {`` void f(int);``};` As a result, the following code will fail to compile. `B* b;``b-&gt;f();` This setting only applies to C++ and Objective-C++ sources.
    public static var overloadedVirtualFunctions: BuildSetting { 
        BuildSetting(key: .overloadedVirtualFunctions, value: "NO")
    }

    /// Overloaded Virtual Functions
    ///
    /// Warn when a function declaration hides virtual functions from a base class. For example, in the following example, the `A` class version of `f()` is hidden in `B`. `struct A {`` virtual void f();``};``struct B: public A {`` void f(int);``};` As a result, the following code will fail to compile. `B* b;``b-&gt;f();` This setting only applies to C++ and Objective-C++ sources.
    public static func overloadedVirtualFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .overloadedVirtualFunctions, value: value.asText)
    }

    /// Overloaded Virtual Functions
    ///
    /// Warn when a function declaration hides virtual functions from a base class. For example, in the following example, the `A` class version of `f()` is hidden in `B`. `struct A {`` virtual void f();``};``struct B: public A {`` void f(int);``};` As a result, the following code will fail to compile. `B* b;``b-&gt;f();` This setting only applies to C++ and Objective-C++ sources.
    public static func overloadedVirtualFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .overloadedVirtualFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Overloaded Virtual Functions
    ///
    /// Warn when a function declaration hides virtual functions from a base class. For example, in the following example, the `A` class version of `f()` is hidden in `B`. `struct A {`` virtual void f();``};``struct B: public A {`` void f(int);``};` As a result, the following code will fail to compile. `B* b;``b-&gt;f();` This setting only applies to C++ and Objective-C++ sources.
    public static let overloadedVirtualFunctions: BuildSettingsKey = "GCC_WARN_HIDDEN_VIRTUAL_FUNCTIONS"
}

// MARK: Inhibit All Warnings
extension BuildSetting {

    /// Inhibit All Warnings
    ///
    /// Inhibit all warning messages.
    public static var inhibitAllWarnings: BuildSetting { 
        BuildSetting(key: .inhibitAllWarnings, value: "NO")
    }

    /// Inhibit All Warnings
    ///
    /// Inhibit all warning messages.
    public static func inhibitAllWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inhibitAllWarnings, value: value.asText)
    }

    /// Inhibit All Warnings
    ///
    /// Inhibit all warning messages.
    public static func inhibitAllWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inhibitAllWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Inhibit All Warnings
    ///
    /// Inhibit all warning messages.
    public static let inhibitAllWarnings: BuildSettingsKey = "GCC_WARN_INHIBIT_ALL_WARNINGS"
}

// MARK: Initializer Not Fully Bracketed
extension BuildSetting {

    /// Initializer Not Fully Bracketed
    ///
    /// Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for `a` is not fully bracketed, but the initializer for `b` is fully bracketed. `int a`2`2` = { 0, 1, 2, 3 };`int b`2``2` = { { 0, 1 }, { 2, 3 } };`
    public static var initializerNotFullyBracketed: BuildSetting { 
        BuildSetting(key: .initializerNotFullyBracketed, value: "NO")
    }

    /// Initializer Not Fully Bracketed
    ///
    /// Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for `a` is not fully bracketed, but the initializer for `b` is fully bracketed. `int a`2`2` = { 0, 1, 2, 3 };`int b`2``2` = { { 0, 1 }, { 2, 3 } };`
    public static func initializerNotFullyBracketed(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .initializerNotFullyBracketed, value: value.asText)
    }

    /// Initializer Not Fully Bracketed
    ///
    /// Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for `a` is not fully bracketed, but the initializer for `b` is fully bracketed. `int a`2`2` = { 0, 1, 2, 3 };`int b`2``2` = { { 0, 1 }, { 2, 3 } };`
    public static func initializerNotFullyBracketed(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .initializerNotFullyBracketed, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Initializer Not Fully Bracketed
    ///
    /// Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for `a` is not fully bracketed, but the initializer for `b` is fully bracketed. `int a`2`2` = { 0, 1, 2, 3 };`int b`2``2` = { { 0, 1 }, { 2, 3 } };`
    public static let initializerNotFullyBracketed: BuildSettingsKey = "GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED"
}

// MARK: Missing Braces and Parentheses
extension BuildSetting {

    /// Missing Braces and Parentheses
    ///
    /// Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence causes confusion. Also, warn about constructions where there may be confusion as to which `if` statement an `else` branch belongs. For example: `{`` if (a)`` if (b)`` foo ();`` else`` bar ();``}` In C, every `else` branch belongs to the innermost possible `if` statement, which in the example above is `if (b)`. This is often not what the programmer expects, as illustrated by indentation used in the example above. This build setting causes GCC to issue a warning when there is the potential for this confusion. To eliminate the warning, add explicit braces around the innermost `if` statement so there is no way the `else` could belong to the enclosing `if`. For example: `{`` if (a)`` {`` if (b)`` foo ();`` else`` bar ();`` }``}`
    public static var missingBracesAndParentheses: BuildSetting { 
        BuildSetting(key: .missingBracesAndParentheses, value: "YES")
    }

    /// Missing Braces and Parentheses
    ///
    /// Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence causes confusion. Also, warn about constructions where there may be confusion as to which `if` statement an `else` branch belongs. For example: `{`` if (a)`` if (b)`` foo ();`` else`` bar ();``}` In C, every `else` branch belongs to the innermost possible `if` statement, which in the example above is `if (b)`. This is often not what the programmer expects, as illustrated by indentation used in the example above. This build setting causes GCC to issue a warning when there is the potential for this confusion. To eliminate the warning, add explicit braces around the innermost `if` statement so there is no way the `else` could belong to the enclosing `if`. For example: `{`` if (a)`` {`` if (b)`` foo ();`` else`` bar ();`` }``}`
    public static func missingBracesAndParentheses(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingBracesAndParentheses, value: value.asText)
    }

    /// Missing Braces and Parentheses
    ///
    /// Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence causes confusion. Also, warn about constructions where there may be confusion as to which `if` statement an `else` branch belongs. For example: `{`` if (a)`` if (b)`` foo ();`` else`` bar ();``}` In C, every `else` branch belongs to the innermost possible `if` statement, which in the example above is `if (b)`. This is often not what the programmer expects, as illustrated by indentation used in the example above. This build setting causes GCC to issue a warning when there is the potential for this confusion. To eliminate the warning, add explicit braces around the innermost `if` statement so there is no way the `else` could belong to the enclosing `if`. For example: `{`` if (a)`` {`` if (b)`` foo ();`` else`` bar ();`` }``}`
    public static func missingBracesAndParentheses(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingBracesAndParentheses, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Braces and Parentheses
    ///
    /// Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence causes confusion. Also, warn about constructions where there may be confusion as to which `if` statement an `else` branch belongs. For example: `{`` if (a)`` if (b)`` foo ();`` else`` bar ();``}` In C, every `else` branch belongs to the innermost possible `if` statement, which in the example above is `if (b)`. This is often not what the programmer expects, as illustrated by indentation used in the example above. This build setting causes GCC to issue a warning when there is the potential for this confusion. To eliminate the warning, add explicit braces around the innermost `if` statement so there is no way the `else` could belong to the enclosing `if`. For example: `{`` if (a)`` {`` if (b)`` foo ();`` else`` bar ();`` }``}`
    public static let missingBracesAndParentheses: BuildSettingsKey = "GCC_WARN_MISSING_PARENTHESES"
}

// MARK: Gcc Warn Multiple Definition Types For Selector
extension BuildSetting {

    /// Gcc Warn Multiple Definition Types For Selector
    public static var gccWarnMultipleDefinitionTypesForSelector: BuildSetting { 
        BuildSetting(key: .gccWarnMultipleDefinitionTypesForSelector, value: "NO")
    }

    /// Gcc Warn Multiple Definition Types For Selector
    public static func gccWarnMultipleDefinitionTypesForSelector(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .gccWarnMultipleDefinitionTypesForSelector, value: value.asText)
    }

    /// Gcc Warn Multiple Definition Types For Selector
    public static func gccWarnMultipleDefinitionTypesForSelector(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccWarnMultipleDefinitionTypesForSelector, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Gcc Warn Multiple Definition Types For Selector
    public static let gccWarnMultipleDefinitionTypesForSelector: BuildSettingsKey = "GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR"
}

// MARK: Nonvirtual Destructor
extension BuildSetting {

    /// Nonvirtual Destructor
    ///
    /// Warn when a class declares an nonvirtual destructor that should probably be virtual, because it looks like the class will be used polymorphically. This is only active for C++ or Objective-C++ sources.
    public static var nonvirtualDestructor: BuildSetting { 
        BuildSetting(key: .nonvirtualDestructor, value: "NO")
    }

    /// Nonvirtual Destructor
    ///
    /// Warn when a class declares an nonvirtual destructor that should probably be virtual, because it looks like the class will be used polymorphically. This is only active for C++ or Objective-C++ sources.
    public static func nonvirtualDestructor(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .nonvirtualDestructor, value: value.asText)
    }

    /// Nonvirtual Destructor
    ///
    /// Warn when a class declares an nonvirtual destructor that should probably be virtual, because it looks like the class will be used polymorphically. This is only active for C++ or Objective-C++ sources.
    public static func nonvirtualDestructor(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nonvirtualDestructor, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Nonvirtual Destructor
    ///
    /// Warn when a class declares an nonvirtual destructor that should probably be virtual, because it looks like the class will be used polymorphically. This is only active for C++ or Objective-C++ sources.
    public static let nonvirtualDestructor: BuildSettingsKey = "GCC_WARN_NON_VIRTUAL_DESTRUCTOR"
}

// MARK: Pedantic Warnings
extension BuildSetting {

    /// Pedantic Warnings
    ///
    /// Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any `-std` option used.
    public static var pedanticWarnings: BuildSetting { 
        BuildSetting(key: .pedanticWarnings, value: "NO")
    }

    /// Pedantic Warnings
    ///
    /// Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any `-std` option used.
    public static func pedanticWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pedanticWarnings, value: value.asText)
    }

    /// Pedantic Warnings
    ///
    /// Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any `-std` option used.
    public static func pedanticWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pedanticWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pedantic Warnings
    ///
    /// Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any `-std` option used.
    public static let pedanticWarnings: BuildSettingsKey = "GCC_WARN_PEDANTIC"
}

// MARK: Hidden Local Variables
extension BuildSetting {

    /// Hidden Local Variables
    ///
    /// Warn whenever a local variable shadows another local variable, parameter or global variable or whenever a builtin function is shadowed.
    public static var hiddenLocalVariables: BuildSetting { 
        BuildSetting(key: .hiddenLocalVariables, value: "NO")
    }

    /// Hidden Local Variables
    ///
    /// Warn whenever a local variable shadows another local variable, parameter or global variable or whenever a builtin function is shadowed.
    public static func hiddenLocalVariables(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .hiddenLocalVariables, value: value.asText)
    }

    /// Hidden Local Variables
    ///
    /// Warn whenever a local variable shadows another local variable, parameter or global variable or whenever a builtin function is shadowed.
    public static func hiddenLocalVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .hiddenLocalVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Hidden Local Variables
    ///
    /// Warn whenever a local variable shadows another local variable, parameter or global variable or whenever a builtin function is shadowed.
    public static let hiddenLocalVariables: BuildSettingsKey = "GCC_WARN_SHADOW"
}

// MARK: Sign Comparison
extension BuildSetting {

    /// Sign Comparison
    ///
    /// Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
    public static var signComparison: BuildSetting { 
        BuildSetting(key: .signComparison, value: "NO")
    }

    /// Sign Comparison
    ///
    /// Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
    public static func signComparison(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .signComparison, value: value.asText)
    }

    /// Sign Comparison
    ///
    /// Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
    public static func signComparison(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .signComparison, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Sign Comparison
    ///
    /// Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
    public static let signComparison: BuildSettingsKey = "GCC_WARN_SIGN_COMPARE"
}

// MARK: Strict Selector Matching
extension BuildSetting {

    /// Strict Selector Matching
    ///
    /// Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type `id` or `Class`. When this setting is disabled, the compiler will omit such warnings if any differences found are confined to types that share the same size and alignment.
    public static var strictSelectorMatching: BuildSetting { 
        BuildSetting(key: .strictSelectorMatching, value: "NO")
    }

    /// Strict Selector Matching
    ///
    /// Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type `id` or `Class`. When this setting is disabled, the compiler will omit such warnings if any differences found are confined to types that share the same size and alignment.
    public static func strictSelectorMatching(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .strictSelectorMatching, value: value.asText)
    }

    /// Strict Selector Matching
    ///
    /// Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type `id` or `Class`. When this setting is disabled, the compiler will omit such warnings if any differences found are confined to types that share the same size and alignment.
    public static func strictSelectorMatching(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .strictSelectorMatching, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strict Selector Matching
    ///
    /// Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type `id` or `Class`. When this setting is disabled, the compiler will omit such warnings if any differences found are confined to types that share the same size and alignment.
    public static let strictSelectorMatching: BuildSettingsKey = "GCC_WARN_STRICT_SELECTOR_MATCH"
}

// MARK: Typecheck Calls to printf/scanf
extension BuildSetting {

    /// Typecheck Calls to printf/scanf
    ///
    /// Check calls to `printf` and `scanf` to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.
    public static var typecheckCallsToPrintfScanf: BuildSetting { 
        BuildSetting(key: .typecheckCallsToPrintfScanf, value: "YES")
    }

    /// Typecheck Calls to printf/scanf
    ///
    /// Check calls to `printf` and `scanf` to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.
    public static func typecheckCallsToPrintfScanf(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .typecheckCallsToPrintfScanf, value: value.asText)
    }

    /// Typecheck Calls to printf/scanf
    ///
    /// Check calls to `printf` and `scanf` to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.
    public static func typecheckCallsToPrintfScanf(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .typecheckCallsToPrintfScanf, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Typecheck Calls to printf/scanf
    ///
    /// Check calls to `printf` and `scanf` to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.
    public static let typecheckCallsToPrintfScanf: BuildSettingsKey = "GCC_WARN_TYPECHECK_CALLS_TO_PRINTF"
}

// MARK: Undeclared Selector
extension BuildSetting {

    /// Undeclared Selector
    ///
    /// Warn if a `@selector(...)` expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the `@selector(...)` expression, either explicitly in an `@interface` or `@protocol` declaration, or implicitly in an `@implementation` section. This option always performs its checks as soon as a `@selector(...)` expression is found, while `-Wselector` only performs its checks in the final stage of compilation. This also enforces the coding style convention that methods and selectors must be declared before being used.
    public static var undeclaredSelector: BuildSetting { 
        BuildSetting(key: .undeclaredSelector, value: "NO")
    }

    /// Undeclared Selector
    ///
    /// Warn if a `@selector(...)` expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the `@selector(...)` expression, either explicitly in an `@interface` or `@protocol` declaration, or implicitly in an `@implementation` section. This option always performs its checks as soon as a `@selector(...)` expression is found, while `-Wselector` only performs its checks in the final stage of compilation. This also enforces the coding style convention that methods and selectors must be declared before being used.
    public static func undeclaredSelector(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .undeclaredSelector, value: value.asText)
    }

    /// Undeclared Selector
    ///
    /// Warn if a `@selector(...)` expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the `@selector(...)` expression, either explicitly in an `@interface` or `@protocol` declaration, or implicitly in an `@implementation` section. This option always performs its checks as soon as a `@selector(...)` expression is found, while `-Wselector` only performs its checks in the final stage of compilation. This also enforces the coding style convention that methods and selectors must be declared before being used.
    public static func undeclaredSelector(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .undeclaredSelector, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Undeclared Selector
    ///
    /// Warn if a `@selector(...)` expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the `@selector(...)` expression, either explicitly in an `@interface` or `@protocol` declaration, or implicitly in an `@implementation` section. This option always performs its checks as soon as a `@selector(...)` expression is found, while `-Wselector` only performs its checks in the final stage of compilation. This also enforces the coding style convention that methods and selectors must be declared before being used.
    public static let undeclaredSelector: BuildSettingsKey = "GCC_WARN_UNDECLARED_SELECTOR"
}

// MARK: Uninitialized Variables
extension BuildSetting {

    /// Uninitialized Variables
    ///
    /// Warn if a variable might be clobbered by a `setjmp` call or if an automatic variable is used without prior initialization. The compiler may not detect all cases where an automatic variable is initialized or all usage patterns that may lead to use prior to initialization. You can toggle between the normal uninitialized value checking or the more aggressive (conservative) checking, which finds more issues but the checking is much stricter.
    public static var uninitializedVariables: BuildSetting { 
        .uninitializedVariables(.no) 
    }

    /// Uninitialized Variables
    ///
    /// Warn if a variable might be clobbered by a `setjmp` call or if an automatic variable is used without prior initialization. The compiler may not detect all cases where an automatic variable is initialized or all usage patterns that may lead to use prior to initialization. You can toggle between the normal uninitialized value checking or the more aggressive (conservative) checking, which finds more issues but the checking is much stricter.
    public static func uninitializedVariables(_ value: UninitializedVariables) -> BuildSetting { 
        BuildSetting(key: .uninitializedVariables, value: \(value))
    }

    /// Uninitialized Variables
    ///
    /// Warn if a variable might be clobbered by a `setjmp` call or if an automatic variable is used without prior initialization. The compiler may not detect all cases where an automatic variable is initialized or all usage patterns that may lead to use prior to initialization. You can toggle between the normal uninitialized value checking or the more aggressive (conservative) checking, which finds more issues but the checking is much stricter.
    public static func uninitializedVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .uninitializedVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Uninitialized Variables
    ///
    /// Warn if a variable might be clobbered by a `setjmp` call or if an automatic variable is used without prior initialization. The compiler may not detect all cases where an automatic variable is initialized or all usage patterns that may lead to use prior to initialization. You can toggle between the normal uninitialized value checking or the more aggressive (conservative) checking, which finds more issues but the checking is much stricter.
    public static let uninitializedVariables: BuildSettingsKey = "GCC_WARN_UNINITIALIZED_AUTOS"
}

public enum UninitializedVariables: String, Hashable, Codable, CustomStringConvertible {
    case yesAggressive = "YES_AGGRESSIVE"
    case no = "NO"
    case yes = "YES"

    public var description: String {
        rawValue
    }
}

// MARK: Unknown Pragma
extension BuildSetting {

    /// Unknown Pragma
    ///
    /// Warn when a `#pragma` directive is encountered that is not understood by GCC. If this command line option is used, warnings will even be issued for unknown pragmas in system header files. This is not the case if the warnings were only enabled by the `-Wall` command-line option.
    public static var unknownPragma: BuildSetting { 
        BuildSetting(key: .unknownPragma, value: "NO")
    }

    /// Unknown Pragma
    ///
    /// Warn when a `#pragma` directive is encountered that is not understood by GCC. If this command line option is used, warnings will even be issued for unknown pragmas in system header files. This is not the case if the warnings were only enabled by the `-Wall` command-line option.
    public static func unknownPragma(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unknownPragma, value: value.asText)
    }

    /// Unknown Pragma
    ///
    /// Warn when a `#pragma` directive is encountered that is not understood by GCC. If this command line option is used, warnings will even be issued for unknown pragmas in system header files. This is not the case if the warnings were only enabled by the `-Wall` command-line option.
    public static func unknownPragma(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unknownPragma, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unknown Pragma
    ///
    /// Warn when a `#pragma` directive is encountered that is not understood by GCC. If this command line option is used, warnings will even be issued for unknown pragmas in system header files. This is not the case if the warnings were only enabled by the `-Wall` command-line option.
    public static let unknownPragma: BuildSettingsKey = "GCC_WARN_UNKNOWN_PRAGMAS"
}

// MARK: Unused Functions
extension BuildSetting {

    /// Unused Functions
    ///
    /// Warn whenever a static function is declared but not defined or a noninline static function is unused.
    public static var unusedFunctions: BuildSetting { 
        BuildSetting(key: .unusedFunctions, value: "NO")
    }

    /// Unused Functions
    ///
    /// Warn whenever a static function is declared but not defined or a noninline static function is unused.
    public static func unusedFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedFunctions, value: value.asText)
    }

    /// Unused Functions
    ///
    /// Warn whenever a static function is declared but not defined or a noninline static function is unused.
    public static func unusedFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Functions
    ///
    /// Warn whenever a static function is declared but not defined or a noninline static function is unused.
    public static let unusedFunctions: BuildSettingsKey = "GCC_WARN_UNUSED_FUNCTION"
}

// MARK: Unused Labels
extension BuildSetting {

    /// Unused Labels
    ///
    /// Warn whenever a label is declared but not used.
    public static var unusedLabels: BuildSetting { 
        BuildSetting(key: .unusedLabels, value: "NO")
    }

    /// Unused Labels
    ///
    /// Warn whenever a label is declared but not used.
    public static func unusedLabels(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedLabels, value: value.asText)
    }

    /// Unused Labels
    ///
    /// Warn whenever a label is declared but not used.
    public static func unusedLabels(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedLabels, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Labels
    ///
    /// Warn whenever a label is declared but not used.
    public static let unusedLabels: BuildSettingsKey = "GCC_WARN_UNUSED_LABEL"
}

// MARK: Unused Parameters
extension BuildSetting {

    /// Unused Parameters
    ///
    /// Warn whenever a function parameter is unused aside from its declaration.
    public static var unusedParameters: BuildSetting { 
        BuildSetting(key: .unusedParameters, value: "NO")
    }

    /// Unused Parameters
    ///
    /// Warn whenever a function parameter is unused aside from its declaration.
    public static func unusedParameters(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedParameters, value: value.asText)
    }

    /// Unused Parameters
    ///
    /// Warn whenever a function parameter is unused aside from its declaration.
    public static func unusedParameters(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedParameters, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Parameters
    ///
    /// Warn whenever a function parameter is unused aside from its declaration.
    public static let unusedParameters: BuildSettingsKey = "GCC_WARN_UNUSED_PARAMETER"
}

// MARK: Unused Values
extension BuildSetting {

    /// Unused Values
    ///
    /// Warn whenever a statement computes a result that is explicitly not used.
    public static var unusedValues: BuildSetting { 
        BuildSetting(key: .unusedValues, value: "YES")
    }

    /// Unused Values
    ///
    /// Warn whenever a statement computes a result that is explicitly not used.
    public static func unusedValues(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedValues, value: value.asText)
    }

    /// Unused Values
    ///
    /// Warn whenever a statement computes a result that is explicitly not used.
    public static func unusedValues(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedValues, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Values
    ///
    /// Warn whenever a statement computes a result that is explicitly not used.
    public static let unusedValues: BuildSettingsKey = "GCC_WARN_UNUSED_VALUE"
}

// MARK: Unused Variables
extension BuildSetting {

    /// Unused Variables
    ///
    /// Warn whenever a local variable or nonconstant static variable is unused aside from its declaration.
    public static var unusedVariables: BuildSetting { 
        BuildSetting(key: .unusedVariables, value: "NO")
    }

    /// Unused Variables
    ///
    /// Warn whenever a local variable or nonconstant static variable is unused aside from its declaration.
    public static func unusedVariables(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedVariables, value: value.asText)
    }

    /// Unused Variables
    ///
    /// Warn whenever a local variable or nonconstant static variable is unused aside from its declaration.
    public static func unusedVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Variables
    ///
    /// Warn whenever a local variable or nonconstant static variable is unused aside from its declaration.
    public static let unusedVariables: BuildSettingsKey = "GCC_WARN_UNUSED_VARIABLE"
}

// MARK: Headermap File Format
extension BuildSetting {

    /// Headermap File Format
    public static var headermapFileFormat: BuildSetting { 
        .headermapFileFormat(.traditional) 
    }

    /// Headermap File Format
    public static func headermapFileFormat(_ value: HeadermapFileFormat) -> BuildSetting { 
        BuildSetting(key: .headermapFileFormat, value: \(value))
    }

    /// Headermap File Format
    public static func headermapFileFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapFileFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Headermap File Format
    public static let headermapFileFormat: BuildSettingsKey = "HEADERMAP_FILE_FORMAT"
}

public enum HeadermapFileFormat: String, Hashable, Codable, CustomStringConvertible {
    case traditional = "traditional"

    public var description: String {
        rawValue
    }
}

// MARK: Llvm Implicit Aggressive Optimizations
extension BuildSetting {

    /// Llvm Implicit Aggressive Optimizations
    public static var llvmImplicitAggressiveOptimizations: BuildSetting { 
        BuildSetting(key: .llvmImplicitAggressiveOptimizations, value: "$(LLVM_OPTIMIZATION_LEVEL_VAL_$(GCC_OPTIMIZATION_LEVEL))")
    }

    /// Llvm Implicit Aggressive Optimizations
    public static func llvmImplicitAggressiveOptimizations(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .llvmImplicitAggressiveOptimizations, value: value.asText)
    }

    /// Llvm Implicit Aggressive Optimizations
    public static func llvmImplicitAggressiveOptimizations(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmImplicitAggressiveOptimizations, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Llvm Implicit Aggressive Optimizations
    public static let llvmImplicitAggressiveOptimizations: BuildSettingsKey = "LLVM_IMPLICIT_AGGRESSIVE_OPTIMIZATIONS"
}

// MARK: Link-Time Optimization
extension BuildSetting {

    /// Link-Time Optimization
    ///
    /// Enabling this setting allows optimization across file boundaries during linking.
    public static var linkTimeOptimization: BuildSetting { 
        .linkTimeOptimization(.no) 
    }

    /// Link-Time Optimization
    ///
    /// Enabling this setting allows optimization across file boundaries during linking.
    public static func linkTimeOptimization(_ value: LinkTimeOptimization) -> BuildSetting { 
        BuildSetting(key: .linkTimeOptimization, value: \(value))
    }

    /// Link-Time Optimization
    ///
    /// Enabling this setting allows optimization across file boundaries during linking.
    public static func linkTimeOptimization(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkTimeOptimization, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Link-Time Optimization
    ///
    /// Enabling this setting allows optimization across file boundaries during linking.
    public static let linkTimeOptimization: BuildSettingsKey = "LLVM_LTO"
}

public enum LinkTimeOptimization: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesThin = "YES_THIN"

    public var description: String {
        rawValue
    }
}

// MARK: Analyze During 'Build'
extension BuildSetting {

    /// Analyze During 'Build'
    ///
    /// Activating this setting will cause Xcode to run the `Clang` static analysis tool on qualifying source files during every build.
    public static var analyzeDuringBuild: BuildSetting { 
        BuildSetting(key: .analyzeDuringBuild, value: "NO")
    }

    /// Analyze During 'Build'
    ///
    /// Activating this setting will cause Xcode to run the `Clang` static analysis tool on qualifying source files during every build.
    public static func analyzeDuringBuild(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .analyzeDuringBuild, value: value.asText)
    }

    /// Analyze During 'Build'
    ///
    /// Activating this setting will cause Xcode to run the `Clang` static analysis tool on qualifying source files during every build.
    public static func analyzeDuringBuild(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .analyzeDuringBuild, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Analyze During 'Build'
    ///
    /// Activating this setting will cause Xcode to run the `Clang` static analysis tool on qualifying source files during every build.
    public static let analyzeDuringBuild: BuildSettingsKey = "RUN_CLANG_STATIC_ANALYZER"
}

// MARK: Other Warning Flags
extension BuildSetting {

    /// Other Warning Flags
    ///
    /// Space-separated list of additional warning flags to pass to the compiler. Use this setting if Xcode does not already provide UI for a particular compiler warning flag.
    public static func otherWarningFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherWarningFlags, value: .array(value))
    }

    /// Other Warning Flags
    ///
    /// Space-separated list of additional warning flags to pass to the compiler. Use this setting if Xcode does not already provide UI for a particular compiler warning flag.
    public static func otherWarningFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherWarningFlags, inherit: key)
    }

    /// Other Warning Flags
    ///
    /// Space-separated list of additional warning flags to pass to the compiler. Use this setting if Xcode does not already provide UI for a particular compiler warning flag.
    public static func otherWarningFlags(_ value: String...) -> BuildSetting { 
        .otherWarningFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Warning Flags
    ///
    /// Space-separated list of additional warning flags to pass to the compiler. Use this setting if Xcode does not already provide UI for a particular compiler warning flag.
    public static let otherWarningFlags: BuildSettingsKey = "WARNING_CFLAGS"
}

// MARK: Watch Complication Name
extension BuildSetting {

    /// Watch Complication Name
    ///
    /// The name of a watch complication to use from the asset catalog.
    public static func watchComplicationName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .watchComplicationName, value: \(value))
    }

    /// Watch Complication Name
    ///
    /// The name of a watch complication to use from the asset catalog.
    public static func watchComplicationName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .watchComplicationName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Watch Complication Name
    ///
    /// The name of a watch complication to use from the asset catalog.
    public static let watchComplicationName: BuildSettingsKey = "ASSETCATALOG_COMPILER_COMPLICATION_NAME"
}

// MARK: Clang Diagnostics File
extension BuildSetting {

    /// Clang Diagnostics File
    public static var clangDiagnosticsFile: BuildSetting { 
        BuildSetting(key: .clangDiagnosticsFile, value: "$(MTLCOMPILER_OUTPUT_FILE:dir)$(InputFileBase)$(InputFileBaseUniquefier).dia")
    }

    /// Clang Diagnostics File
    public static func clangDiagnosticsFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangDiagnosticsFile, value: \(value))
    }

    /// Clang Diagnostics File
    public static func clangDiagnosticsFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangDiagnosticsFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Clang Diagnostics File
    public static let clangDiagnosticsFile: BuildSettingsKey = "CLANG_DIAGNOSTICS_FILE"
}

// MARK: Mtlcompiler Dependency Info File
extension BuildSetting {

    /// Mtlcompiler Dependency Info File
    public static var mtlcompilerDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .mtlcompilerDependencyInfoFile, value: "$(TARGET_TEMP_DIR)/Metal/$(InputFileBase)$(InputFileBaseUniquefier).dat")
    }

    /// Mtlcompiler Dependency Info File
    public static func mtlcompilerDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlcompilerDependencyInfoFile, value: \(value))
    }

    /// Mtlcompiler Dependency Info File
    public static func mtlcompilerDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlcompilerDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtlcompiler Dependency Info File
    public static let mtlcompilerDependencyInfoFile: BuildSettingsKey = "MTLCOMPILER_DEPENDENCY_INFO_FILE"
}

// MARK: Mtlcompiler Output File
extension BuildSetting {

    /// Mtlcompiler Output File
    public static var mtlcompilerOutputFile: BuildSetting { 
        BuildSetting(key: .mtlcompilerOutputFile, value: "$(TARGET_TEMP_DIR)/Metal/$(InputFileBase)$(InputFileBaseUniquefier).air")
    }

    /// Mtlcompiler Output File
    public static func mtlcompilerOutputFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlcompilerOutputFile, value: \(value))
    }

    /// Mtlcompiler Output File
    public static func mtlcompilerOutputFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlcompilerOutputFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtlcompiler Output File
    public static let mtlcompilerOutputFile: BuildSettingsKey = "MTLCOMPILER_OUTPUT_FILE"
}

// MARK: Other Metal Compiler Flags
extension BuildSetting {

    /// Other Metal Compiler Flags
    ///
    /// Space-separated list of compiler flags
    public static func otherMetalCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherMetalCompilerFlags, value: .array(value))
    }

    /// Other Metal Compiler Flags
    ///
    /// Space-separated list of compiler flags
    public static func otherMetalCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherMetalCompilerFlags, inherit: key)
    }

    /// Other Metal Compiler Flags
    ///
    /// Space-separated list of compiler flags
    public static func otherMetalCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherMetalCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Metal Compiler Flags
    ///
    /// Space-separated list of compiler flags
    public static let otherMetalCompilerFlags: BuildSettingsKey = "MTL_COMPILER_FLAGS"
}

// MARK: Produce Debugging Information
extension BuildSetting {

    /// Produce Debugging Information
    ///
    /// Debugging information is required for shader debugging and profiling.
    public static var produceDebuggingInformation: BuildSetting { 
        BuildSetting(key: .produceDebuggingInformation, value: "NO")
    }

    /// Produce Debugging Information
    ///
    /// Debugging information is required for shader debugging and profiling.
    public static func produceDebuggingInformation(_ value: ProduceDebuggingInformation) -> BuildSetting { 
        BuildSetting(key: .produceDebuggingInformation, value: \(value))
    }

    /// Produce Debugging Information
    ///
    /// Debugging information is required for shader debugging and profiling.
    public static func produceDebuggingInformation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .produceDebuggingInformation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Produce Debugging Information
    ///
    /// Debugging information is required for shader debugging and profiling.
    public static let produceDebuggingInformation: BuildSettingsKey = "MTL_ENABLE_DEBUG_INFO"
}

// MARK: Enable Index-While-Building Functionality (Metal)
extension BuildSetting {

    /// Enable Index-While-Building Functionality (Metal)
    ///
    /// Control whether the compiler should emit index data while building.
    public static var enableIndexWhileBuildingFunctionalityMetal: BuildSetting { 
        BuildSetting(key: .enableIndexWhileBuildingFunctionalityMetal, value: "$(INDEX_ENABLE_DATA_STORE)")
    }

    /// Enable Index-While-Building Functionality (Metal)
    ///
    /// Control whether the compiler should emit index data while building.
    public static func enableIndexWhileBuildingFunctionalityMetal(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableIndexWhileBuildingFunctionalityMetal, value: value.asText)
    }

    /// Enable Index-While-Building Functionality (Metal)
    ///
    /// Control whether the compiler should emit index data while building.
    public static func enableIndexWhileBuildingFunctionalityMetal(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableIndexWhileBuildingFunctionalityMetal, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Index-While-Building Functionality (Metal)
    ///
    /// Control whether the compiler should emit index data while building.
    public static let enableIndexWhileBuildingFunctionalityMetal: BuildSettingsKey = "MTL_ENABLE_INDEX_STORE"
}

// MARK: Enable Modules (Metal)
extension BuildSetting {

    /// Enable Modules (Metal)
    ///
    /// Enables the use of modules. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static var enableModulesMetal: BuildSetting { 
        BuildSetting(key: .enableModulesMetal, value: "NO")
    }

    /// Enable Modules (Metal)
    ///
    /// Enables the use of modules. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static func enableModulesMetal(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableModulesMetal, value: value.asText)
    }

    /// Enable Modules (Metal)
    ///
    /// Enables the use of modules. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static func enableModulesMetal(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableModulesMetal, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Modules (Metal)
    ///
    /// Enables the use of modules. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static let enableModulesMetal: BuildSettingsKey = "MTL_ENABLE_MODULES"
}

// MARK: Enable Fast Math
extension BuildSetting {

    /// Enable Fast Math
    ///
    /// Enable optimizations for floating-point arithmetic that may violate the IEEE 754 standard and disable the high precision variant of math functions for single and half precision floating-point.
    public static var enableFastMath: BuildSetting { 
        BuildSetting(key: .enableFastMath, value: "YES")
    }

    /// Enable Fast Math
    ///
    /// Enable optimizations for floating-point arithmetic that may violate the IEEE 754 standard and disable the high precision variant of math functions for single and half precision floating-point.
    public static func enableFastMath(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableFastMath, value: value.asText)
    }

    /// Enable Fast Math
    ///
    /// Enable optimizations for floating-point arithmetic that may violate the IEEE 754 standard and disable the high precision variant of math functions for single and half precision floating-point.
    public static func enableFastMath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableFastMath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Fast Math
    ///
    /// Enable optimizations for floating-point arithmetic that may violate the IEEE 754 standard and disable the high precision variant of math functions for single and half precision floating-point.
    public static let enableFastMath: BuildSettingsKey = "MTL_FAST_MATH"
}

// MARK: Mtl Framework Search Path Built Products Dir
extension BuildSetting {

    /// Mtl Framework Search Path Built Products Dir
    public static func mtlFrameworkSearchPathBuiltProductsDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlFrameworkSearchPathBuiltProductsDir, value: \(value))
    }

    /// Mtl Framework Search Path Built Products Dir
    public static func mtlFrameworkSearchPathBuiltProductsDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlFrameworkSearchPathBuiltProductsDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtl Framework Search Path Built Products Dir
    public static let mtlFrameworkSearchPathBuiltProductsDir: BuildSettingsKey = "MTL_FRAMEWORK_SEARCH_PATH_BUILT_PRODUCTS_DIR"
}

// MARK: MTL Header Search Paths
extension BuildSetting {

    /// MTL Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling Metal. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. `MTL_HEADER_SEARCH_PATHS, -I`
    public static func mtlHeaderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .mtlHeaderSearchPaths, value: .array(value))
    }

    /// MTL Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling Metal. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. `MTL_HEADER_SEARCH_PATHS, -I`
    public static func mtlHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlHeaderSearchPaths, inherit: key)
    }

    /// MTL Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling Metal. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. `MTL_HEADER_SEARCH_PATHS, -I`
    public static func mtlHeaderSearchPaths(_ value: String...) -> BuildSetting { 
        .mtlHeaderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// MTL Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling Metal. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. `MTL_HEADER_SEARCH_PATHS, -I`
    public static let mtlHeaderSearchPaths: BuildSettingsKey = "MTL_HEADER_SEARCH_PATHS"
}

// MARK: Mtl Header Search Path Built Products Dir
extension BuildSetting {

    /// Mtl Header Search Path Built Products Dir
    public static func mtlHeaderSearchPathBuiltProductsDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlHeaderSearchPathBuiltProductsDir, value: \(value))
    }

    /// Mtl Header Search Path Built Products Dir
    public static func mtlHeaderSearchPathBuiltProductsDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlHeaderSearchPathBuiltProductsDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtl Header Search Path Built Products Dir
    public static let mtlHeaderSearchPathBuiltProductsDir: BuildSettingsKey = "MTL_HEADER_SEARCH_PATH_BUILT_PRODUCTS_DIR"
}

// MARK: Ignore Warnings
extension BuildSetting {

    /// Ignore Warnings
    ///
    /// Enabling this option causes all warnings to be ignored. `MTL_IGNORE_WARNINGS, -W`
    public static var ignoreWarnings: BuildSetting { 
        BuildSetting(key: .ignoreWarnings, value: "NO")
    }

    /// Ignore Warnings
    ///
    /// Enabling this option causes all warnings to be ignored. `MTL_IGNORE_WARNINGS, -W`
    public static func ignoreWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ignoreWarnings, value: value.asText)
    }

    /// Ignore Warnings
    ///
    /// Enabling this option causes all warnings to be ignored. `MTL_IGNORE_WARNINGS, -W`
    public static func ignoreWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ignoreWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ignore Warnings
    ///
    /// Enabling this option causes all warnings to be ignored. `MTL_IGNORE_WARNINGS, -W`
    public static let ignoreWarnings: BuildSettingsKey = "MTL_IGNORE_WARNINGS"
}

// MARK: Mtl Index Store Path
extension BuildSetting {

    /// Mtl Index Store Path
    public static var mtlIndexStorePath: BuildSetting { 
        BuildSetting(key: .mtlIndexStorePath, value: "$(INDEX_DATA_STORE_DIR)")
    }

    /// Mtl Index Store Path
    public static func mtlIndexStorePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlIndexStorePath, value: \(value))
    }

    /// Mtl Index Store Path
    public static func mtlIndexStorePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlIndexStorePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtl Index Store Path
    public static let mtlIndexStorePath: BuildSettingsKey = "MTL_INDEX_STORE_PATH"
}

// MARK: Metal Language Revision
extension BuildSetting {

    /// Metal Language Revision
    ///
    /// Determine the language revision to use. A value for this option must be provided.
    public static var metalLanguageRevision: BuildSetting { 
        BuildSetting(key: .metalLanguageRevision, value: "UseDeploymentTarget")
    }

    /// Metal Language Revision
    ///
    /// Determine the language revision to use. A value for this option must be provided.
    public static func metalLanguageRevision(_ value: MetalLanguageRevision) -> BuildSetting { 
        BuildSetting(key: .metalLanguageRevision, value: \(value))
    }

    /// Metal Language Revision
    ///
    /// Determine the language revision to use. A value for this option must be provided.
    public static func metalLanguageRevision(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .metalLanguageRevision, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Metal Language Revision
    ///
    /// Determine the language revision to use. A value for this option must be provided.
    public static let metalLanguageRevision: BuildSettingsKey = "MTL_LANGUAGE_REVISION"
}

// MARK: Preprocessor Definitions
extension BuildSetting {

    /// Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form “foo” or “foo=bar”.
    public static func preprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorDefinitions, value: .array(value))
    }

    /// Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form “foo” or “foo=bar”.
    public static func preprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorDefinitions, inherit: key)
    }

    /// Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form “foo” or “foo=bar”.
    public static func preprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .preprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form “foo” or “foo=bar”.
    public static let preprocessorDefinitions: BuildSettingsKey = "MTL_PREPROCESSOR_DEFINITIONS"
}

// MARK: Mtl Target Triple
extension BuildSetting {

    /// Mtl Target Triple
    public static var mtlTargetTriple: BuildSetting { 
        BuildSetting(key: .mtlTargetTriple, value: "air64-$(LLVM_TARGET_TRIPLE_VENDOR)-$(LLVM_TARGET_TRIPLE_OS_VERSION)$(LLVM_TARGET_TRIPLE_SUFFIX)")
    }

    /// Mtl Target Triple
    public static func mtlTargetTriple(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlTargetTriple, value: \(value))
    }

    /// Mtl Target Triple
    public static func mtlTargetTriple(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlTargetTriple, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtl Target Triple
    public static let mtlTargetTriple: BuildSettingsKey = "MTL_TARGET_TRIPLE"
}

// MARK: MTL Treat Warnings as Errors
extension BuildSetting {

    /// MTL Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors. `MTL_TREAT_WARNINGS_AS_ERRORS, -Werror`
    public static var mtlTreatWarningsAsErrors: BuildSetting { 
        BuildSetting(key: .mtlTreatWarningsAsErrors, value: "NO")
    }

    /// MTL Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors. `MTL_TREAT_WARNINGS_AS_ERRORS, -Werror`
    public static func mtlTreatWarningsAsErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .mtlTreatWarningsAsErrors, value: value.asText)
    }

    /// MTL Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors. `MTL_TREAT_WARNINGS_AS_ERRORS, -Werror`
    public static func mtlTreatWarningsAsErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlTreatWarningsAsErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTL Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors. `MTL_TREAT_WARNINGS_AS_ERRORS, -Werror`
    public static let mtlTreatWarningsAsErrors: BuildSettingsKey = "MTL_TREAT_WARNINGS_AS_ERRORS"
}

// MARK: Mtllinker Alternate Linker
extension BuildSetting {

    /// Mtllinker Alternate Linker
    public static func mtllinkerAlternateLinker(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtllinkerAlternateLinker, value: \(value))
    }

    /// Mtllinker Alternate Linker
    public static func mtllinkerAlternateLinker(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtllinkerAlternateLinker, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtllinker Alternate Linker
    public static let mtllinkerAlternateLinker: BuildSettingsKey = "MTLLINKER_ALTERNATE_LINKER"
}

// MARK: Other Metal Linker Flags
extension BuildSetting {

    /// Other Metal Linker Flags
    ///
    /// Space-separated list of metal linker flags
    public static func otherMetalLinkerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherMetalLinkerFlags, value: .array(value))
    }

    /// Other Metal Linker Flags
    ///
    /// Space-separated list of metal linker flags
    public static func otherMetalLinkerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherMetalLinkerFlags, inherit: key)
    }

    /// Other Metal Linker Flags
    ///
    /// Space-separated list of metal linker flags
    public static func otherMetalLinkerFlags(_ value: String...) -> BuildSetting { 
        .otherMetalLinkerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Metal Linker Flags
    ///
    /// Space-separated list of metal linker flags
    public static let otherMetalLinkerFlags: BuildSettingsKey = "MTLLINKER_FLAGS"
}

// MARK: Mtllinker Include Source
extension BuildSetting {

    /// Mtllinker Include Source
    public static func mtllinkerIncludeSource(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtllinkerIncludeSource, value: \(value))
    }

    /// Mtllinker Include Source
    public static func mtllinkerIncludeSource(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtllinkerIncludeSource, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtllinker Include Source
    public static let mtllinkerIncludeSource: BuildSettingsKey = "MTLLINKER_INCLUDE_SOURCE"
}

// MARK: Mtllinker Output File
extension BuildSetting {

    /// Mtllinker Output File
    public static var mtllinkerOutputFile: BuildSetting { 
        BuildSetting(key: .mtllinkerOutputFile, value: "$(METAL_LIBRARY_OUTPUT_DIR)/$(METAL_LIBRARY_FILE_BASE).metallib")
    }

    /// Mtllinker Output File
    public static func mtllinkerOutputFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtllinkerOutputFile, value: \(value))
    }

    /// Mtllinker Output File
    public static func mtllinkerOutputFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtllinkerOutputFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtllinker Output File
    public static let mtllinkerOutputFile: BuildSettingsKey = "MTLLINKER_OUTPUT_FILE"
}

// MARK: Mtllinker Target Triple
extension BuildSetting {

    /// Mtllinker Target Triple
    public static var mtllinkerTargetTriple: BuildSetting { 
        BuildSetting(key: .mtllinkerTargetTriple, value: "air64-$(LLVM_TARGET_TRIPLE_VENDOR)-$(LLVM_TARGET_TRIPLE_OS_VERSION)$(LLVM_TARGET_TRIPLE_SUFFIX)")
    }

    /// Mtllinker Target Triple
    public static func mtllinkerTargetTriple(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtllinkerTargetTriple, value: \(value))
    }

    /// Mtllinker Target Triple
    public static func mtllinkerTargetTriple(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtllinkerTargetTriple, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mtllinker Target Triple
    public static let mtllinkerTargetTriple: BuildSettingsKey = "MTLLINKER_TARGET_TRIPLE"
}

// MARK: Openclc
extension BuildSetting {

    /// Openclc
    public static var openclc: BuildSetting { 
        BuildSetting(key: .openclc, value: "/System/Library/Frameworks/OpenCL.framework/Libraries/openclc")
    }

    /// Openclc
    public static func openclc(_ value: String) -> BuildSetting { 
        BuildSetting(key: .openclc, value: \(value))
    }

    /// Openclc
    public static func openclc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Openclc
    public static let openclc: BuildSettingsKey = "OPENCLC"
}

// MARK: OpenCL Architectures
extension BuildSetting {

    /// OpenCL Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform.
    public static var openclArchitectures: BuildSetting { 
        BuildSetting(key: .openclArchitectures, value: "i386 x86_64 gpu_32 gpu_64")
    }

    /// OpenCL Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform.
    public static func openclArchitectures(_ value: OpenCLArchitectures) -> BuildSetting { 
        BuildSetting(key: .openclArchitectures, value: \(value))
    }

    /// OpenCL Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform.
    public static func openclArchitectures(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclArchitectures, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OpenCL Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform.
    public static let openclArchitectures: BuildSettingsKey = "OPENCL_ARCHS"
}

// MARK: Auto-vectorizer
extension BuildSetting {

    /// Auto-vectorizer
    ///
    /// Auto-vectorizes the `OpenCL` kernels for the CPU. This setting takes effect only for the CPU. This makes it possible to write a single kernel that is portable and performant across CPUs and GPUs.
    public static var autoVectorizer: BuildSetting { 
        BuildSetting(key: .autoVectorizer, value: "YES")
    }

    /// Auto-vectorizer
    ///
    /// Auto-vectorizes the `OpenCL` kernels for the CPU. This setting takes effect only for the CPU. This makes it possible to write a single kernel that is portable and performant across CPUs and GPUs.
    public static func autoVectorizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .autoVectorizer, value: value.asText)
    }

    /// Auto-vectorizer
    ///
    /// Auto-vectorizes the `OpenCL` kernels for the CPU. This setting takes effect only for the CPU. This makes it possible to write a single kernel that is portable and performant across CPUs and GPUs.
    public static func autoVectorizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .autoVectorizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Auto-vectorizer
    ///
    /// Auto-vectorizes the `OpenCL` kernels for the CPU. This setting takes effect only for the CPU. This makes it possible to write a single kernel that is portable and performant across CPUs and GPUs.
    public static let autoVectorizer: BuildSettingsKey = "OPENCL_AUTO_VECTORIZE_ENABLE"
}

// MARK: OpenCL Compiler Version
extension BuildSetting {

    /// OpenCL Compiler Version
    ///
    /// The `OpenCL` C compiler version supported by the platform.
    public static var openclCompilerVersion: BuildSetting { 
        .openclCompilerVersion(.cl11) 
    }

    /// OpenCL Compiler Version
    ///
    /// The `OpenCL` C compiler version supported by the platform.
    public static func openclCompilerVersion(_ value: OpenclCompilerVersion) -> BuildSetting { 
        BuildSetting(key: .openclCompilerVersion, value: \(value))
    }

    /// OpenCL Compiler Version
    ///
    /// The `OpenCL` C compiler version supported by the platform.
    public static func openclCompilerVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclCompilerVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OpenCL Compiler Version
    ///
    /// The `OpenCL` C compiler version supported by the platform.
    public static let openclCompilerVersion: BuildSettingsKey = "OPENCL_COMPILER_VERSION"
}

public enum OpenclCompilerVersion: String, Hashable, Codable, CustomStringConvertible {
    case cl12 = "CL1.2"
    case cl11 = "CL1.1"

    public var description: String {
        rawValue
    }
}

// MARK: Flush denorms to zero
extension BuildSetting {

    /// Flush denorms to zero
    ///
    /// This option controls how single precision and double precision denormalized numbers are handled. If specified as a build option, the single precision denormalized numbers may be flushed to zero; double precision denormalized numbers may also be flushed to zero if the optional extension for double precision is supported. This is intended to be a performance hint and the `OpenCL` compiler can choose not to flush denorms to zero if the device supports single precision (or double precision) denormalized numbers. This option is ignored for single precision numbers if the device does not support single precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_SINGLE_FP_CONFIG`. This option is ignored for double precision numbers if the device does not support double precision or if it does support double precision but not double precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_DOUBLE_FP_CONFIG`. This flag only applies for scalar and vector single precision floating-point variables and computations on these floating-point variables inside a program. It does not apply to reading from or writing to image objects.
    public static var flushDenormsToZero: BuildSetting { 
        BuildSetting(key: .flushDenormsToZero, value: "NO")
    }

    /// Flush denorms to zero
    ///
    /// This option controls how single precision and double precision denormalized numbers are handled. If specified as a build option, the single precision denormalized numbers may be flushed to zero; double precision denormalized numbers may also be flushed to zero if the optional extension for double precision is supported. This is intended to be a performance hint and the `OpenCL` compiler can choose not to flush denorms to zero if the device supports single precision (or double precision) denormalized numbers. This option is ignored for single precision numbers if the device does not support single precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_SINGLE_FP_CONFIG`. This option is ignored for double precision numbers if the device does not support double precision or if it does support double precision but not double precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_DOUBLE_FP_CONFIG`. This flag only applies for scalar and vector single precision floating-point variables and computations on these floating-point variables inside a program. It does not apply to reading from or writing to image objects.
    public static func flushDenormsToZero(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .flushDenormsToZero, value: value.asText)
    }

    /// Flush denorms to zero
    ///
    /// This option controls how single precision and double precision denormalized numbers are handled. If specified as a build option, the single precision denormalized numbers may be flushed to zero; double precision denormalized numbers may also be flushed to zero if the optional extension for double precision is supported. This is intended to be a performance hint and the `OpenCL` compiler can choose not to flush denorms to zero if the device supports single precision (or double precision) denormalized numbers. This option is ignored for single precision numbers if the device does not support single precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_SINGLE_FP_CONFIG`. This option is ignored for double precision numbers if the device does not support double precision or if it does support double precision but not double precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_DOUBLE_FP_CONFIG`. This flag only applies for scalar and vector single precision floating-point variables and computations on these floating-point variables inside a program. It does not apply to reading from or writing to image objects.
    public static func flushDenormsToZero(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .flushDenormsToZero, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Flush denorms to zero
    ///
    /// This option controls how single precision and double precision denormalized numbers are handled. If specified as a build option, the single precision denormalized numbers may be flushed to zero; double precision denormalized numbers may also be flushed to zero if the optional extension for double precision is supported. This is intended to be a performance hint and the `OpenCL` compiler can choose not to flush denorms to zero if the device supports single precision (or double precision) denormalized numbers. This option is ignored for single precision numbers if the device does not support single precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_SINGLE_FP_CONFIG`. This option is ignored for double precision numbers if the device does not support double precision or if it does support double precision but not double precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_DOUBLE_FP_CONFIG`. This flag only applies for scalar and vector single precision floating-point variables and computations on these floating-point variables inside a program. It does not apply to reading from or writing to image objects.
    public static let flushDenormsToZero: BuildSettingsKey = "OPENCL_DENORMS_ARE_ZERO"
}

// MARK: Double as single
extension BuildSetting {

    /// Double as single
    ///
    /// Treat double precision floating-point expression as a single precision floating-point expression. This option is available for GPUs only.
    public static var doubleAsSingle: BuildSetting { 
        BuildSetting(key: .doubleAsSingle, value: "NO")
    }

    /// Double as single
    ///
    /// Treat double precision floating-point expression as a single precision floating-point expression. This option is available for GPUs only.
    public static func doubleAsSingle(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .doubleAsSingle, value: value.asText)
    }

    /// Double as single
    ///
    /// Treat double precision floating-point expression as a single precision floating-point expression. This option is available for GPUs only.
    public static func doubleAsSingle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .doubleAsSingle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Double as single
    ///
    /// Treat double precision floating-point expression as a single precision floating-point expression. This option is available for GPUs only.
    public static let doubleAsSingle: BuildSettingsKey = "OPENCL_DOUBLE_AS_SINGLE"
}

// MARK: OpenCL Relax IEEE Compliance
extension BuildSetting {

    /// OpenCL Relax IEEE Compliance
    ///
    /// This allows optimizations for floating-point arithmetic that may violate the IEEE 754 standard and the `OpenCL` numerical compliance requirements defined in in section 7.4 for single-precision floating-point, section 9.3.9 for double-precision floating-point, and edge case behavior in section 7.5 of the `OpenCL` 1.1 specification. This is intended to be a performance optimization. This option causes the preprocessor macro ` **FAST_RELAXED_MATH** ` to be defined in the `OpenCL` program.
    public static var openclRelaxIeeeCompliance: BuildSetting { 
        BuildSetting(key: .openclRelaxIeeeCompliance, value: "NO")
    }

    /// OpenCL Relax IEEE Compliance
    ///
    /// This allows optimizations for floating-point arithmetic that may violate the IEEE 754 standard and the `OpenCL` numerical compliance requirements defined in in section 7.4 for single-precision floating-point, section 9.3.9 for double-precision floating-point, and edge case behavior in section 7.5 of the `OpenCL` 1.1 specification. This is intended to be a performance optimization. This option causes the preprocessor macro ` **FAST_RELAXED_MATH** ` to be defined in the `OpenCL` program.
    public static func openclRelaxIeeeCompliance(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .openclRelaxIeeeCompliance, value: value.asText)
    }

    /// OpenCL Relax IEEE Compliance
    ///
    /// This allows optimizations for floating-point arithmetic that may violate the IEEE 754 standard and the `OpenCL` numerical compliance requirements defined in in section 7.4 for single-precision floating-point, section 9.3.9 for double-precision floating-point, and edge case behavior in section 7.5 of the `OpenCL` 1.1 specification. This is intended to be a performance optimization. This option causes the preprocessor macro ` **FAST_RELAXED_MATH** ` to be defined in the `OpenCL` program.
    public static func openclRelaxIeeeCompliance(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclRelaxIeeeCompliance, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OpenCL Relax IEEE Compliance
    ///
    /// This allows optimizations for floating-point arithmetic that may violate the IEEE 754 standard and the `OpenCL` numerical compliance requirements defined in in section 7.4 for single-precision floating-point, section 9.3.9 for double-precision floating-point, and edge case behavior in section 7.5 of the `OpenCL` 1.1 specification. This is intended to be a performance optimization. This option causes the preprocessor macro ` **FAST_RELAXED_MATH** ` to be defined in the `OpenCL` program.
    public static let openclRelaxIeeeCompliance: BuildSettingsKey = "OPENCL_FAST_RELAXED_MATH"
}

// MARK: Use MAD
extension BuildSetting {

    /// Use MAD
    ///
    /// Allow `a * b + c` to be replaced by a `mad` instruction. The `mad` computes `a * b + c` with reduced accuracy. For example, some `OpenCL` devices implement `mad` as truncate the result of `a * b` before adding it to `c`. This is intended to be a performance optimization.
    public static var useMad: BuildSetting { 
        BuildSetting(key: .useMad, value: "NO")
    }

    /// Use MAD
    ///
    /// Allow `a * b + c` to be replaced by a `mad` instruction. The `mad` computes `a * b + c` with reduced accuracy. For example, some `OpenCL` devices implement `mad` as truncate the result of `a * b` before adding it to `c`. This is intended to be a performance optimization.
    public static func useMad(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useMad, value: value.asText)
    }

    /// Use MAD
    ///
    /// Allow `a * b + c` to be replaced by a `mad` instruction. The `mad` computes `a * b + c` with reduced accuracy. For example, some `OpenCL` devices implement `mad` as truncate the result of `a * b` before adding it to `c`. This is intended to be a performance optimization.
    public static func useMad(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useMad, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use MAD
    ///
    /// Allow `a * b + c` to be replaced by a `mad` instruction. The `mad` computes `a * b + c` with reduced accuracy. For example, some `OpenCL` devices implement `mad` as truncate the result of `a * b` before adding it to `c`. This is intended to be a performance optimization.
    public static let useMad: BuildSettingsKey = "OPENCL_MAD_ENABLE"
}

// MARK: OpenCL Optimization Level
extension BuildSetting {

    /// OpenCL Optimization Level
    public static var openclOptimizationLevel: BuildSetting { 
        .openclOptimizationLevel(.s) 
    }

    /// OpenCL Optimization Level
    public static func openclOptimizationLevel(_ value: OpenclOptimizationLevel) -> BuildSetting { 
        BuildSetting(key: .openclOptimizationLevel, value: \(value))
    }

    /// OpenCL Optimization Level
    public static func openclOptimizationLevel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclOptimizationLevel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OpenCL Optimization Level
    public static let openclOptimizationLevel: BuildSettingsKey = "OPENCL_OPTIMIZATION_LEVEL"
}

public enum OpenclOptimizationLevel: String, Hashable, Codable, CustomStringConvertible {
    case s = "s"
    case _2 = "2"
    case _1 = "1"
    case _0 = "0"
    case _3 = "3"

    public var description: String {
        rawValue
    }
}

// MARK: OpenCL Other Flags
extension BuildSetting {

    /// OpenCL Other Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular compiler flag.
    public static func openclOtherFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .openclOtherFlags, value: .array(value))
    }

    /// OpenCL Other Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular compiler flag.
    public static func openclOtherFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclOtherFlags, inherit: key)
    }

    /// OpenCL Other Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular compiler flag.
    public static func openclOtherFlags(_ value: String...) -> BuildSetting { 
        .openclOtherFlags(value)
    }
}

extension BuildSettingsKey {

    /// OpenCL Other Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular compiler flag.
    public static let openclOtherFlags: BuildSettingsKey = "OPENCL_OTHER_BC_FLAGS"
}

// MARK: OpenCL Preprocessor Macros
extension BuildSetting {

    /// OpenCL Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func openclPreprocessorMacros(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .openclPreprocessorMacros, value: .array(value))
    }

    /// OpenCL Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func openclPreprocessorMacros(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclPreprocessorMacros, inherit: key)
    }

    /// OpenCL Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func openclPreprocessorMacros(_ value: String...) -> BuildSetting { 
        .openclPreprocessorMacros(value)
    }
}

extension BuildSettingsKey {

    /// OpenCL Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static let openclPreprocessorMacros: BuildSettingsKey = "OPENCL_PREPROCESSOR_DEFINITIONS"
}

// MARK: Auto-Activate Custom Fonts
extension BuildSetting {

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the XIB compiler to add custom fonts to the application’s `Info.plist`, which will cause the fonts to activate upon application launch.
    public static var autoActivateCustomFonts: BuildSetting { 
        BuildSetting(key: .autoActivateCustomFonts, value: "YES")
    }

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the XIB compiler to add custom fonts to the application’s `Info.plist`, which will cause the fonts to activate upon application launch.
    public static func autoActivateCustomFonts(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .autoActivateCustomFonts, value: value.asText)
    }

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the XIB compiler to add custom fonts to the application’s `Info.plist`, which will cause the fonts to activate upon application launch.
    public static func autoActivateCustomFonts(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .autoActivateCustomFonts, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the XIB compiler to add custom fonts to the application’s `Info.plist`, which will cause the fonts to activate upon application launch.
    public static let autoActivateCustomFonts: BuildSettingsKey = "IBC_COMPILER_AUTO_ACTIVATE_CUSTOM_FONTS"
}

// MARK: Ibc Compiler Use Nibarchives For Macos
extension BuildSetting {

    /// Ibc Compiler Use Nibarchives For Macos
    public static func ibcCompilerUseNibarchivesForMacos(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ibcCompilerUseNibarchivesForMacos, value: \(value))
    }

    /// Ibc Compiler Use Nibarchives For Macos
    public static func ibcCompilerUseNibarchivesForMacos(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibcCompilerUseNibarchivesForMacos, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ibc Compiler Use Nibarchives For Macos
    public static let ibcCompilerUseNibarchivesForMacos: BuildSettingsKey = "IBC_COMPILER_USE_NIBARCHIVES_FOR_MACOS"
}

// MARK: Show Errors
extension BuildSetting {

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of XIB files.
    public static var showErrors: BuildSetting { 
        BuildSetting(key: .showErrors, value: "YES")
    }

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of XIB files.
    public static func showErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showErrors, value: value.asText)
    }

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of XIB files.
    public static func showErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of XIB files.
    public static let showErrors: BuildSettingsKey = "IBC_ERRORS"
}

// MARK: Flatten Compiled XIB Files
extension BuildSetting {

    /// Flatten Compiled XIB Files
    ///
    /// If enabled, compile XIB files into flattened (non-wrapper) NIB files. After flattening, the resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable in Interface Builder.
    public static var flattenCompiledXibFiles: BuildSetting { 
        BuildSetting(key: .flattenCompiledXibFiles, value: "YES")
    }

    /// Flatten Compiled XIB Files
    ///
    /// If enabled, compile XIB files into flattened (non-wrapper) NIB files. After flattening, the resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable in Interface Builder.
    public static func flattenCompiledXibFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .flattenCompiledXibFiles, value: value.asText)
    }

    /// Flatten Compiled XIB Files
    ///
    /// If enabled, compile XIB files into flattened (non-wrapper) NIB files. After flattening, the resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable in Interface Builder.
    public static func flattenCompiledXibFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .flattenCompiledXibFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Flatten Compiled XIB Files
    ///
    /// If enabled, compile XIB files into flattened (non-wrapper) NIB files. After flattening, the resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable in Interface Builder.
    public static let flattenCompiledXibFiles: BuildSettingsKey = "IBC_FLATTEN_NIBS"
}

// MARK: Default Module
extension BuildSetting {

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static var defaultModule: BuildSetting { 
        .defaultModule(inherit: .productModuleName) 
    }

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static func defaultModule(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultModule, value: \(value))
    }

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static func defaultModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static let defaultModule: BuildSettingsKey = "IBC_MODULE"
}

// MARK: Show Notices
extension BuildSetting {

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of XIB files.
    public static var showNotices: BuildSetting { 
        BuildSetting(key: .showNotices, value: "YES")
    }

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of XIB files.
    public static func showNotices(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showNotices, value: value.asText)
    }

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of XIB files.
    public static func showNotices(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showNotices, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of XIB files.
    public static let showNotices: BuildSettingsKey = "IBC_NOTICES"
}

// MARK: Other Interface Builder Compiler Flags
extension BuildSetting {

    /// Other Interface Builder Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherInterfaceBuilderCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherInterfaceBuilderCompilerFlags, value: .array(value))
    }

    /// Other Interface Builder Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherInterfaceBuilderCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherInterfaceBuilderCompilerFlags, inherit: key)
    }

    /// Other Interface Builder Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherInterfaceBuilderCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherInterfaceBuilderCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Interface Builder Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static let otherInterfaceBuilderCompilerFlags: BuildSettingsKey = "IBC_OTHER_FLAGS"
}

// MARK: Overriding Plug-In and Framework Directory
extension BuildSetting {

    /// Overriding Plug-In and Framework Directory
    ///
    /// Instructs Interface Builder to load frameworks and Interface Builder plugins from the specified directory. Setting this value to `$(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)` will ensure that Interface Builder will load frameworks and plug-ins from the built products directory of the current build configuration.
    public static func overridingPlugInAndFrameworkDirectory(_ value: String) -> BuildSetting { 
        BuildSetting(key: .overridingPlugInAndFrameworkDirectory, value: \(value))
    }

    /// Overriding Plug-In and Framework Directory
    ///
    /// Instructs Interface Builder to load frameworks and Interface Builder plugins from the specified directory. Setting this value to `$(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)` will ensure that Interface Builder will load frameworks and plug-ins from the built products directory of the current build configuration.
    public static func overridingPlugInAndFrameworkDirectory(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .overridingPlugInAndFrameworkDirectory, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Overriding Plug-In and Framework Directory
    ///
    /// Instructs Interface Builder to load frameworks and Interface Builder plugins from the specified directory. Setting this value to `$(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)` will ensure that Interface Builder will load frameworks and plug-ins from the built products directory of the current build configuration.
    public static let overridingPlugInAndFrameworkDirectory: BuildSettingsKey = "IBC_OVERRIDING_PLUGINS_AND_FRAMEWORKS_DIR"
}

// MARK: Plug-Ins
extension BuildSetting {

    /// Plug-Ins
    ///
    /// A list of paths to Interface Builder plugins to load when compiling XIB files.
    public static func plugIns(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .plugIns, value: .array(value))
    }

    /// Plug-Ins
    ///
    /// A list of paths to Interface Builder plugins to load when compiling XIB files.
    public static func plugIns(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .plugIns, inherit: key)
    }

    /// Plug-Ins
    ///
    /// A list of paths to Interface Builder plugins to load when compiling XIB files.
    public static func plugIns(_ value: String...) -> BuildSetting { 
        .plugIns(value)
    }
}

extension BuildSettingsKey {

    /// Plug-Ins
    ///
    /// A list of paths to Interface Builder plugins to load when compiling XIB files.
    public static let plugIns: BuildSettingsKey = "IBC_PLUGINS"
}

// MARK: Plug-In Search Paths
extension BuildSetting {

    /// Plug-In Search Paths
    ///
    /// A list of paths to be searched for Interface Builder plug-ins to load when compiling XIB files.
    public static func plugInSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .plugInSearchPaths, value: .array(value))
    }

    /// Plug-In Search Paths
    ///
    /// A list of paths to be searched for Interface Builder plug-ins to load when compiling XIB files.
    public static func plugInSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .plugInSearchPaths, inherit: key)
    }

    /// Plug-In Search Paths
    ///
    /// A list of paths to be searched for Interface Builder plug-ins to load when compiling XIB files.
    public static func plugInSearchPaths(_ value: String...) -> BuildSetting { 
        .plugInSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Plug-In Search Paths
    ///
    /// A list of paths to be searched for Interface Builder plug-ins to load when compiling XIB files.
    public static let plugInSearchPaths: BuildSettingsKey = "IBC_PLUGIN_SEARCH_PATHS"
}

// MARK: Ibc Regions And Strings Files
extension BuildSetting {

    /// Ibc Regions And Strings Files
    public static func ibcRegionsAndStringsFiles(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ibcRegionsAndStringsFiles, value: .array(value))
    }

    /// Ibc Regions And Strings Files
    public static func ibcRegionsAndStringsFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibcRegionsAndStringsFiles, inherit: key)
    }

    /// Ibc Regions And Strings Files
    public static func ibcRegionsAndStringsFiles(_ value: String...) -> BuildSetting { 
        .ibcRegionsAndStringsFiles(value)
    }
}

extension BuildSettingsKey {

    /// Ibc Regions And Strings Files
    public static let ibcRegionsAndStringsFiles: BuildSettingsKey = "IBC_REGIONS_AND_STRINGS_FILES"
}

// MARK: Show Warnings
extension BuildSetting {

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of XIB files.
    public static var showWarnings: BuildSetting { 
        BuildSetting(key: .showWarnings, value: "YES")
    }

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of XIB files.
    public static func showWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showWarnings, value: value.asText)
    }

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of XIB files.
    public static func showWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of XIB files.
    public static let showWarnings: BuildSettingsKey = "IBC_WARNINGS"
}

// MARK: Resources Platform Name
extension BuildSetting {

    /// Resources Platform Name
    public static func resourcesPlatformName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .resourcesPlatformName, value: \(value))
    }

    /// Resources Platform Name
    public static func resourcesPlatformName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resourcesPlatformName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Resources Platform Name
    public static let resourcesPlatformName: BuildSettingsKey = "RESOURCES_PLATFORM_NAME"
}

// MARK: Xib Compiler Infoplist Content File
extension BuildSetting {

    /// Xib Compiler Infoplist Content File
    public static var xibCompilerInfoplistContentFile: BuildSetting { 
        BuildSetting(key: .xibCompilerInfoplistContentFile, value: "$(TARGET_TEMP_DIR)/$(InputFileRegionPathComponent)$(InputFileBase)-PartialInfo.plist")
    }

    /// Xib Compiler Infoplist Content File
    public static func xibCompilerInfoplistContentFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .xibCompilerInfoplistContentFile, value: \(value))
    }

    /// Xib Compiler Infoplist Content File
    public static func xibCompilerInfoplistContentFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .xibCompilerInfoplistContentFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Xib Compiler Infoplist Content File
    public static let xibCompilerInfoplistContentFile: BuildSettingsKey = "XIB_COMPILER_INFOPLIST_CONTENT_FILE"
}

// MARK: Strip NIB Files
extension BuildSetting {

    /// Strip NIB Files
    ///
    /// Strips an Interface Builder NIB to reduce its size for deployment. The resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable by Interface Builder.
    public static var stripNibFiles: BuildSetting { 
        .stripNibFiles(inherit: .flattenCompiledXibFiles) 
    }

    /// Strip NIB Files
    ///
    /// Strips an Interface Builder NIB to reduce its size for deployment. The resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable by Interface Builder.
    public static func stripNibFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripNibFiles, value: value.asText)
    }

    /// Strip NIB Files
    ///
    /// Strips an Interface Builder NIB to reduce its size for deployment. The resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable by Interface Builder.
    public static func stripNibFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripNibFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip NIB Files
    ///
    /// Strips an Interface Builder NIB to reduce its size for deployment. The resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable by Interface Builder.
    public static let stripNibFiles: BuildSettingsKey = "IBC_STRIP_NIBS"
}

// MARK: IBSC Auto-Activate Custom Fonts
extension BuildSetting {

    /// IBSC Auto-Activate Custom Fonts
    ///
    /// Instructs the Storyboard compiler to add custom fonts to the application’s `Info.plist` that will cause the fonts to activate upon application launch.
    public static var ibscAutoActivateCustomFonts: BuildSetting { 
        BuildSetting(key: .ibscAutoActivateCustomFonts, value: "YES")
    }

    /// IBSC Auto-Activate Custom Fonts
    ///
    /// Instructs the Storyboard compiler to add custom fonts to the application’s `Info.plist` that will cause the fonts to activate upon application launch.
    public static func ibscAutoActivateCustomFonts(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ibscAutoActivateCustomFonts, value: value.asText)
    }

    /// IBSC Auto-Activate Custom Fonts
    ///
    /// Instructs the Storyboard compiler to add custom fonts to the application’s `Info.plist` that will cause the fonts to activate upon application launch.
    public static func ibscAutoActivateCustomFonts(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibscAutoActivateCustomFonts, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IBSC Auto-Activate Custom Fonts
    ///
    /// Instructs the Storyboard compiler to add custom fonts to the application’s `Info.plist` that will cause the fonts to activate upon application launch.
    public static let ibscAutoActivateCustomFonts: BuildSettingsKey = "IBSC_COMPILER_AUTO_ACTIVATE_CUSTOM_FONTS"
}

// MARK: Ibsc Compiler Use Nibarchives For Macos
extension BuildSetting {

    /// Ibsc Compiler Use Nibarchives For Macos
    public static func ibscCompilerUseNibarchivesForMacos(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ibscCompilerUseNibarchivesForMacos, value: \(value))
    }

    /// Ibsc Compiler Use Nibarchives For Macos
    public static func ibscCompilerUseNibarchivesForMacos(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibscCompilerUseNibarchivesForMacos, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ibsc Compiler Use Nibarchives For Macos
    public static let ibscCompilerUseNibarchivesForMacos: BuildSettingsKey = "IBSC_COMPILER_USE_NIBARCHIVES_FOR_MACOS"
}

// MARK: IBSC Show Errors
extension BuildSetting {

    /// IBSC Show Errors
    ///
    /// Show errors encountered during the compilation of Storyboard files.
    public static var ibscShowErrors: BuildSetting { 
        BuildSetting(key: .ibscShowErrors, value: "YES")
    }

    /// IBSC Show Errors
    ///
    /// Show errors encountered during the compilation of Storyboard files.
    public static func ibscShowErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ibscShowErrors, value: value.asText)
    }

    /// IBSC Show Errors
    ///
    /// Show errors encountered during the compilation of Storyboard files.
    public static func ibscShowErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibscShowErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IBSC Show Errors
    ///
    /// Show errors encountered during the compilation of Storyboard files.
    public static let ibscShowErrors: BuildSettingsKey = "IBSC_ERRORS"
}

// MARK: Flatten Compiled Storyboard Files
extension BuildSetting {

    /// Flatten Compiled Storyboard Files
    ///
    /// Compiles a Storyboard file into flattened (non-wrapper) Storyboard file. After flattening, the resulting Storyboard is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting Storyboard file remains editable in Interface Builder.
    public static var flattenCompiledStoryboardFiles: BuildSetting { 
        BuildSetting(key: .flattenCompiledStoryboardFiles, value: "YES")
    }

    /// Flatten Compiled Storyboard Files
    ///
    /// Compiles a Storyboard file into flattened (non-wrapper) Storyboard file. After flattening, the resulting Storyboard is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting Storyboard file remains editable in Interface Builder.
    public static func flattenCompiledStoryboardFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .flattenCompiledStoryboardFiles, value: value.asText)
    }

    /// Flatten Compiled Storyboard Files
    ///
    /// Compiles a Storyboard file into flattened (non-wrapper) Storyboard file. After flattening, the resulting Storyboard is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting Storyboard file remains editable in Interface Builder.
    public static func flattenCompiledStoryboardFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .flattenCompiledStoryboardFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Flatten Compiled Storyboard Files
    ///
    /// Compiles a Storyboard file into flattened (non-wrapper) Storyboard file. After flattening, the resulting Storyboard is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting Storyboard file remains editable in Interface Builder.
    public static let flattenCompiledStoryboardFiles: BuildSettingsKey = "IBSC_FLATTEN_NIBS"
}

// MARK: IBSC Default Module
extension BuildSetting {

    /// IBSC Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static var ibscDefaultModule: BuildSetting { 
        .ibscDefaultModule(inherit: .productModuleName) 
    }

    /// IBSC Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static func ibscDefaultModule(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ibscDefaultModule, value: \(value))
    }

    /// IBSC Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static func ibscDefaultModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibscDefaultModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IBSC Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static let ibscDefaultModule: BuildSettingsKey = "IBSC_MODULE"
}

// MARK: IBSC Show Notices
extension BuildSetting {

    /// IBSC Show Notices
    ///
    /// Show notices encountered during the compilation of Storyboard files.
    public static var ibscShowNotices: BuildSetting { 
        BuildSetting(key: .ibscShowNotices, value: "YES")
    }

    /// IBSC Show Notices
    ///
    /// Show notices encountered during the compilation of Storyboard files.
    public static func ibscShowNotices(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ibscShowNotices, value: value.asText)
    }

    /// IBSC Show Notices
    ///
    /// Show notices encountered during the compilation of Storyboard files.
    public static func ibscShowNotices(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibscShowNotices, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IBSC Show Notices
    ///
    /// Show notices encountered during the compilation of Storyboard files.
    public static let ibscShowNotices: BuildSettingsKey = "IBSC_NOTICES"
}

// MARK: Other Storyboard Compiler Flags
extension BuildSetting {

    /// Other Storyboard Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherStoryboardCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherStoryboardCompilerFlags, value: .array(value))
    }

    /// Other Storyboard Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherStoryboardCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherStoryboardCompilerFlags, inherit: key)
    }

    /// Other Storyboard Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherStoryboardCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherStoryboardCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Storyboard Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static let otherStoryboardCompilerFlags: BuildSettingsKey = "IBSC_OTHER_FLAGS"
}

// MARK: Ibsc Regions And Strings Files
extension BuildSetting {

    /// Ibsc Regions And Strings Files
    public static var ibscRegionsAndStringsFiles: BuildSetting { 
        .ibscRegionsAndStringsFiles(inherit: .ibcRegionsAndStringsFiles) 
    }

    /// Ibsc Regions And Strings Files
    public static func ibscRegionsAndStringsFiles(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ibscRegionsAndStringsFiles, value: .array(value))
    }

    /// Ibsc Regions And Strings Files
    public static func ibscRegionsAndStringsFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibscRegionsAndStringsFiles, inherit: key)
    }

    /// Ibsc Regions And Strings Files
    public static func ibscRegionsAndStringsFiles(_ value: String...) -> BuildSetting { 
        .ibscRegionsAndStringsFiles(value)
    }
}

extension BuildSettingsKey {

    /// Ibsc Regions And Strings Files
    public static let ibscRegionsAndStringsFiles: BuildSettingsKey = "IBSC_REGIONS_AND_STRINGS_FILES"
}

// MARK: IBSC Show Warnings
extension BuildSetting {

    /// IBSC Show Warnings
    ///
    /// Show warnings encountered during the compilation of Storyboard files.
    public static var ibscShowWarnings: BuildSetting { 
        BuildSetting(key: .ibscShowWarnings, value: "YES")
    }

    /// IBSC Show Warnings
    ///
    /// Show warnings encountered during the compilation of Storyboard files.
    public static func ibscShowWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ibscShowWarnings, value: value.asText)
    }

    /// IBSC Show Warnings
    ///
    /// Show warnings encountered during the compilation of Storyboard files.
    public static func ibscShowWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibscShowWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IBSC Show Warnings
    ///
    /// Show warnings encountered during the compilation of Storyboard files.
    public static let ibscShowWarnings: BuildSettingsKey = "IBSC_WARNINGS"
}

// MARK: Storyboard Compiler Infoplist Content File
extension BuildSetting {

    /// Storyboard Compiler Infoplist Content File
    public static var storyboardCompilerInfoplistContentFile: BuildSetting { 
        BuildSetting(key: .storyboardCompilerInfoplistContentFile, value: "$(TARGET_TEMP_DIR)/$(InputFileRegionPathComponent)$(InputFileBase)-SBPartialInfo.plist")
    }

    /// Storyboard Compiler Infoplist Content File
    public static func storyboardCompilerInfoplistContentFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .storyboardCompilerInfoplistContentFile, value: \(value))
    }

    /// Storyboard Compiler Infoplist Content File
    public static func storyboardCompilerInfoplistContentFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .storyboardCompilerInfoplistContentFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Storyboard Compiler Infoplist Content File
    public static let storyboardCompilerInfoplistContentFile: BuildSettingsKey = "STORYBOARD_COMPILER_INFOPLIST_CONTENT_FILE"
}

// MARK: Strip Storyboardc Files
extension BuildSetting {

    /// Strip Storyboardc Files
    ///
    /// Strips an editable Interface Builder storyboardc file to reduce its size for deployment. The resulting storyboardc is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting storyboardc file remains editable by Interface Builder.
    public static var stripStoryboardcFiles: BuildSetting { 
        .stripStoryboardcFiles(inherit: .flattenCompiledStoryboardFiles) 
    }

    /// Strip Storyboardc Files
    ///
    /// Strips an editable Interface Builder storyboardc file to reduce its size for deployment. The resulting storyboardc is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting storyboardc file remains editable by Interface Builder.
    public static func stripStoryboardcFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripStoryboardcFiles, value: value.asText)
    }

    /// Strip Storyboardc Files
    ///
    /// Strips an editable Interface Builder storyboardc file to reduce its size for deployment. The resulting storyboardc is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting storyboardc file remains editable by Interface Builder.
    public static func stripStoryboardcFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripStoryboardcFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Storyboardc Files
    ///
    /// Strips an editable Interface Builder storyboardc file to reduce its size for deployment. The resulting storyboardc is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting storyboardc file remains editable by Interface Builder.
    public static let stripStoryboardcFiles: BuildSettingsKey = "IBSC_STRIP_NIBS"
}

// MARK: Asset Catalog App Icon Set Name
extension BuildSetting {

    /// Asset Catalog App Icon Set Name
    ///
    /// Name of an asset catalog app icon set whose contents will be merged into the `Info.plist`.
    public static func assetCatalogAppIconSetName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetCatalogAppIconSetName, value: \(value))
    }

    /// Asset Catalog App Icon Set Name
    ///
    /// Name of an asset catalog app icon set whose contents will be merged into the `Info.plist`.
    public static func assetCatalogAppIconSetName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetCatalogAppIconSetName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Asset Catalog App Icon Set Name
    ///
    /// Name of an asset catalog app icon set whose contents will be merged into the `Info.plist`.
    public static let assetCatalogAppIconSetName: BuildSettingsKey = "ASSETCATALOG_COMPILER_APPICON_NAME"
}

// MARK: Assetcatalog Compiler Compress Pngs
extension BuildSetting {

    /// Assetcatalog Compiler Compress Pngs
    public static var assetcatalogCompilerCompressPngs: BuildSetting { 
        .assetcatalogCompilerCompressPngs(inherit: .compressPngFiles) 
    }

    /// Assetcatalog Compiler Compress Pngs
    public static func assetcatalogCompilerCompressPngs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerCompressPngs, value: value.asText)
    }

    /// Assetcatalog Compiler Compress Pngs
    public static func assetcatalogCompilerCompressPngs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerCompressPngs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Assetcatalog Compiler Compress Pngs
    public static let assetcatalogCompilerCompressPngs: BuildSettingsKey = "ASSETCATALOG_COMPILER_COMPRESS_PNGS"
}

// MARK: Assetcatalog Compiler Dependency Info File
extension BuildSetting {

    /// Assetcatalog Compiler Dependency Info File
    public static var assetcatalogCompilerDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerDependencyInfoFile, value: "$(TARGET_TEMP_DIR)/assetcatalog_dependencies")
    }

    /// Assetcatalog Compiler Dependency Info File
    public static func assetcatalogCompilerDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerDependencyInfoFile, value: \(value))
    }

    /// Assetcatalog Compiler Dependency Info File
    public static func assetcatalogCompilerDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Assetcatalog Compiler Dependency Info File
    public static let assetcatalogCompilerDependencyInfoFile: BuildSettingsKey = "ASSETCATALOG_COMPILER_DEPENDENCY_INFO_FILE"
}

// MARK: Assetcatalog Compiler Enable On Demand Resources
extension BuildSetting {

    /// Assetcatalog Compiler Enable On Demand Resources
    public static var assetcatalogCompilerEnableOnDemandResources: BuildSetting { 
        .assetcatalogCompilerEnableOnDemandResources(inherit: .enableOnDemandResources) 
    }

    /// Assetcatalog Compiler Enable On Demand Resources
    public static func assetcatalogCompilerEnableOnDemandResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerEnableOnDemandResources, value: value.asText)
    }

    /// Assetcatalog Compiler Enable On Demand Resources
    public static func assetcatalogCompilerEnableOnDemandResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerEnableOnDemandResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Assetcatalog Compiler Enable On Demand Resources
    public static let assetcatalogCompilerEnableOnDemandResources: BuildSettingsKey = "ASSETCATALOG_COMPILER_ENABLE_ON_DEMAND_RESOURCES"
}

// MARK: Global Accent Color Name
extension BuildSetting {

    /// Global Accent Color Name
    ///
    /// The name of a color resource to use as a the target’s accent color, used as the default tint color on iOS and watchOS, and accent color on macOS.
    public static func globalAccentColorName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .globalAccentColorName, value: \(value))
    }

    /// Global Accent Color Name
    ///
    /// The name of a color resource to use as a the target’s accent color, used as the default tint color on iOS and watchOS, and accent color on macOS.
    public static func globalAccentColorName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .globalAccentColorName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Global Accent Color Name
    ///
    /// The name of a color resource to use as a the target’s accent color, used as the default tint color on iOS and watchOS, and accent color on macOS.
    public static let globalAccentColorName: BuildSettingsKey = "ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME"
}

// MARK: Include Asset Localizations in Info.plist
extension BuildSetting {

    /// Include Asset Localizations in Info.plist
    ///
    /// When enabled, includes the localization information of the selected assets in the generated partial Info.plist file under the CFBundleLocalizations key. This will allow the assets to be used at runtime in the absence of a corresponding lproj directory in the bundle.
    public static var includeAssetLocalizationsInInfoPlist: BuildSetting { 
        BuildSetting(key: .includeAssetLocalizationsInInfoPlist, value: "YES")
    }

    /// Include Asset Localizations in Info.plist
    ///
    /// When enabled, includes the localization information of the selected assets in the generated partial Info.plist file under the CFBundleLocalizations key. This will allow the assets to be used at runtime in the absence of a corresponding lproj directory in the bundle.
    public static func includeAssetLocalizationsInInfoPlist(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .includeAssetLocalizationsInInfoPlist, value: value.asText)
    }

    /// Include Asset Localizations in Info.plist
    ///
    /// When enabled, includes the localization information of the selected assets in the generated partial Info.plist file under the CFBundleLocalizations key. This will allow the assets to be used at runtime in the absence of a corresponding lproj directory in the bundle.
    public static func includeAssetLocalizationsInInfoPlist(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .includeAssetLocalizationsInInfoPlist, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Include Asset Localizations in Info.plist
    ///
    /// When enabled, includes the localization information of the selected assets in the generated partial Info.plist file under the CFBundleLocalizations key. This will allow the assets to be used at runtime in the absence of a corresponding lproj directory in the bundle.
    public static let includeAssetLocalizationsInInfoPlist: BuildSettingsKey = "ASSETCATALOG_COMPILER_INCLUDE_INFOPLIST_LOCALIZATIONS"
}

// MARK: Include Sticker Content
extension BuildSetting {

    /// Include Sticker Content
    public static var includeStickerContent: BuildSetting { 
        BuildSetting(key: .includeStickerContent, value: "NO")
    }

    /// Include Sticker Content
    public static func includeStickerContent(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .includeStickerContent, value: value.asText)
    }

    /// Include Sticker Content
    public static func includeStickerContent(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .includeStickerContent, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Include Sticker Content
    public static let includeStickerContent: BuildSettingsKey = "ASSETCATALOG_COMPILER_INCLUDE_STICKER_CONTENT"
}

// MARK: Assetcatalog Compiler Infoplist Content File
extension BuildSetting {

    /// Assetcatalog Compiler Infoplist Content File
    public static var assetcatalogCompilerInfoplistContentFile: BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerInfoplistContentFile, value: "$(TARGET_TEMP_DIR)/assetcatalog_generated_info.plist")
    }

    /// Assetcatalog Compiler Infoplist Content File
    public static func assetcatalogCompilerInfoplistContentFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerInfoplistContentFile, value: \(value))
    }

    /// Assetcatalog Compiler Infoplist Content File
    public static func assetcatalogCompilerInfoplistContentFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerInfoplistContentFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Assetcatalog Compiler Infoplist Content File
    public static let assetcatalogCompilerInfoplistContentFile: BuildSettingsKey = "ASSETCATALOG_COMPILER_INFOPLIST_CONTENT_FILE"
}

// MARK: Asset Catalog Launch Image Set Name
extension BuildSetting {

    /// Asset Catalog Launch Image Set Name
    ///
    /// Name of an asset catalog launch image set whose contents will be merged into the `Info.plist`.
    public static func assetCatalogLaunchImageSetName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetCatalogLaunchImageSetName, value: \(value))
    }

    /// Asset Catalog Launch Image Set Name
    ///
    /// Name of an asset catalog launch image set whose contents will be merged into the `Info.plist`.
    public static func assetCatalogLaunchImageSetName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetCatalogLaunchImageSetName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Asset Catalog Launch Image Set Name
    ///
    /// Name of an asset catalog launch image set whose contents will be merged into the `Info.plist`.
    public static let assetCatalogLaunchImageSetName: BuildSettingsKey = "ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME"
}

// MARK: Optimization
extension BuildSetting {

    /// Optimization
    ///
    /// With no value, the compiler uses the default optimization. You can also specify `time` to optimize for speed of access or `space` to optimize for a smaller compiled asset catalogs.
    public static func optimization(_ value: Optimization) -> BuildSetting { 
        BuildSetting(key: .optimization, value: \(value))
    }

    /// Optimization
    ///
    /// With no value, the compiler uses the default optimization. You can also specify `time` to optimize for speed of access or `space` to optimize for a smaller compiled asset catalogs.
    public static func optimization(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimization, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Optimization
    ///
    /// With no value, the compiler uses the default optimization. You can also specify `time` to optimize for speed of access or `space` to optimize for a smaller compiled asset catalogs.
    public static let optimization: BuildSettingsKey = "ASSETCATALOG_COMPILER_OPTIMIZATION"
}

public enum Optimization: String, Hashable, Codable, CustomStringConvertible {
    case space = "space"
    case time = "time"

    public var description: String {
        rawValue
    }
}

// MARK: Standalone Icon File Behavior
extension BuildSetting {

    /// Standalone Icon File Behavior
    ///
    /// Controls whether loose PNG or ICNS files are created for the app icon, in addition to including the content in the Assets.car file. By default, a small subset of sizes are included as loose files, allowing external management tools to display a representative icon without reading the CAR file. This can be set to ‘all’ or ‘none’ to include more or fewer icon sizes as loose files.
    public static var standaloneIconFileBehavior: BuildSetting { 
        .standaloneIconFileBehavior(.default) 
    }

    /// Standalone Icon File Behavior
    ///
    /// Controls whether loose PNG or ICNS files are created for the app icon, in addition to including the content in the Assets.car file. By default, a small subset of sizes are included as loose files, allowing external management tools to display a representative icon without reading the CAR file. This can be set to ‘all’ or ‘none’ to include more or fewer icon sizes as loose files.
    public static func standaloneIconFileBehavior(_ value: StandaloneIconFileBehavior) -> BuildSetting { 
        BuildSetting(key: .standaloneIconFileBehavior, value: \(value))
    }

    /// Standalone Icon File Behavior
    ///
    /// Controls whether loose PNG or ICNS files are created for the app icon, in addition to including the content in the Assets.car file. By default, a small subset of sizes are included as loose files, allowing external management tools to display a representative icon without reading the CAR file. This can be set to ‘all’ or ‘none’ to include more or fewer icon sizes as loose files.
    public static func standaloneIconFileBehavior(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .standaloneIconFileBehavior, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Standalone Icon File Behavior
    ///
    /// Controls whether loose PNG or ICNS files are created for the app icon, in addition to including the content in the Assets.car file. By default, a small subset of sizes are included as loose files, allowing external management tools to display a representative icon without reading the CAR file. This can be set to ‘all’ or ‘none’ to include more or fewer icon sizes as loose files.
    public static let standaloneIconFileBehavior: BuildSettingsKey = "ASSETCATALOG_COMPILER_STANDALONE_ICON_BEHAVIOR"
}

public enum StandaloneIconFileBehavior: String, Hashable, Codable, CustomStringConvertible {
    case all = "all"
    case none = "none"
    case `default` = "default"

    public var description: String {
        rawValue
    }
}

// MARK: Sticker Pack Identifier Prefix
extension BuildSetting {

    /// Sticker Pack Identifier Prefix
    ///
    /// Sticker Packs in the asset catalog may optionally specify an identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static func stickerPackIdentifierPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .stickerPackIdentifierPrefix, value: \(value))
    }

    /// Sticker Pack Identifier Prefix
    ///
    /// Sticker Packs in the asset catalog may optionally specify an identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static func stickerPackIdentifierPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stickerPackIdentifierPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Sticker Pack Identifier Prefix
    ///
    /// Sticker Packs in the asset catalog may optionally specify an identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static let stickerPackIdentifierPrefix: BuildSettingsKey = "ASSETCATALOG_COMPILER_STICKER_PACK_IDENTIFIER_PREFIX"
}

// MARK: Assetcatalog Compiler Sticker Pack Strings
extension BuildSetting {

    /// Assetcatalog Compiler Sticker Pack Strings
    public static func assetcatalogCompilerStickerPackStrings(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerStickerPackStrings, value: .array(value))
    }

    /// Assetcatalog Compiler Sticker Pack Strings
    public static func assetcatalogCompilerStickerPackStrings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerStickerPackStrings, inherit: key)
    }

    /// Assetcatalog Compiler Sticker Pack Strings
    public static func assetcatalogCompilerStickerPackStrings(_ value: String...) -> BuildSetting { 
        .assetcatalogCompilerStickerPackStrings(value)
    }
}

extension BuildSettingsKey {

    /// Assetcatalog Compiler Sticker Pack Strings
    public static let assetcatalogCompilerStickerPackStrings: BuildSettingsKey = "ASSETCATALOG_COMPILER_STICKER_PACK_STRINGS"
}

// MARK: Stickers Icon Role
extension BuildSetting {

    /// Stickers Icon Role
    public static func stickersIconRole(_ value: StickersIconRole) -> BuildSetting { 
        BuildSetting(key: .stickersIconRole, value: \(value))
    }

    /// Stickers Icon Role
    public static func stickersIconRole(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stickersIconRole, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Stickers Icon Role
    public static let stickersIconRole: BuildSettingsKey = "ASSETCATALOG_COMPILER_TARGET_STICKERS_ICON_ROLE"
}

public enum StickersIconRole: String, Hashable, Codable, CustomStringConvertible {
    case `extension` = "extension"
    case _0 = ""
    case hostApp = "host-app"

    public var description: String {
        rawValue
    }
}

// MARK: Widget Background Color Name
extension BuildSetting {

    /// Widget Background Color Name
    ///
    /// The name of a color resource to use as the background color for a widget.
    public static func widgetBackgroundColorName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .widgetBackgroundColorName, value: \(value))
    }

    /// Widget Background Color Name
    ///
    /// The name of a color resource to use as the background color for a widget.
    public static func widgetBackgroundColorName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .widgetBackgroundColorName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Widget Background Color Name
    ///
    /// The name of a color resource to use as the background color for a widget.
    public static let widgetBackgroundColorName: BuildSettingsKey = "ASSETCATALOG_COMPILER_WIDGET_BACKGROUND_COLOR_NAME"
}

// MARK: Assetcatalog Filter For Device Model
extension BuildSetting {

    /// Assetcatalog Filter For Device Model
    public static var assetcatalogFilterForDeviceModel: BuildSetting { 
        BuildSetting(key: .assetcatalogFilterForDeviceModel, value: "$(TARGET_DEVICE_MODEL)")
    }

    /// Assetcatalog Filter For Device Model
    public static func assetcatalogFilterForDeviceModel(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetcatalogFilterForDeviceModel, value: \(value))
    }

    /// Assetcatalog Filter For Device Model
    public static func assetcatalogFilterForDeviceModel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogFilterForDeviceModel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Assetcatalog Filter For Device Model
    public static let assetcatalogFilterForDeviceModel: BuildSettingsKey = "ASSETCATALOG_FILTER_FOR_DEVICE_MODEL"
}

// MARK: Assetcatalog Filter For Device Os Version
extension BuildSetting {

    /// Assetcatalog Filter For Device Os Version
    public static var assetcatalogFilterForDeviceOsVersion: BuildSetting { 
        BuildSetting(key: .assetcatalogFilterForDeviceOsVersion, value: "$(TARGET_DEVICE_OS_VERSION)")
    }

    /// Assetcatalog Filter For Device Os Version
    public static func assetcatalogFilterForDeviceOsVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetcatalogFilterForDeviceOsVersion, value: \(value))
    }

    /// Assetcatalog Filter For Device Os Version
    public static func assetcatalogFilterForDeviceOsVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogFilterForDeviceOsVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Assetcatalog Filter For Device Os Version
    public static let assetcatalogFilterForDeviceOsVersion: BuildSettingsKey = "ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION"
}

// MARK: Show Asset Catalogs Notices
extension BuildSetting {

    /// Show Asset Catalogs Notices
    ///
    /// Show notices encountered during the compilation of asset catalogs.
    public static var showAssetCatalogsNotices: BuildSetting { 
        BuildSetting(key: .showAssetCatalogsNotices, value: "YES")
    }

    /// Show Asset Catalogs Notices
    ///
    /// Show notices encountered during the compilation of asset catalogs.
    public static func showAssetCatalogsNotices(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showAssetCatalogsNotices, value: value.asText)
    }

    /// Show Asset Catalogs Notices
    ///
    /// Show notices encountered during the compilation of asset catalogs.
    public static func showAssetCatalogsNotices(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showAssetCatalogsNotices, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Asset Catalogs Notices
    ///
    /// Show notices encountered during the compilation of asset catalogs.
    public static let showAssetCatalogsNotices: BuildSettingsKey = "ASSETCATALOG_NOTICES"
}

// MARK: Asset Catalog Other Flags
extension BuildSetting {

    /// Asset Catalog Other Flags
    ///
    /// Pass additional flags through to the asset catalog compiler.
    public static func assetCatalogOtherFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .assetCatalogOtherFlags, value: .array(value))
    }

    /// Asset Catalog Other Flags
    ///
    /// Pass additional flags through to the asset catalog compiler.
    public static func assetCatalogOtherFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetCatalogOtherFlags, inherit: key)
    }

    /// Asset Catalog Other Flags
    ///
    /// Pass additional flags through to the asset catalog compiler.
    public static func assetCatalogOtherFlags(_ value: String...) -> BuildSetting { 
        .assetCatalogOtherFlags(value)
    }
}

extension BuildSettingsKey {

    /// Asset Catalog Other Flags
    ///
    /// Pass additional flags through to the asset catalog compiler.
    public static let assetCatalogOtherFlags: BuildSettingsKey = "ASSETCATALOG_OTHER_FLAGS"
}

// MARK: Assetcatalog Output Format
extension BuildSetting {

    /// Assetcatalog Output Format
    public static var assetcatalogOutputFormat: BuildSetting { 
        .assetcatalogOutputFormat(.humanReadableText) 
    }

    /// Assetcatalog Output Format
    public static func assetcatalogOutputFormat(_ value: AssetcatalogOutputFormat) -> BuildSetting { 
        BuildSetting(key: .assetcatalogOutputFormat, value: \(value))
    }

    /// Assetcatalog Output Format
    public static func assetcatalogOutputFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogOutputFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Assetcatalog Output Format
    public static let assetcatalogOutputFormat: BuildSettingsKey = "ASSETCATALOG_OUTPUT_FORMAT"
}

public enum AssetcatalogOutputFormat: String, Hashable, Codable, CustomStringConvertible {
    case humanReadableText = "human-readable-text"

    public var description: String {
        rawValue
    }
}

// MARK: Show Asset Catalogs Warnings
extension BuildSetting {

    /// Show Asset Catalogs Warnings
    ///
    /// Show warnings encountered during the compilation of asset catalogs.
    public static var showAssetCatalogsWarnings: BuildSetting { 
        BuildSetting(key: .showAssetCatalogsWarnings, value: "YES")
    }

    /// Show Asset Catalogs Warnings
    ///
    /// Show warnings encountered during the compilation of asset catalogs.
    public static func showAssetCatalogsWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showAssetCatalogsWarnings, value: value.asText)
    }

    /// Show Asset Catalogs Warnings
    ///
    /// Show warnings encountered during the compilation of asset catalogs.
    public static func showAssetCatalogsWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showAssetCatalogsWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Asset Catalogs Warnings
    ///
    /// Show warnings encountered during the compilation of asset catalogs.
    public static let showAssetCatalogsWarnings: BuildSettingsKey = "ASSETCATALOG_WARNINGS"
}

// MARK: Development Language
extension BuildSetting {

    /// Development Language
    public static func developmentLanguage(_ value: String) -> BuildSetting { 
        BuildSetting(key: .developmentLanguage, value: \(value))
    }

    /// Development Language
    public static func developmentLanguage(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .developmentLanguage, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Development Language
    public static let developmentLanguage: BuildSettingsKey = "DEVELOPMENT_LANGUAGE"
}

// MARK: Enable Incremental Distill
extension BuildSetting {

    /// Enable Incremental Distill
    ///
    /// Enabled the incremental `distill` option in the asset catalog compiler. This feature is experimental and should only be enabled with caution.
    public static var enableIncrementalDistill: BuildSetting { 
        BuildSetting(key: .enableIncrementalDistill, value: "NO")
    }

    /// Enable Incremental Distill
    ///
    /// Enabled the incremental `distill` option in the asset catalog compiler. This feature is experimental and should only be enabled with caution.
    public static func enableIncrementalDistill(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableIncrementalDistill, value: value.asText)
    }

    /// Enable Incremental Distill
    ///
    /// Enabled the incremental `distill` option in the asset catalog compiler. This feature is experimental and should only be enabled with caution.
    public static func enableIncrementalDistill(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableIncrementalDistill, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Incremental Distill
    ///
    /// Enabled the incremental `distill` option in the asset catalog compiler. This feature is experimental and should only be enabled with caution.
    public static let enableIncrementalDistill: BuildSettingsKey = "ENABLE_INCREMENTAL_DISTILL"
}

// MARK: Enable Build Active Resources Only
extension BuildSetting {

    /// Enable Build Active Resources Only
    ///
    /// Omit inapplicable resources when building for a single device. For example, when building for a device with a Retina display, exclude 1x resources.
    public static var enableBuildActiveResourcesOnly: BuildSetting { 
        BuildSetting(key: .enableBuildActiveResourcesOnly, value: "YES")
    }

    /// Enable Build Active Resources Only
    ///
    /// Omit inapplicable resources when building for a single device. For example, when building for a device with a Retina display, exclude 1x resources.
    public static func enableBuildActiveResourcesOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableBuildActiveResourcesOnly, value: value.asText)
    }

    /// Enable Build Active Resources Only
    ///
    /// Omit inapplicable resources when building for a single device. For example, when building for a device with a Retina display, exclude 1x resources.
    public static func enableBuildActiveResourcesOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableBuildActiveResourcesOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Build Active Resources Only
    ///
    /// Omit inapplicable resources when building for a single device. For example, when building for a device with a Retina display, exclude 1x resources.
    public static let enableBuildActiveResourcesOnly: BuildSettingsKey = "ENABLE_ONLY_ACTIVE_RESOURCES"
}

// MARK: Resources Ui Framework Family
extension BuildSetting {

    /// Resources Ui Framework Family
    public static func resourcesUiFrameworkFamily(_ value: String) -> BuildSetting { 
        BuildSetting(key: .resourcesUiFrameworkFamily, value: \(value))
    }

    /// Resources Ui Framework Family
    public static func resourcesUiFrameworkFamily(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resourcesUiFrameworkFamily, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Resources Ui Framework Family
    public static let resourcesUiFrameworkFamily: BuildSettingsKey = "RESOURCES_UI_FRAMEWORK_FAMILY"
}

// MARK: Other Skybox Compiler Flags
extension BuildSetting {

    /// Other Skybox Compiler Flags
    public static func otherSkyboxCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherSkyboxCompilerFlags, value: .array(value))
    }

    /// Other Skybox Compiler Flags
    public static func otherSkyboxCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherSkyboxCompilerFlags, inherit: key)
    }

    /// Other Skybox Compiler Flags
    public static func otherSkyboxCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherSkyboxCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Skybox Compiler Flags
    public static let otherSkyboxCompilerFlags: BuildSettingsKey = "OTHER_SKYBOX_FLAGS"
}

// MARK: Enable Skybox Warnings
extension BuildSetting {

    /// Enable Skybox Warnings
    public static var enableSkyboxWarnings: BuildSetting { 
        BuildSetting(key: .enableSkyboxWarnings, value: "YES")
    }

    /// Enable Skybox Warnings
    public static func enableSkyboxWarnings(_ value: EnableSkyboxWarnings) -> BuildSetting { 
        BuildSetting(key: .enableSkyboxWarnings, value: \(value))
    }

    /// Enable Skybox Warnings
    public static func enableSkyboxWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableSkyboxWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Skybox Warnings
    public static let enableSkyboxWarnings: BuildSettingsKey = "SKYBOX_ENABLE_WARNINGS"
}

public enum EnableSkyboxWarnings: String, Hashable, Codable, CustomStringConvertible {
    case yes = "Yes"
    case no = "No"

    public var description: String {
        rawValue
    }
}

// MARK: Enable USDZ Compilation
extension BuildSetting {

    /// Enable USDZ Compilation
    public static var enableUsdzCompilation: BuildSetting { 
        BuildSetting(key: .enableUsdzCompilation, value: "NO")
    }

    /// Enable USDZ Compilation
    public static func enableUsdzCompilation(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableUsdzCompilation, value: value.asText)
    }

    /// Enable USDZ Compilation
    public static func enableUsdzCompilation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableUsdzCompilation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable USDZ Compilation
    public static let enableUsdzCompilation: BuildSettingsKey = "ENABLE_USDZ_COMPILATION"
}

// MARK: Other USDZ Compiler Flags
extension BuildSetting {

    /// Other USDZ Compiler Flags
    public static func otherUsdzCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherUsdzCompilerFlags, value: .array(value))
    }

    /// Other USDZ Compiler Flags
    public static func otherUsdzCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherUsdzCompilerFlags, inherit: key)
    }

    /// Other USDZ Compiler Flags
    public static func otherUsdzCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherUsdzCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other USDZ Compiler Flags
    public static let otherUsdzCompilerFlags: BuildSettingsKey = "OTHER_USDZ_FLAGS"
}

// MARK: Enable USDZ Warnings
extension BuildSetting {

    /// Enable USDZ Warnings
    public static var enableUsdzWarnings: BuildSetting { 
        BuildSetting(key: .enableUsdzWarnings, value: "YES")
    }

    /// Enable USDZ Warnings
    public static func enableUsdzWarnings(_ value: EnableUsdzWarnings) -> BuildSetting { 
        BuildSetting(key: .enableUsdzWarnings, value: \(value))
    }

    /// Enable USDZ Warnings
    public static func enableUsdzWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableUsdzWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable USDZ Warnings
    public static let enableUsdzWarnings: BuildSettingsKey = "USDZ_ENABLE_WARNINGS"
}

public enum EnableUsdzWarnings: String, Hashable, Codable, CustomStringConvertible {
    case yes = "Yes"
    case no = "No"

    public var description: String {
        rawValue
    }
}

// MARK: Validate Plist Files While Copying
extension BuildSetting {

    /// Validate Plist Files While Copying
    public static var validatePlistFilesWhileCopying: BuildSetting { 
        BuildSetting(key: .validatePlistFilesWhileCopying, value: "NO")
    }

    /// Validate Plist Files While Copying
    public static func validatePlistFilesWhileCopying(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .validatePlistFilesWhileCopying, value: value.asText)
    }

    /// Validate Plist Files While Copying
    public static func validatePlistFilesWhileCopying(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validatePlistFilesWhileCopying, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Validate Plist Files While Copying
    public static let validatePlistFilesWhileCopying: BuildSettingsKey = "VALIDATE_PLIST_FILES_WHILE_COPYING"
}

// MARK: Strings File Input Encoding
extension BuildSetting {

    /// Strings File Input Encoding
    public static var stringsFileInputEncoding: BuildSetting { 
        BuildSetting(key: .stringsFileInputEncoding, value: "$(InputFileTextEncoding)")
    }

    /// Strings File Input Encoding
    public static func stringsFileInputEncoding(_ value: String) -> BuildSetting { 
        BuildSetting(key: .stringsFileInputEncoding, value: \(value))
    }

    /// Strings File Input Encoding
    public static func stringsFileInputEncoding(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stringsFileInputEncoding, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strings File Input Encoding
    public static let stringsFileInputEncoding: BuildSettingsKey = "STRINGS_FILE_INPUT_ENCODING"
}

// MARK: Validate Strings Files While Copying
extension BuildSetting {

    /// Validate Strings Files While Copying
    public static var validateStringsFilesWhileCopying: BuildSetting { 
        BuildSetting(key: .validateStringsFilesWhileCopying, value: "YES")
    }

    /// Validate Strings Files While Copying
    public static func validateStringsFilesWhileCopying(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .validateStringsFilesWhileCopying, value: value.asText)
    }

    /// Validate Strings Files While Copying
    public static func validateStringsFilesWhileCopying(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validateStringsFilesWhileCopying, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Validate Strings Files While Copying
    public static let validateStringsFilesWhileCopying: BuildSettingsKey = "VALIDATE_STRINGS_FILES_WHILE_COPYING"
}

// MARK: Compress Tiff Files While Copying
extension BuildSetting {

    /// Compress Tiff Files While Copying
    public static var compressTiffFilesWhileCopying: BuildSetting { 
        BuildSetting(key: .compressTiffFilesWhileCopying, value: "NO")
    }

    /// Compress Tiff Files While Copying
    public static func compressTiffFilesWhileCopying(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .compressTiffFilesWhileCopying, value: value.asText)
    }

    /// Compress Tiff Files While Copying
    public static func compressTiffFilesWhileCopying(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compressTiffFilesWhileCopying, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compress Tiff Files While Copying
    public static let compressTiffFilesWhileCopying: BuildSettingsKey = "COMPRESS_TIFF_FILES_WHILE_COPYING"
}

// MARK: Compress PNG Files
extension BuildSetting {

    /// Compress PNG Files
    ///
    /// If enabled, PNG resource files are compressed as they are copied.
    public static var compressPngFiles: BuildSetting { 
        BuildSetting(key: .compressPngFiles, value: "YES")
    }

    /// Compress PNG Files
    ///
    /// If enabled, PNG resource files are compressed as they are copied.
    public static func compressPngFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .compressPngFiles, value: value.asText)
    }

    /// Compress PNG Files
    ///
    /// If enabled, PNG resource files are compressed as they are copied.
    public static func compressPngFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compressPngFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compress PNG Files
    ///
    /// If enabled, PNG resource files are compressed as they are copied.
    public static let compressPngFiles: BuildSettingsKey = "COMPRESS_PNG_FILES"
}

// MARK: Remove Text Metadata From PNG Files
extension BuildSetting {

    /// Remove Text Metadata From PNG Files
    ///
    /// Metadata in the form of text chunks in PNG files will be removed to reduce their footprint on disk.
    public static var removeTextMetadataFromPngFiles: BuildSetting { 
        BuildSetting(key: .removeTextMetadataFromPngFiles, value: "YES")
    }

    /// Remove Text Metadata From PNG Files
    ///
    /// Metadata in the form of text chunks in PNG files will be removed to reduce their footprint on disk.
    public static func removeTextMetadataFromPngFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeTextMetadataFromPngFiles, value: value.asText)
    }

    /// Remove Text Metadata From PNG Files
    ///
    /// Metadata in the form of text chunks in PNG files will be removed to reduce their footprint on disk.
    public static func removeTextMetadataFromPngFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeTextMetadataFromPngFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Remove Text Metadata From PNG Files
    ///
    /// Metadata in the form of text chunks in PNG files will be removed to reduce their footprint on disk.
    public static let removeTextMetadataFromPngFiles: BuildSettingsKey = "STRIP_PNG_TEXT"
}

// MARK: Deployment Target
extension BuildSetting {

    /// Deployment Target
    public static var deploymentTarget: BuildSetting { 
        BuildSetting(key: .deploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// Deployment Target
    public static func deploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .deploymentTarget, value: \(value))
    }

    /// Deployment Target
    public static func deploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Deployment Target
    public static let deploymentTarget: BuildSettingsKey = "DEPLOYMENT_TARGET"
}

// MARK: Mapc Module
extension BuildSetting {

    /// Mapc Module
    public static var mapcModule: BuildSetting { 
        .mapcModule(inherit: .productModuleName) 
    }

    /// Mapc Module
    public static func mapcModule(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mapcModule, value: \(value))
    }

    /// Mapc Module
    public static func mapcModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mapcModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mapc Module
    public static let mapcModule: BuildSettingsKey = "MAPC_MODULE"
}

// MARK: Suppress all mapc warnings
extension BuildSetting {

    /// Suppress all mapc warnings
    ///
    /// Compile `.xcmappingmodel` files into `.cdm` without reporting warnings.
    public static var suppressAllMapcWarnings: BuildSetting { 
        BuildSetting(key: .suppressAllMapcWarnings, value: "NO")
    }

    /// Suppress all mapc warnings
    ///
    /// Compile `.xcmappingmodel` files into `.cdm` without reporting warnings.
    public static func suppressAllMapcWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressAllMapcWarnings, value: value.asText)
    }

    /// Suppress all mapc warnings
    ///
    /// Compile `.xcmappingmodel` files into `.cdm` without reporting warnings.
    public static func suppressAllMapcWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressAllMapcWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress all mapc warnings
    ///
    /// Compile `.xcmappingmodel` files into `.cdm` without reporting warnings.
    public static let suppressAllMapcWarnings: BuildSettingsKey = "MAPC_NO_WARNINGS"
}

// MARK: Momc Module
extension BuildSetting {

    /// Momc Module
    public static var momcModule: BuildSetting { 
        .momcModule(inherit: .productModuleName) 
    }

    /// Momc Module
    public static func momcModule(_ value: String) -> BuildSetting { 
        BuildSetting(key: .momcModule, value: \(value))
    }

    /// Momc Module
    public static func momcModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .momcModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Momc Module
    public static let momcModule: BuildSettingsKey = "MOMC_MODULE"
}

// MARK: Suppress momc warnings for delete rules
extension BuildSetting {

    /// Suppress momc warnings for delete rules
    ///
    /// Suppress managed object model compiler (`momc`) warnings for delete rules during the compilation of `.xcdatamodel(d)` files.
    public static var suppressMomcWarningsForDeleteRules: BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsForDeleteRules, value: "NO")
    }

    /// Suppress momc warnings for delete rules
    ///
    /// Suppress managed object model compiler (`momc`) warnings for delete rules during the compilation of `.xcdatamodel(d)` files.
    public static func suppressMomcWarningsForDeleteRules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsForDeleteRules, value: value.asText)
    }

    /// Suppress momc warnings for delete rules
    ///
    /// Suppress managed object model compiler (`momc`) warnings for delete rules during the compilation of `.xcdatamodel(d)` files.
    public static func suppressMomcWarningsForDeleteRules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressMomcWarningsForDeleteRules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress momc warnings for delete rules
    ///
    /// Suppress managed object model compiler (`momc`) warnings for delete rules during the compilation of `.xcdatamodel(d)` files.
    public static let suppressMomcWarningsForDeleteRules: BuildSettingsKey = "MOMC_NO_DELETE_RULE_WARNINGS"
}

// MARK: Suppress momc warnings on missing inverse relationships
extension BuildSetting {

    /// Suppress momc warnings on missing inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on missing inverse relationships during the compilation of `.xcdatamodel(d)` files
    public static var suppressMomcWarningsOnMissingInverseRelationships: BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsOnMissingInverseRelationships, value: "NO")
    }

    /// Suppress momc warnings on missing inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on missing inverse relationships during the compilation of `.xcdatamodel(d)` files
    public static func suppressMomcWarningsOnMissingInverseRelationships(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsOnMissingInverseRelationships, value: value.asText)
    }

    /// Suppress momc warnings on missing inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on missing inverse relationships during the compilation of `.xcdatamodel(d)` files
    public static func suppressMomcWarningsOnMissingInverseRelationships(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressMomcWarningsOnMissingInverseRelationships, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress momc warnings on missing inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on missing inverse relationships during the compilation of `.xcdatamodel(d)` files
    public static let suppressMomcWarningsOnMissingInverseRelationships: BuildSettingsKey = "MOMC_NO_INVERSE_RELATIONSHIP_WARNINGS"
}

// MARK: Suppress momc warnings for entities with more than 100 properties
extension BuildSetting {

    /// Suppress momc warnings for entities with more than 100 properties
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on entities with more than 100 properties during the compilation of `.xcdatamodel(d)` files.
    public static var suppressMomcWarningsForEntitiesWithMoreThan100Properties: BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsForEntitiesWithMoreThan100Properties, value: "NO")
    }

    /// Suppress momc warnings for entities with more than 100 properties
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on entities with more than 100 properties during the compilation of `.xcdatamodel(d)` files.
    public static func suppressMomcWarningsForEntitiesWithMoreThan100Properties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsForEntitiesWithMoreThan100Properties, value: value.asText)
    }

    /// Suppress momc warnings for entities with more than 100 properties
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on entities with more than 100 properties during the compilation of `.xcdatamodel(d)` files.
    public static func suppressMomcWarningsForEntitiesWithMoreThan100Properties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressMomcWarningsForEntitiesWithMoreThan100Properties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress momc warnings for entities with more than 100 properties
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on entities with more than 100 properties during the compilation of `.xcdatamodel(d)` files.
    public static let suppressMomcWarningsForEntitiesWithMoreThan100Properties: BuildSettingsKey = "MOMC_NO_MAX_PROPERTY_COUNT_WARNINGS"
}

// MARK: Suppress all momc warnings
extension BuildSetting {

    /// Suppress all momc warnings
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output during the compilation of `.xcdatamodel(d)` files
    public static var suppressAllMomcWarnings: BuildSetting { 
        BuildSetting(key: .suppressAllMomcWarnings, value: "NO")
    }

    /// Suppress all momc warnings
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output during the compilation of `.xcdatamodel(d)` files
    public static func suppressAllMomcWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressAllMomcWarnings, value: value.asText)
    }

    /// Suppress all momc warnings
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output during the compilation of `.xcdatamodel(d)` files
    public static func suppressAllMomcWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressAllMomcWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress all momc warnings
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output during the compilation of `.xcdatamodel(d)` files
    public static let suppressAllMomcWarnings: BuildSettingsKey = "MOMC_NO_WARNINGS"
}

// MARK: Momc Output Suffix
extension BuildSetting {

    /// Momc Output Suffix
    public static var momcOutputSuffix: BuildSetting { 
        BuildSetting(key: .momcOutputSuffix, value: "$(MOMC_OUTPUT_SUFFIX_$(InputFileSuffix:identifier))")
    }

    /// Momc Output Suffix
    public static func momcOutputSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .momcOutputSuffix, value: \(value))
    }

    /// Momc Output Suffix
    public static func momcOutputSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .momcOutputSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Momc Output Suffix
    public static let momcOutputSuffix: BuildSettingsKey = "MOMC_OUTPUT_SUFFIX"
}

// MARK: Suppress momc error on transient inverse relationships
extension BuildSetting {

    /// Suppress momc error on transient inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on transient inverse relationships during the compilation of `.xcdatamodel(d)` files. This is only intended to be used on 10.4.x created models that compiled properly in 10.4.x before the error was introduced in 10.5
    public static var suppressMomcErrorOnTransientInverseRelationships: BuildSetting { 
        BuildSetting(key: .suppressMomcErrorOnTransientInverseRelationships, value: "NO")
    }

    /// Suppress momc error on transient inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on transient inverse relationships during the compilation of `.xcdatamodel(d)` files. This is only intended to be used on 10.4.x created models that compiled properly in 10.4.x before the error was introduced in 10.5
    public static func suppressMomcErrorOnTransientInverseRelationships(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressMomcErrorOnTransientInverseRelationships, value: value.asText)
    }

    /// Suppress momc error on transient inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on transient inverse relationships during the compilation of `.xcdatamodel(d)` files. This is only intended to be used on 10.4.x created models that compiled properly in 10.4.x before the error was introduced in 10.5
    public static func suppressMomcErrorOnTransientInverseRelationships(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressMomcErrorOnTransientInverseRelationships, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress momc error on transient inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on transient inverse relationships during the compilation of `.xcdatamodel(d)` files. This is only intended to be used on 10.4.x created models that compiled properly in 10.4.x before the error was introduced in 10.5
    public static let suppressMomcErrorOnTransientInverseRelationships: BuildSettingsKey = "MOMC_SUPPRESS_INVERSE_TRANSIENT_ERROR"
}

// MARK: Derive Mac Catalyst Product Bundle Identifier
extension BuildSetting {

    /// Derive Mac Catalyst Product Bundle Identifier
    ///
    /// When enabled, Xcode will automatically derive a bundle identifier for this target from its original bundle identifier when it’s building for Mac Catalyst.
    public static var deriveMacCatalystProductBundleIdentifier: BuildSetting { 
        BuildSetting(key: .deriveMacCatalystProductBundleIdentifier, value: "NO")
    }

    /// Derive Mac Catalyst Product Bundle Identifier
    ///
    /// When enabled, Xcode will automatically derive a bundle identifier for this target from its original bundle identifier when it’s building for Mac Catalyst.
    public static func deriveMacCatalystProductBundleIdentifier(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deriveMacCatalystProductBundleIdentifier, value: value.asText)
    }

    /// Derive Mac Catalyst Product Bundle Identifier
    ///
    /// When enabled, Xcode will automatically derive a bundle identifier for this target from its original bundle identifier when it’s building for Mac Catalyst.
    public static func deriveMacCatalystProductBundleIdentifier(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deriveMacCatalystProductBundleIdentifier, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Derive Mac Catalyst Product Bundle Identifier
    ///
    /// When enabled, Xcode will automatically derive a bundle identifier for this target from its original bundle identifier when it’s building for Mac Catalyst.
    public static let deriveMacCatalystProductBundleIdentifier: BuildSettingsKey = "DERIVE_MACCATALYST_PRODUCT_BUNDLE_IDENTIFIER"
}

// MARK: Building for Mac Catalyst
extension BuildSetting {

    /// Building for Mac Catalyst
    ///
    /// Indicates whether the target is building for Mac Catalyst. This build setting is intended for use in shell scripts and build setting composition and should be considered read-only.
    public static func buildingForMacCatalyst(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .buildingForMacCatalyst, value: value.asText)
    }

    /// Building for Mac Catalyst
    ///
    /// Indicates whether the target is building for Mac Catalyst. This build setting is intended for use in shell scripts and build setting composition and should be considered read-only.
    public static func buildingForMacCatalyst(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildingForMacCatalyst, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Building for Mac Catalyst
    ///
    /// Indicates whether the target is building for Mac Catalyst. This build setting is intended for use in shell scripts and build setting composition and should be considered read-only.
    public static let buildingForMacCatalyst: BuildSettingsKey = "IS_MACCATALYST"
}

// MARK: Supports Mac Catalyst
extension BuildSetting {

    /// Supports Mac Catalyst
    ///
    /// Support building this target for Mac Catalyst.
    public static var supportsMacCatalyst: BuildSetting { 
        BuildSetting(key: .supportsMacCatalyst, value: "YES")
    }

    /// Supports Mac Catalyst
    ///
    /// Support building this target for Mac Catalyst.
    public static func supportsMacCatalyst(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .supportsMacCatalyst, value: value.asText)
    }

    /// Supports Mac Catalyst
    ///
    /// Support building this target for Mac Catalyst.
    public static func supportsMacCatalyst(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .supportsMacCatalyst, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Supports Mac Catalyst
    ///
    /// Support building this target for Mac Catalyst.
    public static let supportsMacCatalyst: BuildSettingsKey = "SUPPORTS_MACCATALYST"
}

// MARK: Show Mac (Designed for iPhone & iPad) Destination
extension BuildSetting {

    /// Show Mac (Designed for iPhone & iPad) Destination
    ///
    /// Show the Mac (Designed for iPhone) and Mac (Designed for iPad) destinations.
    public static var showMacDesignedForIphoneIpadDestination: BuildSetting { 
        BuildSetting(key: .showMacDesignedForIphoneIpadDestination, value: "YES")
    }

    /// Show Mac (Designed for iPhone & iPad) Destination
    ///
    /// Show the Mac (Designed for iPhone) and Mac (Designed for iPad) destinations.
    public static func showMacDesignedForIphoneIpadDestination(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showMacDesignedForIphoneIpadDestination, value: value.asText)
    }

    /// Show Mac (Designed for iPhone & iPad) Destination
    ///
    /// Show the Mac (Designed for iPhone) and Mac (Designed for iPad) destinations.
    public static func showMacDesignedForIphoneIpadDestination(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showMacDesignedForIphoneIpadDestination, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Mac (Designed for iPhone & iPad) Destination
    ///
    /// Show the Mac (Designed for iPhone) and Mac (Designed for iPad) destinations.
    public static let showMacDesignedForIphoneIpadDestination: BuildSettingsKey = "SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD"
}

// MARK: Ld Entitlements Section
extension BuildSetting {

    /// Ld Entitlements Section
    public static func ldEntitlementsSection(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ldEntitlementsSection, value: \(value))
    }

    /// Ld Entitlements Section
    public static func ldEntitlementsSection(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldEntitlementsSection, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ld Entitlements Section
    public static let ldEntitlementsSection: BuildSettingsKey = "LD_ENTITLEMENTS_SECTION"
}

// MARK: CoreML Model Class Generation Language
extension BuildSetting {

    /// CoreML Model Class Generation Language
    ///
    /// The Source-code language to use for generated CoreML model class. By default “Automatic” will analyze your project to determine the correct language. Adjust this setting to explicitly select “Swift” or “Objective-C”, or select “None” to disable model class generation.
    public static var coremlModelClassGenerationLanguage: BuildSetting { 
        .coremlModelClassGenerationLanguage(.automatic) 
    }

    /// CoreML Model Class Generation Language
    ///
    /// The Source-code language to use for generated CoreML model class. By default “Automatic” will analyze your project to determine the correct language. Adjust this setting to explicitly select “Swift” or “Objective-C”, or select “None” to disable model class generation.
    public static func coremlModelClassGenerationLanguage(_ value: CoremlModelClassGenerationLanguage) -> BuildSetting { 
        BuildSetting(key: .coremlModelClassGenerationLanguage, value: \(value))
    }

    /// CoreML Model Class Generation Language
    ///
    /// The Source-code language to use for generated CoreML model class. By default “Automatic” will analyze your project to determine the correct language. Adjust this setting to explicitly select “Swift” or “Objective-C”, or select “None” to disable model class generation.
    public static func coremlModelClassGenerationLanguage(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlModelClassGenerationLanguage, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CoreML Model Class Generation Language
    ///
    /// The Source-code language to use for generated CoreML model class. By default “Automatic” will analyze your project to determine the correct language. Adjust this setting to explicitly select “Swift” or “Objective-C”, or select “None” to disable model class generation.
    public static let coremlModelClassGenerationLanguage: BuildSettingsKey = "COREML_CODEGEN_LANGUAGE"
}

public enum CoremlModelClassGenerationLanguage: String, Hashable, Codable, CustomStringConvertible {
    case automatic = "Automatic"
    case objectiveC = "Objective-C"
    case swift = "Swift"
    case none = "None"

    public var description: String {
        rawValue
    }
}

// MARK: CoreML Generated Model Inherits NSObject
extension BuildSetting {

    /// CoreML Generated Model Inherits NSObject
    ///
    /// Generate Swift model classes that are marked with @objc and are descendants of NSObject, in order to be accessible and usable in Objective-C. This setting has no effect if “CoreML Model Class Generation Language” is set to “Objective-C”.
    public static var coremlGeneratedModelInheritsNsobject: BuildSetting { 
        BuildSetting(key: .coremlGeneratedModelInheritsNsobject, value: "NO")
    }

    /// CoreML Generated Model Inherits NSObject
    ///
    /// Generate Swift model classes that are marked with @objc and are descendants of NSObject, in order to be accessible and usable in Objective-C. This setting has no effect if “CoreML Model Class Generation Language” is set to “Objective-C”.
    public static func coremlGeneratedModelInheritsNsobject(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .coremlGeneratedModelInheritsNsobject, value: value.asText)
    }

    /// CoreML Generated Model Inherits NSObject
    ///
    /// Generate Swift model classes that are marked with @objc and are descendants of NSObject, in order to be accessible and usable in Objective-C. This setting has no effect if “CoreML Model Class Generation Language” is set to “Objective-C”.
    public static func coremlGeneratedModelInheritsNsobject(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlGeneratedModelInheritsNsobject, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CoreML Generated Model Inherits NSObject
    ///
    /// Generate Swift model classes that are marked with @objc and are descendants of NSObject, in order to be accessible and usable in Objective-C. This setting has no effect if “CoreML Model Class Generation Language” is set to “Objective-C”.
    public static let coremlGeneratedModelInheritsNsobject: BuildSettingsKey = "COREML_CODEGEN_SWIFT_GLOBAL_MODULE"
}

// MARK: Coreml Codegen Swift Version
extension BuildSetting {

    /// Coreml Codegen Swift Version
    public static var coremlCodegenSwiftVersion: BuildSetting { 
        BuildSetting(key: .coremlCodegenSwiftVersion, value: "$(SWIFT_VERSION)")
    }

    /// Coreml Codegen Swift Version
    public static func coremlCodegenSwiftVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlCodegenSwiftVersion, value: \(value))
    }

    /// Coreml Codegen Swift Version
    public static func coremlCodegenSwiftVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlCodegenSwiftVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Coreml Codegen Swift Version
    public static let coremlCodegenSwiftVersion: BuildSettingsKey = "COREML_CODEGEN_SWIFT_VERSION"
}

// MARK: Coreml Compiler Infoplist Content File
extension BuildSetting {

    /// Coreml Compiler Infoplist Content File
    public static var coremlCompilerInfoplistContentFile: BuildSetting { 
        BuildSetting(key: .coremlCompilerInfoplistContentFile, value: "$(TARGET_TEMP_DIR)/$(InputFileBase)-CoreMLPartialInfo.plist")
    }

    /// Coreml Compiler Infoplist Content File
    public static func coremlCompilerInfoplistContentFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlCompilerInfoplistContentFile, value: \(value))
    }

    /// Coreml Compiler Infoplist Content File
    public static func coremlCompilerInfoplistContentFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlCompilerInfoplistContentFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Coreml Compiler Infoplist Content File
    public static let coremlCompilerInfoplistContentFile: BuildSettingsKey = "COREML_COMPILER_INFOPLIST_CONTENT_FILE"
}

// MARK: Coreml Deployment Target
extension BuildSetting {

    /// Coreml Deployment Target
    public static var coremlDeploymentTarget: BuildSetting { 
        BuildSetting(key: .coremlDeploymentTarget, value: "$(COREML_DEPLOYMENT_TARGET__$(IS_MACCATALYST:default=NO))")
    }

    /// Coreml Deployment Target
    public static func coremlDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlDeploymentTarget, value: \(value))
    }

    /// Coreml Deployment Target
    public static func coremlDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Coreml Deployment Target
    public static let coremlDeploymentTarget: BuildSettingsKey = "COREML_DEPLOYMENT_TARGET"
}

// MARK: Coreml Deployment Target No
extension BuildSetting {

    /// Coreml Deployment Target No
    public static var coremlDeploymentTargetNo: BuildSetting { 
        BuildSetting(key: .coremlDeploymentTargetNo, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// Coreml Deployment Target No
    public static func coremlDeploymentTargetNo(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlDeploymentTargetNo, value: \(value))
    }

    /// Coreml Deployment Target No
    public static func coremlDeploymentTargetNo(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlDeploymentTargetNo, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Coreml Deployment Target No
    public static let coremlDeploymentTargetNo: BuildSettingsKey = "COREML_DEPLOYMENT_TARGET__NO"
}

// MARK: Coreml Deployment Target Yes
extension BuildSetting {

    /// Coreml Deployment Target Yes
    public static var coremlDeploymentTargetYes: BuildSetting { 
        BuildSetting(key: .coremlDeploymentTargetYes, value: "$(IPHONEOS_DEPLOYMENT_TARGET)")
    }

    /// Coreml Deployment Target Yes
    public static func coremlDeploymentTargetYes(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlDeploymentTargetYes, value: \(value))
    }

    /// Coreml Deployment Target Yes
    public static func coremlDeploymentTargetYes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlDeploymentTargetYes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Coreml Deployment Target Yes
    public static let coremlDeploymentTargetYes: BuildSettingsKey = "COREML_DEPLOYMENT_TARGET__YES"
}

// MARK: Coreml Platform Name
extension BuildSetting {

    /// Coreml Platform Name
    public static var coremlPlatformName: BuildSetting { 
        BuildSetting(key: .coremlPlatformName, value: "$(COREML_PLATFORM_NAME__$(IS_MACCATALYST:default=NO))")
    }

    /// Coreml Platform Name
    public static func coremlPlatformName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlPlatformName, value: \(value))
    }

    /// Coreml Platform Name
    public static func coremlPlatformName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlPlatformName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Coreml Platform Name
    public static let coremlPlatformName: BuildSettingsKey = "COREML_PLATFORM_NAME"
}

// MARK: Coreml Platform Name No
extension BuildSetting {

    /// Coreml Platform Name No
    public static var coremlPlatformNameNo: BuildSetting { 
        .coremlPlatformNameNo(inherit: .swiftPlatformTargetPrefix) 
    }

    /// Coreml Platform Name No
    public static func coremlPlatformNameNo(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlPlatformNameNo, value: \(value))
    }

    /// Coreml Platform Name No
    public static func coremlPlatformNameNo(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlPlatformNameNo, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Coreml Platform Name No
    public static let coremlPlatformNameNo: BuildSettingsKey = "COREML_PLATFORM_NAME__NO"
}

// MARK: Coreml Platform Name Yes
extension BuildSetting {

    /// Coreml Platform Name Yes
    public static var coremlPlatformNameYes: BuildSetting { 
        BuildSetting(key: .coremlPlatformNameYes, value: "maccatalyst")
    }

    /// Coreml Platform Name Yes
    public static func coremlPlatformNameYes(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlPlatformNameYes, value: \(value))
    }

    /// Coreml Platform Name Yes
    public static func coremlPlatformNameYes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlPlatformNameYes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Coreml Platform Name Yes
    public static let coremlPlatformNameYes: BuildSettingsKey = "COREML_PLATFORM_NAME__YES"
}

// MARK: Instruments Package Builder
extension BuildSetting {

    /// Instruments Package Builder
    public static var instrumentsPackageBuilder: BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilder, value: "instrumentbuilder")
    }

    /// Instruments Package Builder
    public static func instrumentsPackageBuilder(_ value: String) -> BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilder, value: \(value))
    }

    /// Instruments Package Builder
    public static func instrumentsPackageBuilder(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentsPackageBuilder, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Instruments Package Builder
    public static let instrumentsPackageBuilder: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER"
}

// MARK: Instruments Package Builder Dependency Info File
extension BuildSetting {

    /// Instruments Package Builder Dependency Info File
    public static var instrumentsPackageBuilderDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilderDependencyInfoFile, value: "$(TARGET_TEMP_DIR)/instruments-package-builder.dependencies")
    }

    /// Instruments Package Builder Dependency Info File
    public static func instrumentsPackageBuilderDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilderDependencyInfoFile, value: \(value))
    }

    /// Instruments Package Builder Dependency Info File
    public static func instrumentsPackageBuilderDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentsPackageBuilderDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Instruments Package Builder Dependency Info File
    public static let instrumentsPackageBuilderDependencyInfoFile: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_DEPENDENCY_INFO_FILE"
}

// MARK: Linked Instruments Packages
extension BuildSetting {

    /// Linked Instruments Packages
    public static func linkedInstrumentsPackages(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .linkedInstrumentsPackages, value: .array(value))
    }

    /// Linked Instruments Packages
    public static func linkedInstrumentsPackages(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkedInstrumentsPackages, inherit: key)
    }

    /// Linked Instruments Packages
    public static func linkedInstrumentsPackages(_ value: String...) -> BuildSetting { 
        .linkedInstrumentsPackages(value)
    }
}

extension BuildSettingsKey {

    /// Linked Instruments Packages
    public static let linkedInstrumentsPackages: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_LINKED_PACKAGES"
}

// MARK: Disable Standard Instruments Package Search Path
extension BuildSetting {

    /// Disable Standard Instruments Package Search Path
    public static var disableStandardInstrumentsPackageSearchPath: BuildSetting { 
        BuildSetting(key: .disableStandardInstrumentsPackageSearchPath, value: "NO")
    }

    /// Disable Standard Instruments Package Search Path
    public static func disableStandardInstrumentsPackageSearchPath(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .disableStandardInstrumentsPackageSearchPath, value: value.asText)
    }

    /// Disable Standard Instruments Package Search Path
    public static func disableStandardInstrumentsPackageSearchPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .disableStandardInstrumentsPackageSearchPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Disable Standard Instruments Package Search Path
    public static let disableStandardInstrumentsPackageSearchPath: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_NO_SYSTEM_SEARCH"
}

// MARK: Instruments Package Builder Search Paths
extension BuildSetting {

    /// Instruments Package Builder Search Paths
    public static var instrumentsPackageBuilderSearchPaths: BuildSetting { 
        .instrumentsPackageBuilderSearchPaths(inherit: .builtProductsDir) 
    }

    /// Instruments Package Builder Search Paths
    public static func instrumentsPackageBuilderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilderSearchPaths, value: .array(value))
    }

    /// Instruments Package Builder Search Paths
    public static func instrumentsPackageBuilderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentsPackageBuilderSearchPaths, inherit: key)
    }

    /// Instruments Package Builder Search Paths
    public static func instrumentsPackageBuilderSearchPaths(_ value: String...) -> BuildSetting { 
        .instrumentsPackageBuilderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Instruments Package Builder Search Paths
    public static let instrumentsPackageBuilderSearchPaths: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_SEARCH_PATHS"
}

// MARK: Instruments Package Version
extension BuildSetting {

    /// Instruments Package Version
    public static func instrumentsPackageVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .instrumentsPackageVersion, value: \(value))
    }

    /// Instruments Package Version
    public static func instrumentsPackageVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentsPackageVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Instruments Package Version
    public static let instrumentsPackageVersion: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_VERSION_OVERRIDE"
}

// MARK: Iig Cxx Language Standard
extension BuildSetting {

    /// Iig Cxx Language Standard
    public static var iigCxxLanguageStandard: BuildSetting { 
        .iigCxxLanguageStandard(inherit: .cppLanguageDialect) 
    }

    /// Iig Cxx Language Standard
    public static func iigCxxLanguageStandard(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigCxxLanguageStandard, value: \(value))
    }

    /// Iig Cxx Language Standard
    public static func iigCxxLanguageStandard(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigCxxLanguageStandard, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Iig Cxx Language Standard
    public static let iigCxxLanguageStandard: BuildSettingsKey = "IIG_CXX_LANGUAGE_STANDARD"
}

// MARK: Iig Derived File Dir
extension BuildSetting {

    /// Iig Derived File Dir
    public static var iigDerivedFileDir: BuildSetting { 
        BuildSetting(key: .iigDerivedFileDir, value: "$(DERIVED_FILE_DIR)/$(IIG_FRAMEWORK_NAME)")
    }

    /// Iig Derived File Dir
    public static func iigDerivedFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigDerivedFileDir, value: \(value))
    }

    /// Iig Derived File Dir
    public static func iigDerivedFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigDerivedFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Iig Derived File Dir
    public static let iigDerivedFileDir: BuildSettingsKey = "IIG_DERIVED_FILE_DIR"
}

// MARK: Iig Framework Name
extension BuildSetting {

    /// Iig Framework Name
    public static var iigFrameworkName: BuildSetting { 
        .iigFrameworkName(inherit: .productName) 
    }

    /// Iig Framework Name
    public static func iigFrameworkName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigFrameworkName, value: \(value))
    }

    /// Iig Framework Name
    public static func iigFrameworkName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigFrameworkName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Iig Framework Name
    public static let iigFrameworkName: BuildSettingsKey = "IIG_FRAMEWORK_NAME"
}

// MARK: Iig Headers Dir
extension BuildSetting {

    /// Iig Headers Dir
    public static var iigHeadersDir: BuildSetting { 
        .iigHeadersDir(inherit: .iigDerivedFileDir) 
    }

    /// Iig Headers Dir
    public static func iigHeadersDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigHeadersDir, value: \(value))
    }

    /// Iig Headers Dir
    public static func iigHeadersDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigHeadersDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Iig Headers Dir
    public static let iigHeadersDir: BuildSettingsKey = "IIG_HEADERS_DIR"
}

// MARK: Iig Implementation Dir
extension BuildSetting {

    /// Iig Implementation Dir
    public static var iigImplementationDir: BuildSetting { 
        .iigImplementationDir(inherit: .iigDerivedFileDir) 
    }

    /// Iig Implementation Dir
    public static func iigImplementationDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigImplementationDir, value: \(value))
    }

    /// Iig Implementation Dir
    public static func iigImplementationDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigImplementationDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Iig Implementation Dir
    public static let iigImplementationDir: BuildSettingsKey = "IIG_IMPLEMENTATION_DIR"
}

// MARK: Iig Preprocessor Definitions
extension BuildSetting {

    /// Iig Preprocessor Definitions
    public static var iigPreprocessorDefinitions: BuildSetting { 
        BuildSetting(key: .iigPreprocessorDefinitions, value: "__IIG=1")
    }

    /// Iig Preprocessor Definitions
    public static func iigPreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .iigPreprocessorDefinitions, value: .array(value))
    }

    /// Iig Preprocessor Definitions
    public static func iigPreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigPreprocessorDefinitions, inherit: key)
    }

    /// Iig Preprocessor Definitions
    public static func iigPreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .iigPreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// Iig Preprocessor Definitions
    public static let iigPreprocessorDefinitions: BuildSettingsKey = "IIG_PREPROCESSOR_DEFINITIONS"
}

// MARK: Other IIG C Flags
extension BuildSetting {

    /// Other IIG C Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` invocation of clang. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigCFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherIigCFlags, value: .array(value))
    }

    /// Other IIG C Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` invocation of clang. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigCFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherIigCFlags, inherit: key)
    }

    /// Other IIG C Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` invocation of clang. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigCFlags(_ value: String...) -> BuildSetting { 
        .otherIigCFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other IIG C Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` invocation of clang. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static let otherIigCFlags: BuildSettingsKey = "OTHER_IIG_CFLAGS"
}

// MARK: Other IIG Flags
extension BuildSetting {

    /// Other IIG Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherIigFlags, value: .array(value))
    }

    /// Other IIG Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherIigFlags, inherit: key)
    }

    /// Other IIG Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigFlags(_ value: String...) -> BuildSetting { 
        .otherIigFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other IIG Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static let otherIigFlags: BuildSettingsKey = "OTHER_IIG_FLAGS"
}

// MARK: Save as Execute-Only
extension BuildSetting {

    /// Save as Execute-Only
    ///
    /// Saves the output script in execute-only form; the script can be run, but cannot be opened in Script Editor or Xcode. With this option turned off, a user may see the original script source by opening the script.
    public static var saveAsExecuteOnly: BuildSetting { 
        BuildSetting(key: .saveAsExecuteOnly, value: "NO")
    }

    /// Save as Execute-Only
    ///
    /// Saves the output script in execute-only form; the script can be run, but cannot be opened in Script Editor or Xcode. With this option turned off, a user may see the original script source by opening the script.
    public static func saveAsExecuteOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .saveAsExecuteOnly, value: value.asText)
    }

    /// Save as Execute-Only
    ///
    /// Saves the output script in execute-only form; the script can be run, but cannot be opened in Script Editor or Xcode. With this option turned off, a user may see the original script source by opening the script.
    public static func saveAsExecuteOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .saveAsExecuteOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Save as Execute-Only
    ///
    /// Saves the output script in execute-only form; the script can be run, but cannot be opened in Script Editor or Xcode. With this option turned off, a user may see the original script source by opening the script.
    public static let saveAsExecuteOnly: BuildSettingsKey = "OSACOMPILE_EXECUTE_ONLY"
}

// MARK: Other OSACompile Flags
extension BuildSetting {

    /// Other OSACompile Flags
    ///
    /// Space-separated list of additional flags to pass to `osacompile`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `osacompile` flag.
    public static func otherOsacompileFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherOsacompileFlags, value: .array(value))
    }

    /// Other OSACompile Flags
    ///
    /// Space-separated list of additional flags to pass to `osacompile`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `osacompile` flag.
    public static func otherOsacompileFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherOsacompileFlags, inherit: key)
    }

    /// Other OSACompile Flags
    ///
    /// Space-separated list of additional flags to pass to `osacompile`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `osacompile` flag.
    public static func otherOsacompileFlags(_ value: String...) -> BuildSetting { 
        .otherOsacompileFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other OSACompile Flags
    ///
    /// Space-separated list of additional flags to pass to `osacompile`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `osacompile` flag.
    public static let otherOsacompileFlags: BuildSettingsKey = "OTHER_OSACOMPILEFLAGS"
}

// MARK: Other DTrace Flags
extension BuildSetting {

    /// Other DTrace Flags
    ///
    /// Space-separated list of additional flags to pass to the `dtrace` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `dtrace` flag.
    public static func otherDtraceFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherDtraceFlags, value: .array(value))
    }

    /// Other DTrace Flags
    ///
    /// Space-separated list of additional flags to pass to the `dtrace` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `dtrace` flag.
    public static func otherDtraceFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherDtraceFlags, inherit: key)
    }

    /// Other DTrace Flags
    ///
    /// Space-separated list of additional flags to pass to the `dtrace` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `dtrace` flag.
    public static func otherDtraceFlags(_ value: String...) -> BuildSetting { 
        .otherDtraceFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other DTrace Flags
    ///
    /// Space-separated list of additional flags to pass to the `dtrace` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `dtrace` flag.
    public static let otherDtraceFlags: BuildSettingsKey = "DTRACE_OTHER_FLAGS"
}

// MARK: Dtrace Output File Type
extension BuildSetting {

    /// Dtrace Output File Type
    public static var dtraceOutputFileType: BuildSetting { 
        .dtraceOutputFileType(.header) 
    }

    /// Dtrace Output File Type
    public static func dtraceOutputFileType(_ value: DtraceOutputFileType) -> BuildSetting { 
        BuildSetting(key: .dtraceOutputFileType, value: \(value))
    }

    /// Dtrace Output File Type
    public static func dtraceOutputFileType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dtraceOutputFileType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dtrace Output File Type
    public static let dtraceOutputFileType: BuildSettingsKey = "DTRACE_OUTPUT_FILE_TYPE"
}

public enum DtraceOutputFileType: String, Hashable, Codable, CustomStringConvertible {
    case header = "Header"

    public var description: String {
        rawValue
    }
}

// MARK: Mig Deployment Target
extension BuildSetting {

    /// Mig Deployment Target
    public static var migDeploymentTarget: BuildSetting { 
        BuildSetting(key: .migDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// Mig Deployment Target
    public static func migDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .migDeploymentTarget, value: \(value))
    }

    /// Mig Deployment Target
    public static func migDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .migDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mig Deployment Target
    public static let migDeploymentTarget: BuildSettingsKey = "MIG_DEPLOYMENT_TARGET"
}

// MARK: Other Nasm Flags
extension BuildSetting {

    /// Other Nasm Flags
    ///
    /// Space-separated list of additional flags to pass to the `nasm` assembler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `nasm` flag.
    public static func otherNasmFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherNasmFlags, value: .array(value))
    }

    /// Other Nasm Flags
    ///
    /// Space-separated list of additional flags to pass to the `nasm` assembler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `nasm` flag.
    public static func otherNasmFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherNasmFlags, inherit: key)
    }

    /// Other Nasm Flags
    ///
    /// Space-separated list of additional flags to pass to the `nasm` assembler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `nasm` flag.
    public static func otherNasmFlags(_ value: String...) -> BuildSetting { 
        .otherNasmFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Nasm Flags
    ///
    /// Space-separated list of additional flags to pass to the `nasm` assembler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `nasm` flag.
    public static let otherNasmFlags: BuildSettingsKey = "NASM_OTHER_FLAGS"
}

// MARK: Nasm Output File Format
extension BuildSetting {

    /// Nasm Output File Format
    public static var nasmOutputFileFormat: BuildSetting { 
        BuildSetting(key: .nasmOutputFileFormat, value: "macho")
    }

    /// Nasm Output File Format
    public static func nasmOutputFileFormat(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nasmOutputFileFormat, value: \(value))
    }

    /// Nasm Output File Format
    public static func nasmOutputFileFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nasmOutputFileFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Nasm Output File Format
    public static let nasmOutputFileFormat: BuildSettingsKey = "NASM_OUTPUT_FILE_FORMAT"
}

// MARK: Nasm Preinclude File
extension BuildSetting {

    /// Nasm Preinclude File
    ///
    /// Specifies a file to be preincluded, before the main source file starts to be processed.
    public static func nasmPreincludeFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nasmPreincludeFile, value: \(value))
    }

    /// Nasm Preinclude File
    ///
    /// Specifies a file to be preincluded, before the main source file starts to be processed.
    public static func nasmPreincludeFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nasmPreincludeFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Nasm Preinclude File
    ///
    /// Specifies a file to be preincluded, before the main source file starts to be processed.
    public static let nasmPreincludeFile: BuildSettingsKey = "NASM_PREINCLUDE_FILE"
}

// MARK: File Fork of Binary Sources
extension BuildSetting {

    /// File Fork of Binary Sources
    ///
    /// Determines whether `ResMerger` treats binary input files as data-fork hosted or resource-fork hosted, or whether it automatically examines each input file.
    public static var fileForkOfBinarySources: BuildSetting { 
        .fileForkOfBinarySources(.auto) 
    }

    /// File Fork of Binary Sources
    ///
    /// Determines whether `ResMerger` treats binary input files as data-fork hosted or resource-fork hosted, or whether it automatically examines each input file.
    public static func fileForkOfBinarySources(_ value: FileForkOfBinarySources) -> BuildSetting { 
        BuildSetting(key: .fileForkOfBinarySources, value: \(value))
    }

    /// File Fork of Binary Sources
    ///
    /// Determines whether `ResMerger` treats binary input files as data-fork hosted or resource-fork hosted, or whether it automatically examines each input file.
    public static func fileForkOfBinarySources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fileForkOfBinarySources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// File Fork of Binary Sources
    ///
    /// Determines whether `ResMerger` treats binary input files as data-fork hosted or resource-fork hosted, or whether it automatically examines each input file.
    public static let fileForkOfBinarySources: BuildSettingsKey = "RESMERGER_SOURCES_FORK"
}

public enum FileForkOfBinarySources: String, Hashable, Codable, CustomStringConvertible {
    case data = "data"
    case resource = "resource"
    case auto = "auto"

    public var description: String {
        rawValue
    }
}

// MARK: Rez Prefix File
extension BuildSetting {

    /// Rez Prefix File
    ///
    /// Implicitly include the named file on the command line for each `Rez` file compiled. The path given should either be a project relative path or an absolute path.
    public static func rezPrefixFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .rezPrefixFile, value: \(value))
    }

    /// Rez Prefix File
    ///
    /// Implicitly include the named file on the command line for each `Rez` file compiled. The path given should either be a project relative path or an absolute path.
    public static func rezPrefixFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezPrefixFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Rez Prefix File
    ///
    /// Implicitly include the named file on the command line for each `Rez` file compiled. The path given should either be a project relative path or an absolute path.
    public static let rezPrefixFile: BuildSettingsKey = "REZ_PREFIX_FILE"
}

// MARK: Preprocessor Defines
extension BuildSetting {

    /// Preprocessor Defines
    ///
    /// These strings will be defined when compiling resource manager resources.
    public static func preprocessorDefines(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorDefines, value: .array(value))
    }

    /// Preprocessor Defines
    ///
    /// These strings will be defined when compiling resource manager resources.
    public static func preprocessorDefines(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorDefines, inherit: key)
    }

    /// Preprocessor Defines
    ///
    /// These strings will be defined when compiling resource manager resources.
    public static func preprocessorDefines(_ value: String...) -> BuildSetting { 
        .preprocessorDefines(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Defines
    ///
    /// These strings will be defined when compiling resource manager resources.
    public static let preprocessorDefines: BuildSettingsKey = "REZ_PREPROCESSOR_DEFINITIONS"
}

// MARK: Preprocessor Undefines
extension BuildSetting {

    /// Preprocessor Undefines
    ///
    /// These strings will be undefined when compiling resource manager resources.
    public static func preprocessorUndefines(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorUndefines, value: .array(value))
    }

    /// Preprocessor Undefines
    ///
    /// These strings will be undefined when compiling resource manager resources.
    public static func preprocessorUndefines(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorUndefines, inherit: key)
    }

    /// Preprocessor Undefines
    ///
    /// These strings will be undefined when compiling resource manager resources.
    public static func preprocessorUndefines(_ value: String...) -> BuildSetting { 
        .preprocessorUndefines(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Undefines
    ///
    /// These strings will be undefined when compiling resource manager resources.
    public static let preprocessorUndefines: BuildSettingsKey = "REZ_PREPROCESSOR_UNDEFINITIONS"
}

// MARK: Resolve Aliases
extension BuildSetting {

    /// Resolve Aliases
    ///
    /// Enables aliases to be unresolved or conditionally resolved. The default is to resolve aliases always.
    public static var resolveAliases: BuildSetting { 
        .resolveAliases(.always) 
    }

    /// Resolve Aliases
    ///
    /// Enables aliases to be unresolved or conditionally resolved. The default is to resolve aliases always.
    public static func resolveAliases(_ value: ResolveAliases) -> BuildSetting { 
        BuildSetting(key: .resolveAliases, value: \(value))
    }

    /// Resolve Aliases
    ///
    /// Enables aliases to be unresolved or conditionally resolved. The default is to resolve aliases always.
    public static func resolveAliases(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resolveAliases, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Resolve Aliases
    ///
    /// Enables aliases to be unresolved or conditionally resolved. The default is to resolve aliases always.
    public static let resolveAliases: BuildSettingsKey = "REZ_RESOLVE_ALIASES"
}

public enum ResolveAliases: String, Hashable, Codable, CustomStringConvertible {
    case always = "Always"
    case never = "Never"
    case outputs = "Outputs"
    case includes = "Includes"

    public var description: String {
        rawValue
    }
}

// MARK: Read-only Resource Map
extension BuildSetting {

    /// Read-only Resource Map
    ///
    /// Enabling this option causes the resource map output to be read-only.
    public static var readOnlyResourceMap: BuildSetting { 
        BuildSetting(key: .readOnlyResourceMap, value: "NO")
    }

    /// Read-only Resource Map
    ///
    /// Enabling this option causes the resource map output to be read-only.
    public static func readOnlyResourceMap(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .readOnlyResourceMap, value: value.asText)
    }

    /// Read-only Resource Map
    ///
    /// Enabling this option causes the resource map output to be read-only.
    public static func readOnlyResourceMap(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .readOnlyResourceMap, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Read-only Resource Map
    ///
    /// Enabling this option causes the resource map output to be read-only.
    public static let readOnlyResourceMap: BuildSettingsKey = "REZ_RESOURCE_MAP_READ_ONLY"
}

// MARK: Rez Script Type
extension BuildSetting {

    /// Rez Script Type
    ///
    /// Enables the recognition of a specific 2-byte character script identifier to use when compiling resource manager resources. This allows for 2-byte characters in strings to be handled as indivisible entities. The default language is Roman, which specifies 1-byte character sets.
    public static var rezScriptType: BuildSetting { 
        .rezScriptType(.roman) 
    }

    /// Rez Script Type
    ///
    /// Enables the recognition of a specific 2-byte character script identifier to use when compiling resource manager resources. This allows for 2-byte characters in strings to be handled as indivisible entities. The default language is Roman, which specifies 1-byte character sets.
    public static func rezScriptType(_ value: RezScriptType) -> BuildSetting { 
        BuildSetting(key: .rezScriptType, value: \(value))
    }

    /// Rez Script Type
    ///
    /// Enables the recognition of a specific 2-byte character script identifier to use when compiling resource manager resources. This allows for 2-byte characters in strings to be handled as indivisible entities. The default language is Roman, which specifies 1-byte character sets.
    public static func rezScriptType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezScriptType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Rez Script Type
    ///
    /// Enables the recognition of a specific 2-byte character script identifier to use when compiling resource manager resources. This allows for 2-byte characters in strings to be handled as indivisible entities. The default language is Roman, which specifies 1-byte character sets.
    public static let rezScriptType: BuildSettingsKey = "REZ_SCRIPT_TYPE"
}

public enum RezScriptType: String, Hashable, Codable, CustomStringConvertible {
    case roman = "Roman"
    case korean = "Korean"
    case tradchinese = "TradChinese"
    case japanese = "Japanese"
    case simpchinese = "SimpChinese"

    public var description: String {
        rawValue
    }
}

// MARK: Show Diagnostic Output
extension BuildSetting {

    /// Show Diagnostic Output
    ///
    /// Enabling this option causes version and progress information to be written when compiling resource manager resources.
    public static var showDiagnosticOutput: BuildSetting { 
        BuildSetting(key: .showDiagnosticOutput, value: "NO")
    }

    /// Show Diagnostic Output
    ///
    /// Enabling this option causes version and progress information to be written when compiling resource manager resources.
    public static func showDiagnosticOutput(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showDiagnosticOutput, value: value.asText)
    }

    /// Show Diagnostic Output
    ///
    /// Enabling this option causes version and progress information to be written when compiling resource manager resources.
    public static func showDiagnosticOutput(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showDiagnosticOutput, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Diagnostic Output
    ///
    /// Enabling this option causes version and progress information to be written when compiling resource manager resources.
    public static let showDiagnosticOutput: BuildSettingsKey = "REZ_SHOW_DEBUG_OUTPUT"
}

// MARK: Suppress Type Redeclaration Warnings
extension BuildSetting {

    /// Suppress Type Redeclaration Warnings
    ///
    /// Enabling this option causes warnings about redeclared resource types to be suppressed.
    public static var suppressTypeRedeclarationWarnings: BuildSetting { 
        BuildSetting(key: .suppressTypeRedeclarationWarnings, value: "NO")
    }

    /// Suppress Type Redeclaration Warnings
    ///
    /// Enabling this option causes warnings about redeclared resource types to be suppressed.
    public static func suppressTypeRedeclarationWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressTypeRedeclarationWarnings, value: value.asText)
    }

    /// Suppress Type Redeclaration Warnings
    ///
    /// Enabling this option causes warnings about redeclared resource types to be suppressed.
    public static func suppressTypeRedeclarationWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressTypeRedeclarationWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress Type Redeclaration Warnings
    ///
    /// Enabling this option causes warnings about redeclared resource types to be suppressed.
    public static let suppressTypeRedeclarationWarnings: BuildSettingsKey = "REZ_SUPPRESS_REDECLARED_RESOURCE_TYPE_WARNINGS"
}

// MARK: Generate Case-Insensitive Scanner
extension BuildSetting {

    /// Generate Case-Insensitive Scanner
    ///
    /// Enabling this option causes `lex` to generate a case-insensitive scanner. The case of letters given in the `lex` input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in `yytext` will have the preserved case (for example, it will not be folded).
    public static var generateCaseInsensitiveScanner: BuildSetting { 
        BuildSetting(key: .generateCaseInsensitiveScanner, value: "NO")
    }

    /// Generate Case-Insensitive Scanner
    ///
    /// Enabling this option causes `lex` to generate a case-insensitive scanner. The case of letters given in the `lex` input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in `yytext` will have the preserved case (for example, it will not be folded).
    public static func generateCaseInsensitiveScanner(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateCaseInsensitiveScanner, value: value.asText)
    }

    /// Generate Case-Insensitive Scanner
    ///
    /// Enabling this option causes `lex` to generate a case-insensitive scanner. The case of letters given in the `lex` input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in `yytext` will have the preserved case (for example, it will not be folded).
    public static func generateCaseInsensitiveScanner(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateCaseInsensitiveScanner, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Case-Insensitive Scanner
    ///
    /// Enabling this option causes `lex` to generate a case-insensitive scanner. The case of letters given in the `lex` input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in `yytext` will have the preserved case (for example, it will not be folded).
    public static let generateCaseInsensitiveScanner: BuildSettingsKey = "LEX_CASE_INSENSITIVE_SCANNER"
}

// MARK: Insert #line Directives
extension BuildSetting {

    /// Insert #line Directives
    ///
    /// Enabling this option instructs `lex` to insert `#line` directives so error messages in the actions will be correctly located with respect to either the original `lex` input file (if the errors are due to code in the input file), or `lex.yy.c` (if the errors are `lex`’s fault). This option is enabled by default; disabling it passes a flag to `lex` to not insert `#line` directives.
    public static var insertLineDirectives: BuildSetting { 
        BuildSetting(key: .insertLineDirectives, value: "YES")
    }

    /// Insert #line Directives
    ///
    /// Enabling this option instructs `lex` to insert `#line` directives so error messages in the actions will be correctly located with respect to either the original `lex` input file (if the errors are due to code in the input file), or `lex.yy.c` (if the errors are `lex`’s fault). This option is enabled by default; disabling it passes a flag to `lex` to not insert `#line` directives.
    public static func insertLineDirectives(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .insertLineDirectives, value: value.asText)
    }

    /// Insert #line Directives
    ///
    /// Enabling this option instructs `lex` to insert `#line` directives so error messages in the actions will be correctly located with respect to either the original `lex` input file (if the errors are due to code in the input file), or `lex.yy.c` (if the errors are `lex`’s fault). This option is enabled by default; disabling it passes a flag to `lex` to not insert `#line` directives.
    public static func insertLineDirectives(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .insertLineDirectives, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Insert #line Directives
    ///
    /// Enabling this option instructs `lex` to insert `#line` directives so error messages in the actions will be correctly located with respect to either the original `lex` input file (if the errors are due to code in the input file), or `lex.yy.c` (if the errors are `lex`’s fault). This option is enabled by default; disabling it passes a flag to `lex` to not insert `#line` directives.
    public static let insertLineDirectives: BuildSettingsKey = "LEX_INSERT_LINE_DIRECTIVES"
}

// MARK: Suppress Default Rule
extension BuildSetting {

    /// Suppress Default Rule
    ///
    /// Enabling this option causes the default rule (that unmatched scanner input is echoed to `stdout`) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner’s rule set.
    public static var suppressDefaultRule: BuildSetting { 
        BuildSetting(key: .suppressDefaultRule, value: "NO")
    }

    /// Suppress Default Rule
    ///
    /// Enabling this option causes the default rule (that unmatched scanner input is echoed to `stdout`) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner’s rule set.
    public static func suppressDefaultRule(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressDefaultRule, value: value.asText)
    }

    /// Suppress Default Rule
    ///
    /// Enabling this option causes the default rule (that unmatched scanner input is echoed to `stdout`) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner’s rule set.
    public static func suppressDefaultRule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressDefaultRule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress Default Rule
    ///
    /// Enabling this option causes the default rule (that unmatched scanner input is echoed to `stdout`) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner’s rule set.
    public static let suppressDefaultRule: BuildSettingsKey = "LEX_SUPPRESS_DEFAULT_RULE"
}

// MARK: Suppress Warning Messages
extension BuildSetting {

    /// Suppress Warning Messages
    ///
    /// Enabling this option causes `lex` to suppress its warning messages.
    public static var suppressWarningMessages: BuildSetting { 
        BuildSetting(key: .suppressWarningMessages, value: "NO")
    }

    /// Suppress Warning Messages
    ///
    /// Enabling this option causes `lex` to suppress its warning messages.
    public static func suppressWarningMessages(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressWarningMessages, value: value.asText)
    }

    /// Suppress Warning Messages
    ///
    /// Enabling this option causes `lex` to suppress its warning messages.
    public static func suppressWarningMessages(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressWarningMessages, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress Warning Messages
    ///
    /// Enabling this option causes `lex` to suppress its warning messages.
    public static let suppressWarningMessages: BuildSettingsKey = "LEX_SUPPRESS_WARNINGS"
}

// MARK: Generated File Stem
extension BuildSetting {

    /// Generated File Stem
    ///
    /// The file stem to use for the files generated by `yacc`. The files will be named `&lt;stem&gt;.tab.c` and `&lt;stem&gt;.tab.h` based on the value of this setting. The Standard (`y`) option will cause all `yacc` source files in the same target to produce the same output file, and it is not recommended for targets containing multiple `yacc` source files.
    public static var generatedFileStem: BuildSetting { 
        .generatedFileStem(.standard) 
    }

    /// Generated File Stem
    ///
    /// The file stem to use for the files generated by `yacc`. The files will be named `&lt;stem&gt;.tab.c` and `&lt;stem&gt;.tab.h` based on the value of this setting. The Standard (`y`) option will cause all `yacc` source files in the same target to produce the same output file, and it is not recommended for targets containing multiple `yacc` source files.
    public static func generatedFileStem(_ value: GeneratedFileStem) -> BuildSetting { 
        BuildSetting(key: .generatedFileStem, value: \(value))
    }

    /// Generated File Stem
    ///
    /// The file stem to use for the files generated by `yacc`. The files will be named `&lt;stem&gt;.tab.c` and `&lt;stem&gt;.tab.h` based on the value of this setting. The Standard (`y`) option will cause all `yacc` source files in the same target to produce the same output file, and it is not recommended for targets containing multiple `yacc` source files.
    public static func generatedFileStem(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatedFileStem, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generated File Stem
    ///
    /// The file stem to use for the files generated by `yacc`. The files will be named `&lt;stem&gt;.tab.c` and `&lt;stem&gt;.tab.h` based on the value of this setting. The Standard (`y`) option will cause all `yacc` source files in the same target to produce the same output file, and it is not recommended for targets containing multiple `yacc` source files.
    public static let generatedFileStem: BuildSettingsKey = "YACC_GENERATED_FILE_STEM"
}

public enum GeneratedFileStem: String, Hashable, Codable, CustomStringConvertible {
    case inputfilestem = "InputFileStem"
    case standard = "Standard"

    public var description: String {
        rawValue
    }
}

// MARK: Generate Debugging Directives
extension BuildSetting {

    /// Generate Debugging Directives
    ///
    /// Enabling this option changes the preprocessor directives generated by `yacc` so that debugging statements will be incorporated in the compiled code.
    public static var generateDebuggingDirectives: BuildSetting { 
        BuildSetting(key: .generateDebuggingDirectives, value: "NO")
    }

    /// Generate Debugging Directives
    ///
    /// Enabling this option changes the preprocessor directives generated by `yacc` so that debugging statements will be incorporated in the compiled code.
    public static func generateDebuggingDirectives(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateDebuggingDirectives, value: value.asText)
    }

    /// Generate Debugging Directives
    ///
    /// Enabling this option changes the preprocessor directives generated by `yacc` so that debugging statements will be incorporated in the compiled code.
    public static func generateDebuggingDirectives(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateDebuggingDirectives, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Debugging Directives
    ///
    /// Enabling this option changes the preprocessor directives generated by `yacc` so that debugging statements will be incorporated in the compiled code.
    public static let generateDebuggingDirectives: BuildSettingsKey = "YACC_GENERATE_DEBUGGING_DIRECTIVES"
}

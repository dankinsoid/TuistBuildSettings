import ProjectDescription


// MARK: Active Build Action
extension BuildSetting {

    /// Active Build Action
    ///
    /// A string identifying the build system action being performed.
    public static var activeBuildAction: BuildSetting { 
        BuildSetting(key: .activeBuildAction, value: "")
    }

    /// Active Build Action
    ///
    /// A string identifying the build system action being performed.
    public static func activeBuildAction(_ value: String) -> BuildSetting { 
        BuildSetting(key: .activeBuildAction, value: "\(value)")
    }

    /// Active Build Action
    ///
    /// A string identifying the build system action being performed.
    public static func activeBuildAction(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .activeBuildAction, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Active Build Action
    ///
    /// A string identifying the build system action being performed.
    public static let activeBuildAction: BuildSettingsKey = "ACTION"
}

// MARK: Additional SDKs
extension BuildSetting {

    /// Additional SDKs
    ///
    /// The locations of any sparse SDKs that should be layered on top of the one specified by [Base SDK (SDKROOT)](itcaec37c2a6.html#devabcaadbaf). If more than one SDK is listed, the first one has highest precedence. Every SDK specified in this setting should be a "sparse" SDK, for example, not an SDK for an entire macOS release.
    public static var additionalSdks: BuildSetting { 
        BuildSetting(key: .additionalSdks, value: "")
    }

    /// Additional SDKs
    ///
    /// The locations of any sparse SDKs that should be layered on top of the one specified by [Base SDK (SDKROOT)](itcaec37c2a6.html#devabcaadbaf). If more than one SDK is listed, the first one has highest precedence. Every SDK specified in this setting should be a "sparse" SDK, for example, not an SDK for an entire macOS release.
    public static func additionalSdks(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .additionalSdks, value: .array(value))
    }

    /// Additional SDKs
    ///
    /// The locations of any sparse SDKs that should be layered on top of the one specified by [Base SDK (SDKROOT)](itcaec37c2a6.html#devabcaadbaf). If more than one SDK is listed, the first one has highest precedence. Every SDK specified in this setting should be a "sparse" SDK, for example, not an SDK for an entire macOS release.
    public static func additionalSdks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .additionalSdks, inherit: key)
    }

    /// Additional SDKs
    ///
    /// The locations of any sparse SDKs that should be layered on top of the one specified by [Base SDK (SDKROOT)](itcaec37c2a6.html#devabcaadbaf). If more than one SDK is listed, the first one has highest precedence. Every SDK specified in this setting should be a "sparse" SDK, for example, not an SDK for an entire macOS release.
    public static func additionalSdks(_ value: String...) -> BuildSetting { 
        .additionalSdks(value)
    }
}

extension BuildSettingsKey {

    /// Additional SDKs
    ///
    /// The locations of any sparse SDKs that should be layered on top of the one specified by [Base SDK (SDKROOT)](itcaec37c2a6.html#devabcaadbaf). If more than one SDK is listed, the first one has highest precedence. Every SDK specified in this setting should be a "sparse" SDK, for example, not an SDK for an entire macOS release.
    public static let additionalSdks: BuildSettingsKey = "ADDITIONAL_SDKS"
}

// MARK: ALL_OTHER_LDFLAGS
extension BuildSetting {

    /// ALL_OTHER_LDFLAGS
    public static var allOtherLdflags: BuildSetting { 
        BuildSetting(key: .allOtherLdflags, value: "$(LD_FLAGS) $(SECTORDER_FLAGS) $(OTHER_LDFLAGS) $(OTHER_LDFLAGS_$(variant)) $(OTHER_LDFLAGS_$(arch)) $(OTHER_LDFLAGS_$(variant)_$(arch)) $(PRODUCT_SPECIFIC_LDFLAGS)")
    }

    /// ALL_OTHER_LDFLAGS
    public static func allOtherLdflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .allOtherLdflags, value: .array(value))
    }

    /// ALL_OTHER_LDFLAGS
    public static func allOtherLdflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .allOtherLdflags, inherit: key)
    }

    /// ALL_OTHER_LDFLAGS
    public static func allOtherLdflags(_ value: String...) -> BuildSetting { 
        .allOtherLdflags(value)
    }
}

extension BuildSettingsKey {

    /// ALL_OTHER_LDFLAGS
    public static let allOtherLdflags: BuildSettingsKey = "ALL_OTHER_LDFLAGS"
}

// MARK: ALL_OTHER_LIBTOOLFLAGS
extension BuildSetting {

    /// ALL_OTHER_LIBTOOLFLAGS
    public static var allOtherLibtoolflags: BuildSetting { 
        BuildSetting(key: .allOtherLibtoolflags, value: "$(OTHER_LIBTOOLFLAGS) $(OTHER_LIBTOOLFLAGS_$(variant)) $(OTHER_LIBTOOLFLAGS_$(arch)) $(OTHER_LIBTOOLFLAGS_$(variant)_$(arch)) $(PRODUCT_SPECIFIC_LIBTOOLFLAGS)")
    }

    /// ALL_OTHER_LIBTOOLFLAGS
    public static func allOtherLibtoolflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .allOtherLibtoolflags, value: .array(value))
    }

    /// ALL_OTHER_LIBTOOLFLAGS
    public static func allOtherLibtoolflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .allOtherLibtoolflags, inherit: key)
    }

    /// ALL_OTHER_LIBTOOLFLAGS
    public static func allOtherLibtoolflags(_ value: String...) -> BuildSetting { 
        .allOtherLibtoolflags(value)
    }
}

extension BuildSettingsKey {

    /// ALL_OTHER_LIBTOOLFLAGS
    public static let allOtherLibtoolflags: BuildSettingsKey = "ALL_OTHER_LIBTOOLFLAGS"
}

// MARK: Alternate Install Group
extension BuildSetting {

    /// Alternate Install Group
    ///
    /// The group name or gid for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static var alternateInstallGroup: BuildSetting { 
        .alternateInstallGroup(inherit: .installGroup) 
    }

    /// Alternate Install Group
    ///
    /// The group name or gid for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static func alternateInstallGroup(_ value: String) -> BuildSetting { 
        BuildSetting(key: .alternateInstallGroup, value: "\(value)")
    }

    /// Alternate Install Group
    ///
    /// The group name or gid for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static func alternateInstallGroup(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternateInstallGroup, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Alternate Install Group
    ///
    /// The group name or gid for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static let alternateInstallGroup: BuildSettingsKey = "ALTERNATE_GROUP"
}

// MARK: ALTERNATE_LINKER
extension BuildSetting {

    /// ALTERNATE_LINKER
    public static func alternateLinker(_ value: String) -> BuildSetting { 
        BuildSetting(key: .alternateLinker, value: "\(value)")
    }

    /// ALTERNATE_LINKER
    public static func alternateLinker(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternateLinker, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ALTERNATE_LINKER
    public static let alternateLinker: BuildSettingsKey = "ALTERNATE_LINKER"
}

// MARK: Alternate Install Permissions
extension BuildSetting {

    /// Alternate Install Permissions
    ///
    /// Permissions used for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static var alternateInstallPermissions: BuildSetting { 
        .alternateInstallPermissions(inherit: .installPermissions) 
    }

    /// Alternate Install Permissions
    ///
    /// Permissions used for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static func alternateInstallPermissions(_ value: String) -> BuildSetting { 
        BuildSetting(key: .alternateInstallPermissions, value: "\(value)")
    }

    /// Alternate Install Permissions
    ///
    /// Permissions used for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static func alternateInstallPermissions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternateInstallPermissions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Alternate Install Permissions
    ///
    /// Permissions used for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static let alternateInstallPermissions: BuildSettingsKey = "ALTERNATE_MODE"
}

// MARK: Alternate Install Owner
extension BuildSetting {

    /// Alternate Install Owner
    ///
    /// The owner name or uid for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static var alternateInstallOwner: BuildSetting { 
        .alternateInstallOwner(inherit: .installOwner) 
    }

    /// Alternate Install Owner
    ///
    /// The owner name or uid for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static func alternateInstallOwner(_ value: String) -> BuildSetting { 
        BuildSetting(key: .alternateInstallOwner, value: "\(value)")
    }

    /// Alternate Install Owner
    ///
    /// The owner name or uid for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static func alternateInstallOwner(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternateInstallOwner, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Alternate Install Owner
    ///
    /// The owner name or uid for the files listed under the [Alternate Permissions Files (ALTERNATE\_PERMISSIONS\_FILES)](itcaec37c2a6.html#dev40b8becae) setting.
    public static let alternateInstallOwner: BuildSettingsKey = "ALTERNATE_OWNER"
}

// MARK: Alternate Permissions Files
extension BuildSetting {

    /// Alternate Permissions Files
    ///
    /// List of files to which the alternate owner, group and permissions are applied.
    public static var alternatePermissionsFiles: BuildSetting { 
        BuildSetting(key: .alternatePermissionsFiles, value: "")
    }

    /// Alternate Permissions Files
    ///
    /// List of files to which the alternate owner, group and permissions are applied.
    public static func alternatePermissionsFiles(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .alternatePermissionsFiles, value: .array(value))
    }

    /// Alternate Permissions Files
    ///
    /// List of files to which the alternate owner, group and permissions are applied.
    public static func alternatePermissionsFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alternatePermissionsFiles, inherit: key)
    }

    /// Alternate Permissions Files
    ///
    /// List of files to which the alternate owner, group and permissions are applied.
    public static func alternatePermissionsFiles(_ value: String...) -> BuildSetting { 
        .alternatePermissionsFiles(value)
    }
}

extension BuildSettingsKey {

    /// Alternate Permissions Files
    ///
    /// List of files to which the alternate owner, group and permissions are applied.
    public static let alternatePermissionsFiles: BuildSettingsKey = "ALTERNATE_PERMISSIONS_FILES"
}

// MARK: Always Embed Swift Standard Libraries
extension BuildSetting {

    /// Always Embed Swift Standard Libraries
    ///
    /// Always embed the Swift standard libraries in the target's products, even if the target does not contain any Swift code. For example, this should be enabled if the target is embedding other products which contain Swift, or if it is a test target which does not contain Swift but which is testing a product which does. This setting only applies to wrapped products, not to standalone binary products.
    public static var alwaysEmbedSwiftStandardLibraries: BuildSetting { 
        .alwaysEmbedSwiftStandardLibraries(inherit: .embeddedContentContainsSwift) 
    }

    /// Always Embed Swift Standard Libraries
    ///
    /// Always embed the Swift standard libraries in the target's products, even if the target does not contain any Swift code. For example, this should be enabled if the target is embedding other products which contain Swift, or if it is a test target which does not contain Swift but which is testing a product which does. This setting only applies to wrapped products, not to standalone binary products.
    public static func alwaysEmbedSwiftStandardLibraries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .alwaysEmbedSwiftStandardLibraries, value: SettingValue(booleanLiteral: value))
    }

    /// Always Embed Swift Standard Libraries
    ///
    /// Always embed the Swift standard libraries in the target's products, even if the target does not contain any Swift code. For example, this should be enabled if the target is embedding other products which contain Swift, or if it is a test target which does not contain Swift but which is testing a product which does. This setting only applies to wrapped products, not to standalone binary products.
    public static func alwaysEmbedSwiftStandardLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alwaysEmbedSwiftStandardLibraries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Always Embed Swift Standard Libraries
    ///
    /// Always embed the Swift standard libraries in the target's products, even if the target does not contain any Swift code. For example, this should be enabled if the target is embedding other products which contain Swift, or if it is a test target which does not contain Swift but which is testing a product which does. This setting only applies to wrapped products, not to standalone binary products.
    public static let alwaysEmbedSwiftStandardLibraries: BuildSettingsKey = "ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES"
}

// MARK: Always Search User Paths (Deprecated)
extension BuildSetting {

    /// Always Search User Paths (Deprecated)
    @available(*, deprecated, message: "This setting is deprecated as of Xcode 8.3 and may not be supported in future versions. It is recommended that you disable the setting.

If enabled, both `#include <header.h>`-style and `#include "header.h"`-style directives search the paths in [User Header Search Paths (USER\_HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#deved642222b) before [Header Search Paths (HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#dev3c9f85d97). As a consequence, user headers, such as your own `String.h` header, have precedence over system headers when using `#include <header.h>`. This is done using the `-iquote` flag for the paths provided in [User Header Search Paths (USER\_HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#deved642222b). If disabled and your compiler fully supports separate user paths, user headers are only accessible with `#include "header.h"`-style preprocessor directives.

For backwards compatibility reasons, this setting is enabled by default. Disabling it is strongly recommended.")
    public static var alwaysSearchUserPathsDeprecated: BuildSetting { 
        BuildSetting(key: .alwaysSearchUserPathsDeprecated, value: "YES")
    }

    /// Always Search User Paths (Deprecated)
    @available(*, deprecated, message: "This setting is deprecated as of Xcode 8.3 and may not be supported in future versions. It is recommended that you disable the setting.

If enabled, both `#include <header.h>`-style and `#include "header.h"`-style directives search the paths in [User Header Search Paths (USER\_HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#deved642222b) before [Header Search Paths (HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#dev3c9f85d97). As a consequence, user headers, such as your own `String.h` header, have precedence over system headers when using `#include <header.h>`. This is done using the `-iquote` flag for the paths provided in [User Header Search Paths (USER\_HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#deved642222b). If disabled and your compiler fully supports separate user paths, user headers are only accessible with `#include "header.h"`-style preprocessor directives.

For backwards compatibility reasons, this setting is enabled by default. Disabling it is strongly recommended.")
    public static func alwaysSearchUserPathsDeprecated(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .alwaysSearchUserPathsDeprecated, value: SettingValue(booleanLiteral: value))
    }

    /// Always Search User Paths (Deprecated)
    @available(*, deprecated, message: "This setting is deprecated as of Xcode 8.3 and may not be supported in future versions. It is recommended that you disable the setting.

If enabled, both `#include <header.h>`-style and `#include "header.h"`-style directives search the paths in [User Header Search Paths (USER\_HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#deved642222b) before [Header Search Paths (HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#dev3c9f85d97). As a consequence, user headers, such as your own `String.h` header, have precedence over system headers when using `#include <header.h>`. This is done using the `-iquote` flag for the paths provided in [User Header Search Paths (USER\_HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#deved642222b). If disabled and your compiler fully supports separate user paths, user headers are only accessible with `#include "header.h"`-style preprocessor directives.

For backwards compatibility reasons, this setting is enabled by default. Disabling it is strongly recommended.")
    public static func alwaysSearchUserPathsDeprecated(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alwaysSearchUserPathsDeprecated, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Always Search User Paths (Deprecated)
    @available(*, deprecated, message: "This setting is deprecated as of Xcode 8.3 and may not be supported in future versions. It is recommended that you disable the setting.

If enabled, both `#include <header.h>`-style and `#include "header.h"`-style directives search the paths in [User Header Search Paths (USER\_HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#deved642222b) before [Header Search Paths (HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#dev3c9f85d97). As a consequence, user headers, such as your own `String.h` header, have precedence over system headers when using `#include <header.h>`. This is done using the `-iquote` flag for the paths provided in [User Header Search Paths (USER\_HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#deved642222b). If disabled and your compiler fully supports separate user paths, user headers are only accessible with `#include "header.h"`-style preprocessor directives.

For backwards compatibility reasons, this setting is enabled by default. Disabling it is strongly recommended.")
    public static let alwaysSearchUserPathsDeprecated: BuildSettingsKey = "ALWAYS_SEARCH_USER_PATHS"
}

// MARK: ALWAYS_USE_SEPARATE_HEADERMAPS
extension BuildSetting {

    /// ALWAYS_USE_SEPARATE_HEADERMAPS
    public static var alwaysUseSeparateHeadermaps: BuildSetting { 
        BuildSetting(key: .alwaysUseSeparateHeadermaps, value: "NO")
    }

    /// ALWAYS_USE_SEPARATE_HEADERMAPS
    public static func alwaysUseSeparateHeadermaps(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .alwaysUseSeparateHeadermaps, value: SettingValue(booleanLiteral: value))
    }

    /// ALWAYS_USE_SEPARATE_HEADERMAPS
    public static func alwaysUseSeparateHeadermaps(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .alwaysUseSeparateHeadermaps, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ALWAYS_USE_SEPARATE_HEADERMAPS
    public static let alwaysUseSeparateHeadermaps: BuildSettingsKey = "ALWAYS_USE_SEPARATE_HEADERMAPS"
}

// MARK: Require Only App-Extension-Safe API
extension BuildSetting {

    /// Require Only App-Extension-Safe API
    ///
    /// When enabled, this causes the compiler and linker to disallow use of APIs that are not available to app extensions and to disallow linking to frameworks that have not been built with this setting enabled.
    public static var requireOnlyAppExtensionSafeApi: BuildSetting { 
        BuildSetting(key: .requireOnlyAppExtensionSafeApi, value: "NO")
    }

    /// Require Only App-Extension-Safe API
    ///
    /// When enabled, this causes the compiler and linker to disallow use of APIs that are not available to app extensions and to disallow linking to frameworks that have not been built with this setting enabled.
    public static func requireOnlyAppExtensionSafeApi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .requireOnlyAppExtensionSafeApi, value: SettingValue(booleanLiteral: value))
    }

    /// Require Only App-Extension-Safe API
    ///
    /// When enabled, this causes the compiler and linker to disallow use of APIs that are not available to app extensions and to disallow linking to frameworks that have not been built with this setting enabled.
    public static func requireOnlyAppExtensionSafeApi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .requireOnlyAppExtensionSafeApi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Require Only App-Extension-Safe API
    ///
    /// When enabled, this causes the compiler and linker to disallow use of APIs that are not available to app extensions and to disallow linking to frameworks that have not been built with this setting enabled.
    public static let requireOnlyAppExtensionSafeApi: BuildSettingsKey = "APPLICATION_EXTENSION_API_ONLY"
}

// MARK: Convert Copied Files
extension BuildSetting {

    /// Convert Copied Files
    ///
    /// Enabling this setting will cause files in the target's Copy Files build phases to be processed by build rules. For example, property list files (`.plist`) and strings files will be converted as specified by [Property List Output Encoding (PLIST\_FILE\_OUTPUT\_FORMAT)](itcaec37c2a6.html#dev70f6976ed) and [Strings File Output Encoding (STRINGS\_FILE\_OUTPUT\_ENCODING)](itcaec37c2a6.html#dev8d71dff90), respectively.
    public static var convertCopiedFiles: BuildSetting { 
        BuildSetting(key: .convertCopiedFiles, value: "NO")
    }

    /// Convert Copied Files
    ///
    /// Enabling this setting will cause files in the target's Copy Files build phases to be processed by build rules. For example, property list files (`.plist`) and strings files will be converted as specified by [Property List Output Encoding (PLIST\_FILE\_OUTPUT\_FORMAT)](itcaec37c2a6.html#dev70f6976ed) and [Strings File Output Encoding (STRINGS\_FILE\_OUTPUT\_ENCODING)](itcaec37c2a6.html#dev8d71dff90), respectively.
    public static func convertCopiedFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .convertCopiedFiles, value: SettingValue(booleanLiteral: value))
    }

    /// Convert Copied Files
    ///
    /// Enabling this setting will cause files in the target's Copy Files build phases to be processed by build rules. For example, property list files (`.plist`) and strings files will be converted as specified by [Property List Output Encoding (PLIST\_FILE\_OUTPUT\_FORMAT)](itcaec37c2a6.html#dev70f6976ed) and [Strings File Output Encoding (STRINGS\_FILE\_OUTPUT\_ENCODING)](itcaec37c2a6.html#dev8d71dff90), respectively.
    public static func convertCopiedFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .convertCopiedFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Convert Copied Files
    ///
    /// Enabling this setting will cause files in the target's Copy Files build phases to be processed by build rules. For example, property list files (`.plist`) and strings files will be converted as specified by [Property List Output Encoding (PLIST\_FILE\_OUTPUT\_FORMAT)](itcaec37c2a6.html#dev70f6976ed) and [Strings File Output Encoding (STRINGS\_FILE\_OUTPUT\_ENCODING)](itcaec37c2a6.html#dev8d71dff90), respectively.
    public static let convertCopiedFiles: BuildSettingsKey = "APPLY_RULES_IN_COPY_FILES"
}

// MARK: Process Header Files
extension BuildSetting {

    /// Process Header Files
    ///
    /// Enabling this setting will cause all Public and Private headers in the target's Copy Headers build phase to be processed by build rules. This allows custom build rules to be defined to process these headers. Custom script rules can define their outputs relative to `HEADER_OUTPUT_DIR`, which will be provided to that script, taking the header visibility into account. The scripts are also passed `SCRIPT_HEADER_VISIBILITY` ("public" or "private"). Files that should not be processed by build rules may need to be moved to a Copy Files build phase when this setting is enabled.
    public static var processHeaderFiles: BuildSetting { 
        BuildSetting(key: .processHeaderFiles, value: "NO")
    }

    /// Process Header Files
    ///
    /// Enabling this setting will cause all Public and Private headers in the target's Copy Headers build phase to be processed by build rules. This allows custom build rules to be defined to process these headers. Custom script rules can define their outputs relative to `HEADER_OUTPUT_DIR`, which will be provided to that script, taking the header visibility into account. The scripts are also passed `SCRIPT_HEADER_VISIBILITY` ("public" or "private"). Files that should not be processed by build rules may need to be moved to a Copy Files build phase when this setting is enabled.
    public static func processHeaderFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .processHeaderFiles, value: SettingValue(booleanLiteral: value))
    }

    /// Process Header Files
    ///
    /// Enabling this setting will cause all Public and Private headers in the target's Copy Headers build phase to be processed by build rules. This allows custom build rules to be defined to process these headers. Custom script rules can define their outputs relative to `HEADER_OUTPUT_DIR`, which will be provided to that script, taking the header visibility into account. The scripts are also passed `SCRIPT_HEADER_VISIBILITY` ("public" or "private"). Files that should not be processed by build rules may need to be moved to a Copy Files build phase when this setting is enabled.
    public static func processHeaderFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .processHeaderFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Process Header Files
    ///
    /// Enabling this setting will cause all Public and Private headers in the target's Copy Headers build phase to be processed by build rules. This allows custom build rules to be defined to process these headers. Custom script rules can define their outputs relative to `HEADER_OUTPUT_DIR`, which will be provided to that script, taking the header visibility into account. The scripts are also passed `SCRIPT_HEADER_VISIBILITY` ("public" or "private"). Files that should not be processed by build rules may need to be moved to a Copy Files build phase when this setting is enabled.
    public static let processHeaderFiles: BuildSettingsKey = "APPLY_RULES_IN_COPY_HEADERS"
}

// MARK: Architectures
extension BuildSetting {

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static var architectures: BuildSetting { 
        BuildSetting(key: .architectures, value: "$(ARCHS_STANDARD)")
    }

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static func architectures(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .architectures, value: .array(value))
    }

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static func architectures(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .architectures, inherit: key)
    }

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static func architectures(_ value: String...) -> BuildSetting { 
        .architectures(value)
    }
}

extension BuildSettingsKey {

    /// Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform. If more than one architecture is specified, a universal binary will be produced.
    public static let architectures: BuildSettingsKey = "ARCHS"
}

// MARK: ARCHS_STANDARD_32_64_BIT
extension BuildSetting {

    /// ARCHS_STANDARD_32_64_BIT
    public static func archsStandard3264Bit(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .archsStandard3264Bit, value: .array(value))
    }

    /// ARCHS_STANDARD_32_64_BIT
    public static func archsStandard3264Bit(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .archsStandard3264Bit, inherit: key)
    }

    /// ARCHS_STANDARD_32_64_BIT
    public static func archsStandard3264Bit(_ value: String...) -> BuildSetting { 
        .archsStandard3264Bit(value)
    }
}

extension BuildSettingsKey {

    /// ARCHS_STANDARD_32_64_BIT
    public static let archsStandard3264Bit: BuildSettingsKey = "ARCHS_STANDARD_32_64_BIT"
}

// MARK: ARCHS_STANDARD_32_BIT
extension BuildSetting {

    /// ARCHS_STANDARD_32_BIT
    public static func archsStandard32Bit(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .archsStandard32Bit, value: .array(value))
    }

    /// ARCHS_STANDARD_32_BIT
    public static func archsStandard32Bit(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .archsStandard32Bit, inherit: key)
    }

    /// ARCHS_STANDARD_32_BIT
    public static func archsStandard32Bit(_ value: String...) -> BuildSetting { 
        .archsStandard32Bit(value)
    }
}

extension BuildSettingsKey {

    /// ARCHS_STANDARD_32_BIT
    public static let archsStandard32Bit: BuildSettingsKey = "ARCHS_STANDARD_32_BIT"
}

// MARK: ARCHS_STANDARD_64_BIT
extension BuildSetting {

    /// ARCHS_STANDARD_64_BIT
    public static func archsStandard64Bit(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .archsStandard64Bit, value: .array(value))
    }

    /// ARCHS_STANDARD_64_BIT
    public static func archsStandard64Bit(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .archsStandard64Bit, inherit: key)
    }

    /// ARCHS_STANDARD_64_BIT
    public static func archsStandard64Bit(_ value: String...) -> BuildSetting { 
        .archsStandard64Bit(value)
    }
}

extension BuildSettingsKey {

    /// ARCHS_STANDARD_64_BIT
    public static let archsStandard64Bit: BuildSettingsKey = "ARCHS_STANDARD_64_BIT"
}

// MARK: ARCHS_STANDARD_INCLUDING_64_BIT
extension BuildSetting {

    /// ARCHS_STANDARD_INCLUDING_64_BIT
    public static func archsStandardIncluding64Bit(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .archsStandardIncluding64Bit, value: .array(value))
    }

    /// ARCHS_STANDARD_INCLUDING_64_BIT
    public static func archsStandardIncluding64Bit(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .archsStandardIncluding64Bit, inherit: key)
    }

    /// ARCHS_STANDARD_INCLUDING_64_BIT
    public static func archsStandardIncluding64Bit(_ value: String...) -> BuildSetting { 
        .archsStandardIncluding64Bit(value)
    }
}

extension BuildSettingsKey {

    /// ARCHS_STANDARD_INCLUDING_64_BIT
    public static let archsStandardIncluding64Bit: BuildSettingsKey = "ARCHS_STANDARD_INCLUDING_64_BIT"
}

// MARK: Asset Catalog App Icon Set Name
extension BuildSetting {

    /// Asset Catalog App Icon Set Name
    ///
    /// Name of an asset catalog app icon set whose contents will be merged into the `Info.plist`.
    public static func assetCatalogAppIconSetName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetCatalogAppIconSetName, value: "\(value)")
    }

    /// Asset Catalog App Icon Set Name
    ///
    /// Name of an asset catalog app icon set whose contents will be merged into the `Info.plist`.
    public static func assetCatalogAppIconSetName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetCatalogAppIconSetName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Asset Catalog App Icon Set Name
    ///
    /// Name of an asset catalog app icon set whose contents will be merged into the `Info.plist`.
    public static let assetCatalogAppIconSetName: BuildSettingsKey = "ASSETCATALOG_COMPILER_APPICON_NAME"
}

// MARK: Watch Complication Name
extension BuildSetting {

    /// Watch Complication Name
    ///
    /// The name of a watch complication to use from the asset catalog.
    public static func watchComplicationName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .watchComplicationName, value: "\(value)")
    }

    /// Watch Complication Name
    ///
    /// The name of a watch complication to use from the asset catalog.
    public static func watchComplicationName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .watchComplicationName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Watch Complication Name
    ///
    /// The name of a watch complication to use from the asset catalog.
    public static let watchComplicationName: BuildSettingsKey = "ASSETCATALOG_COMPILER_COMPLICATION_NAME"
}

// MARK: ASSETCATALOG_COMPILER_COMPRESS_PNGS
extension BuildSetting {

    /// ASSETCATALOG_COMPILER_COMPRESS_PNGS
    public static var assetcatalogCompilerCompressPngs: BuildSetting { 
        .assetcatalogCompilerCompressPngs(inherit: .compressPngFiles) 
    }

    /// ASSETCATALOG_COMPILER_COMPRESS_PNGS
    public static func assetcatalogCompilerCompressPngs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerCompressPngs, value: SettingValue(booleanLiteral: value))
    }

    /// ASSETCATALOG_COMPILER_COMPRESS_PNGS
    public static func assetcatalogCompilerCompressPngs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerCompressPngs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ASSETCATALOG_COMPILER_COMPRESS_PNGS
    public static let assetcatalogCompilerCompressPngs: BuildSettingsKey = "ASSETCATALOG_COMPILER_COMPRESS_PNGS"
}

// MARK: ASSETCATALOG_COMPILER_DEPENDENCY_INFO_FILE
extension BuildSetting {

    /// ASSETCATALOG_COMPILER_DEPENDENCY_INFO_FILE
    public static var assetcatalogCompilerDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerDependencyInfoFile, value: "$(TARGET_TEMP_DIR)/assetcatalog_dependencies")
    }

    /// ASSETCATALOG_COMPILER_DEPENDENCY_INFO_FILE
    public static func assetcatalogCompilerDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerDependencyInfoFile, value: "\(value)")
    }

    /// ASSETCATALOG_COMPILER_DEPENDENCY_INFO_FILE
    public static func assetcatalogCompilerDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ASSETCATALOG_COMPILER_DEPENDENCY_INFO_FILE
    public static let assetcatalogCompilerDependencyInfoFile: BuildSettingsKey = "ASSETCATALOG_COMPILER_DEPENDENCY_INFO_FILE"
}

// MARK: ASSETCATALOG_COMPILER_ENABLE_ON_DEMAND_RESOURCES
extension BuildSetting {

    /// ASSETCATALOG_COMPILER_ENABLE_ON_DEMAND_RESOURCES
    public static var assetcatalogCompilerEnableOnDemandResources: BuildSetting { 
        .assetcatalogCompilerEnableOnDemandResources(inherit: .enableOnDemandResources) 
    }

    /// ASSETCATALOG_COMPILER_ENABLE_ON_DEMAND_RESOURCES
    public static func assetcatalogCompilerEnableOnDemandResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerEnableOnDemandResources, value: SettingValue(booleanLiteral: value))
    }

    /// ASSETCATALOG_COMPILER_ENABLE_ON_DEMAND_RESOURCES
    public static func assetcatalogCompilerEnableOnDemandResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerEnableOnDemandResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ASSETCATALOG_COMPILER_ENABLE_ON_DEMAND_RESOURCES
    public static let assetcatalogCompilerEnableOnDemandResources: BuildSettingsKey = "ASSETCATALOG_COMPILER_ENABLE_ON_DEMAND_RESOURCES"
}

// MARK: ASSETCATALOG_COMPILER_FLATTENED_APP_ICON_PATH
extension BuildSetting {

    /// ASSETCATALOG_COMPILER_FLATTENED_APP_ICON_PATH
    public static func assetcatalogCompilerFlattenedAppIconPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerFlattenedAppIconPath, value: "\(value)")
    }

    /// ASSETCATALOG_COMPILER_FLATTENED_APP_ICON_PATH
    public static func assetcatalogCompilerFlattenedAppIconPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerFlattenedAppIconPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ASSETCATALOG_COMPILER_FLATTENED_APP_ICON_PATH
    public static let assetcatalogCompilerFlattenedAppIconPath: BuildSettingsKey = "ASSETCATALOG_COMPILER_FLATTENED_APP_ICON_PATH"
}

// MARK: Global Accent Color Name
extension BuildSetting {

    /// Global Accent Color Name
    ///
    /// The name of a color resource to use as a the target's accent color, used as the default tint color on iOS and watchOS, and accent color on macOS.
    public static func globalAccentColorName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .globalAccentColorName, value: "\(value)")
    }

    /// Global Accent Color Name
    ///
    /// The name of a color resource to use as a the target's accent color, used as the default tint color on iOS and watchOS, and accent color on macOS.
    public static func globalAccentColorName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .globalAccentColorName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Global Accent Color Name
    ///
    /// The name of a color resource to use as a the target's accent color, used as the default tint color on iOS and watchOS, and accent color on macOS.
    public static let globalAccentColorName: BuildSettingsKey = "ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME"
}

// MARK: Include Asset Localizations in Info.plist
extension BuildSetting {

    /// Include Asset Localizations in Info.plist
    ///
    /// When enabled, includes the localization information of the selected assets in the generated partial Info.plist file under the CFBundleLocalizations key. This will allow the assets to be used at runtime in the absence of a corresponding lproj directory in the bundle.
    public static var includeAssetLocalizationsInInfoPlist: BuildSetting { 
        BuildSetting(key: .includeAssetLocalizationsInInfoPlist, value: "YES")
    }

    /// Include Asset Localizations in Info.plist
    ///
    /// When enabled, includes the localization information of the selected assets in the generated partial Info.plist file under the CFBundleLocalizations key. This will allow the assets to be used at runtime in the absence of a corresponding lproj directory in the bundle.
    public static func includeAssetLocalizationsInInfoPlist(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .includeAssetLocalizationsInInfoPlist, value: SettingValue(booleanLiteral: value))
    }

    /// Include Asset Localizations in Info.plist
    ///
    /// When enabled, includes the localization information of the selected assets in the generated partial Info.plist file under the CFBundleLocalizations key. This will allow the assets to be used at runtime in the absence of a corresponding lproj directory in the bundle.
    public static func includeAssetLocalizationsInInfoPlist(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .includeAssetLocalizationsInInfoPlist, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Include Asset Localizations in Info.plist
    ///
    /// When enabled, includes the localization information of the selected assets in the generated partial Info.plist file under the CFBundleLocalizations key. This will allow the assets to be used at runtime in the absence of a corresponding lproj directory in the bundle.
    public static let includeAssetLocalizationsInInfoPlist: BuildSettingsKey = "ASSETCATALOG_COMPILER_INCLUDE_INFOPLIST_LOCALIZATIONS"
}

// MARK: Include Sticker Content
extension BuildSetting {

    /// Include Sticker Content
    public static var includeStickerContent: BuildSetting { 
        BuildSetting(key: .includeStickerContent, value: "NO")
    }

    /// Include Sticker Content
    public static func includeStickerContent(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .includeStickerContent, value: SettingValue(booleanLiteral: value))
    }

    /// Include Sticker Content
    public static func includeStickerContent(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .includeStickerContent, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Include Sticker Content
    public static let includeStickerContent: BuildSettingsKey = "ASSETCATALOG_COMPILER_INCLUDE_STICKER_CONTENT"
}

// MARK: ASSETCATALOG_COMPILER_INFOPLIST_CONTENT_FILE
extension BuildSetting {

    /// ASSETCATALOG_COMPILER_INFOPLIST_CONTENT_FILE
    public static var assetcatalogCompilerInfoplistContentFile: BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerInfoplistContentFile, value: "$(TARGET_TEMP_DIR)/assetcatalog_generated_info.plist")
    }

    /// ASSETCATALOG_COMPILER_INFOPLIST_CONTENT_FILE
    public static func assetcatalogCompilerInfoplistContentFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerInfoplistContentFile, value: "\(value)")
    }

    /// ASSETCATALOG_COMPILER_INFOPLIST_CONTENT_FILE
    public static func assetcatalogCompilerInfoplistContentFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerInfoplistContentFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ASSETCATALOG_COMPILER_INFOPLIST_CONTENT_FILE
    public static let assetcatalogCompilerInfoplistContentFile: BuildSettingsKey = "ASSETCATALOG_COMPILER_INFOPLIST_CONTENT_FILE"
}

// MARK: Asset Catalog Launch Image Set Name
extension BuildSetting {

    /// Asset Catalog Launch Image Set Name
    ///
    /// Name of an asset catalog launch image set whose contents will be merged into the `Info.plist`.
    public static func assetCatalogLaunchImageSetName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetCatalogLaunchImageSetName, value: "\(value)")
    }

    /// Asset Catalog Launch Image Set Name
    ///
    /// Name of an asset catalog launch image set whose contents will be merged into the `Info.plist`.
    public static func assetCatalogLaunchImageSetName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetCatalogLaunchImageSetName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Asset Catalog Launch Image Set Name
    ///
    /// Name of an asset catalog launch image set whose contents will be merged into the `Info.plist`.
    public static let assetCatalogLaunchImageSetName: BuildSettingsKey = "ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME"
}

// MARK: Leaderboard Identifier Prefix
extension BuildSetting {

    /// Leaderboard Identifier Prefix
    ///
    /// Leaderboards in the asset catalog may optionally specify a Game Center identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static var leaderboardIdentifierPrefix: BuildSetting { 
        BuildSetting(key: .leaderboardIdentifierPrefix, value: "$(PRODUCT_NAME:identifier).game-center.leaderboard.")
    }

    /// Leaderboard Identifier Prefix
    ///
    /// Leaderboards in the asset catalog may optionally specify a Game Center identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static func leaderboardIdentifierPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .leaderboardIdentifierPrefix, value: "\(value)")
    }

    /// Leaderboard Identifier Prefix
    ///
    /// Leaderboards in the asset catalog may optionally specify a Game Center identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static func leaderboardIdentifierPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .leaderboardIdentifierPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Leaderboard Identifier Prefix
    ///
    /// Leaderboards in the asset catalog may optionally specify a Game Center identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static let leaderboardIdentifierPrefix: BuildSettingsKey = "ASSETCATALOG_COMPILER_LEADERBOARD_IDENTIFIER_PREFIX"
}

// MARK: Leaderboard Set Identifier Prefix
extension BuildSetting {

    /// Leaderboard Set Identifier Prefix
    ///
    /// Leaderboard sets in the asset catalog may optionally specify a Game Center identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static var leaderboardSetIdentifierPrefix: BuildSetting { 
        BuildSetting(key: .leaderboardSetIdentifierPrefix, value: "$(PRODUCT_NAME:identifier).game-center.leaderboard-set.")
    }

    /// Leaderboard Set Identifier Prefix
    ///
    /// Leaderboard sets in the asset catalog may optionally specify a Game Center identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static func leaderboardSetIdentifierPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .leaderboardSetIdentifierPrefix, value: "\(value)")
    }

    /// Leaderboard Set Identifier Prefix
    ///
    /// Leaderboard sets in the asset catalog may optionally specify a Game Center identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static func leaderboardSetIdentifierPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .leaderboardSetIdentifierPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Leaderboard Set Identifier Prefix
    ///
    /// Leaderboard sets in the asset catalog may optionally specify a Game Center identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static let leaderboardSetIdentifierPrefix: BuildSettingsKey = "ASSETCATALOG_COMPILER_LEADERBOARD_SET_IDENTIFIER_PREFIX"
}

// MARK: Optimization
extension BuildSetting {

    /// Optimization
    ///
    /// With no value, the compiler uses the default optimization. You can also specify `time` to optimize for speed of access or `space` to optimize for a smaller compiled asset catalogs.
    public static var optimization: BuildSetting { 
        .optimization(.empty) 
    }

    /// Optimization
    ///
    /// With no value, the compiler uses the default optimization. You can also specify `time` to optimize for speed of access or `space` to optimize for a smaller compiled asset catalogs.
    public static func optimization(_ value: Optimization) -> BuildSetting { 
        BuildSetting(key: .optimization, value: "\(value)")
    }

    /// Optimization
    ///
    /// With no value, the compiler uses the default optimization. You can also specify `time` to optimize for speed of access or `space` to optimize for a smaller compiled asset catalogs.
    public static func optimization(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimization, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Optimization
    ///
    /// With no value, the compiler uses the default optimization. You can also specify `time` to optimize for speed of access or `space` to optimize for a smaller compiled asset catalogs.
    public static let optimization: BuildSettingsKey = "ASSETCATALOG_COMPILER_OPTIMIZATION"
}

public enum Optimization: String, Hashable, Codable, CustomStringConvertible {
    case empty = ""
    case time = "time"
    case space = "space"

    public var description: String {
        rawValue
    }
}

// MARK: Standalone Icon File Behavior
extension BuildSetting {

    /// Standalone Icon File Behavior
    ///
    /// Controls whether loose PNG or ICNS files are created for the app icon, in addition to including the content in the Assets.car file. By default, a small subset of sizes are included as loose files, allowing external management tools to display a representative icon without reading the CAR file. This can be set to 'all' or 'none' to include more or fewer icon sizes as loose files.
    public static var standaloneIconFileBehavior: BuildSetting { 
        .standaloneIconFileBehavior(.default) 
    }

    /// Standalone Icon File Behavior
    ///
    /// Controls whether loose PNG or ICNS files are created for the app icon, in addition to including the content in the Assets.car file. By default, a small subset of sizes are included as loose files, allowing external management tools to display a representative icon without reading the CAR file. This can be set to 'all' or 'none' to include more or fewer icon sizes as loose files.
    public static func standaloneIconFileBehavior(_ value: StandaloneIconFileBehavior) -> BuildSetting { 
        BuildSetting(key: .standaloneIconFileBehavior, value: "\(value)")
    }

    /// Standalone Icon File Behavior
    ///
    /// Controls whether loose PNG or ICNS files are created for the app icon, in addition to including the content in the Assets.car file. By default, a small subset of sizes are included as loose files, allowing external management tools to display a representative icon without reading the CAR file. This can be set to 'all' or 'none' to include more or fewer icon sizes as loose files.
    public static func standaloneIconFileBehavior(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .standaloneIconFileBehavior, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Standalone Icon File Behavior
    ///
    /// Controls whether loose PNG or ICNS files are created for the app icon, in addition to including the content in the Assets.car file. By default, a small subset of sizes are included as loose files, allowing external management tools to display a representative icon without reading the CAR file. This can be set to 'all' or 'none' to include more or fewer icon sizes as loose files.
    public static let standaloneIconFileBehavior: BuildSettingsKey = "ASSETCATALOG_COMPILER_STANDALONE_ICON_BEHAVIOR"
}

public enum StandaloneIconFileBehavior: String, Hashable, Codable, CustomStringConvertible {
    case `default` = "default"
    case all = "all"
    case none = "none"

    public var description: String {
        rawValue
    }
}

// MARK: Sticker Pack Identifier Prefix
extension BuildSetting {

    /// Sticker Pack Identifier Prefix
    ///
    /// Sticker Packs in the asset catalog may optionally specify an identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static func stickerPackIdentifierPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .stickerPackIdentifierPrefix, value: "\(value)")
    }

    /// Sticker Pack Identifier Prefix
    ///
    /// Sticker Packs in the asset catalog may optionally specify an identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static func stickerPackIdentifierPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stickerPackIdentifierPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Sticker Pack Identifier Prefix
    ///
    /// Sticker Packs in the asset catalog may optionally specify an identifier. If they do not, their name will be prefixed by this value to form an automatically generated identifier.
    public static let stickerPackIdentifierPrefix: BuildSettingsKey = "ASSETCATALOG_COMPILER_STICKER_PACK_IDENTIFIER_PREFIX"
}

// MARK: ASSETCATALOG_COMPILER_STICKER_PACK_STRINGS
extension BuildSetting {

    /// ASSETCATALOG_COMPILER_STICKER_PACK_STRINGS
    public static var assetcatalogCompilerStickerPackStrings: BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerStickerPackStrings, value: "")
    }

    /// ASSETCATALOG_COMPILER_STICKER_PACK_STRINGS
    public static func assetcatalogCompilerStickerPackStrings(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .assetcatalogCompilerStickerPackStrings, value: .array(value))
    }

    /// ASSETCATALOG_COMPILER_STICKER_PACK_STRINGS
    public static func assetcatalogCompilerStickerPackStrings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogCompilerStickerPackStrings, inherit: key)
    }

    /// ASSETCATALOG_COMPILER_STICKER_PACK_STRINGS
    public static func assetcatalogCompilerStickerPackStrings(_ value: String...) -> BuildSetting { 
        .assetcatalogCompilerStickerPackStrings(value)
    }
}

extension BuildSettingsKey {

    /// ASSETCATALOG_COMPILER_STICKER_PACK_STRINGS
    public static let assetcatalogCompilerStickerPackStrings: BuildSettingsKey = "ASSETCATALOG_COMPILER_STICKER_PACK_STRINGS"
}

// MARK: Stickers Icon Role
extension BuildSetting {

    /// Stickers Icon Role
    public static func stickersIconRole(_ value: StickersIconRole) -> BuildSetting { 
        BuildSetting(key: .stickersIconRole, value: "\(value)")
    }

    /// Stickers Icon Role
    public static func stickersIconRole(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stickersIconRole, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Stickers Icon Role
    public static let stickersIconRole: BuildSettingsKey = "ASSETCATALOG_COMPILER_TARGET_STICKERS_ICON_ROLE"
}

public enum StickersIconRole: String, Hashable, Codable, CustomStringConvertible {
    case empty = ""
    case hostApp = "host-app"
    case `extension` = "extension"

    public var description: String {
        rawValue
    }
}

// MARK: Widget Background Color Name
extension BuildSetting {

    /// Widget Background Color Name
    ///
    /// The name of a color resource to use as the background color for a widget.
    public static func widgetBackgroundColorName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .widgetBackgroundColorName, value: "\(value)")
    }

    /// Widget Background Color Name
    ///
    /// The name of a color resource to use as the background color for a widget.
    public static func widgetBackgroundColorName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .widgetBackgroundColorName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Widget Background Color Name
    ///
    /// The name of a color resource to use as the background color for a widget.
    public static let widgetBackgroundColorName: BuildSettingsKey = "ASSETCATALOG_COMPILER_WIDGET_BACKGROUND_COLOR_NAME"
}

// MARK: ASSETCATALOG_FILTER_FOR_DEVICE_MODEL
extension BuildSetting {

    /// ASSETCATALOG_FILTER_FOR_DEVICE_MODEL
    public static var assetcatalogFilterForDeviceModel: BuildSetting { 
        BuildSetting(key: .assetcatalogFilterForDeviceModel, value: "$(TARGET_DEVICE_MODEL)")
    }

    /// ASSETCATALOG_FILTER_FOR_DEVICE_MODEL
    public static func assetcatalogFilterForDeviceModel(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetcatalogFilterForDeviceModel, value: "\(value)")
    }

    /// ASSETCATALOG_FILTER_FOR_DEVICE_MODEL
    public static func assetcatalogFilterForDeviceModel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogFilterForDeviceModel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ASSETCATALOG_FILTER_FOR_DEVICE_MODEL
    public static let assetcatalogFilterForDeviceModel: BuildSettingsKey = "ASSETCATALOG_FILTER_FOR_DEVICE_MODEL"
}

// MARK: ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION
extension BuildSetting {

    /// ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION
    public static var assetcatalogFilterForDeviceOsVersion: BuildSetting { 
        BuildSetting(key: .assetcatalogFilterForDeviceOsVersion, value: "$(TARGET_DEVICE_OS_VERSION)")
    }

    /// ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION
    public static func assetcatalogFilterForDeviceOsVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetcatalogFilterForDeviceOsVersion, value: "\(value)")
    }

    /// ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION
    public static func assetcatalogFilterForDeviceOsVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogFilterForDeviceOsVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION
    public static let assetcatalogFilterForDeviceOsVersion: BuildSettingsKey = "ASSETCATALOG_FILTER_FOR_DEVICE_OS_VERSION"
}

// MARK: Show Notices
extension BuildSetting {

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of asset catalogs.
    public static var showNotices: BuildSetting { 
        BuildSetting(key: .showNotices, value: "YES")
    }

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of asset catalogs.
    public static func showNotices(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showNotices, value: SettingValue(booleanLiteral: value))
    }

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of asset catalogs.
    public static func showNotices(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showNotices, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of asset catalogs.
    public static let showNotices: BuildSettingsKey = "ASSETCATALOG_NOTICES"
}

// MARK: Asset Catalog Other Flags
extension BuildSetting {

    /// Asset Catalog Other Flags
    ///
    /// Pass additional flags through to the asset catalog compiler.
    public static var assetCatalogOtherFlags: BuildSetting { 
        BuildSetting(key: .assetCatalogOtherFlags, value: "")
    }

    /// Asset Catalog Other Flags
    ///
    /// Pass additional flags through to the asset catalog compiler.
    public static func assetCatalogOtherFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .assetCatalogOtherFlags, value: .array(value))
    }

    /// Asset Catalog Other Flags
    ///
    /// Pass additional flags through to the asset catalog compiler.
    public static func assetCatalogOtherFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetCatalogOtherFlags, inherit: key)
    }

    /// Asset Catalog Other Flags
    ///
    /// Pass additional flags through to the asset catalog compiler.
    public static func assetCatalogOtherFlags(_ value: String...) -> BuildSetting { 
        .assetCatalogOtherFlags(value)
    }
}

extension BuildSettingsKey {

    /// Asset Catalog Other Flags
    ///
    /// Pass additional flags through to the asset catalog compiler.
    public static let assetCatalogOtherFlags: BuildSettingsKey = "ASSETCATALOG_OTHER_FLAGS"
}

// MARK: ASSETCATALOG_OUTPUT_FORMAT
extension BuildSetting {

    /// ASSETCATALOG_OUTPUT_FORMAT
    public static var assetcatalogOutputFormat: BuildSetting { 
        .assetcatalogOutputFormat(.humanReadableText) 
    }

    /// ASSETCATALOG_OUTPUT_FORMAT
    public static func assetcatalogOutputFormat(_ value: AssetcatalogOutputFormat) -> BuildSetting { 
        BuildSetting(key: .assetcatalogOutputFormat, value: "\(value)")
    }

    /// ASSETCATALOG_OUTPUT_FORMAT
    public static func assetcatalogOutputFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetcatalogOutputFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ASSETCATALOG_OUTPUT_FORMAT
    public static let assetcatalogOutputFormat: BuildSettingsKey = "ASSETCATALOG_OUTPUT_FORMAT"
}

public enum AssetcatalogOutputFormat: String, Hashable, Codable, CustomStringConvertible {
    case humanReadableText = "human-readable-text"

    public var description: String {
        rawValue
    }
}

// MARK: Show Warnings
extension BuildSetting {

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of asset catalogs.
    public static var showWarnings: BuildSetting { 
        BuildSetting(key: .showWarnings, value: "YES")
    }

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of asset catalogs.
    public static func showWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of asset catalogs.
    public static func showWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of asset catalogs.
    public static let showWarnings: BuildSettingsKey = "ASSETCATALOG_WARNINGS"
}

// MARK: Asset Pack Manifest URL Prefix
extension BuildSetting {

    /// Asset Pack Manifest URL Prefix
    ///
    /// If set to anything other than the empty string, every URL in the `AssetPackManifest.plist` file will consist of this string with the name of the asset pack appended. If not set, the URLs in the `AssetPackManifest.plist` will be formed as appropriate for the build location of the asset packs. The prefix string is not escaped or quoted in any way, so any necessary escaping must be part of the URL string. This setting affects only URLs in the `AssetPackManifest.plist` file  it does not affect where asset packs are built in the local file system.
    public static var assetPackManifestUrlPrefix: BuildSetting { 
        BuildSetting(key: .assetPackManifestUrlPrefix, value: "")
    }

    /// Asset Pack Manifest URL Prefix
    ///
    /// If set to anything other than the empty string, every URL in the `AssetPackManifest.plist` file will consist of this string with the name of the asset pack appended. If not set, the URLs in the `AssetPackManifest.plist` will be formed as appropriate for the build location of the asset packs. The prefix string is not escaped or quoted in any way, so any necessary escaping must be part of the URL string. This setting affects only URLs in the `AssetPackManifest.plist` file  it does not affect where asset packs are built in the local file system.
    public static func assetPackManifestUrlPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .assetPackManifestUrlPrefix, value: "\(value)")
    }

    /// Asset Pack Manifest URL Prefix
    ///
    /// If set to anything other than the empty string, every URL in the `AssetPackManifest.plist` file will consist of this string with the name of the asset pack appended. If not set, the URLs in the `AssetPackManifest.plist` will be formed as appropriate for the build location of the asset packs. The prefix string is not escaped or quoted in any way, so any necessary escaping must be part of the URL string. This setting affects only URLs in the `AssetPackManifest.plist` file  it does not affect where asset packs are built in the local file system.
    public static func assetPackManifestUrlPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .assetPackManifestUrlPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Asset Pack Manifest URL Prefix
    ///
    /// If set to anything other than the empty string, every URL in the `AssetPackManifest.plist` file will consist of this string with the name of the asset pack appended. If not set, the URLs in the `AssetPackManifest.plist` will be formed as appropriate for the build location of the asset packs. The prefix string is not escaped or quoted in any way, so any necessary escaping must be part of the URL string. This setting affects only URLs in the `AssetPackManifest.plist` file  it does not affect where asset packs are built in the local file system.
    public static let assetPackManifestUrlPrefix: BuildSettingsKey = "ASSET_PACK_MANIFEST_URL_PREFIX"
}

// MARK: AdditionalCommandLineArguments
extension BuildSetting {

    /// AdditionalCommandLineArguments
    public static func additionalcommandlinearguments(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .additionalcommandlinearguments, value: .array(value))
    }

    /// AdditionalCommandLineArguments
    public static func additionalcommandlinearguments(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .additionalcommandlinearguments, inherit: key)
    }

    /// AdditionalCommandLineArguments
    public static func additionalcommandlinearguments(_ value: String...) -> BuildSetting { 
        .additionalcommandlinearguments(value)
    }
}

extension BuildSettingsKey {

    /// AdditionalCommandLineArguments
    public static let additionalcommandlinearguments: BuildSettingsKey = "AdditionalCommandLineArguments"
}

// MARK: AdditionalContentFilePaths
extension BuildSetting {

    /// AdditionalContentFilePaths
    public static func additionalcontentfilepaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .additionalcontentfilepaths, value: .array(value))
    }

    /// AdditionalContentFilePaths
    public static func additionalcontentfilepaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .additionalcontentfilepaths, inherit: key)
    }

    /// AdditionalContentFilePaths
    public static func additionalcontentfilepaths(_ value: String...) -> BuildSetting { 
        .additionalcontentfilepaths(value)
    }
}

extension BuildSettingsKey {

    /// AdditionalContentFilePaths
    public static let additionalcontentfilepaths: BuildSettingsKey = "AdditionalContentFilePaths"
}

// MARK: AdditionalInfoFileKeys
extension BuildSetting {

    /// AdditionalInfoFileKeys
    public static func additionalinfofilekeys(_ value: String) -> BuildSetting { 
        BuildSetting(key: .additionalinfofilekeys, value: "\(value)")
    }

    /// AdditionalInfoFileKeys
    public static func additionalinfofilekeys(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .additionalinfofilekeys, inherit: key)
    }
}

extension BuildSettingsKey {

    /// AdditionalInfoFileKeys
    public static let additionalinfofilekeys: BuildSettingsKey = "AdditionalInfoFileKeys"
}

// MARK: AdditionalInfoFileValues
extension BuildSetting {

    /// AdditionalInfoFileValues
    public static func additionalinfofilevalues(_ value: String) -> BuildSetting { 
        BuildSetting(key: .additionalinfofilevalues, value: "\(value)")
    }

    /// AdditionalInfoFileValues
    public static func additionalinfofilevalues(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .additionalinfofilevalues, inherit: key)
    }
}

extension BuildSettingsKey {

    /// AdditionalInfoFileValues
    public static let additionalinfofilevalues: BuildSettingsKey = "AdditionalInfoFileValues"
}

// MARK: BITCODE_GENERATION_MODE
extension BuildSetting {

    /// BITCODE_GENERATION_MODE
    public static var bitcodeGenerationMode: BuildSetting { 
        .bitcodeGenerationMode(.marker) 
    }

    /// BITCODE_GENERATION_MODE
    public static func bitcodeGenerationMode(_ value: BitcodeGenerationMode) -> BuildSetting { 
        BuildSetting(key: .bitcodeGenerationMode, value: "\(value)")
    }

    /// BITCODE_GENERATION_MODE
    public static func bitcodeGenerationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bitcodeGenerationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BITCODE_GENERATION_MODE
    public static let bitcodeGenerationMode: BuildSettingsKey = "BITCODE_GENERATION_MODE"
}

public enum BitcodeGenerationMode: String, Hashable, Codable, CustomStringConvertible {
    case marker = "marker"
    case bitcode = "bitcode"

    public var description: String {
        rawValue
    }
}

// MARK: BUILD_ACTIVE_RESOURCES_ONLY
extension BuildSetting {

    /// BUILD_ACTIVE_RESOURCES_ONLY
    public static var buildActiveResourcesOnly: BuildSetting { 
        BuildSetting(key: .buildActiveResourcesOnly, value: "NO")
    }

    /// BUILD_ACTIVE_RESOURCES_ONLY
    public static func buildActiveResourcesOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .buildActiveResourcesOnly, value: SettingValue(booleanLiteral: value))
    }

    /// BUILD_ACTIVE_RESOURCES_ONLY
    public static func buildActiveResourcesOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildActiveResourcesOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUILD_ACTIVE_RESOURCES_ONLY
    public static let buildActiveResourcesOnly: BuildSettingsKey = "BUILD_ACTIVE_RESOURCES_ONLY"
}

// MARK: Active Build Components
extension BuildSetting {

    /// Active Build Components
    ///
    /// A list of components being built during this action.
    public static var activeBuildComponents: BuildSetting { 
        BuildSetting(key: .activeBuildComponents, value: "")
    }

    /// Active Build Components
    ///
    /// A list of components being built during this action.
    public static func activeBuildComponents(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .activeBuildComponents, value: .array(value))
    }

    /// Active Build Components
    ///
    /// A list of components being built during this action.
    public static func activeBuildComponents(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .activeBuildComponents, inherit: key)
    }

    /// Active Build Components
    ///
    /// A list of components being built during this action.
    public static func activeBuildComponents(_ value: String...) -> BuildSetting { 
        .activeBuildComponents(value)
    }
}

extension BuildSettingsKey {

    /// Active Build Components
    ///
    /// A list of components being built during this action.
    public static let activeBuildComponents: BuildSettingsKey = "BUILD_COMPONENTS"
}

// MARK: BUILD_DIR
extension BuildSetting {

    /// BUILD_DIR
    public static var buildDir: BuildSetting { 
        .buildDir(inherit: .buildProductsPath) 
    }

    /// BUILD_DIR
    public static func buildDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .buildDir, value: "\(value)")
    }

    /// BUILD_DIR
    public static func buildDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUILD_DIR
    public static let buildDir: BuildSettingsKey = "BUILD_DIR"
}

// MARK: Build Libraries for Distribution
extension BuildSetting {

    /// Build Libraries for Distribution
    ///
    /// Ensures that your libraries are built for distribution. For Swift, this enables support for library evolution and generation of a module interface file.
    public static var buildLibrariesForDistribution: BuildSetting { 
        BuildSetting(key: .buildLibrariesForDistribution, value: "NO")
    }

    /// Build Libraries for Distribution
    ///
    /// Ensures that your libraries are built for distribution. For Swift, this enables support for library evolution and generation of a module interface file.
    public static func buildLibrariesForDistribution(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .buildLibrariesForDistribution, value: SettingValue(booleanLiteral: value))
    }

    /// Build Libraries for Distribution
    ///
    /// Ensures that your libraries are built for distribution. For Swift, this enables support for library evolution and generation of a module interface file.
    public static func buildLibrariesForDistribution(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildLibrariesForDistribution, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Libraries for Distribution
    ///
    /// Ensures that your libraries are built for distribution. For Swift, this enables support for library evolution and generation of a module interface file.
    public static let buildLibrariesForDistribution: BuildSettingsKey = "BUILD_LIBRARY_FOR_DISTRIBUTION"
}

// MARK: BUILD_ROOT
extension BuildSetting {

    /// BUILD_ROOT
    public static var buildRoot: BuildSetting { 
        .buildRoot(inherit: .buildProductsPath) 
    }

    /// BUILD_ROOT
    public static func buildRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .buildRoot, value: "\(value)")
    }

    /// BUILD_ROOT
    public static func buildRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUILD_ROOT
    public static let buildRoot: BuildSettingsKey = "BUILD_ROOT"
}

// MARK: BUILD_STYLE
extension BuildSetting {

    /// BUILD_STYLE
    public static var buildStyle: BuildSetting { 
        BuildSetting(key: .buildStyle, value: "")
    }

    /// BUILD_STYLE
    public static func buildStyle(_ value: String) -> BuildSetting { 
        BuildSetting(key: .buildStyle, value: "\(value)")
    }

    /// BUILD_STYLE
    public static func buildStyle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildStyle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUILD_STYLE
    public static let buildStyle: BuildSettingsKey = "BUILD_STYLE"
}

// MARK: Build Variants
extension BuildSetting {

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static var buildVariants: BuildSetting { 
        BuildSetting(key: .buildVariants, value: "normal")
    }

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static func buildVariants(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .buildVariants, value: .array(value))
    }

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static func buildVariants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildVariants, inherit: key)
    }

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static func buildVariants(_ value: String...) -> BuildSetting { 
        .buildVariants(value)
    }
}

extension BuildSettingsKey {

    /// Build Variants
    ///
    /// A list of the build variants of the linked binary that will be produced. By default, only the `normal` variant is produced. Other common values include `debug` and `profile`.
    public static let buildVariants: BuildSettingsKey = "BUILD_VARIANTS"
}

// MARK: BUILT_PRODUCTS_DIR
extension BuildSetting {

    /// BUILT_PRODUCTS_DIR
    ///
    /// Identifies the directory under which all the products files can be found. This directory contains either product files or symbolic links to them. Run Script build phases can use the value of this build setting as a convenient way to refer to the product files built by one or more targets even when these files are scattered throughout a directory hierarchy (for example, when `DEPLOYMENT_LOCATION` is set to `YES`.
    public static var builtProductsDir: BuildSetting { 
        .builtProductsDir(inherit: .perConfigurationBuildProductsPath) 
    }

    /// BUILT_PRODUCTS_DIR
    ///
    /// Identifies the directory under which all the products files can be found. This directory contains either product files or symbolic links to them. Run Script build phases can use the value of this build setting as a convenient way to refer to the product files built by one or more targets even when these files are scattered throughout a directory hierarchy (for example, when `DEPLOYMENT_LOCATION` is set to `YES`.
    public static func builtProductsDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .builtProductsDir, value: "\(value)")
    }

    /// BUILT_PRODUCTS_DIR
    ///
    /// Identifies the directory under which all the products files can be found. This directory contains either product files or symbolic links to them. Run Script build phases can use the value of this build setting as a convenient way to refer to the product files built by one or more targets even when these files are scattered throughout a directory hierarchy (for example, when `DEPLOYMENT_LOCATION` is set to `YES`.
    public static func builtProductsDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .builtProductsDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUILT_PRODUCTS_DIR
    ///
    /// Identifies the directory under which all the products files can be found. This directory contains either product files or symbolic links to them. Run Script build phases can use the value of this build setting as a convenient way to refer to the product files built by one or more targets even when these files are scattered throughout a directory hierarchy (for example, when `DEPLOYMENT_LOCATION` is set to `YES`.
    public static let builtProductsDir: BuildSettingsKey = "BUILT_PRODUCTS_DIR"
}

// MARK: BUNDLE_CONTENTS_FOLDER_PATH
extension BuildSetting {

    /// BUNDLE_CONTENTS_FOLDER_PATH
    public static var bundleContentsFolderPath: BuildSetting { 
        BuildSetting(key: .bundleContentsFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH_$(BUNDLE_FORMAT))")
    }

    /// BUNDLE_CONTENTS_FOLDER_PATH
    public static func bundleContentsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleContentsFolderPath, value: "\(value)")
    }

    /// BUNDLE_CONTENTS_FOLDER_PATH
    public static func bundleContentsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleContentsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUNDLE_CONTENTS_FOLDER_PATH
    public static let bundleContentsFolderPath: BuildSettingsKey = "BUNDLE_CONTENTS_FOLDER_PATH"
}

// MARK: BUNDLE_CONTENTS_FOLDER_PATH_deep
extension BuildSetting {

    /// BUNDLE_CONTENTS_FOLDER_PATH_deep
    public static var bundleContentsFolderPathDeep: BuildSetting { 
        BuildSetting(key: .bundleContentsFolderPathDeep, value: "Contents/")
    }

    /// BUNDLE_CONTENTS_FOLDER_PATH_deep
    public static func bundleContentsFolderPathDeep(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleContentsFolderPathDeep, value: "\(value)")
    }

    /// BUNDLE_CONTENTS_FOLDER_PATH_deep
    public static func bundleContentsFolderPathDeep(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleContentsFolderPathDeep, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUNDLE_CONTENTS_FOLDER_PATH_deep
    public static let bundleContentsFolderPathDeep: BuildSettingsKey = "BUNDLE_CONTENTS_FOLDER_PATH_deep"
}

// MARK: BUNDLE_EXECUTABLE_FOLDER_NAME_deep
extension BuildSetting {

    /// BUNDLE_EXECUTABLE_FOLDER_NAME_deep
    public static var bundleExecutableFolderNameDeep: BuildSetting { 
        BuildSetting(key: .bundleExecutableFolderNameDeep, value: "MacOS")
    }

    /// BUNDLE_EXECUTABLE_FOLDER_NAME_deep
    public static func bundleExecutableFolderNameDeep(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleExecutableFolderNameDeep, value: "\(value)")
    }

    /// BUNDLE_EXECUTABLE_FOLDER_NAME_deep
    public static func bundleExecutableFolderNameDeep(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleExecutableFolderNameDeep, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUNDLE_EXECUTABLE_FOLDER_NAME_deep
    public static let bundleExecutableFolderNameDeep: BuildSettingsKey = "BUNDLE_EXECUTABLE_FOLDER_NAME_deep"
}

// MARK: BUNDLE_EXECUTABLE_FOLDER_PATH
extension BuildSetting {

    /// BUNDLE_EXECUTABLE_FOLDER_PATH
    public static var bundleExecutableFolderPath: BuildSetting { 
        BuildSetting(key: .bundleExecutableFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)$(BUNDLE_EXECUTABLE_FOLDER_NAME_$(BUNDLE_FORMAT))")
    }

    /// BUNDLE_EXECUTABLE_FOLDER_PATH
    public static func bundleExecutableFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleExecutableFolderPath, value: "\(value)")
    }

    /// BUNDLE_EXECUTABLE_FOLDER_PATH
    public static func bundleExecutableFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleExecutableFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUNDLE_EXECUTABLE_FOLDER_PATH
    public static let bundleExecutableFolderPath: BuildSettingsKey = "BUNDLE_EXECUTABLE_FOLDER_PATH"
}

// MARK: BUNDLE_FORMAT
extension BuildSetting {

    /// BUNDLE_FORMAT
    public static var bundleFormat: BuildSetting { 
        .bundleFormat(.shallow) 
    }

    /// BUNDLE_FORMAT
    public static func bundleFormat(_ value: BundleFormat) -> BuildSetting { 
        BuildSetting(key: .bundleFormat, value: "\(value)")
    }

    /// BUNDLE_FORMAT
    public static func bundleFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUNDLE_FORMAT
    public static let bundleFormat: BuildSettingsKey = "BUNDLE_FORMAT"
}

public enum BundleFormat: String, Hashable, Codable, CustomStringConvertible {
    case deep = "deep"
    case shallow = "shallow"

    public var description: String {
        rawValue
    }
}

// MARK: BUNDLE_FRAMEWORKS_FOLDER_PATH
extension BuildSetting {

    /// BUNDLE_FRAMEWORKS_FOLDER_PATH
    public static var bundleFrameworksFolderPath: BuildSetting { 
        BuildSetting(key: .bundleFrameworksFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)Frameworks")
    }

    /// BUNDLE_FRAMEWORKS_FOLDER_PATH
    public static func bundleFrameworksFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleFrameworksFolderPath, value: "\(value)")
    }

    /// BUNDLE_FRAMEWORKS_FOLDER_PATH
    public static func bundleFrameworksFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleFrameworksFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUNDLE_FRAMEWORKS_FOLDER_PATH
    public static let bundleFrameworksFolderPath: BuildSettingsKey = "BUNDLE_FRAMEWORKS_FOLDER_PATH"
}

// MARK: Bundle Loader
extension BuildSetting {

    /// Bundle Loader
    ///
    /// Specifies the executable that will load the bundle output file being linked. Undefined symbols from the bundle are checked against the specified executable as if it is one of the dynamic libraries the bundle was linked with.
    public static var bundleLoader: BuildSetting { 
        BuildSetting(key: .bundleLoader, value: "")
    }

    /// Bundle Loader
    ///
    /// Specifies the executable that will load the bundle output file being linked. Undefined symbols from the bundle are checked against the specified executable as if it is one of the dynamic libraries the bundle was linked with.
    public static func bundleLoader(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundleLoader, value: "\(value)")
    }

    /// Bundle Loader
    ///
    /// Specifies the executable that will load the bundle output file being linked. Undefined symbols from the bundle are checked against the specified executable as if it is one of the dynamic libraries the bundle was linked with.
    public static func bundleLoader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundleLoader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Bundle Loader
    ///
    /// Specifies the executable that will load the bundle output file being linked. Undefined symbols from the bundle are checked against the specified executable as if it is one of the dynamic libraries the bundle was linked with.
    public static let bundleLoader: BuildSettingsKey = "BUNDLE_LOADER"
}

// MARK: BUNDLE_PLUGINS_FOLDER_PATH
extension BuildSetting {

    /// BUNDLE_PLUGINS_FOLDER_PATH
    public static var bundlePluginsFolderPath: BuildSetting { 
        BuildSetting(key: .bundlePluginsFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)PlugIns")
    }

    /// BUNDLE_PLUGINS_FOLDER_PATH
    public static func bundlePluginsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundlePluginsFolderPath, value: "\(value)")
    }

    /// BUNDLE_PLUGINS_FOLDER_PATH
    public static func bundlePluginsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundlePluginsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUNDLE_PLUGINS_FOLDER_PATH
    public static let bundlePluginsFolderPath: BuildSettingsKey = "BUNDLE_PLUGINS_FOLDER_PATH"
}

// MARK: BUNDLE_PRIVATE_HEADERS_FOLDER_PATH
extension BuildSetting {

    /// BUNDLE_PRIVATE_HEADERS_FOLDER_PATH
    public static var bundlePrivateHeadersFolderPath: BuildSetting { 
        BuildSetting(key: .bundlePrivateHeadersFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)PrivateHeaders")
    }

    /// BUNDLE_PRIVATE_HEADERS_FOLDER_PATH
    public static func bundlePrivateHeadersFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundlePrivateHeadersFolderPath, value: "\(value)")
    }

    /// BUNDLE_PRIVATE_HEADERS_FOLDER_PATH
    public static func bundlePrivateHeadersFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundlePrivateHeadersFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUNDLE_PRIVATE_HEADERS_FOLDER_PATH
    public static let bundlePrivateHeadersFolderPath: BuildSettingsKey = "BUNDLE_PRIVATE_HEADERS_FOLDER_PATH"
}

// MARK: BUNDLE_PUBLIC_HEADERS_FOLDER_PATH
extension BuildSetting {

    /// BUNDLE_PUBLIC_HEADERS_FOLDER_PATH
    public static var bundlePublicHeadersFolderPath: BuildSetting { 
        BuildSetting(key: .bundlePublicHeadersFolderPath, value: "$(BUNDLE_CONTENTS_FOLDER_PATH)Headers")
    }

    /// BUNDLE_PUBLIC_HEADERS_FOLDER_PATH
    public static func bundlePublicHeadersFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .bundlePublicHeadersFolderPath, value: "\(value)")
    }

    /// BUNDLE_PUBLIC_HEADERS_FOLDER_PATH
    public static func bundlePublicHeadersFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .bundlePublicHeadersFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// BUNDLE_PUBLIC_HEADERS_FOLDER_PATH
    public static let bundlePublicHeadersFolderPath: BuildSettingsKey = "BUNDLE_PUBLIC_HEADERS_FOLDER_PATH"
}

// MARK: CC
extension BuildSetting {

    /// CC
    public static func cc(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cc, value: "\(value)")
    }

    /// CC
    public static func cc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CC
    public static let cc: BuildSettingsKey = "CC"
}

// MARK: CCHROOT
extension BuildSetting {

    /// CCHROOT
    public static var cchroot: BuildSetting { 
        BuildSetting(key: .cchroot, value: "$(CACHE_ROOT)")
    }

    /// CCHROOT
    public static func cchroot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cchroot, value: "\(value)")
    }

    /// CCHROOT
    public static func cchroot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cchroot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CCHROOT
    public static let cchroot: BuildSettingsKey = "CCHROOT"
}

// MARK: CHMOD
extension BuildSetting {

    /// CHMOD
    public static var chmod: BuildSetting { 
        BuildSetting(key: .chmod, value: "/bin/chmod")
    }

    /// CHMOD
    public static func chmod(_ value: String) -> BuildSetting { 
        BuildSetting(key: .chmod, value: "\(value)")
    }

    /// CHMOD
    public static func chmod(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .chmod, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CHMOD
    public static let chmod: BuildSettingsKey = "CHMOD"
}

// MARK: CHOWN
extension BuildSetting {

    /// CHOWN
    public static var chown: BuildSetting { 
        BuildSetting(key: .chown, value: "/usr/sbin/chown")
    }

    /// CHOWN
    public static func chown(_ value: String) -> BuildSetting { 
        BuildSetting(key: .chown, value: "\(value)")
    }

    /// CHOWN
    public static func chown(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .chown, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CHOWN
    public static let chown: BuildSettingsKey = "CHOWN"
}

// MARK: CLANG
extension BuildSetting {

    /// CLANG
    public static var clang: BuildSetting { 
        BuildSetting(key: .clang, value: "clang")
    }

    /// CLANG
    public static func clang(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clang, value: "\(value)")
    }

    /// CLANG
    public static func clang(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clang, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG
    public static let clang: BuildSettingsKey = "CLANG"
}

// MARK: CLANG_ADDRESS_SANITIZER
extension BuildSetting {

    /// CLANG_ADDRESS_SANITIZER
    public static func clangAddressSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAddressSanitizer, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ADDRESS_SANITIZER
    public static func clangAddressSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAddressSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ADDRESS_SANITIZER
    public static let clangAddressSanitizer: BuildSettingsKey = "CLANG_ADDRESS_SANITIZER"
}

// MARK: CLANG_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
extension BuildSetting {

    /// CLANG_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
    public static var clangAddressSanitizerAllowErrorRecovery: BuildSetting { 
        BuildSetting(key: .clangAddressSanitizerAllowErrorRecovery, value: "$(ENABLE_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY)")
    }

    /// CLANG_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
    public static func clangAddressSanitizerAllowErrorRecovery(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAddressSanitizerAllowErrorRecovery, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
    public static func clangAddressSanitizerAllowErrorRecovery(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAddressSanitizerAllowErrorRecovery, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
    public static let clangAddressSanitizerAllowErrorRecovery: BuildSettingsKey = "CLANG_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY"
}

// MARK: Enable C++ Container Overflow Checks
extension BuildSetting {

    /// Enable C++ Container Overflow Checks
    ///
    /// Check for C++ container overflow when Address Sanitizer is enabled. This check requires the entire application to be built with Address Sanitizer. If not, it may report false positives.
    public static var enableCppContainerOverflowChecks: BuildSetting { 
        BuildSetting(key: .enableCppContainerOverflowChecks, value: "NO")
    }

    /// Enable C++ Container Overflow Checks
    ///
    /// Check for C++ container overflow when Address Sanitizer is enabled. This check requires the entire application to be built with Address Sanitizer. If not, it may report false positives.
    public static func enableCppContainerOverflowChecks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableCppContainerOverflowChecks, value: SettingValue(booleanLiteral: value))
    }

    /// Enable C++ Container Overflow Checks
    ///
    /// Check for C++ container overflow when Address Sanitizer is enabled. This check requires the entire application to be built with Address Sanitizer. If not, it may report false positives.
    public static func enableCppContainerOverflowChecks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableCppContainerOverflowChecks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable C++ Container Overflow Checks
    ///
    /// Check for C++ container overflow when Address Sanitizer is enabled. This check requires the entire application to be built with Address Sanitizer. If not, it may report false positives.
    public static let enableCppContainerOverflowChecks: BuildSettingsKey = "CLANG_ADDRESS_SANITIZER_CONTAINER_OVERFLOW"
}

// MARK: CLANG_ADDRESS_SANITIZER_USE_AFTER_SCOPE
extension BuildSetting {

    /// CLANG_ADDRESS_SANITIZER_USE_AFTER_SCOPE
    public static var clangAddressSanitizerUseAfterScope: BuildSetting { 
        BuildSetting(key: .clangAddressSanitizerUseAfterScope, value: "NO")
    }

    /// CLANG_ADDRESS_SANITIZER_USE_AFTER_SCOPE
    public static func clangAddressSanitizerUseAfterScope(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAddressSanitizerUseAfterScope, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ADDRESS_SANITIZER_USE_AFTER_SCOPE
    public static func clangAddressSanitizerUseAfterScope(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAddressSanitizerUseAfterScope, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ADDRESS_SANITIZER_USE_AFTER_SCOPE
    public static let clangAddressSanitizerUseAfterScope: BuildSettingsKey = "CLANG_ADDRESS_SANITIZER_USE_AFTER_SCOPE"
}

// MARK: Allow Non-modular Includes In Framework Modules
extension BuildSetting {

    /// Allow Non-modular Includes In Framework Modules
    ///
    /// Enabling this setting allows non-modular includes to be used from within framework modules. This is inherently unsafe, as such headers might cause duplicate definitions when used by any client that imports both the framework and the non-modular includes.
    public static var allowNonModularIncludesInFrameworkModules: BuildSetting { 
        BuildSetting(key: .allowNonModularIncludesInFrameworkModules, value: "NO")
    }

    /// Allow Non-modular Includes In Framework Modules
    ///
    /// Enabling this setting allows non-modular includes to be used from within framework modules. This is inherently unsafe, as such headers might cause duplicate definitions when used by any client that imports both the framework and the non-modular includes.
    public static func allowNonModularIncludesInFrameworkModules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .allowNonModularIncludesInFrameworkModules, value: SettingValue(booleanLiteral: value))
    }

    /// Allow Non-modular Includes In Framework Modules
    ///
    /// Enabling this setting allows non-modular includes to be used from within framework modules. This is inherently unsafe, as such headers might cause duplicate definitions when used by any client that imports both the framework and the non-modular includes.
    public static func allowNonModularIncludesInFrameworkModules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .allowNonModularIncludesInFrameworkModules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Allow Non-modular Includes In Framework Modules
    ///
    /// Enabling this setting allows non-modular includes to be used from within framework modules. This is inherently unsafe, as such headers might cause duplicate definitions when used by any client that imports both the framework and the non-modular includes.
    public static let allowNonModularIncludesInFrameworkModules: BuildSettingsKey = "CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES"
}

// MARK: CLANG_ANALYZER_ALTERNATE_EDGES
extension BuildSetting {

    /// CLANG_ANALYZER_ALTERNATE_EDGES
    public static var clangAnalyzerAlternateEdges: BuildSetting { 
        BuildSetting(key: .clangAnalyzerAlternateEdges, value: "YES")
    }

    /// CLANG_ANALYZER_ALTERNATE_EDGES
    public static func clangAnalyzerAlternateEdges(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerAlternateEdges, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ANALYZER_ALTERNATE_EDGES
    public static func clangAnalyzerAlternateEdges(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerAlternateEdges, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_ALTERNATE_EDGES
    public static let clangAnalyzerAlternateEdges: BuildSettingsKey = "CLANG_ANALYZER_ALTERNATE_EDGES"
}

// MARK: Dead Stores
extension BuildSetting {

    /// Dead Stores
    ///
    /// Check for values stored to variables and never read again.
    public static var deadStores: BuildSetting { 
        BuildSetting(key: .deadStores, value: "YES")
    }

    /// Dead Stores
    ///
    /// Check for values stored to variables and never read again.
    public static func deadStores(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deadStores, value: SettingValue(booleanLiteral: value))
    }

    /// Dead Stores
    ///
    /// Check for values stored to variables and never read again.
    public static func deadStores(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deadStores, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dead Stores
    ///
    /// Check for values stored to variables and never read again.
    public static let deadStores: BuildSettingsKey = "CLANG_ANALYZER_DEADCODE_DEADSTORES"
}

// MARK: CLANG_ANALYZER_DEFINES
extension BuildSetting {

    /// CLANG_ANALYZER_DEFINES
    public static var clangAnalyzerDefines: BuildSetting { 
        BuildSetting(key: .clangAnalyzerDefines, value: "-D__clang_analyzer__")
    }

    /// CLANG_ANALYZER_DEFINES
    public static func clangAnalyzerDefines(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerDefines, value: "\(value)")
    }

    /// CLANG_ANALYZER_DEFINES
    public static func clangAnalyzerDefines(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerDefines, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_DEFINES
    public static let clangAnalyzerDefines: BuildSettingsKey = "CLANG_ANALYZER_DEFINES"
}

// MARK: CLANG_ANALYZER_DIVIDE_BY_ZERO
extension BuildSetting {

    /// CLANG_ANALYZER_DIVIDE_BY_ZERO
    public static var clangAnalyzerDivideByZero: BuildSetting { 
        BuildSetting(key: .clangAnalyzerDivideByZero, value: "YES")
    }

    /// CLANG_ANALYZER_DIVIDE_BY_ZERO
    public static func clangAnalyzerDivideByZero(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerDivideByZero, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ANALYZER_DIVIDE_BY_ZERO
    public static func clangAnalyzerDivideByZero(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerDivideByZero, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_DIVIDE_BY_ZERO
    public static let clangAnalyzerDivideByZero: BuildSettingsKey = "CLANG_ANALYZER_DIVIDE_BY_ZERO"
}

// MARK: CLANG_ANALYZER_EXEC
extension BuildSetting {

    /// CLANG_ANALYZER_EXEC
    public static var clangAnalyzerExec: BuildSetting { 
        BuildSetting(key: .clangAnalyzerExec, value: "clang")
    }

    /// CLANG_ANALYZER_EXEC
    public static func clangAnalyzerExec(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerExec, value: "\(value)")
    }

    /// CLANG_ANALYZER_EXEC
    public static func clangAnalyzerExec(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerExec, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_EXEC
    public static let clangAnalyzerExec: BuildSettingsKey = "CLANG_ANALYZER_EXEC"
}

// MARK: Misuse of Grand Central Dispatch
extension BuildSetting {

    /// Misuse of Grand Central Dispatch
    ///
    /// Check for misuses of the Grand Central Dispatch API.
    public static var misuseOfGrandCentralDispatch: BuildSetting { 
        BuildSetting(key: .misuseOfGrandCentralDispatch, value: "YES")
    }

    /// Misuse of Grand Central Dispatch
    ///
    /// Check for misuses of the Grand Central Dispatch API.
    public static func misuseOfGrandCentralDispatch(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .misuseOfGrandCentralDispatch, value: SettingValue(booleanLiteral: value))
    }

    /// Misuse of Grand Central Dispatch
    ///
    /// Check for misuses of the Grand Central Dispatch API.
    public static func misuseOfGrandCentralDispatch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfGrandCentralDispatch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of Grand Central Dispatch
    ///
    /// Check for misuses of the Grand Central Dispatch API.
    public static let misuseOfGrandCentralDispatch: BuildSettingsKey = "CLANG_ANALYZER_GCD"
}

// MARK: Performance Anti-Patterns with Grand Central Dispatch
extension BuildSetting {

    /// Performance Anti-Patterns with Grand Central Dispatch
    ///
    /// Check for Grand Central Dispatch idioms that may lead to poor performance.
    public static var performanceAntiPatternsWithGrandCentralDispatch: BuildSetting { 
        .performanceAntiPatternsWithGrandCentralDispatch(.no) 
    }

    /// Performance Anti-Patterns with Grand Central Dispatch
    ///
    /// Check for Grand Central Dispatch idioms that may lead to poor performance.
    public static func performanceAntiPatternsWithGrandCentralDispatch(_ value: PerformanceAntiPatternsWithGrandCentralDispatch) -> BuildSetting { 
        BuildSetting(key: .performanceAntiPatternsWithGrandCentralDispatch, value: "\(value)")
    }

    /// Performance Anti-Patterns with Grand Central Dispatch
    ///
    /// Check for Grand Central Dispatch idioms that may lead to poor performance.
    public static func performanceAntiPatternsWithGrandCentralDispatch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .performanceAntiPatternsWithGrandCentralDispatch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Performance Anti-Patterns with Grand Central Dispatch
    ///
    /// Check for Grand Central Dispatch idioms that may lead to poor performance.
    public static let performanceAntiPatternsWithGrandCentralDispatch: BuildSettingsKey = "CLANG_ANALYZER_GCD_PERFORMANCE"
}

public enum PerformanceAntiPatternsWithGrandCentralDispatch: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension PerformanceAntiPatternsWithGrandCentralDispatch: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Violation of IOKit and libkern Reference Counting Rules
extension BuildSetting {

    /// Violation of IOKit and libkern Reference Counting Rules
    ///
    /// Finds leaks and overreleases associated with objects inheriting from OSObject
    public static var violationOfIokitAndLibkernReferenceCountingRules: BuildSetting { 
        BuildSetting(key: .violationOfIokitAndLibkernReferenceCountingRules, value: "YES")
    }

    /// Violation of IOKit and libkern Reference Counting Rules
    ///
    /// Finds leaks and overreleases associated with objects inheriting from OSObject
    public static func violationOfIokitAndLibkernReferenceCountingRules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .violationOfIokitAndLibkernReferenceCountingRules, value: SettingValue(booleanLiteral: value))
    }

    /// Violation of IOKit and libkern Reference Counting Rules
    ///
    /// Finds leaks and overreleases associated with objects inheriting from OSObject
    public static func violationOfIokitAndLibkernReferenceCountingRules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .violationOfIokitAndLibkernReferenceCountingRules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Violation of IOKit and libkern Reference Counting Rules
    ///
    /// Finds leaks and overreleases associated with objects inheriting from OSObject
    public static let violationOfIokitAndLibkernReferenceCountingRules: BuildSettingsKey = "CLANG_ANALYZER_LIBKERN_RETAIN_COUNT"
}

// MARK: Missing Localization Context Comment
extension BuildSetting {

    /// Missing Localization Context Comment
    ///
    /// Warn when a call to an `NSLocalizedString()` macro is missing a context comment for the localizer.
    public static var missingLocalizationContextComment: BuildSetting { 
        .missingLocalizationContextComment(.no) 
    }

    /// Missing Localization Context Comment
    ///
    /// Warn when a call to an `NSLocalizedString()` macro is missing a context comment for the localizer.
    public static func missingLocalizationContextComment(_ value: MissingLocalizationContextComment) -> BuildSetting { 
        BuildSetting(key: .missingLocalizationContextComment, value: "\(value)")
    }

    /// Missing Localization Context Comment
    ///
    /// Warn when a call to an `NSLocalizedString()` macro is missing a context comment for the localizer.
    public static func missingLocalizationContextComment(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingLocalizationContextComment, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Localization Context Comment
    ///
    /// Warn when a call to an `NSLocalizedString()` macro is missing a context comment for the localizer.
    public static let missingLocalizationContextComment: BuildSettingsKey = "CLANG_ANALYZER_LOCALIZABILITY_EMPTY_CONTEXT"
}

public enum MissingLocalizationContextComment: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension MissingLocalizationContextComment: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Missing Localizability
extension BuildSetting {

    /// Missing Localizability
    ///
    /// Warn when a nonlocalized string is passed to a user interface method expecting a localized string.
    public static var missingLocalizability: BuildSetting { 
        .missingLocalizability(.no) 
    }

    /// Missing Localizability
    ///
    /// Warn when a nonlocalized string is passed to a user interface method expecting a localized string.
    public static func missingLocalizability(_ value: MissingLocalizability) -> BuildSetting { 
        BuildSetting(key: .missingLocalizability, value: "\(value)")
    }

    /// Missing Localizability
    ///
    /// Warn when a nonlocalized string is passed to a user interface method expecting a localized string.
    public static func missingLocalizability(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingLocalizability, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Localizability
    ///
    /// Warn when a nonlocalized string is passed to a user interface method expecting a localized string.
    public static let missingLocalizability: BuildSettingsKey = "CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED"
}

public enum MissingLocalizability: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension MissingLocalizability: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: CLANG_ANALYZER_MALLOC
extension BuildSetting {

    /// CLANG_ANALYZER_MALLOC
    public static var clangAnalyzerMalloc: BuildSetting { 
        BuildSetting(key: .clangAnalyzerMalloc, value: "YES")
    }

    /// CLANG_ANALYZER_MALLOC
    public static func clangAnalyzerMalloc(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerMalloc, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ANALYZER_MALLOC
    public static func clangAnalyzerMalloc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerMalloc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_MALLOC
    public static let clangAnalyzerMalloc: BuildSettingsKey = "CLANG_ANALYZER_MALLOC"
}

// MARK: Improper Memory Management
extension BuildSetting {

    /// Improper Memory Management
    ///
    /// Warn about memory leaks, use-after-free, and other API misuses.
    public static var improperMemoryManagement: BuildSetting { 
        .improperMemoryManagement(inherit: .clangAnalyzerMalloc) 
    }

    /// Improper Memory Management
    ///
    /// Warn about memory leaks, use-after-free, and other API misuses.
    public static func improperMemoryManagement(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .improperMemoryManagement, value: SettingValue(booleanLiteral: value))
    }

    /// Improper Memory Management
    ///
    /// Warn about memory leaks, use-after-free, and other API misuses.
    public static func improperMemoryManagement(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .improperMemoryManagement, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Improper Memory Management
    ///
    /// Warn about memory leaks, use-after-free, and other API misuses.
    public static let improperMemoryManagement: BuildSettingsKey = "CLANG_ANALYZER_MEMORY_MANAGEMENT"
}

// MARK: Violation of Mach Interface Generator Conventions
extension BuildSetting {

    /// Violation of Mach Interface Generator Conventions
    ///
    /// Warn when a MIG routine violates memory management conventions.
    public static var violationOfMachInterfaceGeneratorConventions: BuildSetting { 
        .violationOfMachInterfaceGeneratorConventions(.yes) 
    }

    /// Violation of Mach Interface Generator Conventions
    ///
    /// Warn when a MIG routine violates memory management conventions.
    public static func violationOfMachInterfaceGeneratorConventions(_ value: ViolationOfMachInterfaceGeneratorConventions) -> BuildSetting { 
        BuildSetting(key: .violationOfMachInterfaceGeneratorConventions, value: "\(value)")
    }

    /// Violation of Mach Interface Generator Conventions
    ///
    /// Warn when a MIG routine violates memory management conventions.
    public static func violationOfMachInterfaceGeneratorConventions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .violationOfMachInterfaceGeneratorConventions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Violation of Mach Interface Generator Conventions
    ///
    /// Warn when a MIG routine violates memory management conventions.
    public static let violationOfMachInterfaceGeneratorConventions: BuildSettingsKey = "CLANG_ANALYZER_MIG_CONVENTIONS"
}

public enum ViolationOfMachInterfaceGeneratorConventions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ViolationOfMachInterfaceGeneratorConventions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Misuse of 'nonnull'
extension BuildSetting {

    /// Misuse of 'nonnull'
    ///
    /// Check for misuses of `nonnull` parameter and return types.
    public static var misuseOfNonnull: BuildSetting { 
        .misuseOfNonnull(.yesNonaggressive) 
    }

    /// Misuse of 'nonnull'
    ///
    /// Check for misuses of `nonnull` parameter and return types.
    public static func misuseOfNonnull(_ value: MisuseOfNonnull) -> BuildSetting { 
        BuildSetting(key: .misuseOfNonnull, value: "\(value)")
    }

    /// Misuse of 'nonnull'
    ///
    /// Check for misuses of `nonnull` parameter and return types.
    public static func misuseOfNonnull(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfNonnull, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of 'nonnull'
    ///
    /// Check for misuses of `nonnull` parameter and return types.
    public static let misuseOfNonnull: BuildSettingsKey = "CLANG_ANALYZER_NONNULL"
}

public enum MisuseOfNonnull: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesNonaggressive = "YES_NONAGGRESSIVE"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension MisuseOfNonnull: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: CLANG_ANALYZER_NULL_DEREFERENCE
extension BuildSetting {

    /// CLANG_ANALYZER_NULL_DEREFERENCE
    public static var clangAnalyzerNullDereference: BuildSetting { 
        BuildSetting(key: .clangAnalyzerNullDereference, value: "YES")
    }

    /// CLANG_ANALYZER_NULL_DEREFERENCE
    public static func clangAnalyzerNullDereference(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerNullDereference, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ANALYZER_NULL_DEREFERENCE
    public static func clangAnalyzerNullDereference(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerNullDereference, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_NULL_DEREFERENCE
    public static let clangAnalyzerNullDereference: BuildSettingsKey = "CLANG_ANALYZER_NULL_DEREFERENCE"
}

// MARK: Suspicious Conversions of NSNumber and CFNumberRef
extension BuildSetting {

    /// Suspicious Conversions of NSNumber and CFNumberRef
    ///
    /// Warn when a number object, such as an instance of `NSNumber`, `CFNumberRef`, `OSNumber`, or `OSBoolean` is compared or converted to a primitive value instead of another object.
    public static var suspiciousConversionsOfNsnumberAndCfnumberref: BuildSetting { 
        .suspiciousConversionsOfNsnumberAndCfnumberref(.yes) 
    }

    /// Suspicious Conversions of NSNumber and CFNumberRef
    ///
    /// Warn when a number object, such as an instance of `NSNumber`, `CFNumberRef`, `OSNumber`, or `OSBoolean` is compared or converted to a primitive value instead of another object.
    public static func suspiciousConversionsOfNsnumberAndCfnumberref(_ value: SuspiciousConversionsOfNsnumberAndCfnumberref) -> BuildSetting { 
        BuildSetting(key: .suspiciousConversionsOfNsnumberAndCfnumberref, value: "\(value)")
    }

    /// Suspicious Conversions of NSNumber and CFNumberRef
    ///
    /// Warn when a number object, such as an instance of `NSNumber`, `CFNumberRef`, `OSNumber`, or `OSBoolean` is compared or converted to a primitive value instead of another object.
    public static func suspiciousConversionsOfNsnumberAndCfnumberref(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousConversionsOfNsnumberAndCfnumberref, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Conversions of NSNumber and CFNumberRef
    ///
    /// Warn when a number object, such as an instance of `NSNumber`, `CFNumberRef`, `OSNumber`, or `OSBoolean` is compared or converted to a primitive value instead of another object.
    public static let suspiciousConversionsOfNsnumberAndCfnumberref: BuildSettingsKey = "CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION"
}

public enum SuspiciousConversionsOfNsnumberAndCfnumberref: String, Hashable, Codable, CustomStringConvertible {
    case yesAggressive = "YES_AGGRESSIVE"
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension SuspiciousConversionsOfNsnumberAndCfnumberref: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: @synchronized with nil mutex
extension BuildSetting {

    /// @synchronized with nil mutex
    ///
    /// Warn on `nil` pointers used as mutexes for `@synchronized`.
    public static var SynchronizedWithNilMutex: BuildSetting { 
        BuildSetting(key: .SynchronizedWithNilMutex, value: "YES")
    }

    /// @synchronized with nil mutex
    ///
    /// Warn on `nil` pointers used as mutexes for `@synchronized`.
    public static func SynchronizedWithNilMutex(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .SynchronizedWithNilMutex, value: SettingValue(booleanLiteral: value))
    }

    /// @synchronized with nil mutex
    ///
    /// Warn on `nil` pointers used as mutexes for `@synchronized`.
    public static func SynchronizedWithNilMutex(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .SynchronizedWithNilMutex, inherit: key)
    }
}

extension BuildSettingsKey {

    /// @synchronized with nil mutex
    ///
    /// Warn on `nil` pointers used as mutexes for `@synchronized`.
    public static let SynchronizedWithNilMutex: BuildSettingsKey = "CLANG_ANALYZER_OBJC_ATSYNC"
}

// MARK: Misuse of Collections API
extension BuildSetting {

    /// Misuse of Collections API
    ///
    /// Warn if `CF` collections are created with non-pointer-size values. Check if `NS` collections are initialized with non-Objective-C type elements.
    public static var misuseOfCollectionsApi: BuildSetting { 
        BuildSetting(key: .misuseOfCollectionsApi, value: "YES")
    }

    /// Misuse of Collections API
    ///
    /// Warn if `CF` collections are created with non-pointer-size values. Check if `NS` collections are initialized with non-Objective-C type elements.
    public static func misuseOfCollectionsApi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .misuseOfCollectionsApi, value: SettingValue(booleanLiteral: value))
    }

    /// Misuse of Collections API
    ///
    /// Warn if `CF` collections are created with non-pointer-size values. Check if `NS` collections are initialized with non-Objective-C type elements.
    public static func misuseOfCollectionsApi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfCollectionsApi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of Collections API
    ///
    /// Warn if `CF` collections are created with non-pointer-size values. Check if `NS` collections are initialized with non-Objective-C type elements.
    public static let misuseOfCollectionsApi: BuildSettingsKey = "CLANG_ANALYZER_OBJC_COLLECTIONS"
}

// MARK: Improper Instance Cleanup in '-dealloc'
extension BuildSetting {

    /// Improper Instance Cleanup in '-dealloc'
    ///
    /// Warn when an instance is improperly cleaned up in `-dealloc`.
    public static var improperInstanceCleanupInDealloc: BuildSetting { 
        BuildSetting(key: .improperInstanceCleanupInDealloc, value: "YES")
    }

    /// Improper Instance Cleanup in '-dealloc'
    ///
    /// Warn when an instance is improperly cleaned up in `-dealloc`.
    public static func improperInstanceCleanupInDealloc(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .improperInstanceCleanupInDealloc, value: SettingValue(booleanLiteral: value))
    }

    /// Improper Instance Cleanup in '-dealloc'
    ///
    /// Warn when an instance is improperly cleaned up in `-dealloc`.
    public static func improperInstanceCleanupInDealloc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .improperInstanceCleanupInDealloc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Improper Instance Cleanup in '-dealloc'
    ///
    /// Warn when an instance is improperly cleaned up in `-dealloc`.
    public static let improperInstanceCleanupInDealloc: BuildSettingsKey = "CLANG_ANALYZER_OBJC_DEALLOC"
}

// MARK: Misuse of Objective-C generics
extension BuildSetting {

    /// Misuse of Objective-C generics
    ///
    /// Warn if a specialized generic type is converted to an incompatible type.
    public static var misuseOfObjectiveCGenerics: BuildSetting { 
        BuildSetting(key: .misuseOfObjectiveCGenerics, value: "YES")
    }

    /// Misuse of Objective-C generics
    ///
    /// Warn if a specialized generic type is converted to an incompatible type.
    public static func misuseOfObjectiveCGenerics(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .misuseOfObjectiveCGenerics, value: SettingValue(booleanLiteral: value))
    }

    /// Misuse of Objective-C generics
    ///
    /// Warn if a specialized generic type is converted to an incompatible type.
    public static func misuseOfObjectiveCGenerics(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfObjectiveCGenerics, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of Objective-C generics
    ///
    /// Warn if a specialized generic type is converted to an incompatible type.
    public static let misuseOfObjectiveCGenerics: BuildSettingsKey = "CLANG_ANALYZER_OBJC_GENERICS"
}

// MARK: Method Signatures Mismatch
extension BuildSetting {

    /// Method Signatures Mismatch
    ///
    /// Warn about Objective-C method signatures with type incompatibilities.
    public static var methodSignaturesMismatch: BuildSetting { 
        BuildSetting(key: .methodSignaturesMismatch, value: "YES")
    }

    /// Method Signatures Mismatch
    ///
    /// Warn about Objective-C method signatures with type incompatibilities.
    public static func methodSignaturesMismatch(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .methodSignaturesMismatch, value: SettingValue(booleanLiteral: value))
    }

    /// Method Signatures Mismatch
    ///
    /// Warn about Objective-C method signatures with type incompatibilities.
    public static func methodSignaturesMismatch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .methodSignaturesMismatch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Method Signatures Mismatch
    ///
    /// Warn about Objective-C method signatures with type incompatibilities.
    public static let methodSignaturesMismatch: BuildSettingsKey = "CLANG_ANALYZER_OBJC_INCOMP_METHOD_TYPES"
}

// MARK: Improper Handling of CFError and NSError
extension BuildSetting {

    /// Improper Handling of CFError and NSError
    ///
    /// Warn if functions accepting `CFErrorRef` or `NSError` cannot indicate that an error occurred.
    public static var improperHandlingOfCferrorAndNserror: BuildSetting { 
        BuildSetting(key: .improperHandlingOfCferrorAndNserror, value: "YES")
    }

    /// Improper Handling of CFError and NSError
    ///
    /// Warn if functions accepting `CFErrorRef` or `NSError` cannot indicate that an error occurred.
    public static func improperHandlingOfCferrorAndNserror(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .improperHandlingOfCferrorAndNserror, value: SettingValue(booleanLiteral: value))
    }

    /// Improper Handling of CFError and NSError
    ///
    /// Warn if functions accepting `CFErrorRef` or `NSError` cannot indicate that an error occurred.
    public static func improperHandlingOfCferrorAndNserror(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .improperHandlingOfCferrorAndNserror, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Improper Handling of CFError and NSError
    ///
    /// Warn if functions accepting `CFErrorRef` or `NSError` cannot indicate that an error occurred.
    public static let improperHandlingOfCferrorAndNserror: BuildSettingsKey = "CLANG_ANALYZER_OBJC_NSCFERROR"
}

// MARK: Violation of Reference Counting Rules
extension BuildSetting {

    /// Violation of Reference Counting Rules
    ///
    /// Warn on leaks and improper reference count management.
    public static var violationOfReferenceCountingRules: BuildSetting { 
        BuildSetting(key: .violationOfReferenceCountingRules, value: "YES")
    }

    /// Violation of Reference Counting Rules
    ///
    /// Warn on leaks and improper reference count management.
    public static func violationOfReferenceCountingRules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .violationOfReferenceCountingRules, value: SettingValue(booleanLiteral: value))
    }

    /// Violation of Reference Counting Rules
    ///
    /// Warn on leaks and improper reference count management.
    public static func violationOfReferenceCountingRules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .violationOfReferenceCountingRules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Violation of Reference Counting Rules
    ///
    /// Warn on leaks and improper reference count management.
    public static let violationOfReferenceCountingRules: BuildSettingsKey = "CLANG_ANALYZER_OBJC_RETAIN_COUNT"
}

// MARK: Violation of 'self = `super init`' Rule
extension BuildSetting {

    /// Violation of 'self = `super init`' Rule
    ///
    /// Check that `super init` is properly called within an Objective-C initialization method.
    public static var violationOfSelfSuperInitRule: BuildSetting { 
        BuildSetting(key: .violationOfSelfSuperInitRule, value: "YES")
    }

    /// Violation of 'self = `super init`' Rule
    ///
    /// Check that `super init` is properly called within an Objective-C initialization method.
    public static func violationOfSelfSuperInitRule(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .violationOfSelfSuperInitRule, value: SettingValue(booleanLiteral: value))
    }

    /// Violation of 'self = `super init`' Rule
    ///
    /// Check that `super init` is properly called within an Objective-C initialization method.
    public static func violationOfSelfSuperInitRule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .violationOfSelfSuperInitRule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Violation of 'self = `super init`' Rule
    ///
    /// Check that `super init` is properly called within an Objective-C initialization method.
    public static let violationOfSelfSuperInitRule: BuildSettingsKey = "CLANG_ANALYZER_OBJC_SELF_INIT"
}

// MARK: Unused Ivars
extension BuildSetting {

    /// Unused Ivars
    ///
    /// Warn about private ivars that are never used.
    public static var unusedIvars: BuildSetting { 
        BuildSetting(key: .unusedIvars, value: "YES")
    }

    /// Unused Ivars
    ///
    /// Warn about private ivars that are never used.
    public static func unusedIvars(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedIvars, value: SettingValue(booleanLiteral: value))
    }

    /// Unused Ivars
    ///
    /// Warn about private ivars that are never used.
    public static func unusedIvars(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedIvars, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Ivars
    ///
    /// Warn about private ivars that are never used.
    public static let unusedIvars: BuildSettingsKey = "CLANG_ANALYZER_OBJC_UNUSED_IVARS"
}

// MARK: CLANG_ANALYZER_OTHER_CHECKERS
extension BuildSetting {

    /// CLANG_ANALYZER_OTHER_CHECKERS
    public static func clangAnalyzerOtherCheckers(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerOtherCheckers, value: .array(value))
    }

    /// CLANG_ANALYZER_OTHER_CHECKERS
    public static func clangAnalyzerOtherCheckers(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerOtherCheckers, inherit: key)
    }

    /// CLANG_ANALYZER_OTHER_CHECKERS
    public static func clangAnalyzerOtherCheckers(_ value: String...) -> BuildSetting { 
        .clangAnalyzerOtherCheckers(value)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_OTHER_CHECKERS
    public static let clangAnalyzerOtherCheckers: BuildSettingsKey = "CLANG_ANALYZER_OTHER_CHECKERS"
}

// MARK: CLANG_ANALYZER_OTHER_FLAGS
extension BuildSetting {

    /// CLANG_ANALYZER_OTHER_FLAGS
    public static func clangAnalyzerOtherFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerOtherFlags, value: .array(value))
    }

    /// CLANG_ANALYZER_OTHER_FLAGS
    public static func clangAnalyzerOtherFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerOtherFlags, inherit: key)
    }

    /// CLANG_ANALYZER_OTHER_FLAGS
    public static func clangAnalyzerOtherFlags(_ value: String...) -> BuildSetting { 
        .clangAnalyzerOtherFlags(value)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_OTHER_FLAGS
    public static let clangAnalyzerOtherFlags: BuildSettingsKey = "CLANG_ANALYZER_OTHER_FLAGS"
}

// MARK: CLANG_ANALYZER_OUTPUT
extension BuildSetting {

    /// CLANG_ANALYZER_OUTPUT
    public static var clangAnalyzerOutput: BuildSetting { 
        .clangAnalyzerOutput(.plistMultiFile) 
    }

    /// CLANG_ANALYZER_OUTPUT
    public static func clangAnalyzerOutput(_ value: ClangAnalyzerOutput) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerOutput, value: "\(value)")
    }

    /// CLANG_ANALYZER_OUTPUT
    public static func clangAnalyzerOutput(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerOutput, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_OUTPUT
    public static let clangAnalyzerOutput: BuildSettingsKey = "CLANG_ANALYZER_OUTPUT"
}

public enum ClangAnalyzerOutput: String, Hashable, Codable, CustomStringConvertible {
    case `default` = "default"
    case plistMultiFile = "plist-multi-file"

    public var description: String {
        rawValue
    }
}

// MARK: CLANG_ANALYZER_OUTPUT_DIR
extension BuildSetting {

    /// CLANG_ANALYZER_OUTPUT_DIR
    public static var clangAnalyzerOutputDir: BuildSetting { 
        .clangAnalyzerOutputDir(inherit: .tempDir) 
    }

    /// CLANG_ANALYZER_OUTPUT_DIR
    public static func clangAnalyzerOutputDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerOutputDir, value: "\(value)")
    }

    /// CLANG_ANALYZER_OUTPUT_DIR
    public static func clangAnalyzerOutputDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerOutputDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_OUTPUT_DIR
    public static let clangAnalyzerOutputDir: BuildSettingsKey = "CLANG_ANALYZER_OUTPUT_DIR"
}

// MARK: CLANG_ANALYZER_REPORT_MAIN_SOURCE_FILE
extension BuildSetting {

    /// CLANG_ANALYZER_REPORT_MAIN_SOURCE_FILE
    public static var clangAnalyzerReportMainSourceFile: BuildSetting { 
        BuildSetting(key: .clangAnalyzerReportMainSourceFile, value: "YES")
    }

    /// CLANG_ANALYZER_REPORT_MAIN_SOURCE_FILE
    public static func clangAnalyzerReportMainSourceFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangAnalyzerReportMainSourceFile, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ANALYZER_REPORT_MAIN_SOURCE_FILE
    public static func clangAnalyzerReportMainSourceFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangAnalyzerReportMainSourceFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ANALYZER_REPORT_MAIN_SOURCE_FILE
    public static let clangAnalyzerReportMainSourceFile: BuildSettingsKey = "CLANG_ANALYZER_REPORT_MAIN_SOURCE_FILE"
}

// MARK: *EXPERIMENTAL* Buffer overflows
extension BuildSetting {

    /// *EXPERIMENTAL* Buffer overflows
    ///
    /// Check for potential buffer overflows.
    public static var ExperimentalBufferOverflows: BuildSetting { 
        BuildSetting(key: .ExperimentalBufferOverflows, value: "NO")
    }

    /// *EXPERIMENTAL* Buffer overflows
    ///
    /// Check for potential buffer overflows.
    public static func ExperimentalBufferOverflows(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ExperimentalBufferOverflows, value: SettingValue(booleanLiteral: value))
    }

    /// *EXPERIMENTAL* Buffer overflows
    ///
    /// Check for potential buffer overflows.
    public static func ExperimentalBufferOverflows(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ExperimentalBufferOverflows, inherit: key)
    }
}

extension BuildSettingsKey {

    /// *EXPERIMENTAL* Buffer overflows
    ///
    /// Check for potential buffer overflows.
    public static let ExperimentalBufferOverflows: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_BUFFER_OVERFLOW_EXPERIMENTAL"
}

// MARK: Floating Point Value Used as Loop Counter
extension BuildSetting {

    /// Floating Point Value Used as Loop Counter
    ///
    /// Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP).
    public static var floatingPointValueUsedAsLoopCounter: BuildSetting { 
        BuildSetting(key: .floatingPointValueUsedAsLoopCounter, value: "NO")
    }

    /// Floating Point Value Used as Loop Counter
    ///
    /// Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP).
    public static func floatingPointValueUsedAsLoopCounter(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .floatingPointValueUsedAsLoopCounter, value: SettingValue(booleanLiteral: value))
    }

    /// Floating Point Value Used as Loop Counter
    ///
    /// Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP).
    public static func floatingPointValueUsedAsLoopCounter(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .floatingPointValueUsedAsLoopCounter, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Floating Point Value Used as Loop Counter
    ///
    /// Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP).
    public static let floatingPointValueUsedAsLoopCounter: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_FLOATLOOPCOUNTER"
}

// MARK: Use of 'getpw', 'gets' (Buffer Overflow)
extension BuildSetting {

    /// Use of 'getpw', 'gets' (Buffer Overflow)
    ///
    /// Warn on uses of `getpw` and `gets`. The functions are dangerous as they may trigger a buffer overflow.
    public static var useOfGetpwGetsBufferOverflow: BuildSetting { 
        BuildSetting(key: .useOfGetpwGetsBufferOverflow, value: "YES")
    }

    /// Use of 'getpw', 'gets' (Buffer Overflow)
    ///
    /// Warn on uses of `getpw` and `gets`. The functions are dangerous as they may trigger a buffer overflow.
    public static func useOfGetpwGetsBufferOverflow(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfGetpwGetsBufferOverflow, value: SettingValue(booleanLiteral: value))
    }

    /// Use of 'getpw', 'gets' (Buffer Overflow)
    ///
    /// Warn on uses of `getpw` and `gets`. The functions are dangerous as they may trigger a buffer overflow.
    public static func useOfGetpwGetsBufferOverflow(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfGetpwGetsBufferOverflow, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'getpw', 'gets' (Buffer Overflow)
    ///
    /// Warn on uses of `getpw` and `gets`. The functions are dangerous as they may trigger a buffer overflow.
    public static let useOfGetpwGetsBufferOverflow: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_GETPW_GETS"
}

// MARK: Use of 'mktemp' or Predictable 'mktemps'
extension BuildSetting {

    /// Use of 'mktemp' or Predictable 'mktemps'
    ///
    /// Warn on uses of `mktemp`, which produces predictable temporary files. It is obsoleted by `mktemps`. Warn when `mkstemp` is passed fewer than 6 `X`'s in the format string.
    public static var useOfMktempOrPredictableMktemps: BuildSetting { 
        BuildSetting(key: .useOfMktempOrPredictableMktemps, value: "YES")
    }

    /// Use of 'mktemp' or Predictable 'mktemps'
    ///
    /// Warn on uses of `mktemp`, which produces predictable temporary files. It is obsoleted by `mktemps`. Warn when `mkstemp` is passed fewer than 6 `X`'s in the format string.
    public static func useOfMktempOrPredictableMktemps(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfMktempOrPredictableMktemps, value: SettingValue(booleanLiteral: value))
    }

    /// Use of 'mktemp' or Predictable 'mktemps'
    ///
    /// Warn on uses of `mktemp`, which produces predictable temporary files. It is obsoleted by `mktemps`. Warn when `mkstemp` is passed fewer than 6 `X`'s in the format string.
    public static func useOfMktempOrPredictableMktemps(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfMktempOrPredictableMktemps, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'mktemp' or Predictable 'mktemps'
    ///
    /// Warn on uses of `mktemp`, which produces predictable temporary files. It is obsoleted by `mktemps`. Warn when `mkstemp` is passed fewer than 6 `X`'s in the format string.
    public static let useOfMktempOrPredictableMktemps: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_MKSTEMP"
}

// MARK: Use of 'rand' Functions
extension BuildSetting {

    /// Use of 'rand' Functions
    ///
    /// Warn on uses of `rand`, `random`, and related functions, which produce predictable random number sequences. Use `arc4random` instead.
    public static var useOfRandFunctions: BuildSetting { 
        BuildSetting(key: .useOfRandFunctions, value: "NO")
    }

    /// Use of 'rand' Functions
    ///
    /// Warn on uses of `rand`, `random`, and related functions, which produce predictable random number sequences. Use `arc4random` instead.
    public static func useOfRandFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfRandFunctions, value: SettingValue(booleanLiteral: value))
    }

    /// Use of 'rand' Functions
    ///
    /// Warn on uses of `rand`, `random`, and related functions, which produce predictable random number sequences. Use `arc4random` instead.
    public static func useOfRandFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfRandFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'rand' Functions
    ///
    /// Warn on uses of `rand`, `random`, and related functions, which produce predictable random number sequences. Use `arc4random` instead.
    public static let useOfRandFunctions: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_RAND"
}

// MARK: Use of 'strcpy' and 'strcat'
extension BuildSetting {

    /// Use of 'strcpy' and 'strcat'
    ///
    /// Warn on uses of the `strcpy` and `strcat` functions, which can result in buffer overflows. Use `strlcpy` or `strlcat` instead.
    public static var useOfStrcpyAndStrcat: BuildSetting { 
        BuildSetting(key: .useOfStrcpyAndStrcat, value: "NO")
    }

    /// Use of 'strcpy' and 'strcat'
    ///
    /// Warn on uses of the `strcpy` and `strcat` functions, which can result in buffer overflows. Use `strlcpy` or `strlcat` instead.
    public static func useOfStrcpyAndStrcat(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfStrcpyAndStrcat, value: SettingValue(booleanLiteral: value))
    }

    /// Use of 'strcpy' and 'strcat'
    ///
    /// Warn on uses of the `strcpy` and `strcat` functions, which can result in buffer overflows. Use `strlcpy` or `strlcat` instead.
    public static func useOfStrcpyAndStrcat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfStrcpyAndStrcat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'strcpy' and 'strcat'
    ///
    /// Warn on uses of the `strcpy` and `strcat` functions, which can result in buffer overflows. Use `strlcpy` or `strlcat` instead.
    public static let useOfStrcpyAndStrcat: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_STRCPY"
}

// MARK: Unchecked Return Values
extension BuildSetting {

    /// Unchecked Return Values
    ///
    /// Warn on uses of sensitive functions whose return values must be always checked.
    public static var uncheckedReturnValues: BuildSetting { 
        BuildSetting(key: .uncheckedReturnValues, value: "YES")
    }

    /// Unchecked Return Values
    ///
    /// Warn on uses of sensitive functions whose return values must be always checked.
    public static func uncheckedReturnValues(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .uncheckedReturnValues, value: SettingValue(booleanLiteral: value))
    }

    /// Unchecked Return Values
    ///
    /// Warn on uses of sensitive functions whose return values must be always checked.
    public static func uncheckedReturnValues(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .uncheckedReturnValues, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unchecked Return Values
    ///
    /// Warn on uses of sensitive functions whose return values must be always checked.
    public static let uncheckedReturnValues: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_UNCHECKEDRETURN"
}

// MARK: Use of 'vfork'
extension BuildSetting {

    /// Use of 'vfork'
    ///
    /// Warn on uses of the `vfork` function, which is inherently insecure. Use the safer `posix_spawn` function instead.
    public static var useOfVfork: BuildSetting { 
        BuildSetting(key: .useOfVfork, value: "YES")
    }

    /// Use of 'vfork'
    ///
    /// Warn on uses of the `vfork` function, which is inherently insecure. Use the safer `posix_spawn` function instead.
    public static func useOfVfork(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOfVfork, value: SettingValue(booleanLiteral: value))
    }

    /// Use of 'vfork'
    ///
    /// Warn on uses of the `vfork` function, which is inherently insecure. Use the safer `posix_spawn` function instead.
    public static func useOfVfork(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOfVfork, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use of 'vfork'
    ///
    /// Warn on uses of the `vfork` function, which is inherently insecure. Use the safer `posix_spawn` function instead.
    public static let useOfVfork: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_INSECUREAPI_VFORK"
}

// MARK: Misuse of Keychain Services API
extension BuildSetting {

    /// Misuse of Keychain Services API
    ///
    /// Check for leaks of keychain attribute lists and data buffers returned by the Keychain Services API.
    public static var misuseOfKeychainServicesApi: BuildSetting { 
        BuildSetting(key: .misuseOfKeychainServicesApi, value: "YES")
    }

    /// Misuse of Keychain Services API
    ///
    /// Check for leaks of keychain attribute lists and data buffers returned by the Keychain Services API.
    public static func misuseOfKeychainServicesApi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .misuseOfKeychainServicesApi, value: SettingValue(booleanLiteral: value))
    }

    /// Misuse of Keychain Services API
    ///
    /// Check for leaks of keychain attribute lists and data buffers returned by the Keychain Services API.
    public static func misuseOfKeychainServicesApi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .misuseOfKeychainServicesApi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Misuse of Keychain Services API
    ///
    /// Check for leaks of keychain attribute lists and data buffers returned by the Keychain Services API.
    public static let misuseOfKeychainServicesApi: BuildSettingsKey = "CLANG_ANALYZER_SECURITY_KEYCHAIN_API"
}

// MARK: Use-After-Move Errors in C++
extension BuildSetting {

    /// Use-After-Move Errors in C++
    ///
    /// Warn when a C++ object is used after it has been moved from.
    public static var useAfterMoveErrorsInCpp: BuildSetting { 
        .useAfterMoveErrorsInCpp(.yesAggressive) 
    }

    /// Use-After-Move Errors in C++
    ///
    /// Warn when a C++ object is used after it has been moved from.
    public static func useAfterMoveErrorsInCpp(_ value: UseAfterMoveErrorsInCpp) -> BuildSetting { 
        BuildSetting(key: .useAfterMoveErrorsInCpp, value: "\(value)")
    }

    /// Use-After-Move Errors in C++
    ///
    /// Warn when a C++ object is used after it has been moved from.
    public static func useAfterMoveErrorsInCpp(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useAfterMoveErrorsInCpp, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use-After-Move Errors in C++
    ///
    /// Warn when a C++ object is used after it has been moved from.
    public static let useAfterMoveErrorsInCpp: BuildSettingsKey = "CLANG_ANALYZER_USE_AFTER_MOVE"
}

public enum UseAfterMoveErrorsInCpp: String, Hashable, Codable, CustomStringConvertible {
    case yesAggressive = "YES_AGGRESSIVE"
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension UseAfterMoveErrorsInCpp: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: CLANG_ARC_MIGRATE_DIR
extension BuildSetting {

    /// CLANG_ARC_MIGRATE_DIR
    public static func clangArcMigrateDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangArcMigrateDir, value: "\(value)")
    }

    /// CLANG_ARC_MIGRATE_DIR
    public static func clangArcMigrateDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangArcMigrateDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ARC_MIGRATE_DIR
    public static let clangArcMigrateDir: BuildSettingsKey = "CLANG_ARC_MIGRATE_DIR"
}

// MARK: CLANG_ARC_MIGRATE_EMIT_ERROR
extension BuildSetting {

    /// CLANG_ARC_MIGRATE_EMIT_ERROR
    public static var clangArcMigrateEmitError: BuildSetting { 
        BuildSetting(key: .clangArcMigrateEmitError, value: "NO")
    }

    /// CLANG_ARC_MIGRATE_EMIT_ERROR
    public static func clangArcMigrateEmitError(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangArcMigrateEmitError, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ARC_MIGRATE_EMIT_ERROR
    public static func clangArcMigrateEmitError(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangArcMigrateEmitError, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ARC_MIGRATE_EMIT_ERROR
    public static let clangArcMigrateEmitError: BuildSettingsKey = "CLANG_ARC_MIGRATE_EMIT_ERROR"
}

// MARK: CLANG_ARC_MIGRATE_PRECHECK
extension BuildSetting {

    /// CLANG_ARC_MIGRATE_PRECHECK
    public static var clangArcMigratePrecheck: BuildSetting { 
        .clangArcMigratePrecheck(.donothing) 
    }

    /// CLANG_ARC_MIGRATE_PRECHECK
    public static func clangArcMigratePrecheck(_ value: ClangArcMigratePrecheck) -> BuildSetting { 
        BuildSetting(key: .clangArcMigratePrecheck, value: "\(value)")
    }

    /// CLANG_ARC_MIGRATE_PRECHECK
    public static func clangArcMigratePrecheck(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangArcMigratePrecheck, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ARC_MIGRATE_PRECHECK
    public static let clangArcMigratePrecheck: BuildSettingsKey = "CLANG_ARC_MIGRATE_PRECHECK"
}

public enum ClangArcMigratePrecheck: String, Hashable, Codable, CustomStringConvertible {
    case donothing = "donothing"
    case precheck = "precheck"

    public var description: String {
        rawValue
    }
}

// MARK: CLANG_ARC_MIGRATE_REPORT_OUTPUT
extension BuildSetting {

    /// CLANG_ARC_MIGRATE_REPORT_OUTPUT
    public static func clangArcMigrateReportOutput(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangArcMigrateReportOutput, value: "\(value)")
    }

    /// CLANG_ARC_MIGRATE_REPORT_OUTPUT
    public static func clangArcMigrateReportOutput(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangArcMigrateReportOutput, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ARC_MIGRATE_REPORT_OUTPUT
    public static let clangArcMigrateReportOutput: BuildSettingsKey = "CLANG_ARC_MIGRATE_REPORT_OUTPUT"
}

// MARK: CLANG_BITCODE_GENERATION_MODE
extension BuildSetting {

    /// CLANG_BITCODE_GENERATION_MODE
    public static var clangBitcodeGenerationMode: BuildSetting { 
        .clangBitcodeGenerationMode(inherit: .bitcodeGenerationMode) 
    }

    /// CLANG_BITCODE_GENERATION_MODE
    public static func clangBitcodeGenerationMode(_ value: ClangBitcodeGenerationMode) -> BuildSetting { 
        BuildSetting(key: .clangBitcodeGenerationMode, value: "\(value)")
    }

    /// CLANG_BITCODE_GENERATION_MODE
    public static func clangBitcodeGenerationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangBitcodeGenerationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_BITCODE_GENERATION_MODE
    public static let clangBitcodeGenerationMode: BuildSettingsKey = "CLANG_BITCODE_GENERATION_MODE"
}

public enum ClangBitcodeGenerationMode: String, Hashable, Codable, CustomStringConvertible {
    case none = "none"
    case marker = "marker"
    case bitcode = "bitcode"

    public var description: String {
        rawValue
    }
}

// MARK: CLANG_COLOR_DIAGNOSTICS
extension BuildSetting {

    /// CLANG_COLOR_DIAGNOSTICS
    public static var clangColorDiagnostics: BuildSetting { 
        .clangColorDiagnostics(inherit: .colorDiagnostics) 
    }

    /// CLANG_COLOR_DIAGNOSTICS
    public static func clangColorDiagnostics(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangColorDiagnostics, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_COLOR_DIAGNOSTICS
    public static func clangColorDiagnostics(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangColorDiagnostics, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_COLOR_DIAGNOSTICS
    public static let clangColorDiagnostics: BuildSettingsKey = "CLANG_COLOR_DIAGNOSTICS"
}

// MARK: CLANG_COVERAGE_MAPPING
extension BuildSetting {

    /// CLANG_COVERAGE_MAPPING
    public static var clangCoverageMapping: BuildSetting { 
        BuildSetting(key: .clangCoverageMapping, value: "NO")
    }

    /// CLANG_COVERAGE_MAPPING
    public static func clangCoverageMapping(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangCoverageMapping, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_COVERAGE_MAPPING
    public static func clangCoverageMapping(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangCoverageMapping, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_COVERAGE_MAPPING
    public static let clangCoverageMapping: BuildSettingsKey = "CLANG_COVERAGE_MAPPING"
}

// MARK: CLANG_COVERAGE_MAPPING_LINKER_ARGS
extension BuildSetting {

    /// CLANG_COVERAGE_MAPPING_LINKER_ARGS
    public static var clangCoverageMappingLinkerArgs: BuildSetting { 
        .clangCoverageMappingLinkerArgs(inherit: .clangCoverageMapping) 
    }

    /// CLANG_COVERAGE_MAPPING_LINKER_ARGS
    public static func clangCoverageMappingLinkerArgs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangCoverageMappingLinkerArgs, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_COVERAGE_MAPPING_LINKER_ARGS
    public static func clangCoverageMappingLinkerArgs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangCoverageMappingLinkerArgs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_COVERAGE_MAPPING_LINKER_ARGS
    public static let clangCoverageMappingLinkerArgs: BuildSettingsKey = "CLANG_COVERAGE_MAPPING_LINKER_ARGS"
}

// MARK: C++ Language Dialect
extension BuildSetting {

    /// C++ Language Dialect
    ///
    /// Choose a standard or non-standard C++ language dialect. Options include:

- _C++98:_ Accept ISO C++ 1998 with amendments, but not GNU extensions. `-std=c++98`

- _GNU++98:_ Accept ISO C++ 1998 with amendments and GNU extensions. `-std=gnu++98`

- _C++11:_ Accept the ISO C++ 2011 standard with amendments, but not GNU extensions. `-std=c++11`

- _GNU++11:_ Accept the ISO C++ 2011 standard with amendments and GNU extensions. `-std=gnu++11`

- _C++14:_ Accept the ISO C++ 2014 standard with amendments, but not GNU extensions. `-std=c++14`

- _GNU++14:_ Accept the ISO C++ 2014 standard with amendments and GNU extensions. `-std=gnu++14`

- _C++17:_ Accept the ISO C++ 2017 standard with amendments, but not GNU extensions. `-std=c++17`

- _GNU++17:_ Accept the ISO C++ 2017 standard with amendments and GNU extensions. `-std=gnu++17`

- _Compiler Default:_ Tells the compiler to use its default C++ language dialect. This is normally the best choice unless you have specific needs. (Currently equivalent to GNU++98.)
    public static var cppLanguageDialect: BuildSetting { 
        .cppLanguageDialect(.compilerDefault) 
    }

    /// C++ Language Dialect
    ///
    /// Choose a standard or non-standard C++ language dialect. Options include:

- _C++98:_ Accept ISO C++ 1998 with amendments, but not GNU extensions. `-std=c++98`

- _GNU++98:_ Accept ISO C++ 1998 with amendments and GNU extensions. `-std=gnu++98`

- _C++11:_ Accept the ISO C++ 2011 standard with amendments, but not GNU extensions. `-std=c++11`

- _GNU++11:_ Accept the ISO C++ 2011 standard with amendments and GNU extensions. `-std=gnu++11`

- _C++14:_ Accept the ISO C++ 2014 standard with amendments, but not GNU extensions. `-std=c++14`

- _GNU++14:_ Accept the ISO C++ 2014 standard with amendments and GNU extensions. `-std=gnu++14`

- _C++17:_ Accept the ISO C++ 2017 standard with amendments, but not GNU extensions. `-std=c++17`

- _GNU++17:_ Accept the ISO C++ 2017 standard with amendments and GNU extensions. `-std=gnu++17`

- _Compiler Default:_ Tells the compiler to use its default C++ language dialect. This is normally the best choice unless you have specific needs. (Currently equivalent to GNU++98.)
    public static func cppLanguageDialect(_ value: CppLanguageDialect) -> BuildSetting { 
        BuildSetting(key: .cppLanguageDialect, value: "\(value)")
    }

    /// C++ Language Dialect
    ///
    /// Choose a standard or non-standard C++ language dialect. Options include:

- _C++98:_ Accept ISO C++ 1998 with amendments, but not GNU extensions. `-std=c++98`

- _GNU++98:_ Accept ISO C++ 1998 with amendments and GNU extensions. `-std=gnu++98`

- _C++11:_ Accept the ISO C++ 2011 standard with amendments, but not GNU extensions. `-std=c++11`

- _GNU++11:_ Accept the ISO C++ 2011 standard with amendments and GNU extensions. `-std=gnu++11`

- _C++14:_ Accept the ISO C++ 2014 standard with amendments, but not GNU extensions. `-std=c++14`

- _GNU++14:_ Accept the ISO C++ 2014 standard with amendments and GNU extensions. `-std=gnu++14`

- _C++17:_ Accept the ISO C++ 2017 standard with amendments, but not GNU extensions. `-std=c++17`

- _GNU++17:_ Accept the ISO C++ 2017 standard with amendments and GNU extensions. `-std=gnu++17`

- _Compiler Default:_ Tells the compiler to use its default C++ language dialect. This is normally the best choice unless you have specific needs. (Currently equivalent to GNU++98.)
    public static func cppLanguageDialect(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppLanguageDialect, inherit: key)
    }
}

extension BuildSettingsKey {

    /// C++ Language Dialect
    ///
    /// Choose a standard or non-standard C++ language dialect. Options include:

- _C++98:_ Accept ISO C++ 1998 with amendments, but not GNU extensions. `-std=c++98`

- _GNU++98:_ Accept ISO C++ 1998 with amendments and GNU extensions. `-std=gnu++98`

- _C++11:_ Accept the ISO C++ 2011 standard with amendments, but not GNU extensions. `-std=c++11`

- _GNU++11:_ Accept the ISO C++ 2011 standard with amendments and GNU extensions. `-std=gnu++11`

- _C++14:_ Accept the ISO C++ 2014 standard with amendments, but not GNU extensions. `-std=c++14`

- _GNU++14:_ Accept the ISO C++ 2014 standard with amendments and GNU extensions. `-std=gnu++14`

- _C++17:_ Accept the ISO C++ 2017 standard with amendments, but not GNU extensions. `-std=c++17`

- _GNU++17:_ Accept the ISO C++ 2017 standard with amendments and GNU extensions. `-std=gnu++17`

- _Compiler Default:_ Tells the compiler to use its default C++ language dialect. This is normally the best choice unless you have specific needs. (Currently equivalent to GNU++98.)
    public static let cppLanguageDialect: BuildSettingsKey = "CLANG_CXX_LANGUAGE_STANDARD"
}

public enum CppLanguageDialect: String, Hashable, Codable, CustomStringConvertible {
    case cpp98 = "c++98"
    case gnupp98 = "gnu++98"
    case cpp0x = "c++0x"
    case gnupp0x = "gnu++0x"
    case cpp14 = "c++14"
    case gnupp14 = "gnu++14"
    case cpp17 = "c++17"
    case gnupp17 = "gnu++17"
    case compilerDefault = "compiler-default"

    public var description: String {
        rawValue
    }
}

// MARK: C++ Standard Library
extension BuildSetting {

    /// C++ Standard Library
    ///
    /// Choose a version of the C++ standard library to use.

- _libstdc++:_ A traditional C++ standard library that works with GCC and Clang (default).

- _libc++:_ A highly optimized C++ standard library that works only with Clang, and is designed to support new C++11 features.
    public static var cppStandardLibrary: BuildSetting { 
        .cppStandardLibrary(.compilerDefault) 
    }

    /// C++ Standard Library
    ///
    /// Choose a version of the C++ standard library to use.

- _libstdc++:_ A traditional C++ standard library that works with GCC and Clang (default).

- _libc++:_ A highly optimized C++ standard library that works only with Clang, and is designed to support new C++11 features.
    public static func cppStandardLibrary(_ value: CppStandardLibrary) -> BuildSetting { 
        BuildSetting(key: .cppStandardLibrary, value: "\(value)")
    }

    /// C++ Standard Library
    ///
    /// Choose a version of the C++ standard library to use.

- _libstdc++:_ A traditional C++ standard library that works with GCC and Clang (default).

- _libc++:_ A highly optimized C++ standard library that works only with Clang, and is designed to support new C++11 features.
    public static func cppStandardLibrary(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppStandardLibrary, inherit: key)
    }
}

extension BuildSettingsKey {

    /// C++ Standard Library
    ///
    /// Choose a version of the C++ standard library to use.

- _libstdc++:_ A traditional C++ standard library that works with GCC and Clang (default).

- _libc++:_ A highly optimized C++ standard library that works only with Clang, and is designed to support new C++11 features.
    public static let cppStandardLibrary: BuildSettingsKey = "CLANG_CXX_LIBRARY"
}

public enum CppStandardLibrary: String, Hashable, Codable, CustomStringConvertible {
    case libstdcpp = "libstdc++"
    case libcpp = "libc++"
    case compilerDefault = "compiler-default"

    public var description: String {
        rawValue
    }
}

// MARK: Debug Information Level
extension BuildSetting {

    /// Debug Information Level
    ///
    /// Toggles the amount of debug information emitted when debug symbols are enabled. This can impact the size of the generated debug information, which may matter in some cases for large projects, such as when using LTO.
    public static var debugInformationLevel: BuildSetting { 
        .debugInformationLevel(.default) 
    }

    /// Debug Information Level
    ///
    /// Toggles the amount of debug information emitted when debug symbols are enabled. This can impact the size of the generated debug information, which may matter in some cases for large projects, such as when using LTO.
    public static func debugInformationLevel(_ value: DebugInformationLevel) -> BuildSetting { 
        BuildSetting(key: .debugInformationLevel, value: "\(value)")
    }

    /// Debug Information Level
    ///
    /// Toggles the amount of debug information emitted when debug symbols are enabled. This can impact the size of the generated debug information, which may matter in some cases for large projects, such as when using LTO.
    public static func debugInformationLevel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .debugInformationLevel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Debug Information Level
    ///
    /// Toggles the amount of debug information emitted when debug symbols are enabled. This can impact the size of the generated debug information, which may matter in some cases for large projects, such as when using LTO.
    public static let debugInformationLevel: BuildSettingsKey = "CLANG_DEBUG_INFORMATION_LEVEL"
}

public enum DebugInformationLevel: String, Hashable, Codable, CustomStringConvertible {
    case `default` = "default"
    case lineTablesOnly = "line-tables-only"

    public var description: String {
        rawValue
    }
}

// MARK: CLANG_DEBUG_MODULES
extension BuildSetting {

    /// CLANG_DEBUG_MODULES
    public static var clangDebugModules: BuildSetting { 
        .clangDebugModules(inherit: .enableClangModuleDebugging) 
    }

    /// CLANG_DEBUG_MODULES
    public static func clangDebugModules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangDebugModules, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_DEBUG_MODULES
    public static func clangDebugModules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangDebugModules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_DEBUG_MODULES
    public static let clangDebugModules: BuildSettingsKey = "CLANG_DEBUG_MODULES"
}

// MARK: CLANG_DIAGNOSTICS_FILE
extension BuildSetting {

    /// CLANG_DIAGNOSTICS_FILE
    public static var clangDiagnosticsFile: BuildSetting { 
        BuildSetting(key: .clangDiagnosticsFile, value: "$(MTLCOMPILER_OUTPUT_FILE:dir)$(InputFileBase)$(InputFileBaseUniquefier).dia")
    }

    /// CLANG_DIAGNOSTICS_FILE
    public static func clangDiagnosticsFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangDiagnosticsFile, value: "\(value)")
    }

    /// CLANG_DIAGNOSTICS_FILE
    public static func clangDiagnosticsFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangDiagnosticsFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_DIAGNOSTICS_FILE
    public static let clangDiagnosticsFile: BuildSettingsKey = "CLANG_DIAGNOSTICS_FILE"
}

// MARK: CLANG_ENABLE_APP_EXTENSION
extension BuildSetting {

    /// CLANG_ENABLE_APP_EXTENSION
    public static var clangEnableAppExtension: BuildSetting { 
        .clangEnableAppExtension(inherit: .requireOnlyAppExtensionSafeApi) 
    }

    /// CLANG_ENABLE_APP_EXTENSION
    public static func clangEnableAppExtension(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangEnableAppExtension, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ENABLE_APP_EXTENSION
    public static func clangEnableAppExtension(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangEnableAppExtension, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ENABLE_APP_EXTENSION
    public static let clangEnableAppExtension: BuildSettingsKey = "CLANG_ENABLE_APP_EXTENSION"
}

// MARK: Enable Code Coverage Support
extension BuildSetting {

    /// Enable Code Coverage Support
    ///
    /// Enables building with code coverage instrumentation. This is only used when the build has code coverage enabled, which is typically done via the Xcode scheme settings.
    public static var enableCodeCoverageSupport: BuildSetting { 
        BuildSetting(key: .enableCodeCoverageSupport, value: "YES")
    }

    /// Enable Code Coverage Support
    ///
    /// Enables building with code coverage instrumentation. This is only used when the build has code coverage enabled, which is typically done via the Xcode scheme settings.
    public static func enableCodeCoverageSupport(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableCodeCoverageSupport, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Code Coverage Support
    ///
    /// Enables building with code coverage instrumentation. This is only used when the build has code coverage enabled, which is typically done via the Xcode scheme settings.
    public static func enableCodeCoverageSupport(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableCodeCoverageSupport, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Code Coverage Support
    ///
    /// Enables building with code coverage instrumentation. This is only used when the build has code coverage enabled, which is typically done via the Xcode scheme settings.
    public static let enableCodeCoverageSupport: BuildSettingsKey = "CLANG_ENABLE_CODE_COVERAGE"
}

// MARK: Destroy Static Objects
extension BuildSetting {

    /// Destroy Static Objects
    ///
    /// Controls whether variables with static or thread storage duration should have their exit-time destructors run.
    public static var destroyStaticObjects: BuildSetting { 
        BuildSetting(key: .destroyStaticObjects, value: "YES")
    }

    /// Destroy Static Objects
    ///
    /// Controls whether variables with static or thread storage duration should have their exit-time destructors run.
    public static func destroyStaticObjects(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .destroyStaticObjects, value: SettingValue(booleanLiteral: value))
    }

    /// Destroy Static Objects
    ///
    /// Controls whether variables with static or thread storage duration should have their exit-time destructors run.
    public static func destroyStaticObjects(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .destroyStaticObjects, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Destroy Static Objects
    ///
    /// Controls whether variables with static or thread storage duration should have their exit-time destructors run.
    public static let destroyStaticObjects: BuildSettingsKey = "CLANG_ENABLE_CPP_STATIC_DESTRUCTORS"
}

// MARK: Enable Modules (C and Objective-C)
extension BuildSetting {

    /// Enable Modules (C and Objective-C)
    ///
    /// Enables the use of modules for system APIs. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static var enableModulesCAndObjectiveC: BuildSetting { 
        BuildSetting(key: .enableModulesCAndObjectiveC, value: "NO")
    }

    /// Enable Modules (C and Objective-C)
    ///
    /// Enables the use of modules for system APIs. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static func enableModulesCAndObjectiveC(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableModulesCAndObjectiveC, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Modules (C and Objective-C)
    ///
    /// Enables the use of modules for system APIs. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static func enableModulesCAndObjectiveC(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableModulesCAndObjectiveC, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Modules (C and Objective-C)
    ///
    /// Enables the use of modules for system APIs. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static let enableModulesCAndObjectiveC: BuildSettingsKey = "CLANG_ENABLE_MODULES"
}

// MARK: Enable Clang Module Debugging
extension BuildSetting {

    /// Enable Clang Module Debugging
    ///
    /// When this setting is enabled, `clang` will use the shared debug info available in `clang` modules and precompiled headers. This results in smaller build artifacts, faster compile times, and more complete debug info. This setting should only be disabled when building static libraries with debug info for distribution.
    public static var enableClangModuleDebugging: BuildSetting { 
        BuildSetting(key: .enableClangModuleDebugging, value: "YES")
    }

    /// Enable Clang Module Debugging
    ///
    /// When this setting is enabled, `clang` will use the shared debug info available in `clang` modules and precompiled headers. This results in smaller build artifacts, faster compile times, and more complete debug info. This setting should only be disabled when building static libraries with debug info for distribution.
    public static func enableClangModuleDebugging(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableClangModuleDebugging, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Clang Module Debugging
    ///
    /// When this setting is enabled, `clang` will use the shared debug info available in `clang` modules and precompiled headers. This results in smaller build artifacts, faster compile times, and more complete debug info. This setting should only be disabled when building static libraries with debug info for distribution.
    public static func enableClangModuleDebugging(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableClangModuleDebugging, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Clang Module Debugging
    ///
    /// When this setting is enabled, `clang` will use the shared debug info available in `clang` modules and precompiled headers. This results in smaller build artifacts, faster compile times, and more complete debug info. This setting should only be disabled when building static libraries with debug info for distribution.
    public static let enableClangModuleDebugging: BuildSettingsKey = "CLANG_ENABLE_MODULE_DEBUGGING"
}

// MARK: CLANG_ENABLE_MODULE_IMPLEMENTATION_OF
extension BuildSetting {

    /// CLANG_ENABLE_MODULE_IMPLEMENTATION_OF
    public static var clangEnableModuleImplementationOf: BuildSetting { 
        BuildSetting(key: .clangEnableModuleImplementationOf, value: "YES")
    }

    /// CLANG_ENABLE_MODULE_IMPLEMENTATION_OF
    public static func clangEnableModuleImplementationOf(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangEnableModuleImplementationOf, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_ENABLE_MODULE_IMPLEMENTATION_OF
    public static func clangEnableModuleImplementationOf(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangEnableModuleImplementationOf, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_ENABLE_MODULE_IMPLEMENTATION_OF
    public static let clangEnableModuleImplementationOf: BuildSettingsKey = "CLANG_ENABLE_MODULE_IMPLEMENTATION_OF"
}

// MARK: Objective-C Automatic Reference Counting
extension BuildSetting {

    /// Objective-C Automatic Reference Counting
    ///
    /// Compiles reference-counted Objective-C code (when garbage collection is not enabled) to use Automatic Reference Counting. Code compiled using automated reference counting is compatible with other code (such as frameworks) compiled using either manual reference counting (for example, traditional `retain` and `release` messages) or automated reference counting. Using this mode is currently incompatible with compiling code to use Objective-C Garbage Collection.
    public static var objectiveCAutomaticReferenceCounting: BuildSetting { 
        BuildSetting(key: .objectiveCAutomaticReferenceCounting, value: "NO")
    }

    /// Objective-C Automatic Reference Counting
    ///
    /// Compiles reference-counted Objective-C code (when garbage collection is not enabled) to use Automatic Reference Counting. Code compiled using automated reference counting is compatible with other code (such as frameworks) compiled using either manual reference counting (for example, traditional `retain` and `release` messages) or automated reference counting. Using this mode is currently incompatible with compiling code to use Objective-C Garbage Collection.
    public static func objectiveCAutomaticReferenceCounting(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .objectiveCAutomaticReferenceCounting, value: SettingValue(booleanLiteral: value))
    }

    /// Objective-C Automatic Reference Counting
    ///
    /// Compiles reference-counted Objective-C code (when garbage collection is not enabled) to use Automatic Reference Counting. Code compiled using automated reference counting is compatible with other code (such as frameworks) compiled using either manual reference counting (for example, traditional `retain` and `release` messages) or automated reference counting. Using this mode is currently incompatible with compiling code to use Objective-C Garbage Collection.
    public static func objectiveCAutomaticReferenceCounting(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objectiveCAutomaticReferenceCounting, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Objective-C Automatic Reference Counting
    ///
    /// Compiles reference-counted Objective-C code (when garbage collection is not enabled) to use Automatic Reference Counting. Code compiled using automated reference counting is compatible with other code (such as frameworks) compiled using either manual reference counting (for example, traditional `retain` and `release` messages) or automated reference counting. Using this mode is currently incompatible with compiling code to use Objective-C Garbage Collection.
    public static let objectiveCAutomaticReferenceCounting: BuildSettingsKey = "CLANG_ENABLE_OBJC_ARC"
}

// MARK: Weak References in Manual Retain Release
extension BuildSetting {

    /// Weak References in Manual Retain Release
    ///
    /// Compiles Objective-C code to enable weak references for code compiled with manual retain release (MRR) semantics.
    public static var weakReferencesInManualRetainRelease: BuildSetting { 
        BuildSetting(key: .weakReferencesInManualRetainRelease, value: "NO")
    }

    /// Weak References in Manual Retain Release
    ///
    /// Compiles Objective-C code to enable weak references for code compiled with manual retain release (MRR) semantics.
    public static func weakReferencesInManualRetainRelease(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .weakReferencesInManualRetainRelease, value: SettingValue(booleanLiteral: value))
    }

    /// Weak References in Manual Retain Release
    ///
    /// Compiles Objective-C code to enable weak references for code compiled with manual retain release (MRR) semantics.
    public static func weakReferencesInManualRetainRelease(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .weakReferencesInManualRetainRelease, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Weak References in Manual Retain Release
    ///
    /// Compiles Objective-C code to enable weak references for code compiled with manual retain release (MRR) semantics.
    public static let weakReferencesInManualRetainRelease: BuildSettingsKey = "CLANG_ENABLE_OBJC_WEAK"
}

// MARK: CLANG_INDEX_STORE_ENABLE
extension BuildSetting {

    /// CLANG_INDEX_STORE_ENABLE
    public static func clangIndexStoreEnable(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangIndexStoreEnable, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_INDEX_STORE_ENABLE
    public static func clangIndexStoreEnable(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangIndexStoreEnable, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_INDEX_STORE_ENABLE
    public static let clangIndexStoreEnable: BuildSettingsKey = "CLANG_INDEX_STORE_ENABLE"
}

// MARK: CLANG_INDEX_STORE_PATH
extension BuildSetting {

    /// CLANG_INDEX_STORE_PATH
    public static var clangIndexStorePath: BuildSetting { 
        BuildSetting(key: .clangIndexStorePath, value: "$(INDEX_DATA_STORE_DIR)")
    }

    /// CLANG_INDEX_STORE_PATH
    public static func clangIndexStorePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangIndexStorePath, value: "\(value)")
    }

    /// CLANG_INDEX_STORE_PATH
    public static func clangIndexStorePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangIndexStorePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_INDEX_STORE_PATH
    public static let clangIndexStorePath: BuildSettingsKey = "CLANG_INDEX_STORE_PATH"
}

// MARK: CLANG_INSTRUMENT_FOR_OPTIMIZATION_PROFILING
extension BuildSetting {

    /// CLANG_INSTRUMENT_FOR_OPTIMIZATION_PROFILING
    public static var clangInstrumentForOptimizationProfiling: BuildSetting { 
        BuildSetting(key: .clangInstrumentForOptimizationProfiling, value: "NO")
    }

    /// CLANG_INSTRUMENT_FOR_OPTIMIZATION_PROFILING
    public static func clangInstrumentForOptimizationProfiling(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangInstrumentForOptimizationProfiling, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_INSTRUMENT_FOR_OPTIMIZATION_PROFILING
    public static func clangInstrumentForOptimizationProfiling(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangInstrumentForOptimizationProfiling, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_INSTRUMENT_FOR_OPTIMIZATION_PROFILING
    public static let clangInstrumentForOptimizationProfiling: BuildSettingsKey = "CLANG_INSTRUMENT_FOR_OPTIMIZATION_PROFILING"
}

// MARK: Implicitly Link Objective-C Runtime Support
extension BuildSetting {

    /// Implicitly Link Objective-C Runtime Support
    ///
    /// When linking a target using Objective-C code, implicitly link in Foundation (and if deploying back to an older OS) a backwards compatibility library to allow newer language features to run on an OS where the runtime support is not natively available. Most targets that use Objective-C should use this, although there are rare cases where a target should opt out of this behavior.
    public static var implicitlyLinkObjectiveCRuntimeSupport: BuildSetting { 
        BuildSetting(key: .implicitlyLinkObjectiveCRuntimeSupport, value: "YES")
    }

    /// Implicitly Link Objective-C Runtime Support
    ///
    /// When linking a target using Objective-C code, implicitly link in Foundation (and if deploying back to an older OS) a backwards compatibility library to allow newer language features to run on an OS where the runtime support is not natively available. Most targets that use Objective-C should use this, although there are rare cases where a target should opt out of this behavior.
    public static func implicitlyLinkObjectiveCRuntimeSupport(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitlyLinkObjectiveCRuntimeSupport, value: SettingValue(booleanLiteral: value))
    }

    /// Implicitly Link Objective-C Runtime Support
    ///
    /// When linking a target using Objective-C code, implicitly link in Foundation (and if deploying back to an older OS) a backwards compatibility library to allow newer language features to run on an OS where the runtime support is not natively available. Most targets that use Objective-C should use this, although there are rare cases where a target should opt out of this behavior.
    public static func implicitlyLinkObjectiveCRuntimeSupport(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitlyLinkObjectiveCRuntimeSupport, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicitly Link Objective-C Runtime Support
    ///
    /// When linking a target using Objective-C code, implicitly link in Foundation (and if deploying back to an older OS) a backwards compatibility library to allow newer language features to run on an OS where the runtime support is not natively available. Most targets that use Objective-C should use this, although there are rare cases where a target should opt out of this behavior.
    public static let implicitlyLinkObjectiveCRuntimeSupport: BuildSettingsKey = "CLANG_LINK_OBJC_RUNTIME"
}

// MARK: CLANG_MACRO_BACKTRACE_LIMIT
extension BuildSetting {

    /// CLANG_MACRO_BACKTRACE_LIMIT
    public static var clangMacroBacktraceLimit: BuildSetting { 
        BuildSetting(key: .clangMacroBacktraceLimit, value: "0")
    }

    /// CLANG_MACRO_BACKTRACE_LIMIT
    public static func clangMacroBacktraceLimit(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangMacroBacktraceLimit, value: "\(value)")
    }

    /// CLANG_MACRO_BACKTRACE_LIMIT
    public static func clangMacroBacktraceLimit(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangMacroBacktraceLimit, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_MACRO_BACKTRACE_LIMIT
    public static let clangMacroBacktraceLimit: BuildSettingsKey = "CLANG_MACRO_BACKTRACE_LIMIT"
}

// MARK: Add attribute annotations
extension BuildSetting {

    /// Add attribute annotations
    ///
    /// Add attribute annotations to properties and methods.
    public static var addAttributeAnnotations: BuildSetting { 
        BuildSetting(key: .addAttributeAnnotations, value: "YES")
    }

    /// Add attribute annotations
    ///
    /// Add attribute annotations to properties and methods.
    public static func addAttributeAnnotations(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .addAttributeAnnotations, value: SettingValue(booleanLiteral: value))
    }

    /// Add attribute annotations
    ///
    /// Add attribute annotations to properties and methods.
    public static func addAttributeAnnotations(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .addAttributeAnnotations, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Add attribute annotations
    ///
    /// Add attribute annotations to properties and methods.
    public static let addAttributeAnnotations: BuildSettingsKey = "CLANG_MIGRATOR_ANNOTATIONS"
}

// MARK: Infer instancetype for method result type
extension BuildSetting {

    /// Infer instancetype for method result type
    ///
    /// Infer `instancetype` for method result type instead of `id`.
    public static var inferInstancetypeForMethodResultType: BuildSetting { 
        BuildSetting(key: .inferInstancetypeForMethodResultType, value: "YES")
    }

    /// Infer instancetype for method result type
    ///
    /// Infer `instancetype` for method result type instead of `id`.
    public static func inferInstancetypeForMethodResultType(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferInstancetypeForMethodResultType, value: SettingValue(booleanLiteral: value))
    }

    /// Infer instancetype for method result type
    ///
    /// Infer `instancetype` for method result type instead of `id`.
    public static func inferInstancetypeForMethodResultType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferInstancetypeForMethodResultType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer instancetype for method result type
    ///
    /// Infer `instancetype` for method result type instead of `id`.
    public static let inferInstancetypeForMethodResultType: BuildSettingsKey = "CLANG_MIGRATOR_INSTANCE_TYPE"
}

// MARK: Use NS_ENUM/NS_OPTIONS macros
extension BuildSetting {

    /// Use NS_ENUM/NS_OPTIONS macros
    ///
    /// Use `NS_ENUM`/`NS_OPTIONS` macros for enumerators.
    public static var useNsEnumNsOptionsMacros: BuildSetting { 
        BuildSetting(key: .useNsEnumNsOptionsMacros, value: "YES")
    }

    /// Use NS_ENUM/NS_OPTIONS macros
    ///
    /// Use `NS_ENUM`/`NS_OPTIONS` macros for enumerators.
    public static func useNsEnumNsOptionsMacros(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useNsEnumNsOptionsMacros, value: SettingValue(booleanLiteral: value))
    }

    /// Use NS_ENUM/NS_OPTIONS macros
    ///
    /// Use `NS_ENUM`/`NS_OPTIONS` macros for enumerators.
    public static func useNsEnumNsOptionsMacros(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useNsEnumNsOptionsMacros, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use NS_ENUM/NS_OPTIONS macros
    ///
    /// Use `NS_ENUM`/`NS_OPTIONS` macros for enumerators.
    public static let useNsEnumNsOptionsMacros: BuildSettingsKey = "CLANG_MIGRATOR_NSENUM_MACROS"
}

// MARK: Infer designated initializer methods
extension BuildSetting {

    /// Infer designated initializer methods
    ///
    /// Infer `NS_DESIGNATED_INITIALIZER` for designated initializer methods.
    public static var inferDesignatedInitializerMethods: BuildSetting { 
        BuildSetting(key: .inferDesignatedInitializerMethods, value: "YES")
    }

    /// Infer designated initializer methods
    ///
    /// Infer `NS_DESIGNATED_INITIALIZER` for designated initializer methods.
    public static func inferDesignatedInitializerMethods(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferDesignatedInitializerMethods, value: SettingValue(booleanLiteral: value))
    }

    /// Infer designated initializer methods
    ///
    /// Infer `NS_DESIGNATED_INITIALIZER` for designated initializer methods.
    public static func inferDesignatedInitializerMethods(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferDesignatedInitializerMethods, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer designated initializer methods
    ///
    /// Infer `NS_DESIGNATED_INITIALIZER` for designated initializer methods.
    public static let inferDesignatedInitializerMethods: BuildSettingsKey = "CLANG_MIGRATOR_OBJC_DESIGNATED_INIT"
}

// MARK: ObjC literals
extension BuildSetting {

    /// ObjC literals
    ///
    /// Enable migration to modern ObjC literals syntax.
    public static var objcLiterals: BuildSetting { 
        BuildSetting(key: .objcLiterals, value: "YES")
    }

    /// ObjC literals
    ///
    /// Enable migration to modern ObjC literals syntax.
    public static func objcLiterals(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .objcLiterals, value: SettingValue(booleanLiteral: value))
    }

    /// ObjC literals
    ///
    /// Enable migration to modern ObjC literals syntax.
    public static func objcLiterals(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objcLiterals, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ObjC literals
    ///
    /// Enable migration to modern ObjC literals syntax.
    public static let objcLiterals: BuildSettingsKey = "CLANG_MIGRATOR_OBJC_LITERALS"
}

// MARK: ObjC subscripting
extension BuildSetting {

    /// ObjC subscripting
    ///
    /// Enable migration to modern ObjC subscripting syntax.
    public static var objcSubscripting: BuildSetting { 
        BuildSetting(key: .objcSubscripting, value: "YES")
    }

    /// ObjC subscripting
    ///
    /// Enable migration to modern ObjC subscripting syntax.
    public static func objcSubscripting(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .objcSubscripting, value: SettingValue(booleanLiteral: value))
    }

    /// ObjC subscripting
    ///
    /// Enable migration to modern ObjC subscripting syntax.
    public static func objcSubscripting(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objcSubscripting, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ObjC subscripting
    ///
    /// Enable migration to modern ObjC subscripting syntax.
    public static let objcSubscripting: BuildSettingsKey = "CLANG_MIGRATOR_OBJC_SUBSCRIPTING"
}

// MARK: Atomicity of inferred properties
extension BuildSetting {

    /// Atomicity of inferred properties
    ///
    /// Choose the atomicity of the inferred properties.
    public static var atomicityOfInferredProperties: BuildSetting { 
        .atomicityOfInferredProperties(.nsNonatomicIosonly) 
    }

    /// Atomicity of inferred properties
    ///
    /// Choose the atomicity of the inferred properties.
    public static func atomicityOfInferredProperties(_ value: AtomicityOfInferredProperties) -> BuildSetting { 
        BuildSetting(key: .atomicityOfInferredProperties, value: "\(value)")
    }

    /// Atomicity of inferred properties
    ///
    /// Choose the atomicity of the inferred properties.
    public static func atomicityOfInferredProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .atomicityOfInferredProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Atomicity of inferred properties
    ///
    /// Choose the atomicity of the inferred properties.
    public static let atomicityOfInferredProperties: BuildSettingsKey = "CLANG_MIGRATOR_PROPERTY_ATOMICITY"
}

public enum AtomicityOfInferredProperties: String, Hashable, Codable, CustomStringConvertible {
    case nonatomic = "nonatomic"
    case atomic = "atomic"
    case nsNonatomicIosonly = "NS_NONATOMIC_IOSONLY"

    public var description: String {
        rawValue
    }
}

// MARK: ObjC property-dot syntax
extension BuildSetting {

    /// ObjC property-dot syntax
    ///
    /// Enable migration of setter/getter messages to property-dot syntax.
    public static var objcPropertyDotSyntax: BuildSetting { 
        BuildSetting(key: .objcPropertyDotSyntax, value: "YES")
    }

    /// ObjC property-dot syntax
    ///
    /// Enable migration of setter/getter messages to property-dot syntax.
    public static func objcPropertyDotSyntax(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .objcPropertyDotSyntax, value: SettingValue(booleanLiteral: value))
    }

    /// ObjC property-dot syntax
    ///
    /// Enable migration of setter/getter messages to property-dot syntax.
    public static func objcPropertyDotSyntax(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objcPropertyDotSyntax, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ObjC property-dot syntax
    ///
    /// Enable migration of setter/getter messages to property-dot syntax.
    public static let objcPropertyDotSyntax: BuildSettingsKey = "CLANG_MIGRATOR_PROPERTY_DOT_SYNTAX"
}

// MARK: Infer protocol conformance
extension BuildSetting {

    /// Infer protocol conformance
    ///
    /// Infer protocol conformance from the interface methods.
    public static var inferProtocolConformance: BuildSetting { 
        BuildSetting(key: .inferProtocolConformance, value: "NO")
    }

    /// Infer protocol conformance
    ///
    /// Infer protocol conformance from the interface methods.
    public static func inferProtocolConformance(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferProtocolConformance, value: SettingValue(booleanLiteral: value))
    }

    /// Infer protocol conformance
    ///
    /// Infer protocol conformance from the interface methods.
    public static func inferProtocolConformance(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferProtocolConformance, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer protocol conformance
    ///
    /// Infer protocol conformance from the interface methods.
    public static let inferProtocolConformance: BuildSettingsKey = "CLANG_MIGRATOR_PROTOCOL_CONFORMANCE"
}

// MARK: Only modify public headers
extension BuildSetting {

    /// Only modify public headers
    ///
    /// Only modify public headers of a target.
    public static var onlyModifyPublicHeaders: BuildSetting { 
        BuildSetting(key: .onlyModifyPublicHeaders, value: "YES")
    }

    /// Only modify public headers
    ///
    /// Only modify public headers of a target.
    public static func onlyModifyPublicHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .onlyModifyPublicHeaders, value: SettingValue(booleanLiteral: value))
    }

    /// Only modify public headers
    ///
    /// Only modify public headers of a target.
    public static func onlyModifyPublicHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .onlyModifyPublicHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Only modify public headers
    ///
    /// Only modify public headers of a target.
    public static let onlyModifyPublicHeaders: BuildSettingsKey = "CLANG_MIGRATOR_PUBLIC_HEADERS_ONLY"
}

// MARK: Infer readonly properties
extension BuildSetting {

    /// Infer readonly properties
    ///
    /// Infer readonly properties from getter methods.
    public static var inferReadonlyProperties: BuildSetting { 
        BuildSetting(key: .inferReadonlyProperties, value: "YES")
    }

    /// Infer readonly properties
    ///
    /// Infer readonly properties from getter methods.
    public static func inferReadonlyProperties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferReadonlyProperties, value: SettingValue(booleanLiteral: value))
    }

    /// Infer readonly properties
    ///
    /// Infer readonly properties from getter methods.
    public static func inferReadonlyProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferReadonlyProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer readonly properties
    ///
    /// Infer readonly properties from getter methods.
    public static let inferReadonlyProperties: BuildSettingsKey = "CLANG_MIGRATOR_READONLY_PROPERTY"
}

// MARK: Infer readwrite properties
extension BuildSetting {

    /// Infer readwrite properties
    ///
    /// Infer readwrite properties from a getter and setter method.
    public static var inferReadwriteProperties: BuildSetting { 
        BuildSetting(key: .inferReadwriteProperties, value: "YES")
    }

    /// Infer readwrite properties
    ///
    /// Infer readwrite properties from a getter and setter method.
    public static func inferReadwriteProperties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inferReadwriteProperties, value: SettingValue(booleanLiteral: value))
    }

    /// Infer readwrite properties
    ///
    /// Infer readwrite properties from a getter and setter method.
    public static func inferReadwriteProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inferReadwriteProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infer readwrite properties
    ///
    /// Infer readwrite properties from a getter and setter method.
    public static let inferReadwriteProperties: BuildSettingsKey = "CLANG_MIGRATOR_READWRITE_PROPERTY"
}

// MARK: Link Frameworks Automatically
extension BuildSetting {

    /// Link Frameworks Automatically
    ///
    /// Automatically link SDK frameworks that are referenced using `#import` or `#include`. This feature requires also enabling support for modules. This build setting only applies to C-family languages.
    public static var linkFrameworksAutomatically: BuildSetting { 
        BuildSetting(key: .linkFrameworksAutomatically, value: "YES")
    }

    /// Link Frameworks Automatically
    ///
    /// Automatically link SDK frameworks that are referenced using `#import` or `#include`. This feature requires also enabling support for modules. This build setting only applies to C-family languages.
    public static func linkFrameworksAutomatically(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .linkFrameworksAutomatically, value: SettingValue(booleanLiteral: value))
    }

    /// Link Frameworks Automatically
    ///
    /// Automatically link SDK frameworks that are referenced using `#import` or `#include`. This feature requires also enabling support for modules. This build setting only applies to C-family languages.
    public static func linkFrameworksAutomatically(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkFrameworksAutomatically, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Link Frameworks Automatically
    ///
    /// Automatically link SDK frameworks that are referenced using `#import` or `#include`. This feature requires also enabling support for modules. This build setting only applies to C-family languages.
    public static let linkFrameworksAutomatically: BuildSettingsKey = "CLANG_MODULES_AUTOLINK"
}

// MARK: CLANG_MODULES_BUILD_SESSION_FILE
extension BuildSetting {

    /// CLANG_MODULES_BUILD_SESSION_FILE
    public static var clangModulesBuildSessionFile: BuildSetting { 
        BuildSetting(key: .clangModulesBuildSessionFile, value: "")
    }

    /// CLANG_MODULES_BUILD_SESSION_FILE
    public static func clangModulesBuildSessionFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangModulesBuildSessionFile, value: "\(value)")
    }

    /// CLANG_MODULES_BUILD_SESSION_FILE
    public static func clangModulesBuildSessionFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesBuildSessionFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_MODULES_BUILD_SESSION_FILE
    public static let clangModulesBuildSessionFile: BuildSettingsKey = "CLANG_MODULES_BUILD_SESSION_FILE"
}

// MARK: Disable Private Modules Warnings
extension BuildSetting {

    /// Disable Private Modules Warnings
    ///
    /// Disable warnings related to the recommended use of private module naming. This only makes sense when support for modules is enabled.
    public static var disablePrivateModulesWarnings: BuildSetting { 
        BuildSetting(key: .disablePrivateModulesWarnings, value: "NO")
    }

    /// Disable Private Modules Warnings
    ///
    /// Disable warnings related to the recommended use of private module naming. This only makes sense when support for modules is enabled.
    public static func disablePrivateModulesWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .disablePrivateModulesWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Disable Private Modules Warnings
    ///
    /// Disable warnings related to the recommended use of private module naming. This only makes sense when support for modules is enabled.
    public static func disablePrivateModulesWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .disablePrivateModulesWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Disable Private Modules Warnings
    ///
    /// Disable warnings related to the recommended use of private module naming. This only makes sense when support for modules is enabled.
    public static let disablePrivateModulesWarnings: BuildSettingsKey = "CLANG_MODULES_DISABLE_PRIVATE_WARNING"
}

// MARK: CLANG_MODULES_IGNORE_MACROS
extension BuildSetting {

    /// CLANG_MODULES_IGNORE_MACROS
    public static var clangModulesIgnoreMacros: BuildSetting { 
        .clangModulesIgnoreMacros(inherit: .preprocessorMacrosNotUsedInPrecompiledHeaders) 
    }

    /// CLANG_MODULES_IGNORE_MACROS
    public static func clangModulesIgnoreMacros(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangModulesIgnoreMacros, value: .array(value))
    }

    /// CLANG_MODULES_IGNORE_MACROS
    public static func clangModulesIgnoreMacros(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesIgnoreMacros, inherit: key)
    }

    /// CLANG_MODULES_IGNORE_MACROS
    public static func clangModulesIgnoreMacros(_ value: String...) -> BuildSetting { 
        .clangModulesIgnoreMacros(value)
    }
}

extension BuildSettingsKey {

    /// CLANG_MODULES_IGNORE_MACROS
    public static let clangModulesIgnoreMacros: BuildSettingsKey = "CLANG_MODULES_IGNORE_MACROS"
}

// MARK: CLANG_MODULES_PRUNE_AFTER
extension BuildSetting {

    /// CLANG_MODULES_PRUNE_AFTER
    public static var clangModulesPruneAfter: BuildSetting { 
        BuildSetting(key: .clangModulesPruneAfter, value: "345600")
    }

    /// CLANG_MODULES_PRUNE_AFTER
    public static func clangModulesPruneAfter(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangModulesPruneAfter, value: "\(value)")
    }

    /// CLANG_MODULES_PRUNE_AFTER
    public static func clangModulesPruneAfter(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesPruneAfter, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_MODULES_PRUNE_AFTER
    public static let clangModulesPruneAfter: BuildSettingsKey = "CLANG_MODULES_PRUNE_AFTER"
}

// MARK: CLANG_MODULES_PRUNE_INTERVAL
extension BuildSetting {

    /// CLANG_MODULES_PRUNE_INTERVAL
    public static var clangModulesPruneInterval: BuildSetting { 
        BuildSetting(key: .clangModulesPruneInterval, value: "86400")
    }

    /// CLANG_MODULES_PRUNE_INTERVAL
    public static func clangModulesPruneInterval(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangModulesPruneInterval, value: "\(value)")
    }

    /// CLANG_MODULES_PRUNE_INTERVAL
    public static func clangModulesPruneInterval(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesPruneInterval, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_MODULES_PRUNE_INTERVAL
    public static let clangModulesPruneInterval: BuildSettingsKey = "CLANG_MODULES_PRUNE_INTERVAL"
}

// MARK: CLANG_MODULES_VALIDATE_SYSTEM_HEADERS
extension BuildSetting {

    /// CLANG_MODULES_VALIDATE_SYSTEM_HEADERS
    public static var clangModulesValidateSystemHeaders: BuildSetting { 
        BuildSetting(key: .clangModulesValidateSystemHeaders, value: "NO")
    }

    /// CLANG_MODULES_VALIDATE_SYSTEM_HEADERS
    public static func clangModulesValidateSystemHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangModulesValidateSystemHeaders, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_MODULES_VALIDATE_SYSTEM_HEADERS
    public static func clangModulesValidateSystemHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModulesValidateSystemHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_MODULES_VALIDATE_SYSTEM_HEADERS
    public static let clangModulesValidateSystemHeaders: BuildSettingsKey = "CLANG_MODULES_VALIDATE_SYSTEM_HEADERS"
}

// MARK: CLANG_MODULE_CACHE_PATH
extension BuildSetting {

    /// CLANG_MODULE_CACHE_PATH
    public static func clangModuleCachePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangModuleCachePath, value: "\(value)")
    }

    /// CLANG_MODULE_CACHE_PATH
    public static func clangModuleCachePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModuleCachePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_MODULE_CACHE_PATH
    public static let clangModuleCachePath: BuildSettingsKey = "CLANG_MODULE_CACHE_PATH"
}

// MARK: CLANG_MODULE_LSV
extension BuildSetting {

    /// CLANG_MODULE_LSV
    public static var clangModuleLsv: BuildSetting { 
        BuildSetting(key: .clangModuleLsv, value: "NO")
    }

    /// CLANG_MODULE_LSV
    public static func clangModuleLsv(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangModuleLsv, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_MODULE_LSV
    public static func clangModuleLsv(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangModuleLsv, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_MODULE_LSV
    public static let clangModuleLsv: BuildSettingsKey = "CLANG_MODULE_LSV"
}

// MARK: CLANG_OBJC_MIGRATE_DIR
extension BuildSetting {

    /// CLANG_OBJC_MIGRATE_DIR
    public static func clangObjcMigrateDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangObjcMigrateDir, value: "\(value)")
    }

    /// CLANG_OBJC_MIGRATE_DIR
    public static func clangObjcMigrateDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangObjcMigrateDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_OBJC_MIGRATE_DIR
    public static let clangObjcMigrateDir: BuildSettingsKey = "CLANG_OBJC_MIGRATE_DIR"
}

// MARK: Optimization Profile File
extension BuildSetting {

    /// Optimization Profile File
    ///
    /// The path to the file of the profile data to use when [Use Optimization Profile (CLANG\_USE\_OPTIMIZATION\_PROFILE)](itcaec37c2a6.html#devb3d935f24) is enabled.
    public static var optimizationProfileFile: BuildSetting { 
        BuildSetting(key: .optimizationProfileFile, value: "$(SRCROOT)/OptimizationProfiles/$(PROJECT_NAME).profdata")
    }

    /// Optimization Profile File
    ///
    /// The path to the file of the profile data to use when [Use Optimization Profile (CLANG\_USE\_OPTIMIZATION\_PROFILE)](itcaec37c2a6.html#devb3d935f24) is enabled.
    public static func optimizationProfileFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .optimizationProfileFile, value: "\(value)")
    }

    /// Optimization Profile File
    ///
    /// The path to the file of the profile data to use when [Use Optimization Profile (CLANG\_USE\_OPTIMIZATION\_PROFILE)](itcaec37c2a6.html#devb3d935f24) is enabled.
    public static func optimizationProfileFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimizationProfileFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Optimization Profile File
    ///
    /// The path to the file of the profile data to use when [Use Optimization Profile (CLANG\_USE\_OPTIMIZATION\_PROFILE)](itcaec37c2a6.html#devb3d935f24) is enabled.
    public static let optimizationProfileFile: BuildSettingsKey = "CLANG_OPTIMIZATION_PROFILE_FILE"
}

// MARK: CLANG_RETAIN_COMMENTS_FROM_SYSTEM_HEADERS
extension BuildSetting {

    /// CLANG_RETAIN_COMMENTS_FROM_SYSTEM_HEADERS
    public static var clangRetainCommentsFromSystemHeaders: BuildSetting { 
        BuildSetting(key: .clangRetainCommentsFromSystemHeaders, value: "NO")
    }

    /// CLANG_RETAIN_COMMENTS_FROM_SYSTEM_HEADERS
    public static func clangRetainCommentsFromSystemHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangRetainCommentsFromSystemHeaders, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_RETAIN_COMMENTS_FROM_SYSTEM_HEADERS
    public static func clangRetainCommentsFromSystemHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangRetainCommentsFromSystemHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_RETAIN_COMMENTS_FROM_SYSTEM_HEADERS
    public static let clangRetainCommentsFromSystemHeaders: BuildSettingsKey = "CLANG_RETAIN_COMMENTS_FROM_SYSTEM_HEADERS"
}

// MARK: Mode of Analysis for 'Build'
extension BuildSetting {

    /// Mode of Analysis for 'Build'
    ///
    /// The depth the static analyzer uses during the Build action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static var modeOfAnalysisForBuild: BuildSetting { 
        .modeOfAnalysisForBuild(.shallow) 
    }

    /// Mode of Analysis for 'Build'
    ///
    /// The depth the static analyzer uses during the Build action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static func modeOfAnalysisForBuild(_ value: ModeOfAnalysisForBuild) -> BuildSetting { 
        BuildSetting(key: .modeOfAnalysisForBuild, value: "\(value)")
    }

    /// Mode of Analysis for 'Build'
    ///
    /// The depth the static analyzer uses during the Build action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static func modeOfAnalysisForBuild(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .modeOfAnalysisForBuild, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mode of Analysis for 'Build'
    ///
    /// The depth the static analyzer uses during the Build action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static let modeOfAnalysisForBuild: BuildSettingsKey = "CLANG_STATIC_ANALYZER_MODE"
}

public enum ModeOfAnalysisForBuild: String, Hashable, Codable, CustomStringConvertible {
    case shallow = "shallow"
    case deep = "deep"

    public var description: String {
        rawValue
    }
}

// MARK: CLANG_STATIC_ANALYZER_MODE_ACTION_deep
extension BuildSetting {

    /// CLANG_STATIC_ANALYZER_MODE_ACTION_deep
    public static var clangStaticAnalyzerModeActionDeep: BuildSetting { 
        BuildSetting(key: .clangStaticAnalyzerModeActionDeep, value: "")
    }

    /// CLANG_STATIC_ANALYZER_MODE_ACTION_deep
    public static func clangStaticAnalyzerModeActionDeep(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangStaticAnalyzerModeActionDeep, value: "\(value)")
    }

    /// CLANG_STATIC_ANALYZER_MODE_ACTION_deep
    public static func clangStaticAnalyzerModeActionDeep(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangStaticAnalyzerModeActionDeep, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_STATIC_ANALYZER_MODE_ACTION_deep
    public static let clangStaticAnalyzerModeActionDeep: BuildSettingsKey = "CLANG_STATIC_ANALYZER_MODE_ACTION_deep"
}

// MARK: CLANG_STATIC_ANALYZER_MODE_ACTION_shallow
extension BuildSetting {

    /// CLANG_STATIC_ANALYZER_MODE_ACTION_shallow
    public static var clangStaticAnalyzerModeActionShallow: BuildSetting { 
        BuildSetting(key: .clangStaticAnalyzerModeActionShallow, value: "Shallow")
    }

    /// CLANG_STATIC_ANALYZER_MODE_ACTION_shallow
    public static func clangStaticAnalyzerModeActionShallow(_ value: String) -> BuildSetting { 
        BuildSetting(key: .clangStaticAnalyzerModeActionShallow, value: "\(value)")
    }

    /// CLANG_STATIC_ANALYZER_MODE_ACTION_shallow
    public static func clangStaticAnalyzerModeActionShallow(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangStaticAnalyzerModeActionShallow, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_STATIC_ANALYZER_MODE_ACTION_shallow
    public static let clangStaticAnalyzerModeActionShallow: BuildSettingsKey = "CLANG_STATIC_ANALYZER_MODE_ACTION_shallow"
}

// MARK: Mode of Analysis for 'Analyze'
extension BuildSetting {

    /// Mode of Analysis for 'Analyze'
    ///
    /// The depth the static analyzer uses during the Analyze action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static var modeOfAnalysisForAnalyze: BuildSetting { 
        .modeOfAnalysisForAnalyze(.deep) 
    }

    /// Mode of Analysis for 'Analyze'
    ///
    /// The depth the static analyzer uses during the Analyze action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static func modeOfAnalysisForAnalyze(_ value: ModeOfAnalysisForAnalyze) -> BuildSetting { 
        BuildSetting(key: .modeOfAnalysisForAnalyze, value: "\(value)")
    }

    /// Mode of Analysis for 'Analyze'
    ///
    /// The depth the static analyzer uses during the Analyze action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static func modeOfAnalysisForAnalyze(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .modeOfAnalysisForAnalyze, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mode of Analysis for 'Analyze'
    ///
    /// The depth the static analyzer uses during the Analyze action. Use `Deep` to exercise the full power of the analyzer. Use `Shallow` for faster analysis.
    public static let modeOfAnalysisForAnalyze: BuildSettingsKey = "CLANG_STATIC_ANALYZER_MODE_ON_ANALYZE_ACTION"
}

public enum ModeOfAnalysisForAnalyze: String, Hashable, Codable, CustomStringConvertible {
    case shallow = "shallow"
    case deep = "deep"

    public var description: String {
        rawValue
    }
}

// MARK: CLANG_TARGET_TRIPLE_ARCHS
extension BuildSetting {

    /// CLANG_TARGET_TRIPLE_ARCHS
    public static var clangTargetTripleArchs: BuildSetting { 
        .clangTargetTripleArchs(inherit: .currentArch) 
    }

    /// CLANG_TARGET_TRIPLE_ARCHS
    public static func clangTargetTripleArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangTargetTripleArchs, value: .array(value))
    }

    /// CLANG_TARGET_TRIPLE_ARCHS
    public static func clangTargetTripleArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangTargetTripleArchs, inherit: key)
    }

    /// CLANG_TARGET_TRIPLE_ARCHS
    public static func clangTargetTripleArchs(_ value: String...) -> BuildSetting { 
        .clangTargetTripleArchs(value)
    }
}

extension BuildSettingsKey {

    /// CLANG_TARGET_TRIPLE_ARCHS
    public static let clangTargetTripleArchs: BuildSettingsKey = "CLANG_TARGET_TRIPLE_ARCHS"
}

// MARK: CLANG_TARGET_TRIPLE_VARIANTS
extension BuildSetting {

    /// CLANG_TARGET_TRIPLE_VARIANTS
    public static func clangTargetTripleVariants(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangTargetTripleVariants, value: .array(value))
    }

    /// CLANG_TARGET_TRIPLE_VARIANTS
    public static func clangTargetTripleVariants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangTargetTripleVariants, inherit: key)
    }

    /// CLANG_TARGET_TRIPLE_VARIANTS
    public static func clangTargetTripleVariants(_ value: String...) -> BuildSetting { 
        .clangTargetTripleVariants(value)
    }
}

extension BuildSettingsKey {

    /// CLANG_TARGET_TRIPLE_VARIANTS
    public static let clangTargetTripleVariants: BuildSettingsKey = "CLANG_TARGET_TRIPLE_VARIANTS"
}

// MARK: CLANG_THREAD_SANITIZER
extension BuildSetting {

    /// CLANG_THREAD_SANITIZER
    public static func clangThreadSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangThreadSanitizer, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_THREAD_SANITIZER
    public static func clangThreadSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangThreadSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_THREAD_SANITIZER
    public static let clangThreadSanitizer: BuildSettingsKey = "CLANG_THREAD_SANITIZER"
}

// MARK: CLANG_TOOLCHAIN_FLAGS
extension BuildSetting {

    /// CLANG_TOOLCHAIN_FLAGS
    public static func clangToolchainFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .clangToolchainFlags, value: .array(value))
    }

    /// CLANG_TOOLCHAIN_FLAGS
    public static func clangToolchainFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangToolchainFlags, inherit: key)
    }

    /// CLANG_TOOLCHAIN_FLAGS
    public static func clangToolchainFlags(_ value: String...) -> BuildSetting { 
        .clangToolchainFlags(value)
    }
}

extension BuildSettingsKey {

    /// CLANG_TOOLCHAIN_FLAGS
    public static let clangToolchainFlags: BuildSettingsKey = "CLANG_TOOLCHAIN_FLAGS"
}

// MARK: Trivial automatic variable initialization
extension BuildSetting {

    /// Trivial automatic variable initialization
    ///
    /// Specify whether stack variables should be uninitialized, which can cause inadvertent information disclosure when uninitialized stack variables are used, or whether they should be pattern-initialized.
    public static var trivialAutomaticVariableInitialization: BuildSetting { 
        .trivialAutomaticVariableInitialization(.uninitialized) 
    }

    /// Trivial automatic variable initialization
    ///
    /// Specify whether stack variables should be uninitialized, which can cause inadvertent information disclosure when uninitialized stack variables are used, or whether they should be pattern-initialized.
    public static func trivialAutomaticVariableInitialization(_ value: TrivialAutomaticVariableInitialization) -> BuildSetting { 
        BuildSetting(key: .trivialAutomaticVariableInitialization, value: "\(value)")
    }

    /// Trivial automatic variable initialization
    ///
    /// Specify whether stack variables should be uninitialized, which can cause inadvertent information disclosure when uninitialized stack variables are used, or whether they should be pattern-initialized.
    public static func trivialAutomaticVariableInitialization(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .trivialAutomaticVariableInitialization, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Trivial automatic variable initialization
    ///
    /// Specify whether stack variables should be uninitialized, which can cause inadvertent information disclosure when uninitialized stack variables are used, or whether they should be pattern-initialized.
    public static let trivialAutomaticVariableInitialization: BuildSettingsKey = "CLANG_TRIVIAL_AUTO_VAR_INIT"
}

public enum TrivialAutomaticVariableInitialization: String, Hashable, Codable, CustomStringConvertible {
    case uninitialized = "uninitialized"
    case pattern = "pattern"

    public var description: String {
        rawValue
    }
}

// MARK: CLANG_UNDEFINED_BEHAVIOR_SANITIZER
extension BuildSetting {

    /// CLANG_UNDEFINED_BEHAVIOR_SANITIZER
    public static func clangUndefinedBehaviorSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .clangUndefinedBehaviorSanitizer, value: SettingValue(booleanLiteral: value))
    }

    /// CLANG_UNDEFINED_BEHAVIOR_SANITIZER
    public static func clangUndefinedBehaviorSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangUndefinedBehaviorSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_UNDEFINED_BEHAVIOR_SANITIZER
    public static let clangUndefinedBehaviorSanitizer: BuildSettingsKey = "CLANG_UNDEFINED_BEHAVIOR_SANITIZER"
}

// MARK: Enable Extra Integer Checks
extension BuildSetting {

    /// Enable Extra Integer Checks
    ///
    /// Check for unsigned integer overflow, in addition to checks for signed integer overflow.
    public static var enableExtraIntegerChecks: BuildSetting { 
        BuildSetting(key: .enableExtraIntegerChecks, value: "NO")
    }

    /// Enable Extra Integer Checks
    ///
    /// Check for unsigned integer overflow, in addition to checks for signed integer overflow.
    public static func enableExtraIntegerChecks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableExtraIntegerChecks, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Extra Integer Checks
    ///
    /// Check for unsigned integer overflow, in addition to checks for signed integer overflow.
    public static func enableExtraIntegerChecks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableExtraIntegerChecks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Extra Integer Checks
    ///
    /// Check for unsigned integer overflow, in addition to checks for signed integer overflow.
    public static let enableExtraIntegerChecks: BuildSettingsKey = "CLANG_UNDEFINED_BEHAVIOR_SANITIZER_INTEGER"
}

// MARK: Enable Nullability Annotation Checks
extension BuildSetting {

    /// Enable Nullability Annotation Checks
    ///
    /// Check for violations of nullability annotations in function calls, return statements, and assignments.
    public static var enableNullabilityAnnotationChecks: BuildSetting { 
        BuildSetting(key: .enableNullabilityAnnotationChecks, value: "NO")
    }

    /// Enable Nullability Annotation Checks
    ///
    /// Check for violations of nullability annotations in function calls, return statements, and assignments.
    public static func enableNullabilityAnnotationChecks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableNullabilityAnnotationChecks, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Nullability Annotation Checks
    ///
    /// Check for violations of nullability annotations in function calls, return statements, and assignments.
    public static func enableNullabilityAnnotationChecks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableNullabilityAnnotationChecks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Nullability Annotation Checks
    ///
    /// Check for violations of nullability annotations in function calls, return statements, and assignments.
    public static let enableNullabilityAnnotationChecks: BuildSettingsKey = "CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY"
}

// MARK: Use Optimization Profile
extension BuildSetting {

    /// Use Optimization Profile
    ///
    /// When this setting is enabled, `clang` will use the optimization profile collected for a target when building it.
    public static var useOptimizationProfile: BuildSetting { 
        BuildSetting(key: .useOptimizationProfile, value: "NO")
    }

    /// Use Optimization Profile
    ///
    /// When this setting is enabled, `clang` will use the optimization profile collected for a target when building it.
    public static func useOptimizationProfile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useOptimizationProfile, value: SettingValue(booleanLiteral: value))
    }

    /// Use Optimization Profile
    ///
    /// When this setting is enabled, `clang` will use the optimization profile collected for a target when building it.
    public static func useOptimizationProfile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useOptimizationProfile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Optimization Profile
    ///
    /// When this setting is enabled, `clang` will use the optimization profile collected for a target when building it.
    public static let useOptimizationProfile: BuildSettingsKey = "CLANG_USE_OPTIMIZATION_PROFILE"
}

// MARK: Out-of-Range Enum Assignments
extension BuildSetting {

    /// Out-of-Range Enum Assignments
    ///
    /// Warn about assigning integer constants to enum values that are out of the range of the enumerated type.
    public static var outOfRangeEnumAssignments: BuildSetting { 
        BuildSetting(key: .outOfRangeEnumAssignments, value: "NO")
    }

    /// Out-of-Range Enum Assignments
    ///
    /// Warn about assigning integer constants to enum values that are out of the range of the enumerated type.
    public static func outOfRangeEnumAssignments(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .outOfRangeEnumAssignments, value: SettingValue(booleanLiteral: value))
    }

    /// Out-of-Range Enum Assignments
    ///
    /// Warn about assigning integer constants to enum values that are out of the range of the enumerated type.
    public static func outOfRangeEnumAssignments(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .outOfRangeEnumAssignments, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Out-of-Range Enum Assignments
    ///
    /// Warn about assigning integer constants to enum values that are out of the range of the enumerated type.
    public static let outOfRangeEnumAssignments: BuildSettingsKey = "CLANG_WARN_ASSIGN_ENUM"
}

// MARK: Usage of implicit sequentially-consistent atomics
extension BuildSetting {

    /// Usage of implicit sequentially-consistent atomics
    ///
    /// Warns when an atomic is used with an implicitly sequentially-consistent memory order, instead of explicitly specifying memory order.
    public static var usageOfImplicitSequentiallyConsistentAtomics: BuildSetting { 
        BuildSetting(key: .usageOfImplicitSequentiallyConsistentAtomics, value: "NO")
    }

    /// Usage of implicit sequentially-consistent atomics
    ///
    /// Warns when an atomic is used with an implicitly sequentially-consistent memory order, instead of explicitly specifying memory order.
    public static func usageOfImplicitSequentiallyConsistentAtomics(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .usageOfImplicitSequentiallyConsistentAtomics, value: SettingValue(booleanLiteral: value))
    }

    /// Usage of implicit sequentially-consistent atomics
    ///
    /// Warns when an atomic is used with an implicitly sequentially-consistent memory order, instead of explicitly specifying memory order.
    public static func usageOfImplicitSequentiallyConsistentAtomics(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .usageOfImplicitSequentiallyConsistentAtomics, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Usage of implicit sequentially-consistent atomics
    ///
    /// Warns when an atomic is used with an implicitly sequentially-consistent memory order, instead of explicitly specifying memory order.
    public static let usageOfImplicitSequentiallyConsistentAtomics: BuildSettingsKey = "CLANG_WARN_ATOMIC_IMPLICIT_SEQ_CST"
}

// MARK: Block Capture of Autoreleasing
extension BuildSetting {

    /// Block Capture of Autoreleasing
    ///
    /// Warn about block captures of implicitly autoreleasing parameters.
    public static var blockCaptureOfAutoreleasing: BuildSetting { 
        .blockCaptureOfAutoreleasing(.no) 
    }

    /// Block Capture of Autoreleasing
    ///
    /// Warn about block captures of implicitly autoreleasing parameters.
    public static func blockCaptureOfAutoreleasing(_ value: BlockCaptureOfAutoreleasing) -> BuildSetting { 
        BuildSetting(key: .blockCaptureOfAutoreleasing, value: "\(value)")
    }

    /// Block Capture of Autoreleasing
    ///
    /// Warn about block captures of implicitly autoreleasing parameters.
    public static func blockCaptureOfAutoreleasing(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .blockCaptureOfAutoreleasing, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Block Capture of Autoreleasing
    ///
    /// Warn about block captures of implicitly autoreleasing parameters.
    public static let blockCaptureOfAutoreleasing: BuildSettingsKey = "CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING"
}

public enum BlockCaptureOfAutoreleasing: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}


extension BlockCaptureOfAutoreleasing: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Implicit Boolean Conversions
extension BuildSetting {

    /// Implicit Boolean Conversions
    ///
    /// Warn about implicit conversions to boolean values that are suspicious. For example, writing `if (foo)` where `foo` is the name a function will trigger a warning.
    public static var implicitBooleanConversions: BuildSetting { 
        .implicitBooleanConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Boolean Conversions
    ///
    /// Warn about implicit conversions to boolean values that are suspicious. For example, writing `if (foo)` where `foo` is the name a function will trigger a warning.
    public static func implicitBooleanConversions(_ value: ImplicitBooleanConversions) -> BuildSetting { 
        BuildSetting(key: .implicitBooleanConversions, value: "\(value)")
    }

    /// Implicit Boolean Conversions
    ///
    /// Warn about implicit conversions to boolean values that are suspicious. For example, writing `if (foo)` where `foo` is the name a function will trigger a warning.
    public static func implicitBooleanConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitBooleanConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Boolean Conversions
    ///
    /// Warn about implicit conversions to boolean values that are suspicious. For example, writing `if (foo)` where `foo` is the name a function will trigger a warning.
    public static let implicitBooleanConversions: BuildSettingsKey = "CLANG_WARN_BOOL_CONVERSION"
}

public enum ImplicitBooleanConversions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ImplicitBooleanConversions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Suspicious Commas
extension BuildSetting {

    /// Suspicious Commas
    ///
    /// Warn about suspicious uses of the comma operator.
    public static var suspiciousCommas: BuildSetting { 
        .suspiciousCommas(.no) 
    }

    /// Suspicious Commas
    ///
    /// Warn about suspicious uses of the comma operator.
    public static func suspiciousCommas(_ value: SuspiciousCommas) -> BuildSetting { 
        BuildSetting(key: .suspiciousCommas, value: "\(value)")
    }

    /// Suspicious Commas
    ///
    /// Warn about suspicious uses of the comma operator.
    public static func suspiciousCommas(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousCommas, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Commas
    ///
    /// Warn about suspicious uses of the comma operator.
    public static let suspiciousCommas: BuildSettingsKey = "CLANG_WARN_COMMA"
}

public enum SuspiciousCommas: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}


extension SuspiciousCommas: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Implicit Constant Conversions
extension BuildSetting {

    /// Implicit Constant Conversions
    ///
    /// Warn about implicit conversions of constant values that cause the constant value to change, either through a loss of precision, or entirely in its meaning.
    public static var implicitConstantConversions: BuildSetting { 
        .implicitConstantConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Constant Conversions
    ///
    /// Warn about implicit conversions of constant values that cause the constant value to change, either through a loss of precision, or entirely in its meaning.
    public static func implicitConstantConversions(_ value: ImplicitConstantConversions) -> BuildSetting { 
        BuildSetting(key: .implicitConstantConversions, value: "\(value)")
    }

    /// Implicit Constant Conversions
    ///
    /// Warn about implicit conversions of constant values that cause the constant value to change, either through a loss of precision, or entirely in its meaning.
    public static func implicitConstantConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitConstantConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Constant Conversions
    ///
    /// Warn about implicit conversions of constant values that cause the constant value to change, either through a loss of precision, or entirely in its meaning.
    public static let implicitConstantConversions: BuildSettingsKey = "CLANG_WARN_CONSTANT_CONVERSION"
}

public enum ImplicitConstantConversions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ImplicitConstantConversions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Using C++11 extensions in earlier versions of C++
extension BuildSetting {

    /// Using C++11 extensions in earlier versions of C++
    ///
    /// When compiling C++ code using a language standard older than C++11, warn about the use of C++11 extensions.
    public static var usingCpp11ExtensionsInEarlierVersionsOfCpp: BuildSetting { 
        BuildSetting(key: .usingCpp11ExtensionsInEarlierVersionsOfCpp, value: "NO")
    }

    /// Using C++11 extensions in earlier versions of C++
    ///
    /// When compiling C++ code using a language standard older than C++11, warn about the use of C++11 extensions.
    public static func usingCpp11ExtensionsInEarlierVersionsOfCpp(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .usingCpp11ExtensionsInEarlierVersionsOfCpp, value: SettingValue(booleanLiteral: value))
    }

    /// Using C++11 extensions in earlier versions of C++
    ///
    /// When compiling C++ code using a language standard older than C++11, warn about the use of C++11 extensions.
    public static func usingCpp11ExtensionsInEarlierVersionsOfCpp(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .usingCpp11ExtensionsInEarlierVersionsOfCpp, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Using C++11 extensions in earlier versions of C++
    ///
    /// When compiling C++ code using a language standard older than C++11, warn about the use of C++11 extensions.
    public static let usingCpp11ExtensionsInEarlierVersionsOfCpp: BuildSettingsKey = "CLANG_WARN_CXX0X_EXTENSIONS"
}

// MARK: Deleting Instance of Polymorphic Class with No Virtual Destructor
extension BuildSetting {

    /// Deleting Instance of Polymorphic Class with No Virtual Destructor
    ///
    /// Warn when deleting an instance of a polymorphic class with virtual functions but without a virtual destructor.
    public static var deletingInstanceOfPolymorphicClassWithNoVirtualDestructor: BuildSetting { 
        .deletingInstanceOfPolymorphicClassWithNoVirtualDestructor(.yes) 
    }

    /// Deleting Instance of Polymorphic Class with No Virtual Destructor
    ///
    /// Warn when deleting an instance of a polymorphic class with virtual functions but without a virtual destructor.
    public static func deletingInstanceOfPolymorphicClassWithNoVirtualDestructor(_ value: DeletingInstanceOfPolymorphicClassWithNoVirtualDestructor) -> BuildSetting { 
        BuildSetting(key: .deletingInstanceOfPolymorphicClassWithNoVirtualDestructor, value: "\(value)")
    }

    /// Deleting Instance of Polymorphic Class with No Virtual Destructor
    ///
    /// Warn when deleting an instance of a polymorphic class with virtual functions but without a virtual destructor.
    public static func deletingInstanceOfPolymorphicClassWithNoVirtualDestructor(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deletingInstanceOfPolymorphicClassWithNoVirtualDestructor, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Deleting Instance of Polymorphic Class with No Virtual Destructor
    ///
    /// Warn when deleting an instance of a polymorphic class with virtual functions but without a virtual destructor.
    public static let deletingInstanceOfPolymorphicClassWithNoVirtualDestructor: BuildSettingsKey = "CLANG_WARN_DELETE_NON_VIRTUAL_DTOR"
}

public enum DeletingInstanceOfPolymorphicClassWithNoVirtualDestructor: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension DeletingInstanceOfPolymorphicClassWithNoVirtualDestructor: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Overriding Deprecated Objective-C Methods
extension BuildSetting {

    /// Overriding Deprecated Objective-C Methods
    @available(*, deprecated, message: "Warn if an Objective-C class either subclasses a deprecated class or overrides a method that has been marked deprecated or unavailable.")
    public static var overridingDeprecatedObjectiveCMethods: BuildSetting { 
        BuildSetting(key: .overridingDeprecatedObjectiveCMethods, value: "NO")
    }

    /// Overriding Deprecated Objective-C Methods
    @available(*, deprecated, message: "Warn if an Objective-C class either subclasses a deprecated class or overrides a method that has been marked deprecated or unavailable.")
    public static func overridingDeprecatedObjectiveCMethods(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .overridingDeprecatedObjectiveCMethods, value: SettingValue(booleanLiteral: value))
    }

    /// Overriding Deprecated Objective-C Methods
    @available(*, deprecated, message: "Warn if an Objective-C class either subclasses a deprecated class or overrides a method that has been marked deprecated or unavailable.")
    public static func overridingDeprecatedObjectiveCMethods(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .overridingDeprecatedObjectiveCMethods, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Overriding Deprecated Objective-C Methods
    @available(*, deprecated, message: "Warn if an Objective-C class either subclasses a deprecated class or overrides a method that has been marked deprecated or unavailable.")
    public static let overridingDeprecatedObjectiveCMethods: BuildSettingsKey = "CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS"
}

// MARK: Direct usage of 'isa'
extension BuildSetting {

    /// Direct usage of 'isa'
    ///
    /// Warn about direct accesses to the Objective-C `isa` pointer instead of using a runtime API.
    public static var directUsageOfIsa: BuildSetting { 
        .directUsageOfIsa(.yes) 
    }

    /// Direct usage of 'isa'
    ///
    /// Warn about direct accesses to the Objective-C `isa` pointer instead of using a runtime API.
    public static func directUsageOfIsa(_ value: DirectUsageOfIsa) -> BuildSetting { 
        BuildSetting(key: .directUsageOfIsa, value: "\(value)")
    }

    /// Direct usage of 'isa'
    ///
    /// Warn about direct accesses to the Objective-C `isa` pointer instead of using a runtime API.
    public static func directUsageOfIsa(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .directUsageOfIsa, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Direct usage of 'isa'
    ///
    /// Warn about direct accesses to the Objective-C `isa` pointer instead of using a runtime API.
    public static let directUsageOfIsa: BuildSettingsKey = "CLANG_WARN_DIRECT_OBJC_ISA_USAGE"
}

public enum DirectUsageOfIsa: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}


extension DirectUsageOfIsa: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Documentation Comments
extension BuildSetting {

    /// Documentation Comments
    ///
    /// Warns about issues in documentation comments (`doxygen`-style) such as missing or incorrect documentation tags.
    public static var documentationComments: BuildSetting { 
        BuildSetting(key: .documentationComments, value: "NO")
    }

    /// Documentation Comments
    ///
    /// Warns about issues in documentation comments (`doxygen`-style) such as missing or incorrect documentation tags.
    public static func documentationComments(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .documentationComments, value: SettingValue(booleanLiteral: value))
    }

    /// Documentation Comments
    ///
    /// Warns about issues in documentation comments (`doxygen`-style) such as missing or incorrect documentation tags.
    public static func documentationComments(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .documentationComments, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Documentation Comments
    ///
    /// Warns about issues in documentation comments (`doxygen`-style) such as missing or incorrect documentation tags.
    public static let documentationComments: BuildSettingsKey = "CLANG_WARN_DOCUMENTATION_COMMENTS"
}

// MARK: Empty Loop Bodies
extension BuildSetting {

    /// Empty Loop Bodies
    ///
    /// Warn about loop bodies that are suspiciously empty.
    public static var emptyLoopBodies: BuildSetting { 
        BuildSetting(key: .emptyLoopBodies, value: "NO")
    }

    /// Empty Loop Bodies
    ///
    /// Warn about loop bodies that are suspiciously empty.
    public static func emptyLoopBodies(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .emptyLoopBodies, value: SettingValue(booleanLiteral: value))
    }

    /// Empty Loop Bodies
    ///
    /// Warn about loop bodies that are suspiciously empty.
    public static func emptyLoopBodies(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .emptyLoopBodies, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Empty Loop Bodies
    ///
    /// Warn about loop bodies that are suspiciously empty.
    public static let emptyLoopBodies: BuildSettingsKey = "CLANG_WARN_EMPTY_BODY"
}

// MARK: Implicit Enum Conversions
extension BuildSetting {

    /// Implicit Enum Conversions
    ///
    /// Warn about implicit conversions between different kinds of enum values. For example, this can catch issues when using the wrong enum flag as an argument to a function or method.
    public static var implicitEnumConversions: BuildSetting { 
        .implicitEnumConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Enum Conversions
    ///
    /// Warn about implicit conversions between different kinds of enum values. For example, this can catch issues when using the wrong enum flag as an argument to a function or method.
    public static func implicitEnumConversions(_ value: ImplicitEnumConversions) -> BuildSetting { 
        BuildSetting(key: .implicitEnumConversions, value: "\(value)")
    }

    /// Implicit Enum Conversions
    ///
    /// Warn about implicit conversions between different kinds of enum values. For example, this can catch issues when using the wrong enum flag as an argument to a function or method.
    public static func implicitEnumConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitEnumConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Enum Conversions
    ///
    /// Warn about implicit conversions between different kinds of enum values. For example, this can catch issues when using the wrong enum flag as an argument to a function or method.
    public static let implicitEnumConversions: BuildSettingsKey = "CLANG_WARN_ENUM_CONVERSION"
}

public enum ImplicitEnumConversions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ImplicitEnumConversions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Implicit Float Conversions
extension BuildSetting {

    /// Implicit Float Conversions
    ///
    /// Warn about implicit conversions that turn floating-point numbers into integers.
    public static var implicitFloatConversions: BuildSetting { 
        .implicitFloatConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Float Conversions
    ///
    /// Warn about implicit conversions that turn floating-point numbers into integers.
    public static func implicitFloatConversions(_ value: ImplicitFloatConversions) -> BuildSetting { 
        BuildSetting(key: .implicitFloatConversions, value: "\(value)")
    }

    /// Implicit Float Conversions
    ///
    /// Warn about implicit conversions that turn floating-point numbers into integers.
    public static func implicitFloatConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitFloatConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Float Conversions
    ///
    /// Warn about implicit conversions that turn floating-point numbers into integers.
    public static let implicitFloatConversions: BuildSettingsKey = "CLANG_WARN_FLOAT_CONVERSION"
}

public enum ImplicitFloatConversions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ImplicitFloatConversions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: CLANG_WARN_FRAMEWORK_INCLUDE_PRIVATE_FROM_PUBLIC
extension BuildSetting {

    /// CLANG_WARN_FRAMEWORK_INCLUDE_PRIVATE_FROM_PUBLIC
    public static var clangWarnFrameworkIncludePrivateFromPublic: BuildSetting { 
        .clangWarnFrameworkIncludePrivateFromPublic(.no) 
    }

    /// CLANG_WARN_FRAMEWORK_INCLUDE_PRIVATE_FROM_PUBLIC
    public static func clangWarnFrameworkIncludePrivateFromPublic(_ value: ClangWarnFrameworkIncludePrivateFromPublic) -> BuildSetting { 
        BuildSetting(key: .clangWarnFrameworkIncludePrivateFromPublic, value: "\(value)")
    }

    /// CLANG_WARN_FRAMEWORK_INCLUDE_PRIVATE_FROM_PUBLIC
    public static func clangWarnFrameworkIncludePrivateFromPublic(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .clangWarnFrameworkIncludePrivateFromPublic, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLANG_WARN_FRAMEWORK_INCLUDE_PRIVATE_FROM_PUBLIC
    public static let clangWarnFrameworkIncludePrivateFromPublic: BuildSettingsKey = "CLANG_WARN_FRAMEWORK_INCLUDE_PRIVATE_FROM_PUBLIC"
}

public enum ClangWarnFrameworkIncludePrivateFromPublic: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ClangWarnFrameworkIncludePrivateFromPublic: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Implicit Signedness Conversions
extension BuildSetting {

    /// Implicit Signedness Conversions
    ///
    /// Warn about implicit integer conversions that change the signedness of an integer value.
    public static var implicitSignednessConversions: BuildSetting { 
        .implicitSignednessConversions(.no) 
    }

    /// Implicit Signedness Conversions
    ///
    /// Warn about implicit integer conversions that change the signedness of an integer value.
    public static func implicitSignednessConversions(_ value: ImplicitSignednessConversions) -> BuildSetting { 
        BuildSetting(key: .implicitSignednessConversions, value: "\(value)")
    }

    /// Implicit Signedness Conversions
    ///
    /// Warn about implicit integer conversions that change the signedness of an integer value.
    public static func implicitSignednessConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitSignednessConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Signedness Conversions
    ///
    /// Warn about implicit integer conversions that change the signedness of an integer value.
    public static let implicitSignednessConversions: BuildSettingsKey = "CLANG_WARN_IMPLICIT_SIGN_CONVERSION"
}

public enum ImplicitSignednessConversions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ImplicitSignednessConversions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Infinite Recursion
extension BuildSetting {

    /// Infinite Recursion
    ///
    /// Warn if all paths through a function call itself.
    public static var infiniteRecursion: BuildSetting { 
        BuildSetting(key: .infiniteRecursion, value: "NO")
    }

    /// Infinite Recursion
    ///
    /// Warn if all paths through a function call itself.
    public static func infiniteRecursion(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .infiniteRecursion, value: SettingValue(booleanLiteral: value))
    }

    /// Infinite Recursion
    ///
    /// Warn if all paths through a function call itself.
    public static func infiniteRecursion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infiniteRecursion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Infinite Recursion
    ///
    /// Warn if all paths through a function call itself.
    public static let infiniteRecursion: BuildSettingsKey = "CLANG_WARN_INFINITE_RECURSION"
}

// MARK: Implicit Integer to Pointer Conversions
extension BuildSetting {

    /// Implicit Integer to Pointer Conversions
    ///
    /// Warn about implicit conversions between pointers and integers. For example, this can catch issues when one incorrectly intermixes using `NSNumber*`'s and raw integers.
    public static var implicitIntegerToPointerConversions: BuildSetting { 
        .implicitIntegerToPointerConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Integer to Pointer Conversions
    ///
    /// Warn about implicit conversions between pointers and integers. For example, this can catch issues when one incorrectly intermixes using `NSNumber*`'s and raw integers.
    public static func implicitIntegerToPointerConversions(_ value: ImplicitIntegerToPointerConversions) -> BuildSetting { 
        BuildSetting(key: .implicitIntegerToPointerConversions, value: "\(value)")
    }

    /// Implicit Integer to Pointer Conversions
    ///
    /// Warn about implicit conversions between pointers and integers. For example, this can catch issues when one incorrectly intermixes using `NSNumber*`'s and raw integers.
    public static func implicitIntegerToPointerConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitIntegerToPointerConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Integer to Pointer Conversions
    ///
    /// Warn about implicit conversions between pointers and integers. For example, this can catch issues when one incorrectly intermixes using `NSNumber*`'s and raw integers.
    public static let implicitIntegerToPointerConversions: BuildSettingsKey = "CLANG_WARN_INT_CONVERSION"
}

public enum ImplicitIntegerToPointerConversions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ImplicitIntegerToPointerConversions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Missing Noescape Annotation
extension BuildSetting {

    /// Missing Noescape Annotation
    ///
    /// Warn about noescape annotations that are missing in a method's signature.
    public static var missingNoescapeAnnotation: BuildSetting { 
        .missingNoescapeAnnotation(.yes) 
    }

    /// Missing Noescape Annotation
    ///
    /// Warn about noescape annotations that are missing in a method's signature.
    public static func missingNoescapeAnnotation(_ value: MissingNoescapeAnnotation) -> BuildSetting { 
        BuildSetting(key: .missingNoescapeAnnotation, value: "\(value)")
    }

    /// Missing Noescape Annotation
    ///
    /// Warn about noescape annotations that are missing in a method's signature.
    public static func missingNoescapeAnnotation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingNoescapeAnnotation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Noescape Annotation
    ///
    /// Warn about noescape annotations that are missing in a method's signature.
    public static let missingNoescapeAnnotation: BuildSettingsKey = "CLANG_WARN_MISSING_NOESCAPE"
}

public enum MissingNoescapeAnnotation: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension MissingNoescapeAnnotation: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Implicit Non-Literal Null Conversions
extension BuildSetting {

    /// Implicit Non-Literal Null Conversions
    ///
    /// Warn about non-literal expressions that evaluate to zero being treated as a null pointer.
    public static var implicitNonLiteralNullConversions: BuildSetting { 
        .implicitNonLiteralNullConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Non-Literal Null Conversions
    ///
    /// Warn about non-literal expressions that evaluate to zero being treated as a null pointer.
    public static func implicitNonLiteralNullConversions(_ value: ImplicitNonLiteralNullConversions) -> BuildSetting { 
        BuildSetting(key: .implicitNonLiteralNullConversions, value: "\(value)")
    }

    /// Implicit Non-Literal Null Conversions
    ///
    /// Warn about non-literal expressions that evaluate to zero being treated as a null pointer.
    public static func implicitNonLiteralNullConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitNonLiteralNullConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Non-Literal Null Conversions
    ///
    /// Warn about non-literal expressions that evaluate to zero being treated as a null pointer.
    public static let implicitNonLiteralNullConversions: BuildSettingsKey = "CLANG_WARN_NON_LITERAL_NULL_CONVERSION"
}

public enum ImplicitNonLiteralNullConversions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ImplicitNonLiteralNullConversions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Incorrect Uses of Nullable Values
extension BuildSetting {

    /// Incorrect Uses of Nullable Values
    ///
    /// Warns when a nullable expression is used somewhere its not allowed, such as when passed as a `_Nonnull` parameter.
    public static var incorrectUsesOfNullableValues: BuildSetting { 
        BuildSetting(key: .incorrectUsesOfNullableValues, value: "NO")
    }

    /// Incorrect Uses of Nullable Values
    ///
    /// Warns when a nullable expression is used somewhere its not allowed, such as when passed as a `_Nonnull` parameter.
    public static func incorrectUsesOfNullableValues(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .incorrectUsesOfNullableValues, value: SettingValue(booleanLiteral: value))
    }

    /// Incorrect Uses of Nullable Values
    ///
    /// Warns when a nullable expression is used somewhere its not allowed, such as when passed as a `_Nonnull` parameter.
    public static func incorrectUsesOfNullableValues(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .incorrectUsesOfNullableValues, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Incorrect Uses of Nullable Values
    ///
    /// Warns when a nullable expression is used somewhere its not allowed, such as when passed as a `_Nonnull` parameter.
    public static let incorrectUsesOfNullableValues: BuildSettingsKey = "CLANG_WARN_NULLABLE_TO_NONNULL_CONVERSION"
}

// MARK: Implicit ownership types on out parameters
extension BuildSetting {

    /// Implicit ownership types on out parameters
    ///
    /// Warn about implicit ownership types on Objective-C object references as out parameters. For example, declaring a parameter with type `NSObject**` will produce a warning because the compiler will assume that the out parameter's ownership type is `__autoreleasing`.
    public static var implicitOwnershipTypesOnOutParameters: BuildSetting { 
        BuildSetting(key: .implicitOwnershipTypesOnOutParameters, value: "NO")
    }

    /// Implicit ownership types on out parameters
    ///
    /// Warn about implicit ownership types on Objective-C object references as out parameters. For example, declaring a parameter with type `NSObject**` will produce a warning because the compiler will assume that the out parameter's ownership type is `__autoreleasing`.
    public static func implicitOwnershipTypesOnOutParameters(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitOwnershipTypesOnOutParameters, value: SettingValue(booleanLiteral: value))
    }

    /// Implicit ownership types on out parameters
    ///
    /// Warn about implicit ownership types on Objective-C object references as out parameters. For example, declaring a parameter with type `NSObject**` will produce a warning because the compiler will assume that the out parameter's ownership type is `__autoreleasing`.
    public static func implicitOwnershipTypesOnOutParameters(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitOwnershipTypesOnOutParameters, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit ownership types on out parameters
    ///
    /// Warn about implicit ownership types on Objective-C object references as out parameters. For example, declaring a parameter with type `NSObject**` will produce a warning because the compiler will assume that the out parameter's ownership type is `__autoreleasing`.
    public static let implicitOwnershipTypesOnOutParameters: BuildSettingsKey = "CLANG_WARN_OBJC_EXPLICIT_OWNERSHIP_TYPE"
}

// MARK: Implicit Atomic Objective-C Properties
extension BuildSetting {

    /// Implicit Atomic Objective-C Properties
    ///
    /// Warn about `@property` declarations that are implicitly atomic.
    public static var implicitAtomicObjectiveCProperties: BuildSetting { 
        BuildSetting(key: .implicitAtomicObjectiveCProperties, value: "NO")
    }

    /// Implicit Atomic Objective-C Properties
    ///
    /// Warn about `@property` declarations that are implicitly atomic.
    public static func implicitAtomicObjectiveCProperties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitAtomicObjectiveCProperties, value: SettingValue(booleanLiteral: value))
    }

    /// Implicit Atomic Objective-C Properties
    ///
    /// Warn about `@property` declarations that are implicitly atomic.
    public static func implicitAtomicObjectiveCProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitAtomicObjectiveCProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Atomic Objective-C Properties
    ///
    /// Warn about `@property` declarations that are implicitly atomic.
    public static let implicitAtomicObjectiveCProperties: BuildSettingsKey = "CLANG_WARN_OBJC_IMPLICIT_ATOMIC_PROPERTIES"
}

// MARK: Implicit retain of 'self' within blocks
extension BuildSetting {

    /// Implicit retain of 'self' within blocks
    ///
    /// Warn about implicit retains of `self` within blocks, which can create a retain-cycle.
    public static var implicitRetainOfSelfWithinBlocks: BuildSetting { 
        BuildSetting(key: .implicitRetainOfSelfWithinBlocks, value: "NO")
    }

    /// Implicit retain of 'self' within blocks
    ///
    /// Warn about implicit retains of `self` within blocks, which can create a retain-cycle.
    public static func implicitRetainOfSelfWithinBlocks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitRetainOfSelfWithinBlocks, value: SettingValue(booleanLiteral: value))
    }

    /// Implicit retain of 'self' within blocks
    ///
    /// Warn about implicit retains of `self` within blocks, which can create a retain-cycle.
    public static func implicitRetainOfSelfWithinBlocks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitRetainOfSelfWithinBlocks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit retain of 'self' within blocks
    ///
    /// Warn about implicit retains of `self` within blocks, which can create a retain-cycle.
    public static let implicitRetainOfSelfWithinBlocks: BuildSettingsKey = "CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF"
}

// MARK: Interface Declarations of Instance Variables
extension BuildSetting {

    /// Interface Declarations of Instance Variables
    ///
    /// Warn about instance variable declarations in `@interface`.
    public static var interfaceDeclarationsOfInstanceVariables: BuildSetting { 
        .interfaceDeclarationsOfInstanceVariables(.no) 
    }

    /// Interface Declarations of Instance Variables
    ///
    /// Warn about instance variable declarations in `@interface`.
    public static func interfaceDeclarationsOfInstanceVariables(_ value: InterfaceDeclarationsOfInstanceVariables) -> BuildSetting { 
        BuildSetting(key: .interfaceDeclarationsOfInstanceVariables, value: "\(value)")
    }

    /// Interface Declarations of Instance Variables
    ///
    /// Warn about instance variable declarations in `@interface`.
    public static func interfaceDeclarationsOfInstanceVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .interfaceDeclarationsOfInstanceVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Interface Declarations of Instance Variables
    ///
    /// Warn about instance variable declarations in `@interface`.
    public static let interfaceDeclarationsOfInstanceVariables: BuildSettingsKey = "CLANG_WARN_OBJC_INTERFACE_IVARS"
}

public enum InterfaceDeclarationsOfInstanceVariables: String, Hashable, Codable, CustomStringConvertible {
    case no = "NO"
    case yes = "YES"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}


extension InterfaceDeclarationsOfInstanceVariables: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Implicit Objective-C Literal Conversions
extension BuildSetting {

    /// Implicit Objective-C Literal Conversions
    ///
    /// Warn about implicit conversions from Objective-C literals to values of incompatible type.
    public static var implicitObjectiveCLiteralConversions: BuildSetting { 
        .implicitObjectiveCLiteralConversions(inherit: .suspiciousImplicitConversions) 
    }

    /// Implicit Objective-C Literal Conversions
    ///
    /// Warn about implicit conversions from Objective-C literals to values of incompatible type.
    public static func implicitObjectiveCLiteralConversions(_ value: ImplicitObjectiveCLiteralConversions) -> BuildSetting { 
        BuildSetting(key: .implicitObjectiveCLiteralConversions, value: "\(value)")
    }

    /// Implicit Objective-C Literal Conversions
    ///
    /// Warn about implicit conversions from Objective-C literals to values of incompatible type.
    public static func implicitObjectiveCLiteralConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitObjectiveCLiteralConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Objective-C Literal Conversions
    ///
    /// Warn about implicit conversions from Objective-C literals to values of incompatible type.
    public static let implicitObjectiveCLiteralConversions: BuildSettingsKey = "CLANG_WARN_OBJC_LITERAL_CONVERSION"
}

public enum ImplicitObjectiveCLiteralConversions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ImplicitObjectiveCLiteralConversions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Implicit Synthesized Properties
extension BuildSetting {

    /// Implicit Synthesized Properties
    ///
    /// Starting in Xcode 4.4, Apple Clang will implicitly synthesize properties that are not explicitly synthesized using `@synthesize`. This setting warns about such implicit behavior, even though the property is still synthesized. This is essentially a backwards compatibility warning, or for those who wish to continue to explicitly use `@synthesize`.
    public static var implicitSynthesizedProperties: BuildSetting { 
        BuildSetting(key: .implicitSynthesizedProperties, value: "NO")
    }

    /// Implicit Synthesized Properties
    ///
    /// Starting in Xcode 4.4, Apple Clang will implicitly synthesize properties that are not explicitly synthesized using `@synthesize`. This setting warns about such implicit behavior, even though the property is still synthesized. This is essentially a backwards compatibility warning, or for those who wish to continue to explicitly use `@synthesize`.
    public static func implicitSynthesizedProperties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .implicitSynthesizedProperties, value: SettingValue(booleanLiteral: value))
    }

    /// Implicit Synthesized Properties
    ///
    /// Starting in Xcode 4.4, Apple Clang will implicitly synthesize properties that are not explicitly synthesized using `@synthesize`. This setting warns about such implicit behavior, even though the property is still synthesized. This is essentially a backwards compatibility warning, or for those who wish to continue to explicitly use `@synthesize`.
    public static func implicitSynthesizedProperties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitSynthesizedProperties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Synthesized Properties
    ///
    /// Starting in Xcode 4.4, Apple Clang will implicitly synthesize properties that are not explicitly synthesized using `@synthesize`. This setting warns about such implicit behavior, even though the property is still synthesized. This is essentially a backwards compatibility warning, or for those who wish to continue to explicitly use `@synthesize`.
    public static let implicitSynthesizedProperties: BuildSettingsKey = "CLANG_WARN_OBJC_MISSING_PROPERTY_SYNTHESIS"
}

// MARK: Repeatedly using a __weak reference
extension BuildSetting {

    /// Repeatedly using a __weak reference
    ///
    /// Warn about repeatedly using a weak reference without assigning the weak reference to a strong reference. This is often symptomatic of a race condition where the weak reference can become `nil` between accesses, resulting in unexpected behavior. Assigning to temporary strong reference ensures the object stays alive during the related accesses.
    public static var repeatedlyUsingAWeakReference: BuildSetting { 
        .repeatedlyUsingAWeakReference(.no) 
    }

    /// Repeatedly using a __weak reference
    ///
    /// Warn about repeatedly using a weak reference without assigning the weak reference to a strong reference. This is often symptomatic of a race condition where the weak reference can become `nil` between accesses, resulting in unexpected behavior. Assigning to temporary strong reference ensures the object stays alive during the related accesses.
    public static func repeatedlyUsingAWeakReference(_ value: RepeatedlyUsingAWeakReference) -> BuildSetting { 
        BuildSetting(key: .repeatedlyUsingAWeakReference, value: "\(value)")
    }

    /// Repeatedly using a __weak reference
    ///
    /// Warn about repeatedly using a weak reference without assigning the weak reference to a strong reference. This is often symptomatic of a race condition where the weak reference can become `nil` between accesses, resulting in unexpected behavior. Assigning to temporary strong reference ensures the object stays alive during the related accesses.
    public static func repeatedlyUsingAWeakReference(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .repeatedlyUsingAWeakReference, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Repeatedly using a __weak reference
    ///
    /// Warn about repeatedly using a weak reference without assigning the weak reference to a strong reference. This is often symptomatic of a race condition where the weak reference can become `nil` between accesses, resulting in unexpected behavior. Assigning to temporary strong reference ensures the object stays alive during the related accesses.
    public static let repeatedlyUsingAWeakReference: BuildSettingsKey = "CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK"
}

public enum RepeatedlyUsingAWeakReference: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesAggressive = "YES_AGGRESSIVE"

    public var description: String {
        rawValue
    }
}


extension RepeatedlyUsingAWeakReference: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Unintentional Root Class
extension BuildSetting {

    /// Unintentional Root Class
    ///
    /// Warn about classes that unintentionally do not subclass a root class, such as `NSObject`.
    public static var unintentionalRootClass: BuildSetting { 
        .unintentionalRootClass(.yes) 
    }

    /// Unintentional Root Class
    ///
    /// Warn about classes that unintentionally do not subclass a root class, such as `NSObject`.
    public static func unintentionalRootClass(_ value: UnintentionalRootClass) -> BuildSetting { 
        BuildSetting(key: .unintentionalRootClass, value: "\(value)")
    }

    /// Unintentional Root Class
    ///
    /// Warn about classes that unintentionally do not subclass a root class, such as `NSObject`.
    public static func unintentionalRootClass(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unintentionalRootClass, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unintentional Root Class
    ///
    /// Warn about classes that unintentionally do not subclass a root class, such as `NSObject`.
    public static let unintentionalRootClass: BuildSettingsKey = "CLANG_WARN_OBJC_ROOT_CLASS"
}

public enum UnintentionalRootClass: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}


extension UnintentionalRootClass: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Suspicious Pragma Pack
extension BuildSetting {

    /// Suspicious Pragma Pack
    ///
    /// Warn when a translation unit is missing terminating '#pragma pack (pop)' directives or when the '#pragma pack' state immediately after an #include is different from the state immediately before.
    public static var suspiciousPragmaPack: BuildSetting { 
        .suspiciousPragmaPack(.yes) 
    }

    /// Suspicious Pragma Pack
    ///
    /// Warn when a translation unit is missing terminating '#pragma pack (pop)' directives or when the '#pragma pack' state immediately after an #include is different from the state immediately before.
    public static func suspiciousPragmaPack(_ value: SuspiciousPragmaPack) -> BuildSetting { 
        BuildSetting(key: .suspiciousPragmaPack, value: "\(value)")
    }

    /// Suspicious Pragma Pack
    ///
    /// Warn when a translation unit is missing terminating '#pragma pack (pop)' directives or when the '#pragma pack' state immediately after an #include is different from the state immediately before.
    public static func suspiciousPragmaPack(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousPragmaPack, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Pragma Pack
    ///
    /// Warn when a translation unit is missing terminating '#pragma pack (pop)' directives or when the '#pragma pack' state immediately after an #include is different from the state immediately before.
    public static let suspiciousPragmaPack: BuildSettingsKey = "CLANG_WARN_PRAGMA_PACK"
}

public enum SuspiciousPragmaPack: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension SuspiciousPragmaPack: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Outdated Private Module Map
extension BuildSetting {

    /// Outdated Private Module Map
    ///
    /// Warn about private modules that do not use the recommended private module layout.
    public static var outdatedPrivateModuleMap: BuildSetting { 
        BuildSetting(key: .outdatedPrivateModuleMap, value: "YES")
    }

    /// Outdated Private Module Map
    ///
    /// Warn about private modules that do not use the recommended private module layout.
    public static func outdatedPrivateModuleMap(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .outdatedPrivateModuleMap, value: SettingValue(booleanLiteral: value))
    }

    /// Outdated Private Module Map
    ///
    /// Warn about private modules that do not use the recommended private module layout.
    public static func outdatedPrivateModuleMap(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .outdatedPrivateModuleMap, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Outdated Private Module Map
    ///
    /// Warn about private modules that do not use the recommended private module layout.
    public static let outdatedPrivateModuleMap: BuildSettingsKey = "CLANG_WARN_PRIVATE_MODULE"
}

// MARK: Quoted Include In Framework Header
extension BuildSetting {

    /// Quoted Include In Framework Header
    ///
    /// Warns when a quoted include is used instead of a framework style include in a framework header.
    public static var quotedIncludeInFrameworkHeader: BuildSetting { 
        .quotedIncludeInFrameworkHeader(.no) 
    }

    /// Quoted Include In Framework Header
    ///
    /// Warns when a quoted include is used instead of a framework style include in a framework header.
    public static func quotedIncludeInFrameworkHeader(_ value: QuotedIncludeInFrameworkHeader) -> BuildSetting { 
        BuildSetting(key: .quotedIncludeInFrameworkHeader, value: "\(value)")
    }

    /// Quoted Include In Framework Header
    ///
    /// Warns when a quoted include is used instead of a framework style include in a framework header.
    public static func quotedIncludeInFrameworkHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .quotedIncludeInFrameworkHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Quoted Include In Framework Header
    ///
    /// Warns when a quoted include is used instead of a framework style include in a framework header.
    public static let quotedIncludeInFrameworkHeader: BuildSettingsKey = "CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER"
}

public enum QuotedIncludeInFrameworkHeader: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension QuotedIncludeInFrameworkHeader: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Range-based For Loops
extension BuildSetting {

    /// Range-based For Loops
    ///
    /// Warn about ranged-based for loops.
    public static var rangeBasedForLoops: BuildSetting { 
        BuildSetting(key: .rangeBasedForLoops, value: "NO")
    }

    /// Range-based For Loops
    ///
    /// Warn about ranged-based for loops.
    public static func rangeBasedForLoops(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .rangeBasedForLoops, value: SettingValue(booleanLiteral: value))
    }

    /// Range-based For Loops
    ///
    /// Warn about ranged-based for loops.
    public static func rangeBasedForLoops(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rangeBasedForLoops, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Range-based For Loops
    ///
    /// Warn about ranged-based for loops.
    public static let rangeBasedForLoops: BuildSettingsKey = "CLANG_WARN_RANGE_LOOP_ANALYSIS"
}

// MARK: Semicolon Before Method Body
extension BuildSetting {

    /// Semicolon Before Method Body
    ///
    /// Warn about ignored semicolon between a method implementation's signature and body.
    public static var semicolonBeforeMethodBody: BuildSetting { 
        BuildSetting(key: .semicolonBeforeMethodBody, value: "NO")
    }

    /// Semicolon Before Method Body
    ///
    /// Warn about ignored semicolon between a method implementation's signature and body.
    public static func semicolonBeforeMethodBody(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .semicolonBeforeMethodBody, value: SettingValue(booleanLiteral: value))
    }

    /// Semicolon Before Method Body
    ///
    /// Warn about ignored semicolon between a method implementation's signature and body.
    public static func semicolonBeforeMethodBody(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .semicolonBeforeMethodBody, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Semicolon Before Method Body
    ///
    /// Warn about ignored semicolon between a method implementation's signature and body.
    public static let semicolonBeforeMethodBody: BuildSettingsKey = "CLANG_WARN_SEMICOLON_BEFORE_METHOD_BODY"
}

// MARK: Strict Prototypes
extension BuildSetting {

    /// Strict Prototypes
    ///
    /// Warn about non-prototype declarations.
    public static var strictPrototypes: BuildSetting { 
        .strictPrototypes(.no) 
    }

    /// Strict Prototypes
    ///
    /// Warn about non-prototype declarations.
    public static func strictPrototypes(_ value: StrictPrototypes) -> BuildSetting { 
        BuildSetting(key: .strictPrototypes, value: "\(value)")
    }

    /// Strict Prototypes
    ///
    /// Warn about non-prototype declarations.
    public static func strictPrototypes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .strictPrototypes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strict Prototypes
    ///
    /// Warn about non-prototype declarations.
    public static let strictPrototypes: BuildSettingsKey = "CLANG_WARN_STRICT_PROTOTYPES"
}

public enum StrictPrototypes: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}


extension StrictPrototypes: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Suspicious Implicit Conversions
extension BuildSetting {

    /// Suspicious Implicit Conversions
    ///
    /// Warn about various implicit conversions that can lose information or are otherwise suspicious.
    public static var suspiciousImplicitConversions: BuildSetting { 
        .suspiciousImplicitConversions(.no) 
    }

    /// Suspicious Implicit Conversions
    ///
    /// Warn about various implicit conversions that can lose information or are otherwise suspicious.
    public static func suspiciousImplicitConversions(_ value: SuspiciousImplicitConversions) -> BuildSetting { 
        BuildSetting(key: .suspiciousImplicitConversions, value: "\(value)")
    }

    /// Suspicious Implicit Conversions
    ///
    /// Warn about various implicit conversions that can lose information or are otherwise suspicious.
    public static func suspiciousImplicitConversions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousImplicitConversions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Implicit Conversions
    ///
    /// Warn about various implicit conversions that can lose information or are otherwise suspicious.
    public static let suspiciousImplicitConversions: BuildSettingsKey = "CLANG_WARN_SUSPICIOUS_IMPLICIT_CONVERSION"
}

public enum SuspiciousImplicitConversions: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension SuspiciousImplicitConversions: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Suspicious Moves
extension BuildSetting {

    /// Suspicious Moves
    ///
    /// Warn about suspicious uses of `std::move`.
    public static var suspiciousMoves: BuildSetting { 
        BuildSetting(key: .suspiciousMoves, value: "NO")
    }

    /// Suspicious Moves
    ///
    /// Warn about suspicious uses of `std::move`.
    public static func suspiciousMoves(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suspiciousMoves, value: SettingValue(booleanLiteral: value))
    }

    /// Suspicious Moves
    ///
    /// Warn about suspicious uses of `std::move`.
    public static func suspiciousMoves(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suspiciousMoves, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suspicious Moves
    ///
    /// Warn about suspicious uses of `std::move`.
    public static let suspiciousMoves: BuildSettingsKey = "CLANG_WARN_SUSPICIOUS_MOVE"
}

// MARK: Unguarded availability
extension BuildSetting {

    /// Unguarded availability
    ///
    /// Warn if an API that is newer than the deployment target is used without "if (@available(...))" guards.
    public static var unguardedAvailability: BuildSetting { 
        .unguardedAvailability(.yes) 
    }

    /// Unguarded availability
    ///
    /// Warn if an API that is newer than the deployment target is used without "if (@available(...))" guards.
    public static func unguardedAvailability(_ value: UnguardedAvailability) -> BuildSetting { 
        BuildSetting(key: .unguardedAvailability, value: "\(value)")
    }

    /// Unguarded availability
    ///
    /// Warn if an API that is newer than the deployment target is used without "if (@available(...))" guards.
    public static func unguardedAvailability(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unguardedAvailability, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unguarded availability
    ///
    /// Warn if an API that is newer than the deployment target is used without "if (@available(...))" guards.
    public static let unguardedAvailability: BuildSettingsKey = "CLANG_WARN_UNGUARDED_AVAILABILITY"
}

public enum UnguardedAvailability: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesAggressive = "YES_AGGRESSIVE"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension UnguardedAvailability: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Unreachable Code
extension BuildSetting {

    /// Unreachable Code
    ///
    /// Warns about potentially unreachable code.
    public static var unreachableCode: BuildSetting { 
        .unreachableCode(.no) 
    }

    /// Unreachable Code
    ///
    /// Warns about potentially unreachable code.
    public static func unreachableCode(_ value: UnreachableCode) -> BuildSetting { 
        BuildSetting(key: .unreachableCode, value: "\(value)")
    }

    /// Unreachable Code
    ///
    /// Warns about potentially unreachable code.
    public static func unreachableCode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unreachableCode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unreachable Code
    ///
    /// Warns about potentially unreachable code.
    public static let unreachableCode: BuildSettingsKey = "CLANG_WARN_UNREACHABLE_CODE"
}

public enum UnreachableCode: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesAggressive = "YES_AGGRESSIVE"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension UnreachableCode: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Ambiguous C++ Parsing Situation
extension BuildSetting {

    /// Ambiguous C++ Parsing Situation
    ///
    /// Warn about a parsing ambiguity between a variable declaration and a function-style cast.
    public static var ambiguousCppParsingSituation: BuildSetting { 
        .ambiguousCppParsingSituation(.yes) 
    }

    /// Ambiguous C++ Parsing Situation
    ///
    /// Warn about a parsing ambiguity between a variable declaration and a function-style cast.
    public static func ambiguousCppParsingSituation(_ value: AmbiguousCppParsingSituation) -> BuildSetting { 
        BuildSetting(key: .ambiguousCppParsingSituation, value: "\(value)")
    }

    /// Ambiguous C++ Parsing Situation
    ///
    /// Warn about a parsing ambiguity between a variable declaration and a function-style cast.
    public static func ambiguousCppParsingSituation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ambiguousCppParsingSituation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ambiguous C++ Parsing Situation
    ///
    /// Warn about a parsing ambiguity between a variable declaration and a function-style cast.
    public static let ambiguousCppParsingSituation: BuildSettingsKey = "CLANG_WARN_VEXING_PARSE"
}

public enum AmbiguousCppParsingSituation: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension AmbiguousCppParsingSituation: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Using __bridge Casts Outside of ARC
extension BuildSetting {

    /// Using __bridge Casts Outside of ARC
    ///
    /// Warn about using `__bridge` casts when not using ARC, where they have no effect.
    public static var usingBridgeCastsOutsideOfArc: BuildSetting { 
        BuildSetting(key: .usingBridgeCastsOutsideOfArc, value: "YES")
    }

    /// Using __bridge Casts Outside of ARC
    ///
    /// Warn about using `__bridge` casts when not using ARC, where they have no effect.
    public static func usingBridgeCastsOutsideOfArc(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .usingBridgeCastsOutsideOfArc, value: SettingValue(booleanLiteral: value))
    }

    /// Using __bridge Casts Outside of ARC
    ///
    /// Warn about using `__bridge` casts when not using ARC, where they have no effect.
    public static func usingBridgeCastsOutsideOfArc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .usingBridgeCastsOutsideOfArc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Using __bridge Casts Outside of ARC
    ///
    /// Warn about using `__bridge` casts when not using ARC, where they have no effect.
    public static let usingBridgeCastsOutsideOfArc: BuildSettingsKey = "CLANG_WARN__ARC_BRIDGE_CAST_NONARC"
}

// MARK: Duplicate Method Definitions
extension BuildSetting {

    /// Duplicate Method Definitions
    ///
    /// Warn about declaring the same method more than once within the same `@interface`.
    public static var duplicateMethodDefinitions: BuildSetting { 
        BuildSetting(key: .duplicateMethodDefinitions, value: "NO")
    }

    /// Duplicate Method Definitions
    ///
    /// Warn about declaring the same method more than once within the same `@interface`.
    public static func duplicateMethodDefinitions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .duplicateMethodDefinitions, value: SettingValue(booleanLiteral: value))
    }

    /// Duplicate Method Definitions
    ///
    /// Warn about declaring the same method more than once within the same `@interface`.
    public static func duplicateMethodDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .duplicateMethodDefinitions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Duplicate Method Definitions
    ///
    /// Warn about declaring the same method more than once within the same `@interface`.
    public static let duplicateMethodDefinitions: BuildSettingsKey = "CLANG_WARN__DUPLICATE_METHOD_MATCH"
}

// MARK: Exit-Time C++ Destructors
extension BuildSetting {

    /// Exit-Time C++ Destructors
    ///
    /// Warn about destructors for C++ objects that are called when an application is terminating.
    public static var exitTimeCppDestructors: BuildSetting { 
        BuildSetting(key: .exitTimeCppDestructors, value: "NO")
    }

    /// Exit-Time C++ Destructors
    ///
    /// Warn about destructors for C++ objects that are called when an application is terminating.
    public static func exitTimeCppDestructors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .exitTimeCppDestructors, value: SettingValue(booleanLiteral: value))
    }

    /// Exit-Time C++ Destructors
    ///
    /// Warn about destructors for C++ objects that are called when an application is terminating.
    public static func exitTimeCppDestructors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .exitTimeCppDestructors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Exit-Time C++ Destructors
    ///
    /// Warn about destructors for C++ objects that are called when an application is terminating.
    public static let exitTimeCppDestructors: BuildSettingsKey = "CLANG_WARN__EXIT_TIME_DESTRUCTORS"
}

// MARK: Enable Additional Vector Extensions
extension BuildSetting {

    /// Enable Additional Vector Extensions
    ///
    /// Enables the use of extended vector instructions. Only used when targeting Intel architectures.
    public static var enableAdditionalVectorExtensions: BuildSetting { 
        BuildSetting(key: .enableAdditionalVectorExtensions, value: "$(DEFAULT_SSE_LEVEL_4_2_$(GCC_ENABLE_SSE42_EXTENSIONS))")
    }

    /// Enable Additional Vector Extensions
    ///
    /// Enables the use of extended vector instructions. Only used when targeting Intel architectures.
    public static func enableAdditionalVectorExtensions(_ value: EnableAdditionalVectorExtensions) -> BuildSetting { 
        BuildSetting(key: .enableAdditionalVectorExtensions, value: "\(value)")
    }

    /// Enable Additional Vector Extensions
    ///
    /// Enables the use of extended vector instructions. Only used when targeting Intel architectures.
    public static func enableAdditionalVectorExtensions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableAdditionalVectorExtensions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Additional Vector Extensions
    ///
    /// Enables the use of extended vector instructions. Only used when targeting Intel architectures.
    public static let enableAdditionalVectorExtensions: BuildSettingsKey = "CLANG_X86_VECTOR_INSTRUCTIONS"
}

public enum EnableAdditionalVectorExtensions: String, Hashable, Codable, CustomStringConvertible {
    case `default` = "default"
    case sse3 = "sse3"
    case ssse3 = "ssse3"
    case sse41 = "sse4.1"
    case sse42 = "sse4.2"
    case avx = "avx"
    case avx2 = "avx2"
    case avx512 = "avx512"

    public var description: String {
        rawValue
    }
}

// MARK: CLASS_FILE_DIR
extension BuildSetting {

    /// CLASS_FILE_DIR
    public static var classFileDir: BuildSetting { 
        BuildSetting(key: .classFileDir, value: "$(TARGET_TEMP_DIR)/JavaClasses")
    }

    /// CLASS_FILE_DIR
    public static func classFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .classFileDir, value: "\(value)")
    }

    /// CLASS_FILE_DIR
    public static func classFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .classFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLASS_FILE_DIR
    public static let classFileDir: BuildSettingsKey = "CLASS_FILE_DIR"
}

// MARK: CLEAN_PRECOMPS
extension BuildSetting {

    /// CLEAN_PRECOMPS
    public static var cleanPrecomps: BuildSetting { 
        BuildSetting(key: .cleanPrecomps, value: "YES")
    }

    /// CLEAN_PRECOMPS
    public static func cleanPrecomps(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .cleanPrecomps, value: SettingValue(booleanLiteral: value))
    }

    /// CLEAN_PRECOMPS
    public static func cleanPrecomps(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cleanPrecomps, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLEAN_PRECOMPS
    public static let cleanPrecomps: BuildSettingsKey = "CLEAN_PRECOMPS"
}

// MARK: CLONE_HEADERS
extension BuildSetting {

    /// CLONE_HEADERS
    public static var cloneHeaders: BuildSetting { 
        BuildSetting(key: .cloneHeaders, value: "NO")
    }

    /// CLONE_HEADERS
    public static func cloneHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .cloneHeaders, value: SettingValue(booleanLiteral: value))
    }

    /// CLONE_HEADERS
    public static func cloneHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cloneHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CLONE_HEADERS
    public static let cloneHeaders: BuildSettingsKey = "CLONE_HEADERS"
}

// MARK: CODESIGNING_FOLDER_PATH
extension BuildSetting {

    /// CODESIGNING_FOLDER_PATH
    public static var codesigningFolderPath: BuildSetting { 
        BuildSetting(key: .codesigningFolderPath, value: "$(TARGET_BUILD_DIR)/$(FULL_PRODUCT_NAME)")
    }

    /// CODESIGNING_FOLDER_PATH
    public static func codesigningFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .codesigningFolderPath, value: "\(value)")
    }

    /// CODESIGNING_FOLDER_PATH
    public static func codesigningFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codesigningFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CODESIGNING_FOLDER_PATH
    public static let codesigningFolderPath: BuildSettingsKey = "CODESIGNING_FOLDER_PATH"
}

// MARK: CODE_SIGNING_ALLOWED
extension BuildSetting {

    /// CODE_SIGNING_ALLOWED
    public static var codeSigningAllowed: BuildSetting { 
        BuildSetting(key: .codeSigningAllowed, value: "NO")
    }

    /// CODE_SIGNING_ALLOWED
    public static func codeSigningAllowed(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .codeSigningAllowed, value: SettingValue(booleanLiteral: value))
    }

    /// CODE_SIGNING_ALLOWED
    public static func codeSigningAllowed(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSigningAllowed, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CODE_SIGNING_ALLOWED
    public static let codeSigningAllowed: BuildSettingsKey = "CODE_SIGNING_ALLOWED"
}

// MARK: Code Signing Entitlements
extension BuildSetting {

    /// Code Signing Entitlements
    ///
    /// The path to a file specifying code-signing entitlements.
    public static var codeSigningEntitlements: BuildSetting { 
        BuildSetting(key: .codeSigningEntitlements, value: "")
    }

    /// Code Signing Entitlements
    ///
    /// The path to a file specifying code-signing entitlements.
    public static func codeSigningEntitlements(_ value: String) -> BuildSetting { 
        BuildSetting(key: .codeSigningEntitlements, value: "\(value)")
    }

    /// Code Signing Entitlements
    ///
    /// The path to a file specifying code-signing entitlements.
    public static func codeSigningEntitlements(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSigningEntitlements, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Signing Entitlements
    ///
    /// The path to a file specifying code-signing entitlements.
    public static let codeSigningEntitlements: BuildSettingsKey = "CODE_SIGN_ENTITLEMENTS"
}

// MARK: Code Signing Identity
extension BuildSetting {

    /// Code Signing Identity
    ///
    /// The name, also known as the _common name_, of a valid code-signing certificate in a keychain within your keychain path. A missing or invalid certificate will cause a build error.
    public static var codeSigningIdentity: BuildSetting { 
        BuildSetting(key: .codeSigningIdentity, value: "")
    }

    /// Code Signing Identity
    ///
    /// The name, also known as the _common name_, of a valid code-signing certificate in a keychain within your keychain path. A missing or invalid certificate will cause a build error.
    public static func codeSigningIdentity(_ value: CodeSignIdentity) -> BuildSetting { 
        BuildSetting(key: .codeSigningIdentity, value: "\(value)")
    }

    /// Code Signing Identity
    ///
    /// The name, also known as the _common name_, of a valid code-signing certificate in a keychain within your keychain path. A missing or invalid certificate will cause a build error.
    public static func codeSigningIdentity(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSigningIdentity, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Signing Identity
    ///
    /// The name, also known as the _common name_, of a valid code-signing certificate in a keychain within your keychain path. A missing or invalid certificate will cause a build error.
    public static let codeSigningIdentity: BuildSettingsKey = "CODE_SIGN_IDENTITY"
}

// MARK: Code Signing Inject Base Entitlements
extension BuildSetting {

    /// Code Signing Inject Base Entitlements
    ///
    /// Automatically inject entitlements from the platform's BaseEntitlements.plist into the code signatures of executables.
    public static var codeSigningInjectBaseEntitlements: BuildSetting { 
        BuildSetting(key: .codeSigningInjectBaseEntitlements, value: "YES")
    }

    /// Code Signing Inject Base Entitlements
    ///
    /// Automatically inject entitlements from the platform's BaseEntitlements.plist into the code signatures of executables.
    public static func codeSigningInjectBaseEntitlements(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .codeSigningInjectBaseEntitlements, value: SettingValue(booleanLiteral: value))
    }

    /// Code Signing Inject Base Entitlements
    ///
    /// Automatically inject entitlements from the platform's BaseEntitlements.plist into the code signatures of executables.
    public static func codeSigningInjectBaseEntitlements(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSigningInjectBaseEntitlements, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Signing Inject Base Entitlements
    ///
    /// Automatically inject entitlements from the platform's BaseEntitlements.plist into the code signatures of executables.
    public static let codeSigningInjectBaseEntitlements: BuildSettingsKey = "CODE_SIGN_INJECT_BASE_ENTITLEMENTS"
}

// MARK: CODE_SIGN_KEYCHAIN
extension BuildSetting {

    /// CODE_SIGN_KEYCHAIN
    public static var codeSignKeychain: BuildSetting { 
        BuildSetting(key: .codeSignKeychain, value: "")
    }

    /// CODE_SIGN_KEYCHAIN
    public static func codeSignKeychain(_ value: String) -> BuildSetting { 
        BuildSetting(key: .codeSignKeychain, value: "\(value)")
    }

    /// CODE_SIGN_KEYCHAIN
    public static func codeSignKeychain(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSignKeychain, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CODE_SIGN_KEYCHAIN
    public static let codeSignKeychain: BuildSettingsKey = "CODE_SIGN_KEYCHAIN"
}

// MARK: CODE_SIGN_LOCAL_EXECUTION_IDENTITY
extension BuildSetting {

    /// CODE_SIGN_LOCAL_EXECUTION_IDENTITY
    public static var codeSignLocalExecutionIdentity: BuildSetting { 
        .codeSignLocalExecutionIdentity(.empty) 
    }

    /// CODE_SIGN_LOCAL_EXECUTION_IDENTITY
    public static func codeSignLocalExecutionIdentity(_ value: CodeSignLocalExecutionIdentity) -> BuildSetting { 
        BuildSetting(key: .codeSignLocalExecutionIdentity, value: "\(value)")
    }

    /// CODE_SIGN_LOCAL_EXECUTION_IDENTITY
    public static func codeSignLocalExecutionIdentity(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSignLocalExecutionIdentity, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CODE_SIGN_LOCAL_EXECUTION_IDENTITY
    public static let codeSignLocalExecutionIdentity: BuildSettingsKey = "CODE_SIGN_LOCAL_EXECUTION_IDENTITY"
}

public enum CodeSignLocalExecutionIdentity: String, Hashable, Codable, CustomStringConvertible {
    case empty = ""
    case adHoc = "Ad Hoc"
    case localCertificate = "Local Certificate"

    public var description: String {
        rawValue
    }
}

// MARK: CODE_SIGN_RESOURCE_RULES_IN_BUNDLE
extension BuildSetting {

    /// CODE_SIGN_RESOURCE_RULES_IN_BUNDLE
    public static func codeSignResourceRulesInBundle(_ value: String) -> BuildSetting { 
        BuildSetting(key: .codeSignResourceRulesInBundle, value: "\(value)")
    }

    /// CODE_SIGN_RESOURCE_RULES_IN_BUNDLE
    public static func codeSignResourceRulesInBundle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSignResourceRulesInBundle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CODE_SIGN_RESOURCE_RULES_IN_BUNDLE
    public static let codeSignResourceRulesInBundle: BuildSettingsKey = "CODE_SIGN_RESOURCE_RULES_IN_BUNDLE"
}

// MARK: Code Sign Style
extension BuildSetting {

    /// Code Sign Style
    ///
    /// This setting specifies the method used to acquire and locate signing assets. Choose `Automatic` to let Xcode automatically create and update profiles, app IDs, and certificates. Choose `Manual` to create and update these yourself on the developer website.
    public static var codeSignStyle: BuildSetting { 
        .codeSignStyle(.empty) 
    }

    /// Code Sign Style
    ///
    /// This setting specifies the method used to acquire and locate signing assets. Choose `Automatic` to let Xcode automatically create and update profiles, app IDs, and certificates. Choose `Manual` to create and update these yourself on the developer website.
    public static func codeSignStyle(_ value: CodeSignStyle) -> BuildSetting { 
        BuildSetting(key: .codeSignStyle, value: "\(value)")
    }

    /// Code Sign Style
    ///
    /// This setting specifies the method used to acquire and locate signing assets. Choose `Automatic` to let Xcode automatically create and update profiles, app IDs, and certificates. Choose `Manual` to create and update these yourself on the developer website.
    public static func codeSignStyle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codeSignStyle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Code Sign Style
    ///
    /// This setting specifies the method used to acquire and locate signing assets. Choose `Automatic` to let Xcode automatically create and update profiles, app IDs, and certificates. Choose `Manual` to create and update these yourself on the developer website.
    public static let codeSignStyle: BuildSettingsKey = "CODE_SIGN_STYLE"
}

public enum CodeSignStyle: String, Hashable, Codable, CustomStringConvertible {
    case empty = ""
    case automatic = "Automatic"
    case manual = "Manual"

    public var description: String {
        rawValue
    }
}

// MARK: COLOR_DIAGNOSTICS
extension BuildSetting {

    /// COLOR_DIAGNOSTICS
    public static var colorDiagnostics: BuildSetting { 
        BuildSetting(key: .colorDiagnostics, value: "NO")
    }

    /// COLOR_DIAGNOSTICS
    public static func colorDiagnostics(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .colorDiagnostics, value: SettingValue(booleanLiteral: value))
    }

    /// COLOR_DIAGNOSTICS
    public static func colorDiagnostics(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .colorDiagnostics, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COLOR_DIAGNOSTICS
    public static let colorDiagnostics: BuildSettingsKey = "COLOR_DIAGNOSTICS"
}

// MARK: COMBINE_HIDPI_IMAGES
extension BuildSetting {

    /// COMBINE_HIDPI_IMAGES
    public static var combineHidpiImages: BuildSetting { 
        BuildSetting(key: .combineHidpiImages, value: "NO")
    }

    /// COMBINE_HIDPI_IMAGES
    public static func combineHidpiImages(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .combineHidpiImages, value: SettingValue(booleanLiteral: value))
    }

    /// COMBINE_HIDPI_IMAGES
    public static func combineHidpiImages(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .combineHidpiImages, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COMBINE_HIDPI_IMAGES
    public static let combineHidpiImages: BuildSettingsKey = "COMBINE_HIDPI_IMAGES"
}

// MARK: Enable Index-While-Building Functionality
extension BuildSetting {

    /// Enable Index-While-Building Functionality
    ///
    /// Control whether the compiler should emit index data while building.
    public static var enableIndexWhileBuildingFunctionality: BuildSetting { 
        .enableIndexWhileBuildingFunctionality(.default) 
    }

    /// Enable Index-While-Building Functionality
    ///
    /// Control whether the compiler should emit index data while building.
    public static func enableIndexWhileBuildingFunctionality(_ value: EnableIndexWhileBuildingFunctionality) -> BuildSetting { 
        BuildSetting(key: .enableIndexWhileBuildingFunctionality, value: "\(value)")
    }

    /// Enable Index-While-Building Functionality
    ///
    /// Control whether the compiler should emit index data while building.
    public static func enableIndexWhileBuildingFunctionality(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableIndexWhileBuildingFunctionality, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Index-While-Building Functionality
    ///
    /// Control whether the compiler should emit index data while building.
    public static let enableIndexWhileBuildingFunctionality: BuildSettingsKey = "COMPILER_INDEX_STORE_ENABLE"
}

public enum EnableIndexWhileBuildingFunctionality: String, Hashable, Codable, CustomStringConvertible {
    case `default` = "Default"
    case yes = "YES"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension EnableIndexWhileBuildingFunctionality: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: COMPOSITE_SDK_DIRS
extension BuildSetting {

    /// COMPOSITE_SDK_DIRS
    public static var compositeSdkDirs: BuildSetting { 
        BuildSetting(key: .compositeSdkDirs, value: "$(OBJROOT)/CompositeSDKs")
    }

    /// COMPOSITE_SDK_DIRS
    public static func compositeSdkDirs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .compositeSdkDirs, value: .array(value))
    }

    /// COMPOSITE_SDK_DIRS
    public static func compositeSdkDirs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compositeSdkDirs, inherit: key)
    }

    /// COMPOSITE_SDK_DIRS
    public static func compositeSdkDirs(_ value: String...) -> BuildSetting { 
        .compositeSdkDirs(value)
    }
}

extension BuildSettingsKey {

    /// COMPOSITE_SDK_DIRS
    public static let compositeSdkDirs: BuildSettingsKey = "COMPOSITE_SDK_DIRS"
}

// MARK: Compress PNG Files
extension BuildSetting {

    /// Compress PNG Files
    ///
    /// If enabled, PNG resource files are compressed as they are copied.
    public static var compressPngFiles: BuildSetting { 
        BuildSetting(key: .compressPngFiles, value: "YES")
    }

    /// Compress PNG Files
    ///
    /// If enabled, PNG resource files are compressed as they are copied.
    public static func compressPngFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .compressPngFiles, value: SettingValue(booleanLiteral: value))
    }

    /// Compress PNG Files
    ///
    /// If enabled, PNG resource files are compressed as they are copied.
    public static func compressPngFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compressPngFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compress PNG Files
    ///
    /// If enabled, PNG resource files are compressed as they are copied.
    public static let compressPngFiles: BuildSettingsKey = "COMPRESS_PNG_FILES"
}

// MARK: COMPRESS_TIFF_FILES_WHILE_COPYING
extension BuildSetting {

    /// COMPRESS_TIFF_FILES_WHILE_COPYING
    public static var compressTiffFilesWhileCopying: BuildSetting { 
        BuildSetting(key: .compressTiffFilesWhileCopying, value: "NO")
    }

    /// COMPRESS_TIFF_FILES_WHILE_COPYING
    public static func compressTiffFilesWhileCopying(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .compressTiffFilesWhileCopying, value: SettingValue(booleanLiteral: value))
    }

    /// COMPRESS_TIFF_FILES_WHILE_COPYING
    public static func compressTiffFilesWhileCopying(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compressTiffFilesWhileCopying, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COMPRESS_TIFF_FILES_WHILE_COPYING
    public static let compressTiffFilesWhileCopying: BuildSettingsKey = "COMPRESS_TIFF_FILES_WHILE_COPYING"
}

// MARK: CONFIGURATION
extension BuildSetting {

    /// CONFIGURATION
    ///
    /// Identifies the build configuration, such as `Debug` or `Release`, that the target uses to generate the product.
    public static var configuration: BuildSetting { 
        BuildSetting(key: .configuration, value: "")
    }

    /// CONFIGURATION
    ///
    /// Identifies the build configuration, such as `Debug` or `Release`, that the target uses to generate the product.
    public static func configuration(_ value: String) -> BuildSetting { 
        BuildSetting(key: .configuration, value: "\(value)")
    }

    /// CONFIGURATION
    ///
    /// Identifies the build configuration, such as `Debug` or `Release`, that the target uses to generate the product.
    public static func configuration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .configuration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CONFIGURATION
    ///
    /// Identifies the build configuration, such as `Debug` or `Release`, that the target uses to generate the product.
    public static let configuration: BuildSettingsKey = "CONFIGURATION"
}

// MARK: Per-configuration Build Products Path
extension BuildSetting {

    /// Per-configuration Build Products Path
    ///
    /// The base path where build products will be placed during a build for a given configuration. By default, this is set to `$(BUILD_DIR)/$(CONFIGURATION)`.
    public static var perConfigurationBuildProductsPath: BuildSetting { 
        .perConfigurationBuildProductsPath(inherit: .buildDir) 
    }

    /// Per-configuration Build Products Path
    ///
    /// The base path where build products will be placed during a build for a given configuration. By default, this is set to `$(BUILD_DIR)/$(CONFIGURATION)`.
    public static func perConfigurationBuildProductsPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .perConfigurationBuildProductsPath, value: "\(value)")
    }

    /// Per-configuration Build Products Path
    ///
    /// The base path where build products will be placed during a build for a given configuration. By default, this is set to `$(BUILD_DIR)/$(CONFIGURATION)`.
    public static func perConfigurationBuildProductsPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .perConfigurationBuildProductsPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Per-configuration Build Products Path
    ///
    /// The base path where build products will be placed during a build for a given configuration. By default, this is set to `$(BUILD_DIR)/$(CONFIGURATION)`.
    public static let perConfigurationBuildProductsPath: BuildSettingsKey = "CONFIGURATION_BUILD_DIR"
}

// MARK: Per-configuration Intermediate Build Files Path
extension BuildSetting {

    /// Per-configuration Intermediate Build Files Path
    ///
    /// The base path where intermediates will be placed during a build for a given configuration. By default, this is set to `$(PROJECT_TEMP_DIR)/$(CONFIGURATION)`.
    public static var perConfigurationIntermediateBuildFilesPath: BuildSetting { 
        .perConfigurationIntermediateBuildFilesPath(inherit: .projectTempDir) 
    }

    /// Per-configuration Intermediate Build Files Path
    ///
    /// The base path where intermediates will be placed during a build for a given configuration. By default, this is set to `$(PROJECT_TEMP_DIR)/$(CONFIGURATION)`.
    public static func perConfigurationIntermediateBuildFilesPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .perConfigurationIntermediateBuildFilesPath, value: "\(value)")
    }

    /// Per-configuration Intermediate Build Files Path
    ///
    /// The base path where intermediates will be placed during a build for a given configuration. By default, this is set to `$(PROJECT_TEMP_DIR)/$(CONFIGURATION)`.
    public static func perConfigurationIntermediateBuildFilesPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .perConfigurationIntermediateBuildFilesPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Per-configuration Intermediate Build Files Path
    ///
    /// The base path where intermediates will be placed during a build for a given configuration. By default, this is set to `$(PROJECT_TEMP_DIR)/$(CONFIGURATION)`.
    public static let perConfigurationIntermediateBuildFilesPath: BuildSettingsKey = "CONFIGURATION_TEMP_DIR"
}

// MARK: CONTENTS_FOLDER_PATH
extension BuildSetting {

    /// CONTENTS_FOLDER_PATH
    ///
    /// Specifies the directory inside the generated bundle that contains the products files.
    public static var contentsFolderPath: BuildSetting { 
        BuildSetting(key: .contentsFolderPath, value: "")
    }

    /// CONTENTS_FOLDER_PATH
    ///
    /// Specifies the directory inside the generated bundle that contains the products files.
    public static func contentsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .contentsFolderPath, value: "\(value)")
    }

    /// CONTENTS_FOLDER_PATH
    ///
    /// Specifies the directory inside the generated bundle that contains the products files.
    public static func contentsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .contentsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CONTENTS_FOLDER_PATH
    ///
    /// Specifies the directory inside the generated bundle that contains the products files.
    public static let contentsFolderPath: BuildSettingsKey = "CONTENTS_FOLDER_PATH"
}

// MARK: Preserve HFS Data
extension BuildSetting {

    /// Preserve HFS Data
    ///
    /// Causes the copying of resources to preserve resource forks and Finder info.
    public static var preserveHfsData: BuildSetting { 
        BuildSetting(key: .preserveHfsData, value: "NO")
    }

    /// Preserve HFS Data
    ///
    /// Causes the copying of resources to preserve resource forks and Finder info.
    public static func preserveHfsData(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .preserveHfsData, value: SettingValue(booleanLiteral: value))
    }

    /// Preserve HFS Data
    ///
    /// Causes the copying of resources to preserve resource forks and Finder info.
    public static func preserveHfsData(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preserveHfsData, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Preserve HFS Data
    ///
    /// Causes the copying of resources to preserve resource forks and Finder info.
    public static let preserveHfsData: BuildSettingsKey = "COPYING_PRESERVES_HFS_DATA"
}

// MARK: Run unifdef on Product Headers
extension BuildSetting {

    /// Run unifdef on Product Headers
    ///
    /// If enabled, headers are run through the `unifdef(1)` tool when copied to the product.
    public static var runUnifdefOnProductHeaders: BuildSetting { 
        BuildSetting(key: .runUnifdefOnProductHeaders, value: "NO")
    }

    /// Run unifdef on Product Headers
    ///
    /// If enabled, headers are run through the `unifdef(1)` tool when copied to the product.
    public static func runUnifdefOnProductHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .runUnifdefOnProductHeaders, value: SettingValue(booleanLiteral: value))
    }

    /// Run unifdef on Product Headers
    ///
    /// If enabled, headers are run through the `unifdef(1)` tool when copied to the product.
    public static func runUnifdefOnProductHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .runUnifdefOnProductHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Run unifdef on Product Headers
    ///
    /// If enabled, headers are run through the `unifdef(1)` tool when copied to the product.
    public static let runUnifdefOnProductHeaders: BuildSettingsKey = "COPY_HEADERS_RUN_UNIFDEF"
}

// MARK: Unifdef Flags for Product Headers
extension BuildSetting {

    /// Unifdef Flags for Product Headers
    ///
    /// Specifies the flags to pass to `unifdef(1)` when invoking that tool to copy headers. This setting has no effect unless [Run unifdef on Product Headers (COPY\_HEADERS\_RUN\_UNIFDEF)](itcaec37c2a6.html#devc2606cc19) is enabled.
    public static var unifdefFlagsForProductHeaders: BuildSetting { 
        BuildSetting(key: .unifdefFlagsForProductHeaders, value: "")
    }

    /// Unifdef Flags for Product Headers
    ///
    /// Specifies the flags to pass to `unifdef(1)` when invoking that tool to copy headers. This setting has no effect unless [Run unifdef on Product Headers (COPY\_HEADERS\_RUN\_UNIFDEF)](itcaec37c2a6.html#devc2606cc19) is enabled.
    public static func unifdefFlagsForProductHeaders(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .unifdefFlagsForProductHeaders, value: .array(value))
    }

    /// Unifdef Flags for Product Headers
    ///
    /// Specifies the flags to pass to `unifdef(1)` when invoking that tool to copy headers. This setting has no effect unless [Run unifdef on Product Headers (COPY\_HEADERS\_RUN\_UNIFDEF)](itcaec37c2a6.html#devc2606cc19) is enabled.
    public static func unifdefFlagsForProductHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unifdefFlagsForProductHeaders, inherit: key)
    }

    /// Unifdef Flags for Product Headers
    ///
    /// Specifies the flags to pass to `unifdef(1)` when invoking that tool to copy headers. This setting has no effect unless [Run unifdef on Product Headers (COPY\_HEADERS\_RUN\_UNIFDEF)](itcaec37c2a6.html#devc2606cc19) is enabled.
    public static func unifdefFlagsForProductHeaders(_ value: String...) -> BuildSetting { 
        .unifdefFlagsForProductHeaders(value)
    }
}

extension BuildSettingsKey {

    /// Unifdef Flags for Product Headers
    ///
    /// Specifies the flags to pass to `unifdef(1)` when invoking that tool to copy headers. This setting has no effect unless [Run unifdef on Product Headers (COPY\_HEADERS\_RUN\_UNIFDEF)](itcaec37c2a6.html#devc2606cc19) is enabled.
    public static let unifdefFlagsForProductHeaders: BuildSettingsKey = "COPY_HEADERS_UNIFDEF_FLAGS"
}

// MARK: Strip Debug Symbols During Copy
extension BuildSetting {

    /// Strip Debug Symbols During Copy
    ///
    /// Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be strippeduse [Strip Linked Product (STRIP\_INSTALLED\_PRODUCT)](itcaec37c2a6.html#dev5c0105d2a) for that.
    public static var stripDebugSymbolsDuringCopy: BuildSetting { 
        BuildSetting(key: .stripDebugSymbolsDuringCopy, value: "YES")
    }

    /// Strip Debug Symbols During Copy
    ///
    /// Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be strippeduse [Strip Linked Product (STRIP\_INSTALLED\_PRODUCT)](itcaec37c2a6.html#dev5c0105d2a) for that.
    public static func stripDebugSymbolsDuringCopy(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripDebugSymbolsDuringCopy, value: SettingValue(booleanLiteral: value))
    }

    /// Strip Debug Symbols During Copy
    ///
    /// Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be strippeduse [Strip Linked Product (STRIP\_INSTALLED\_PRODUCT)](itcaec37c2a6.html#dev5c0105d2a) for that.
    public static func stripDebugSymbolsDuringCopy(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripDebugSymbolsDuringCopy, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Debug Symbols During Copy
    ///
    /// Specifies whether binary files that are copied during the build, such as in a Copy Bundle Resources or Copy Files build phase, should be stripped of debugging symbols. It does not cause the linked product of a target to be strippeduse [Strip Linked Product (STRIP\_INSTALLED\_PRODUCT)](itcaec37c2a6.html#dev5c0105d2a) for that.
    public static let stripDebugSymbolsDuringCopy: BuildSettingsKey = "COPY_PHASE_STRIP"
}

// MARK: COPY_RESOURCES_FROM_STATIC_FRAMEWORKS
extension BuildSetting {

    /// COPY_RESOURCES_FROM_STATIC_FRAMEWORKS
    public static var copyResourcesFromStaticFrameworks: BuildSetting { 
        BuildSetting(key: .copyResourcesFromStaticFrameworks, value: "YES")
    }

    /// COPY_RESOURCES_FROM_STATIC_FRAMEWORKS
    public static func copyResourcesFromStaticFrameworks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .copyResourcesFromStaticFrameworks, value: SettingValue(booleanLiteral: value))
    }

    /// COPY_RESOURCES_FROM_STATIC_FRAMEWORKS
    public static func copyResourcesFromStaticFrameworks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .copyResourcesFromStaticFrameworks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COPY_RESOURCES_FROM_STATIC_FRAMEWORKS
    public static let copyResourcesFromStaticFrameworks: BuildSettingsKey = "COPY_RESOURCES_FROM_STATIC_FRAMEWORKS"
}

// MARK: CoreML Model Class Generation Language
extension BuildSetting {

    /// CoreML Model Class Generation Language
    ///
    /// The Source-code language to use for generated CoreML model class. By default "Automatic" will analyze your project to determine the correct language. Adjust this setting to explicitly select "Swift" or "Objective-C", or select "None" to disable model class generation.
    public static var coremlModelClassGenerationLanguage: BuildSetting { 
        .coremlModelClassGenerationLanguage(.automatic) 
    }

    /// CoreML Model Class Generation Language
    ///
    /// The Source-code language to use for generated CoreML model class. By default "Automatic" will analyze your project to determine the correct language. Adjust this setting to explicitly select "Swift" or "Objective-C", or select "None" to disable model class generation.
    public static func coremlModelClassGenerationLanguage(_ value: CoremlModelClassGenerationLanguage) -> BuildSetting { 
        BuildSetting(key: .coremlModelClassGenerationLanguage, value: "\(value)")
    }

    /// CoreML Model Class Generation Language
    ///
    /// The Source-code language to use for generated CoreML model class. By default "Automatic" will analyze your project to determine the correct language. Adjust this setting to explicitly select "Swift" or "Objective-C", or select "None" to disable model class generation.
    public static func coremlModelClassGenerationLanguage(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlModelClassGenerationLanguage, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CoreML Model Class Generation Language
    ///
    /// The Source-code language to use for generated CoreML model class. By default "Automatic" will analyze your project to determine the correct language. Adjust this setting to explicitly select "Swift" or "Objective-C", or select "None" to disable model class generation.
    public static let coremlModelClassGenerationLanguage: BuildSettingsKey = "COREML_CODEGEN_LANGUAGE"
}

public enum CoremlModelClassGenerationLanguage: String, Hashable, Codable, CustomStringConvertible {
    case swift = "Swift"
    case objectiveC = "Objective-C"
    case automatic = "Automatic"
    case none = "None"

    public var description: String {
        rawValue
    }
}

// MARK: CoreML Generated Model Inherits NSObject
extension BuildSetting {

    /// CoreML Generated Model Inherits NSObject
    ///
    /// Generate Swift model classes that are marked with @objc and are descendants of NSObject, in order to be accessible and usable in Objective-C. This setting has no effect if "CoreML Model Class Generation Language" is set to "Objective-C".
    public static var coremlGeneratedModelInheritsNsobject: BuildSetting { 
        BuildSetting(key: .coremlGeneratedModelInheritsNsobject, value: "NO")
    }

    /// CoreML Generated Model Inherits NSObject
    ///
    /// Generate Swift model classes that are marked with @objc and are descendants of NSObject, in order to be accessible and usable in Objective-C. This setting has no effect if "CoreML Model Class Generation Language" is set to "Objective-C".
    public static func coremlGeneratedModelInheritsNsobject(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .coremlGeneratedModelInheritsNsobject, value: SettingValue(booleanLiteral: value))
    }

    /// CoreML Generated Model Inherits NSObject
    ///
    /// Generate Swift model classes that are marked with @objc and are descendants of NSObject, in order to be accessible and usable in Objective-C. This setting has no effect if "CoreML Model Class Generation Language" is set to "Objective-C".
    public static func coremlGeneratedModelInheritsNsobject(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlGeneratedModelInheritsNsobject, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CoreML Generated Model Inherits NSObject
    ///
    /// Generate Swift model classes that are marked with @objc and are descendants of NSObject, in order to be accessible and usable in Objective-C. This setting has no effect if "CoreML Model Class Generation Language" is set to "Objective-C".
    public static let coremlGeneratedModelInheritsNsobject: BuildSettingsKey = "COREML_CODEGEN_SWIFT_GLOBAL_MODULE"
}

// MARK: COREML_CODEGEN_SWIFT_VERSION
extension BuildSetting {

    /// COREML_CODEGEN_SWIFT_VERSION
    public static var coremlCodegenSwiftVersion: BuildSetting { 
        .coremlCodegenSwiftVersion(inherit: .swiftLanguageVersion) 
    }

    /// COREML_CODEGEN_SWIFT_VERSION
    public static func coremlCodegenSwiftVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlCodegenSwiftVersion, value: "\(value)")
    }

    /// COREML_CODEGEN_SWIFT_VERSION
    public static func coremlCodegenSwiftVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlCodegenSwiftVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COREML_CODEGEN_SWIFT_VERSION
    public static let coremlCodegenSwiftVersion: BuildSettingsKey = "COREML_CODEGEN_SWIFT_VERSION"
}

// MARK: COREML_COMPILER_INFOPLIST_CONTENT_FILE
extension BuildSetting {

    /// COREML_COMPILER_INFOPLIST_CONTENT_FILE
    public static var coremlCompilerInfoplistContentFile: BuildSetting { 
        BuildSetting(key: .coremlCompilerInfoplistContentFile, value: "$(TARGET_TEMP_DIR)/$(InputFileBase)-CoreMLPartialInfo.plist")
    }

    /// COREML_COMPILER_INFOPLIST_CONTENT_FILE
    public static func coremlCompilerInfoplistContentFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlCompilerInfoplistContentFile, value: "\(value)")
    }

    /// COREML_COMPILER_INFOPLIST_CONTENT_FILE
    public static func coremlCompilerInfoplistContentFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlCompilerInfoplistContentFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COREML_COMPILER_INFOPLIST_CONTENT_FILE
    public static let coremlCompilerInfoplistContentFile: BuildSettingsKey = "COREML_COMPILER_INFOPLIST_CONTENT_FILE"
}

// MARK: COREML_DEPLOYMENT_TARGET
extension BuildSetting {

    /// COREML_DEPLOYMENT_TARGET
    public static var coremlDeploymentTarget: BuildSetting { 
        BuildSetting(key: .coremlDeploymentTarget, value: "$(COREML_DEPLOYMENT_TARGET__$(IS_MACCATALYST:default=NO))")
    }

    /// COREML_DEPLOYMENT_TARGET
    public static func coremlDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlDeploymentTarget, value: "\(value)")
    }

    /// COREML_DEPLOYMENT_TARGET
    public static func coremlDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COREML_DEPLOYMENT_TARGET
    public static let coremlDeploymentTarget: BuildSettingsKey = "COREML_DEPLOYMENT_TARGET"
}

// MARK: COREML_DEPLOYMENT_TARGET__NO
extension BuildSetting {

    /// COREML_DEPLOYMENT_TARGET__NO
    public static var coremlDeploymentTargetNo: BuildSetting { 
        BuildSetting(key: .coremlDeploymentTargetNo, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// COREML_DEPLOYMENT_TARGET__NO
    public static func coremlDeploymentTargetNo(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlDeploymentTargetNo, value: "\(value)")
    }

    /// COREML_DEPLOYMENT_TARGET__NO
    public static func coremlDeploymentTargetNo(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlDeploymentTargetNo, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COREML_DEPLOYMENT_TARGET__NO
    public static let coremlDeploymentTargetNo: BuildSettingsKey = "COREML_DEPLOYMENT_TARGET__NO"
}

// MARK: COREML_DEPLOYMENT_TARGET__YES
extension BuildSetting {

    /// COREML_DEPLOYMENT_TARGET__YES
    public static var coremlDeploymentTargetYes: BuildSetting { 
        BuildSetting(key: .coremlDeploymentTargetYes, value: "$(IPHONEOS_DEPLOYMENT_TARGET)")
    }

    /// COREML_DEPLOYMENT_TARGET__YES
    public static func coremlDeploymentTargetYes(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlDeploymentTargetYes, value: "\(value)")
    }

    /// COREML_DEPLOYMENT_TARGET__YES
    public static func coremlDeploymentTargetYes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlDeploymentTargetYes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COREML_DEPLOYMENT_TARGET__YES
    public static let coremlDeploymentTargetYes: BuildSettingsKey = "COREML_DEPLOYMENT_TARGET__YES"
}

// MARK: COREML_PLATFORM_NAME
extension BuildSetting {

    /// COREML_PLATFORM_NAME
    public static var coremlPlatformName: BuildSetting { 
        BuildSetting(key: .coremlPlatformName, value: "$(COREML_PLATFORM_NAME__$(IS_MACCATALYST:default=NO))")
    }

    /// COREML_PLATFORM_NAME
    public static func coremlPlatformName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlPlatformName, value: "\(value)")
    }

    /// COREML_PLATFORM_NAME
    public static func coremlPlatformName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlPlatformName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COREML_PLATFORM_NAME
    public static let coremlPlatformName: BuildSettingsKey = "COREML_PLATFORM_NAME"
}

// MARK: COREML_PLATFORM_NAME__NO
extension BuildSetting {

    /// COREML_PLATFORM_NAME__NO
    public static var coremlPlatformNameNo: BuildSetting { 
        .coremlPlatformNameNo(inherit: .swiftPlatformTargetPrefix) 
    }

    /// COREML_PLATFORM_NAME__NO
    public static func coremlPlatformNameNo(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlPlatformNameNo, value: "\(value)")
    }

    /// COREML_PLATFORM_NAME__NO
    public static func coremlPlatformNameNo(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlPlatformNameNo, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COREML_PLATFORM_NAME__NO
    public static let coremlPlatformNameNo: BuildSettingsKey = "COREML_PLATFORM_NAME__NO"
}

// MARK: COREML_PLATFORM_NAME__YES
extension BuildSetting {

    /// COREML_PLATFORM_NAME__YES
    public static var coremlPlatformNameYes: BuildSetting { 
        BuildSetting(key: .coremlPlatformNameYes, value: "maccatalyst")
    }

    /// COREML_PLATFORM_NAME__YES
    public static func coremlPlatformNameYes(_ value: String) -> BuildSetting { 
        BuildSetting(key: .coremlPlatformNameYes, value: "\(value)")
    }

    /// COREML_PLATFORM_NAME__YES
    public static func coremlPlatformNameYes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .coremlPlatformNameYes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// COREML_PLATFORM_NAME__YES
    public static let coremlPlatformNameYes: BuildSettingsKey = "COREML_PLATFORM_NAME__YES"
}

// MARK: CP
extension BuildSetting {

    /// CP
    public static var cp: BuildSetting { 
        BuildSetting(key: .cp, value: "/bin/cp")
    }

    /// CP
    public static func cp(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cp, value: "\(value)")
    }

    /// CP
    public static func cp(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cp, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CP
    public static let cp: BuildSettingsKey = "CP"
}

// MARK: CPP_HEADERMAP_FILE
extension BuildSetting {

    /// CPP_HEADERMAP_FILE
    public static var cppHeadermapFile: BuildSetting { 
        BuildSetting(key: .cppHeadermapFile, value: "$(TEMP_DIR)/$(PRODUCT_NAME).hmap")
    }

    /// CPP_HEADERMAP_FILE
    public static func cppHeadermapFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFile, value: "\(value)")
    }

    /// CPP_HEADERMAP_FILE
    public static func cppHeadermapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CPP_HEADERMAP_FILE
    public static let cppHeadermapFile: BuildSettingsKey = "CPP_HEADERMAP_FILE"
}

// MARK: CPP_HEADERMAP_FILE_FOR_ALL_NON_FRAMEWORK_TARGET_HEADERS
extension BuildSetting {

    /// CPP_HEADERMAP_FILE_FOR_ALL_NON_FRAMEWORK_TARGET_HEADERS
    public static var cppHeadermapFileForAllNonFrameworkTargetHeaders: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForAllNonFrameworkTargetHeaders, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-all-non-framework-target-headers.hmap")
    }

    /// CPP_HEADERMAP_FILE_FOR_ALL_NON_FRAMEWORK_TARGET_HEADERS
    public static func cppHeadermapFileForAllNonFrameworkTargetHeaders(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForAllNonFrameworkTargetHeaders, value: "\(value)")
    }

    /// CPP_HEADERMAP_FILE_FOR_ALL_NON_FRAMEWORK_TARGET_HEADERS
    public static func cppHeadermapFileForAllNonFrameworkTargetHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForAllNonFrameworkTargetHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CPP_HEADERMAP_FILE_FOR_ALL_NON_FRAMEWORK_TARGET_HEADERS
    public static let cppHeadermapFileForAllNonFrameworkTargetHeaders: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_ALL_NON_FRAMEWORK_TARGET_HEADERS"
}

// MARK: CPP_HEADERMAP_FILE_FOR_ALL_TARGET_HEADERS
extension BuildSetting {

    /// CPP_HEADERMAP_FILE_FOR_ALL_TARGET_HEADERS
    public static var cppHeadermapFileForAllTargetHeaders: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForAllTargetHeaders, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-all-target-headers.hmap")
    }

    /// CPP_HEADERMAP_FILE_FOR_ALL_TARGET_HEADERS
    public static func cppHeadermapFileForAllTargetHeaders(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForAllTargetHeaders, value: "\(value)")
    }

    /// CPP_HEADERMAP_FILE_FOR_ALL_TARGET_HEADERS
    public static func cppHeadermapFileForAllTargetHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForAllTargetHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CPP_HEADERMAP_FILE_FOR_ALL_TARGET_HEADERS
    public static let cppHeadermapFileForAllTargetHeaders: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_ALL_TARGET_HEADERS"
}

// MARK: CPP_HEADERMAP_FILE_FOR_GENERATED_FILES
extension BuildSetting {

    /// CPP_HEADERMAP_FILE_FOR_GENERATED_FILES
    public static var cppHeadermapFileForGeneratedFiles: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForGeneratedFiles, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-generated-files.hmap")
    }

    /// CPP_HEADERMAP_FILE_FOR_GENERATED_FILES
    public static func cppHeadermapFileForGeneratedFiles(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForGeneratedFiles, value: "\(value)")
    }

    /// CPP_HEADERMAP_FILE_FOR_GENERATED_FILES
    public static func cppHeadermapFileForGeneratedFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForGeneratedFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CPP_HEADERMAP_FILE_FOR_GENERATED_FILES
    public static let cppHeadermapFileForGeneratedFiles: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_GENERATED_FILES"
}

// MARK: CPP_HEADERMAP_FILE_FOR_OWN_TARGET_HEADERS
extension BuildSetting {

    /// CPP_HEADERMAP_FILE_FOR_OWN_TARGET_HEADERS
    public static var cppHeadermapFileForOwnTargetHeaders: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForOwnTargetHeaders, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-own-target-headers.hmap")
    }

    /// CPP_HEADERMAP_FILE_FOR_OWN_TARGET_HEADERS
    public static func cppHeadermapFileForOwnTargetHeaders(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForOwnTargetHeaders, value: "\(value)")
    }

    /// CPP_HEADERMAP_FILE_FOR_OWN_TARGET_HEADERS
    public static func cppHeadermapFileForOwnTargetHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForOwnTargetHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CPP_HEADERMAP_FILE_FOR_OWN_TARGET_HEADERS
    public static let cppHeadermapFileForOwnTargetHeaders: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_OWN_TARGET_HEADERS"
}

// MARK: CPP_HEADERMAP_FILE_FOR_PROJECT_FILES
extension BuildSetting {

    /// CPP_HEADERMAP_FILE_FOR_PROJECT_FILES
    public static var cppHeadermapFileForProjectFiles: BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForProjectFiles, value: "$(TEMP_DIR)/$(PRODUCT_NAME)-project-headers.hmap")
    }

    /// CPP_HEADERMAP_FILE_FOR_PROJECT_FILES
    public static func cppHeadermapFileForProjectFiles(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapFileForProjectFiles, value: "\(value)")
    }

    /// CPP_HEADERMAP_FILE_FOR_PROJECT_FILES
    public static func cppHeadermapFileForProjectFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapFileForProjectFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CPP_HEADERMAP_FILE_FOR_PROJECT_FILES
    public static let cppHeadermapFileForProjectFiles: BuildSettingsKey = "CPP_HEADERMAP_FILE_FOR_PROJECT_FILES"
}

// MARK: CPP_HEADERMAP_PRODUCT_HEADERS_VFS_FILE
extension BuildSetting {

    /// CPP_HEADERMAP_PRODUCT_HEADERS_VFS_FILE
    public static var cppHeadermapProductHeadersVfsFile: BuildSetting { 
        BuildSetting(key: .cppHeadermapProductHeadersVfsFile, value: "$(PROJECT_TEMP_DIR)/all-product-headers.yaml")
    }

    /// CPP_HEADERMAP_PRODUCT_HEADERS_VFS_FILE
    public static func cppHeadermapProductHeadersVfsFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeadermapProductHeadersVfsFile, value: "\(value)")
    }

    /// CPP_HEADERMAP_PRODUCT_HEADERS_VFS_FILE
    public static func cppHeadermapProductHeadersVfsFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeadermapProductHeadersVfsFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CPP_HEADERMAP_PRODUCT_HEADERS_VFS_FILE
    public static let cppHeadermapProductHeadersVfsFile: BuildSettingsKey = "CPP_HEADERMAP_PRODUCT_HEADERS_VFS_FILE"
}

// MARK: CPP_HEADER_SYMLINKS_DIR
extension BuildSetting {

    /// CPP_HEADER_SYMLINKS_DIR
    public static var cppHeaderSymlinksDir: BuildSetting { 
        BuildSetting(key: .cppHeaderSymlinksDir, value: "$(TEMP_DIR)/$(PRODUCT_NAME).hdrs")
    }

    /// CPP_HEADER_SYMLINKS_DIR
    public static func cppHeaderSymlinksDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppHeaderSymlinksDir, value: "\(value)")
    }

    /// CPP_HEADER_SYMLINKS_DIR
    public static func cppHeaderSymlinksDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppHeaderSymlinksDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CPP_HEADER_SYMLINKS_DIR
    public static let cppHeaderSymlinksDir: BuildSettingsKey = "CPP_HEADER_SYMLINKS_DIR"
}

// MARK: Cpp Other Preprocessor Flags
extension BuildSetting {

    /// Cpp Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when using the standalone C Preprocessor rule.
    public static func cppOtherPreprocessorFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .cppOtherPreprocessorFlags, value: .array(value))
    }

    /// Cpp Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when using the standalone C Preprocessor rule.
    public static func cppOtherPreprocessorFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppOtherPreprocessorFlags, inherit: key)
    }

    /// Cpp Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when using the standalone C Preprocessor rule.
    public static func cppOtherPreprocessorFlags(_ value: String...) -> BuildSetting { 
        .cppOtherPreprocessorFlags(value)
    }
}

extension BuildSettingsKey {

    /// Cpp Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when using the standalone C Preprocessor rule.
    public static let cppOtherPreprocessorFlags: BuildSettingsKey = "CPP_OTHER_PREPROCESSOR_FLAGS"
}

// MARK: Cpp Prefix File
extension BuildSetting {

    /// Cpp Prefix File
    ///
    /// Implicitly include the given file when preprocessing using the standalone C Preprocessor rule. The path given should either be a project relative path or an absolute path.
    public static func cppPrefixFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .cppPrefixFile, value: "\(value)")
    }

    /// Cpp Prefix File
    ///
    /// Implicitly include the given file when preprocessing using the standalone C Preprocessor rule. The path given should either be a project relative path or an absolute path.
    public static func cppPrefixFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppPrefixFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Cpp Prefix File
    ///
    /// Implicitly include the given file when preprocessing using the standalone C Preprocessor rule. The path given should either be a project relative path or an absolute path.
    public static let cppPrefixFile: BuildSettingsKey = "CPP_PREFIX_HEADER"
}

// MARK: Cpp Preprocessor Definitions
extension BuildSetting {

    /// Cpp Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing using the standalone C Preprocessor rule.
    public static func cppPreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .cppPreprocessorDefinitions, value: .array(value))
    }

    /// Cpp Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing using the standalone C Preprocessor rule.
    public static func cppPreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cppPreprocessorDefinitions, inherit: key)
    }

    /// Cpp Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing using the standalone C Preprocessor rule.
    public static func cppPreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .cppPreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// Cpp Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing using the standalone C Preprocessor rule.
    public static let cppPreprocessorDefinitions: BuildSettingsKey = "CPP_PREPROCESSOR_DEFINITIONS"
}

// MARK: Create Info.plist Section in Binary
extension BuildSetting {

    /// Create Info.plist Section in Binary
    ///
    /// Enabling this setting will create a section in the product's linked binary containing the processed `Info.plist` file for the target. This setting only applies to command-line tool targets.
    public static var createInfoPlistSectionInBinary: BuildSetting { 
        BuildSetting(key: .createInfoPlistSectionInBinary, value: "NO")
    }

    /// Create Info.plist Section in Binary
    ///
    /// Enabling this setting will create a section in the product's linked binary containing the processed `Info.plist` file for the target. This setting only applies to command-line tool targets.
    public static func createInfoPlistSectionInBinary(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .createInfoPlistSectionInBinary, value: SettingValue(booleanLiteral: value))
    }

    /// Create Info.plist Section in Binary
    ///
    /// Enabling this setting will create a section in the product's linked binary containing the processed `Info.plist` file for the target. This setting only applies to command-line tool targets.
    public static func createInfoPlistSectionInBinary(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .createInfoPlistSectionInBinary, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Create Info.plist Section in Binary
    ///
    /// Enabling this setting will create a section in the product's linked binary containing the processed `Info.plist` file for the target. This setting only applies to command-line tool targets.
    public static let createInfoPlistSectionInBinary: BuildSettingsKey = "CREATE_INFOPLIST_SECTION_IN_BINARY"
}

// MARK: CURRENT_ARCH
extension BuildSetting {

    /// CURRENT_ARCH
    ///
    /// The name of the active architecture being processed.
    public static var currentArch: BuildSetting { 
        BuildSetting(key: .currentArch, value: "$(arch)")
    }

    /// CURRENT_ARCH
    ///
    /// The name of the active architecture being processed.
    public static func currentArch(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentArch, value: "\(value)")
    }

    /// CURRENT_ARCH
    ///
    /// The name of the active architecture being processed.
    public static func currentArch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentArch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CURRENT_ARCH
    ///
    /// The name of the active architecture being processed.
    public static let currentArch: BuildSettingsKey = "CURRENT_ARCH"
}

// MARK: Current Project Version
extension BuildSetting {

    /// Current Project Version
    ///
    /// This setting defines the current version of the project. The value must be a integer or floating point number, such as `57` or `365.8`.
    public static var currentProjectVersion: BuildSetting { 
        BuildSetting(key: .currentProjectVersion, value: "")
    }

    /// Current Project Version
    ///
    /// This setting defines the current version of the project. The value must be a integer or floating point number, such as `57` or `365.8`.
    public static func currentProjectVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentProjectVersion, value: "\(value)")
    }

    /// Current Project Version
    ///
    /// This setting defines the current version of the project. The value must be a integer or floating point number, such as `57` or `365.8`.
    public static func currentProjectVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentProjectVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Current Project Version
    ///
    /// This setting defines the current version of the project. The value must be a integer or floating point number, such as `57` or `365.8`.
    public static let currentProjectVersion: BuildSettingsKey = "CURRENT_PROJECT_VERSION"
}

// MARK: CURRENT_VARIANT
extension BuildSetting {

    /// CURRENT_VARIANT
    ///
    /// The name of the active variant being processed.
    public static var currentVariant: BuildSetting { 
        BuildSetting(key: .currentVariant, value: "$(variant)")
    }

    /// CURRENT_VARIANT
    ///
    /// The name of the active variant being processed.
    public static func currentVariant(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentVariant, value: "\(value)")
    }

    /// CURRENT_VARIANT
    ///
    /// The name of the active variant being processed.
    public static func currentVariant(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentVariant, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CURRENT_VARIANT
    ///
    /// The name of the active variant being processed.
    public static let currentVariant: BuildSettingsKey = "CURRENT_VARIANT"
}

// MARK: CURRENT_VERSION
extension BuildSetting {

    /// CURRENT_VERSION
    public static var currentVersion: BuildSetting { 
        BuildSetting(key: .currentVersion, value: "")
    }

    /// CURRENT_VERSION
    public static func currentVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentVersion, value: "\(value)")
    }

    /// CURRENT_VERSION
    public static func currentVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CURRENT_VERSION
    public static let currentVersion: BuildSettingsKey = "CURRENT_VERSION"
}

// MARK: CodeSignEntitlements
extension BuildSetting {

    /// CodeSignEntitlements
    public static func codesignentitlements(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .codesignentitlements, value: SettingValue(booleanLiteral: value))
    }

    /// CodeSignEntitlements
    public static func codesignentitlements(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codesignentitlements, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CodeSignEntitlements
    public static let codesignentitlements: BuildSettingsKey = "CodeSignEntitlements"
}

// MARK: CodeSignResourceRules
extension BuildSetting {

    /// CodeSignResourceRules
    public static func codesignresourcerules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .codesignresourcerules, value: SettingValue(booleanLiteral: value))
    }

    /// CodeSignResourceRules
    public static func codesignresourcerules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codesignresourcerules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CodeSignResourceRules
    public static let codesignresourcerules: BuildSettingsKey = "CodeSignResourceRules"
}

// MARK: Dead Code Stripping
extension BuildSetting {

    /// Dead Code Stripping
    ///
    /// Activating this setting causes the `-dead_strip` flag to be passed to `ld(1)` via `cc(1)` to turn on dead code stripping.
    public static var deadCodeStripping: BuildSetting { 
        BuildSetting(key: .deadCodeStripping, value: "NO")
    }

    /// Dead Code Stripping
    ///
    /// Activating this setting causes the `-dead_strip` flag to be passed to `ld(1)` via `cc(1)` to turn on dead code stripping.
    public static func deadCodeStripping(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deadCodeStripping, value: SettingValue(booleanLiteral: value))
    }

    /// Dead Code Stripping
    ///
    /// Activating this setting causes the `-dead_strip` flag to be passed to `ld(1)` via `cc(1)` to turn on dead code stripping.
    public static func deadCodeStripping(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deadCodeStripping, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dead Code Stripping
    ///
    /// Activating this setting causes the `-dead_strip` flag to be passed to `ld(1)` via `cc(1)` to turn on dead code stripping.
    public static let deadCodeStripping: BuildSettingsKey = "DEAD_CODE_STRIPPING"
}

// MARK: DEBUGGING_SYMBOLS
extension BuildSetting {

    /// DEBUGGING_SYMBOLS
    public static var debuggingSymbols: BuildSetting { 
        BuildSetting(key: .debuggingSymbols, value: "YES")
    }

    /// DEBUGGING_SYMBOLS
    public static func debuggingSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .debuggingSymbols, value: SettingValue(booleanLiteral: value))
    }

    /// DEBUGGING_SYMBOLS
    public static func debuggingSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .debuggingSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEBUGGING_SYMBOLS
    public static let debuggingSymbols: BuildSettingsKey = "DEBUGGING_SYMBOLS"
}

// MARK: Debug Information Format
extension BuildSetting {

    /// Debug Information Format
    ///
    /// The type of debug information to produce.

- _DWARF:_ Object files and linked products will use DWARF as the debug information format. `dwarf`

- _DWARF with dSYM File:_ Object files and linked products will use DWARF as the debug information format, and Xcode will also produce a dSYM file containing the debug information from the individual object files (except that a dSYM file is not needed and will not be created for static library or object file products). `dwarf-with-dsym`
    public static var debugInformationFormat: BuildSetting { 
        .debugInformationFormat(.dwarf) 
    }

    /// Debug Information Format
    ///
    /// The type of debug information to produce.

- _DWARF:_ Object files and linked products will use DWARF as the debug information format. `dwarf`

- _DWARF with dSYM File:_ Object files and linked products will use DWARF as the debug information format, and Xcode will also produce a dSYM file containing the debug information from the individual object files (except that a dSYM file is not needed and will not be created for static library or object file products). `dwarf-with-dsym`
    public static func debugInformationFormat(_ value: DebugInformationFormat) -> BuildSetting { 
        BuildSetting(key: .debugInformationFormat, value: "\(value)")
    }

    /// Debug Information Format
    ///
    /// The type of debug information to produce.

- _DWARF:_ Object files and linked products will use DWARF as the debug information format. `dwarf`

- _DWARF with dSYM File:_ Object files and linked products will use DWARF as the debug information format, and Xcode will also produce a dSYM file containing the debug information from the individual object files (except that a dSYM file is not needed and will not be created for static library or object file products). `dwarf-with-dsym`
    public static func debugInformationFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .debugInformationFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Debug Information Format
    ///
    /// The type of debug information to produce.

- _DWARF:_ Object files and linked products will use DWARF as the debug information format. `dwarf`

- _DWARF with dSYM File:_ Object files and linked products will use DWARF as the debug information format, and Xcode will also produce a dSYM file containing the debug information from the individual object files (except that a dSYM file is not needed and will not be created for static library or object file products). `dwarf-with-dsym`
    public static let debugInformationFormat: BuildSettingsKey = "DEBUG_INFORMATION_FORMAT"
}

public enum DebugInformationFormat: String, Hashable, Codable, CustomStringConvertible {
    case dwarf = "dwarf"
    case dwarfWithDsym = "dwarf-with-dsym"

    public var description: String {
        rawValue
    }
}

// MARK: DEFAULT_COMPILER
extension BuildSetting {

    /// DEFAULT_COMPILER
    public static var defaultCompiler: BuildSetting { 
        BuildSetting(key: .defaultCompiler, value: "")
    }

    /// DEFAULT_COMPILER
    public static func defaultCompiler(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultCompiler, value: "\(value)")
    }

    /// DEFAULT_COMPILER
    public static func defaultCompiler(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultCompiler, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_COMPILER
    public static let defaultCompiler: BuildSettingsKey = "DEFAULT_COMPILER"
}

// MARK: DEFAULT_DEXT_INSTALL_PATH
extension BuildSetting {

    /// DEFAULT_DEXT_INSTALL_PATH
    public static var defaultDextInstallPath: BuildSetting { 
        .defaultDextInstallPath(inherit: .systemDextInstallPath) 
    }

    /// DEFAULT_DEXT_INSTALL_PATH
    public static func defaultDextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultDextInstallPath, value: "\(value)")
    }

    /// DEFAULT_DEXT_INSTALL_PATH
    public static func defaultDextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultDextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_DEXT_INSTALL_PATH
    public static let defaultDextInstallPath: BuildSettingsKey = "DEFAULT_DEXT_INSTALL_PATH"
}

// MARK: DEFAULT_KEXT_INSTALL_PATH
extension BuildSetting {

    /// DEFAULT_KEXT_INSTALL_PATH
    public static var defaultKextInstallPath: BuildSetting { 
        .defaultKextInstallPath(inherit: .systemKextInstallPath) 
    }

    /// DEFAULT_KEXT_INSTALL_PATH
    public static func defaultKextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultKextInstallPath, value: "\(value)")
    }

    /// DEFAULT_KEXT_INSTALL_PATH
    public static func defaultKextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultKextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_KEXT_INSTALL_PATH
    public static let defaultKextInstallPath: BuildSettingsKey = "DEFAULT_KEXT_INSTALL_PATH"
}

// MARK: DEFAULT_SSE_LEVEL_3_NO
extension BuildSetting {

    /// DEFAULT_SSE_LEVEL_3_NO
    public static var defaultSseLevel3No: BuildSetting { 
        BuildSetting(key: .defaultSseLevel3No, value: "default")
    }

    /// DEFAULT_SSE_LEVEL_3_NO
    public static func defaultSseLevel3No(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultSseLevel3No, value: "\(value)")
    }

    /// DEFAULT_SSE_LEVEL_3_NO
    public static func defaultSseLevel3No(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultSseLevel3No, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_SSE_LEVEL_3_NO
    public static let defaultSseLevel3No: BuildSettingsKey = "DEFAULT_SSE_LEVEL_3_NO"
}

// MARK: DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_NO
extension BuildSetting {

    /// DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_NO
    public static var defaultSseLevel3SupplementalNo: BuildSetting { 
        BuildSetting(key: .defaultSseLevel3SupplementalNo, value: "$(DEFAULT_SSE_LEVEL_3_$(GCC_ENABLE_SSE3_EXTENSIONS))")
    }

    /// DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_NO
    public static func defaultSseLevel3SupplementalNo(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultSseLevel3SupplementalNo, value: "\(value)")
    }

    /// DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_NO
    public static func defaultSseLevel3SupplementalNo(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultSseLevel3SupplementalNo, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_NO
    public static let defaultSseLevel3SupplementalNo: BuildSettingsKey = "DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_NO"
}

// MARK: DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_YES
extension BuildSetting {

    /// DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_YES
    public static var defaultSseLevel3SupplementalYes: BuildSetting { 
        BuildSetting(key: .defaultSseLevel3SupplementalYes, value: "ssse3")
    }

    /// DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_YES
    public static func defaultSseLevel3SupplementalYes(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultSseLevel3SupplementalYes, value: "\(value)")
    }

    /// DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_YES
    public static func defaultSseLevel3SupplementalYes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultSseLevel3SupplementalYes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_YES
    public static let defaultSseLevel3SupplementalYes: BuildSettingsKey = "DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_YES"
}

// MARK: DEFAULT_SSE_LEVEL_3_YES
extension BuildSetting {

    /// DEFAULT_SSE_LEVEL_3_YES
    public static var defaultSseLevel3Yes: BuildSetting { 
        BuildSetting(key: .defaultSseLevel3Yes, value: "sse3")
    }

    /// DEFAULT_SSE_LEVEL_3_YES
    public static func defaultSseLevel3Yes(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultSseLevel3Yes, value: "\(value)")
    }

    /// DEFAULT_SSE_LEVEL_3_YES
    public static func defaultSseLevel3Yes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultSseLevel3Yes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_SSE_LEVEL_3_YES
    public static let defaultSseLevel3Yes: BuildSettingsKey = "DEFAULT_SSE_LEVEL_3_YES"
}

// MARK: DEFAULT_SSE_LEVEL_4_1_NO
extension BuildSetting {

    /// DEFAULT_SSE_LEVEL_4_1_NO
    public static var defaultSseLevel41No: BuildSetting { 
        BuildSetting(key: .defaultSseLevel41No, value: "$(DEFAULT_SSE_LEVEL_3_SUPPLEMENTAL_$(GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS))")
    }

    /// DEFAULT_SSE_LEVEL_4_1_NO
    public static func defaultSseLevel41No(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultSseLevel41No, value: "\(value)")
    }

    /// DEFAULT_SSE_LEVEL_4_1_NO
    public static func defaultSseLevel41No(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultSseLevel41No, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_SSE_LEVEL_4_1_NO
    public static let defaultSseLevel41No: BuildSettingsKey = "DEFAULT_SSE_LEVEL_4_1_NO"
}

// MARK: DEFAULT_SSE_LEVEL_4_1_YES
extension BuildSetting {

    /// DEFAULT_SSE_LEVEL_4_1_YES
    public static var defaultSseLevel41Yes: BuildSetting { 
        BuildSetting(key: .defaultSseLevel41Yes, value: "sse4.1")
    }

    /// DEFAULT_SSE_LEVEL_4_1_YES
    public static func defaultSseLevel41Yes(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultSseLevel41Yes, value: "\(value)")
    }

    /// DEFAULT_SSE_LEVEL_4_1_YES
    public static func defaultSseLevel41Yes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultSseLevel41Yes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_SSE_LEVEL_4_1_YES
    public static let defaultSseLevel41Yes: BuildSettingsKey = "DEFAULT_SSE_LEVEL_4_1_YES"
}

// MARK: DEFAULT_SSE_LEVEL_4_2_NO
extension BuildSetting {

    /// DEFAULT_SSE_LEVEL_4_2_NO
    public static var defaultSseLevel42No: BuildSetting { 
        BuildSetting(key: .defaultSseLevel42No, value: "$(DEFAULT_SSE_LEVEL_4_1_$(GCC_ENABLE_SSE41_EXTENSIONS))")
    }

    /// DEFAULT_SSE_LEVEL_4_2_NO
    public static func defaultSseLevel42No(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultSseLevel42No, value: "\(value)")
    }

    /// DEFAULT_SSE_LEVEL_4_2_NO
    public static func defaultSseLevel42No(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultSseLevel42No, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_SSE_LEVEL_4_2_NO
    public static let defaultSseLevel42No: BuildSettingsKey = "DEFAULT_SSE_LEVEL_4_2_NO"
}

// MARK: DEFAULT_SSE_LEVEL_4_2_YES
extension BuildSetting {

    /// DEFAULT_SSE_LEVEL_4_2_YES
    public static var defaultSseLevel42Yes: BuildSetting { 
        BuildSetting(key: .defaultSseLevel42Yes, value: "sse4.2")
    }

    /// DEFAULT_SSE_LEVEL_4_2_YES
    public static func defaultSseLevel42Yes(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultSseLevel42Yes, value: "\(value)")
    }

    /// DEFAULT_SSE_LEVEL_4_2_YES
    public static func defaultSseLevel42Yes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultSseLevel42Yes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEFAULT_SSE_LEVEL_4_2_YES
    public static let defaultSseLevel42Yes: BuildSettingsKey = "DEFAULT_SSE_LEVEL_4_2_YES"
}

// MARK: Defines Module
extension BuildSetting {

    /// Defines Module
    ///
    /// If enabled, the product will be treated as defining its own module. This enables automatic production of LLVM module map files when appropriate, and allows the product to be imported as a module.
    public static var definesModule: BuildSetting { 
        BuildSetting(key: .definesModule, value: "NO")
    }

    /// Defines Module
    ///
    /// If enabled, the product will be treated as defining its own module. This enables automatic production of LLVM module map files when appropriate, and allows the product to be imported as a module.
    public static func definesModule(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .definesModule, value: SettingValue(booleanLiteral: value))
    }

    /// Defines Module
    ///
    /// If enabled, the product will be treated as defining its own module. This enables automatic production of LLVM module map files when appropriate, and allows the product to be imported as a module.
    public static func definesModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .definesModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Defines Module
    ///
    /// If enabled, the product will be treated as defining its own module. This enables automatic production of LLVM module map files when appropriate, and allows the product to be imported as a module.
    public static let definesModule: BuildSettingsKey = "DEFINES_MODULE"
}

// MARK: Deployment Location
extension BuildSetting {

    /// Deployment Location
    ///
    /// If enabled, built products are placed in their installed locations in addition to the built products folder.
    public static var deploymentLocation: BuildSetting { 
        BuildSetting(key: .deploymentLocation, value: "NO")
    }

    /// Deployment Location
    ///
    /// If enabled, built products are placed in their installed locations in addition to the built products folder.
    public static func deploymentLocation(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deploymentLocation, value: SettingValue(booleanLiteral: value))
    }

    /// Deployment Location
    ///
    /// If enabled, built products are placed in their installed locations in addition to the built products folder.
    public static func deploymentLocation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deploymentLocation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Deployment Location
    ///
    /// If enabled, built products are placed in their installed locations in addition to the built products folder.
    public static let deploymentLocation: BuildSettingsKey = "DEPLOYMENT_LOCATION"
}

// MARK: Deployment Postprocessing
extension BuildSetting {

    /// Deployment Postprocessing
    ///
    /// If enabled, indicates that binaries should be stripped and file mode, owner, and group information should be set to standard values.
    public static var deploymentPostprocessing: BuildSetting { 
        BuildSetting(key: .deploymentPostprocessing, value: "NO")
    }

    /// Deployment Postprocessing
    ///
    /// If enabled, indicates that binaries should be stripped and file mode, owner, and group information should be set to standard values.
    public static func deploymentPostprocessing(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deploymentPostprocessing, value: SettingValue(booleanLiteral: value))
    }

    /// Deployment Postprocessing
    ///
    /// If enabled, indicates that binaries should be stripped and file mode, owner, and group information should be set to standard values.
    public static func deploymentPostprocessing(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deploymentPostprocessing, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Deployment Postprocessing
    ///
    /// If enabled, indicates that binaries should be stripped and file mode, owner, and group information should be set to standard values.
    public static let deploymentPostprocessing: BuildSettingsKey = "DEPLOYMENT_POSTPROCESSING"
}

// MARK: DEPLOYMENT_TARGET
extension BuildSetting {

    /// DEPLOYMENT_TARGET
    public static var deploymentTarget: BuildSetting { 
        BuildSetting(key: .deploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// DEPLOYMENT_TARGET
    public static func deploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .deploymentTarget, value: "\(value)")
    }

    /// DEPLOYMENT_TARGET
    public static func deploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEPLOYMENT_TARGET
    public static let deploymentTarget: BuildSettingsKey = "DEPLOYMENT_TARGET"
}

// MARK: DERIVED_FILES_DIR
extension BuildSetting {

    /// DERIVED_FILES_DIR
    public static var derivedFilesDir: BuildSetting { 
        .derivedFilesDir(inherit: .derivedFileDir) 
    }

    /// DERIVED_FILES_DIR
    public static func derivedFilesDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .derivedFilesDir, value: "\(value)")
    }

    /// DERIVED_FILES_DIR
    public static func derivedFilesDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .derivedFilesDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DERIVED_FILES_DIR
    public static let derivedFilesDir: BuildSettingsKey = "DERIVED_FILES_DIR"
}

// MARK: DERIVED_FILE_DIR
extension BuildSetting {

    /// DERIVED_FILE_DIR
    public static var derivedFileDir: BuildSetting { 
        BuildSetting(key: .derivedFileDir, value: "$(TARGET_TEMP_DIR)/DerivedSources")
    }

    /// DERIVED_FILE_DIR
    public static func derivedFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .derivedFileDir, value: "\(value)")
    }

    /// DERIVED_FILE_DIR
    public static func derivedFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .derivedFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DERIVED_FILE_DIR
    public static let derivedFileDir: BuildSettingsKey = "DERIVED_FILE_DIR"
}

// MARK: DERIVED_PATHS
extension BuildSetting {

    /// DERIVED_PATHS
    public static var derivedPaths: BuildSetting { 
        BuildSetting(key: .derivedPaths, value: "")
    }

    /// DERIVED_PATHS
    public static func derivedPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .derivedPaths, value: .array(value))
    }

    /// DERIVED_PATHS
    public static func derivedPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .derivedPaths, inherit: key)
    }

    /// DERIVED_PATHS
    public static func derivedPaths(_ value: String...) -> BuildSetting { 
        .derivedPaths(value)
    }
}

extension BuildSettingsKey {

    /// DERIVED_PATHS
    public static let derivedPaths: BuildSettingsKey = "DERIVED_PATHS"
}

// MARK: DERIVED_SOURCES_DIR
extension BuildSetting {

    /// DERIVED_SOURCES_DIR
    public static var derivedSourcesDir: BuildSetting { 
        .derivedSourcesDir(inherit: .derivedFileDir) 
    }

    /// DERIVED_SOURCES_DIR
    public static func derivedSourcesDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .derivedSourcesDir, value: "\(value)")
    }

    /// DERIVED_SOURCES_DIR
    public static func derivedSourcesDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .derivedSourcesDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DERIVED_SOURCES_DIR
    public static let derivedSourcesDir: BuildSettingsKey = "DERIVED_SOURCES_DIR"
}

// MARK: Derive Mac Catalyst Product Bundle Identifier
extension BuildSetting {

    /// Derive Mac Catalyst Product Bundle Identifier
    ///
    /// When enabled, Xcode will automatically derive a bundle identifier for this target from its original bundle identifier when it's building for Mac Catalyst.
    public static var deriveMacCatalystProductBundleIdentifier: BuildSetting { 
        BuildSetting(key: .deriveMacCatalystProductBundleIdentifier, value: "NO")
    }

    /// Derive Mac Catalyst Product Bundle Identifier
    ///
    /// When enabled, Xcode will automatically derive a bundle identifier for this target from its original bundle identifier when it's building for Mac Catalyst.
    public static func deriveMacCatalystProductBundleIdentifier(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deriveMacCatalystProductBundleIdentifier, value: SettingValue(booleanLiteral: value))
    }

    /// Derive Mac Catalyst Product Bundle Identifier
    ///
    /// When enabled, Xcode will automatically derive a bundle identifier for this target from its original bundle identifier when it's building for Mac Catalyst.
    public static func deriveMacCatalystProductBundleIdentifier(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deriveMacCatalystProductBundleIdentifier, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Derive Mac Catalyst Product Bundle Identifier
    ///
    /// When enabled, Xcode will automatically derive a bundle identifier for this target from its original bundle identifier when it's building for Mac Catalyst.
    public static let deriveMacCatalystProductBundleIdentifier: BuildSettingsKey = "DERIVE_MACCATALYST_PRODUCT_BUNDLE_IDENTIFIER"
}

// MARK: DEVELOPER_DIR
extension BuildSetting {

    /// DEVELOPER_DIR
    public static func developerDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .developerDir, value: "\(value)")
    }

    /// DEVELOPER_DIR
    public static func developerDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .developerDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEVELOPER_DIR
    public static let developerDir: BuildSettingsKey = "DEVELOPER_DIR"
}

// MARK: Development Assets
extension BuildSetting {

    /// Development Assets
    ///
    /// Files and directories used only for development. Archive and install builds will exclude this content.
    public static var developmentAssets: BuildSetting { 
        BuildSetting(key: .developmentAssets, value: "")
    }

    /// Development Assets
    ///
    /// Files and directories used only for development. Archive and install builds will exclude this content.
    public static func developmentAssets(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .developmentAssets, value: .array(value))
    }

    /// Development Assets
    ///
    /// Files and directories used only for development. Archive and install builds will exclude this content.
    public static func developmentAssets(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .developmentAssets, inherit: key)
    }

    /// Development Assets
    ///
    /// Files and directories used only for development. Archive and install builds will exclude this content.
    public static func developmentAssets(_ value: String...) -> BuildSetting { 
        .developmentAssets(value)
    }
}

extension BuildSettingsKey {

    /// Development Assets
    ///
    /// Files and directories used only for development. Archive and install builds will exclude this content.
    public static let developmentAssets: BuildSettingsKey = "DEVELOPMENT_ASSET_PATHS"
}

// MARK: DEVELOPMENT_LANGUAGE
extension BuildSetting {

    /// DEVELOPMENT_LANGUAGE
    public static func developmentLanguage(_ value: String) -> BuildSetting { 
        BuildSetting(key: .developmentLanguage, value: "\(value)")
    }

    /// DEVELOPMENT_LANGUAGE
    public static func developmentLanguage(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .developmentLanguage, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DEVELOPMENT_LANGUAGE
    public static let developmentLanguage: BuildSettingsKey = "DEVELOPMENT_LANGUAGE"
}

// MARK: Development Team
extension BuildSetting {

    /// Development Team
    ///
    /// The team ID of a development team to use for signing certificates and provisioning profiles.
    public static var developmentTeam: BuildSetting { 
        BuildSetting(key: .developmentTeam, value: "")
    }

    /// Development Team
    ///
    /// The team ID of a development team to use for signing certificates and provisioning profiles.
    public static func developmentTeam(_ value: DevelopmentTeam) -> BuildSetting { 
        BuildSetting(key: .developmentTeam, value: "\(value)")
    }

    /// Development Team
    ///
    /// The team ID of a development team to use for signing certificates and provisioning profiles.
    public static func developmentTeam(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .developmentTeam, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Development Team
    ///
    /// The team ID of a development team to use for signing certificates and provisioning profiles.
    public static let developmentTeam: BuildSettingsKey = "DEVELOPMENT_TEAM"
}

// MARK: DOCUMENTATION_FOLDER_PATH
extension BuildSetting {

    /// DOCUMENTATION_FOLDER_PATH
    ///
    /// Identifies the directory that contains the bundles documentation files.
    public static var documentationFolderPath: BuildSetting { 
        BuildSetting(key: .documentationFolderPath, value: "")
    }

    /// DOCUMENTATION_FOLDER_PATH
    ///
    /// Identifies the directory that contains the bundles documentation files.
    public static func documentationFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .documentationFolderPath, value: "\(value)")
    }

    /// DOCUMENTATION_FOLDER_PATH
    ///
    /// Identifies the directory that contains the bundles documentation files.
    public static func documentationFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .documentationFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DOCUMENTATION_FOLDER_PATH
    ///
    /// Identifies the directory that contains the bundles documentation files.
    public static let documentationFolderPath: BuildSettingsKey = "DOCUMENTATION_FOLDER_PATH"
}

// MARK: Don't Force Info.plist Generation
extension BuildSetting {

    /// Don't Force Info.plist Generation
    ///
    /// If enabled, don't automatically generate an Info.plist file for wrapped products when the [Info.plist File (INFOPLIST\_FILE)](itcaec37c2a6.html#dev131d2e1c2) build setting is empty.
    public static var donTForceInfoPlistGeneration: BuildSetting { 
        BuildSetting(key: .donTForceInfoPlistGeneration, value: "NO")
    }

    /// Don't Force Info.plist Generation
    ///
    /// If enabled, don't automatically generate an Info.plist file for wrapped products when the [Info.plist File (INFOPLIST\_FILE)](itcaec37c2a6.html#dev131d2e1c2) build setting is empty.
    public static func donTForceInfoPlistGeneration(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .donTForceInfoPlistGeneration, value: SettingValue(booleanLiteral: value))
    }

    /// Don't Force Info.plist Generation
    ///
    /// If enabled, don't automatically generate an Info.plist file for wrapped products when the [Info.plist File (INFOPLIST\_FILE)](itcaec37c2a6.html#dev131d2e1c2) build setting is empty.
    public static func donTForceInfoPlistGeneration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .donTForceInfoPlistGeneration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Don't Force Info.plist Generation
    ///
    /// If enabled, don't automatically generate an Info.plist file for wrapped products when the [Info.plist File (INFOPLIST\_FILE)](itcaec37c2a6.html#dev131d2e1c2) build setting is empty.
    public static let donTForceInfoPlistGeneration: BuildSettingsKey = "DONT_GENERATE_INFOPLIST_FILE"
}

// MARK: DO_HEADER_SCANNING_IN_JAM
extension BuildSetting {

    /// DO_HEADER_SCANNING_IN_JAM
    public static var doHeaderScanningInJam: BuildSetting { 
        BuildSetting(key: .doHeaderScanningInJam, value: "NO")
    }

    /// DO_HEADER_SCANNING_IN_JAM
    public static func doHeaderScanningInJam(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .doHeaderScanningInJam, value: SettingValue(booleanLiteral: value))
    }

    /// DO_HEADER_SCANNING_IN_JAM
    public static func doHeaderScanningInJam(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .doHeaderScanningInJam, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DO_HEADER_SCANNING_IN_JAM
    public static let doHeaderScanningInJam: BuildSettingsKey = "DO_HEADER_SCANNING_IN_JAM"
}

// MARK: Installation Build Products Location
extension BuildSetting {

    /// Installation Build Products Location
    ///
    /// The path at which all products will be rooted when performing an install build. For instance, to install your products on the system proper, set this path to `/`. Defaults to `/tmp/$(PROJECT_NAME).dst` to prevent a _test_ install build from accidentally overwriting valid and needed data in the ultimate install path.

Typically this path is not set per target, but is provided as an option on the command line when performing an `xcodebuild install`. It may also be set in a build configuration in special circumstances.
    public static var installationBuildProductsLocation: BuildSetting { 
        BuildSetting(key: .installationBuildProductsLocation, value: "/tmp/$(PROJECT_NAME).dst")
    }

    /// Installation Build Products Location
    ///
    /// The path at which all products will be rooted when performing an install build. For instance, to install your products on the system proper, set this path to `/`. Defaults to `/tmp/$(PROJECT_NAME).dst` to prevent a _test_ install build from accidentally overwriting valid and needed data in the ultimate install path.

Typically this path is not set per target, but is provided as an option on the command line when performing an `xcodebuild install`. It may also be set in a build configuration in special circumstances.
    public static func installationBuildProductsLocation(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installationBuildProductsLocation, value: "\(value)")
    }

    /// Installation Build Products Location
    ///
    /// The path at which all products will be rooted when performing an install build. For instance, to install your products on the system proper, set this path to `/`. Defaults to `/tmp/$(PROJECT_NAME).dst` to prevent a _test_ install build from accidentally overwriting valid and needed data in the ultimate install path.

Typically this path is not set per target, but is provided as an option on the command line when performing an `xcodebuild install`. It may also be set in a build configuration in special circumstances.
    public static func installationBuildProductsLocation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installationBuildProductsLocation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Installation Build Products Location
    ///
    /// The path at which all products will be rooted when performing an install build. For instance, to install your products on the system proper, set this path to `/`. Defaults to `/tmp/$(PROJECT_NAME).dst` to prevent a _test_ install build from accidentally overwriting valid and needed data in the ultimate install path.

Typically this path is not set per target, but is provided as an option on the command line when performing an `xcodebuild install`. It may also be set in a build configuration in special circumstances.
    public static let installationBuildProductsLocation: BuildSettingsKey = "DSTROOT"
}

// MARK: DSYMUTIL_VERBOSE
extension BuildSetting {

    /// DSYMUTIL_VERBOSE
    public static var dsymutilVerbose: BuildSetting { 
        BuildSetting(key: .dsymutilVerbose, value: "NO")
    }

    /// DSYMUTIL_VERBOSE
    public static func dsymutilVerbose(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .dsymutilVerbose, value: SettingValue(booleanLiteral: value))
    }

    /// DSYMUTIL_VERBOSE
    public static func dsymutilVerbose(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dsymutilVerbose, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DSYMUTIL_VERBOSE
    public static let dsymutilVerbose: BuildSettingsKey = "DSYMUTIL_VERBOSE"
}

// MARK: Other DTrace Flags
extension BuildSetting {

    /// Other DTrace Flags
    ///
    /// Space-separated list of additional flags to pass to the `dtrace` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `dtrace` flag.
    public static var otherDtraceFlags: BuildSetting { 
        BuildSetting(key: .otherDtraceFlags, value: "")
    }

    /// Other DTrace Flags
    ///
    /// Space-separated list of additional flags to pass to the `dtrace` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `dtrace` flag.
    public static func otherDtraceFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherDtraceFlags, value: .array(value))
    }

    /// Other DTrace Flags
    ///
    /// Space-separated list of additional flags to pass to the `dtrace` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `dtrace` flag.
    public static func otherDtraceFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherDtraceFlags, inherit: key)
    }

    /// Other DTrace Flags
    ///
    /// Space-separated list of additional flags to pass to the `dtrace` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `dtrace` flag.
    public static func otherDtraceFlags(_ value: String...) -> BuildSetting { 
        .otherDtraceFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other DTrace Flags
    ///
    /// Space-separated list of additional flags to pass to the `dtrace` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `dtrace` flag.
    public static let otherDtraceFlags: BuildSettingsKey = "DTRACE_OTHER_FLAGS"
}

// MARK: DTRACE_OUTPUT_FILE_TYPE
extension BuildSetting {

    /// DTRACE_OUTPUT_FILE_TYPE
    public static var dtraceOutputFileType: BuildSetting { 
        .dtraceOutputFileType(.header) 
    }

    /// DTRACE_OUTPUT_FILE_TYPE
    public static func dtraceOutputFileType(_ value: DtraceOutputFileType) -> BuildSetting { 
        BuildSetting(key: .dtraceOutputFileType, value: "\(value)")
    }

    /// DTRACE_OUTPUT_FILE_TYPE
    public static func dtraceOutputFileType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dtraceOutputFileType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DTRACE_OUTPUT_FILE_TYPE
    public static let dtraceOutputFileType: BuildSettingsKey = "DTRACE_OUTPUT_FILE_TYPE"
}

public enum DtraceOutputFileType: String, Hashable, Codable, CustomStringConvertible {
    case header = "Header"

    public var description: String {
        rawValue
    }
}

// MARK: DWARF_DSYM_FILE_NAME
extension BuildSetting {

    /// DWARF_DSYM_FILE_NAME
    public static var dwarfDsymFileName: BuildSetting { 
        BuildSetting(key: .dwarfDsymFileName, value: "$(FULL_PRODUCT_NAME).dSYM")
    }

    /// DWARF_DSYM_FILE_NAME
    public static func dwarfDsymFileName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .dwarfDsymFileName, value: "\(value)")
    }

    /// DWARF_DSYM_FILE_NAME
    public static func dwarfDsymFileName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dwarfDsymFileName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DWARF_DSYM_FILE_NAME
    public static let dwarfDsymFileName: BuildSettingsKey = "DWARF_DSYM_FILE_NAME"
}

// MARK: DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT
extension BuildSetting {

    /// DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT
    public static var dwarfDsymFileShouldAccompanyProduct: BuildSetting { 
        BuildSetting(key: .dwarfDsymFileShouldAccompanyProduct, value: "NO")
    }

    /// DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT
    public static func dwarfDsymFileShouldAccompanyProduct(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .dwarfDsymFileShouldAccompanyProduct, value: SettingValue(booleanLiteral: value))
    }

    /// DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT
    public static func dwarfDsymFileShouldAccompanyProduct(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dwarfDsymFileShouldAccompanyProduct, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT
    public static let dwarfDsymFileShouldAccompanyProduct: BuildSettingsKey = "DWARF_DSYM_FILE_SHOULD_ACCOMPANY_PRODUCT"
}

// MARK: DWARF_DSYM_FOLDER_PATH
extension BuildSetting {

    /// DWARF_DSYM_FOLDER_PATH
    public static var dwarfDsymFolderPath: BuildSetting { 
        .dwarfDsymFolderPath(inherit: .perConfigurationBuildProductsPath) 
    }

    /// DWARF_DSYM_FOLDER_PATH
    public static func dwarfDsymFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .dwarfDsymFolderPath, value: "\(value)")
    }

    /// DWARF_DSYM_FOLDER_PATH
    public static func dwarfDsymFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dwarfDsymFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// DWARF_DSYM_FOLDER_PATH
    public static let dwarfDsymFolderPath: BuildSettingsKey = "DWARF_DSYM_FOLDER_PATH"
}

// MARK: Compatibility Version
extension BuildSetting {

    /// Compatibility Version
    ///
    /// Determines the compatibility version of the resulting library, bundle, or framework binary. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static var compatibilityVersion: BuildSetting { 
        BuildSetting(key: .compatibilityVersion, value: "")
    }

    /// Compatibility Version
    ///
    /// Determines the compatibility version of the resulting library, bundle, or framework binary. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static func compatibilityVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .compatibilityVersion, value: "\(value)")
    }

    /// Compatibility Version
    ///
    /// Determines the compatibility version of the resulting library, bundle, or framework binary. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static func compatibilityVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compatibilityVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compatibility Version
    ///
    /// Determines the compatibility version of the resulting library, bundle, or framework binary. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static let compatibilityVersion: BuildSettingsKey = "DYLIB_COMPATIBILITY_VERSION"
}

// MARK: Current Library Version
extension BuildSetting {

    /// Current Library Version
    ///
    /// This setting defines the current version of any framework built by the project. As with [Current Project Version (CURRENT\_PROJECT\_VERSION)](itcaec37c2a6.html#devd516a860b), the value must be an integer or floating point number, such as `57` or `365.8`. By default, it is set to `$(CURRENT_PROJECT_VERSION)`. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static var currentLibraryVersion: BuildSetting { 
        BuildSetting(key: .currentLibraryVersion, value: "")
    }

    /// Current Library Version
    ///
    /// This setting defines the current version of any framework built by the project. As with [Current Project Version (CURRENT\_PROJECT\_VERSION)](itcaec37c2a6.html#devd516a860b), the value must be an integer or floating point number, such as `57` or `365.8`. By default, it is set to `$(CURRENT_PROJECT_VERSION)`. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static func currentLibraryVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .currentLibraryVersion, value: "\(value)")
    }

    /// Current Library Version
    ///
    /// This setting defines the current version of any framework built by the project. As with [Current Project Version (CURRENT\_PROJECT\_VERSION)](itcaec37c2a6.html#devd516a860b), the value must be an integer or floating point number, such as `57` or `365.8`. By default, it is set to `$(CURRENT_PROJECT_VERSION)`. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static func currentLibraryVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .currentLibraryVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Current Library Version
    ///
    /// This setting defines the current version of any framework built by the project. As with [Current Project Version (CURRENT\_PROJECT\_VERSION)](itcaec37c2a6.html#devd516a860b), the value must be an integer or floating point number, such as `57` or `365.8`. By default, it is set to `$(CURRENT_PROJECT_VERSION)`. See [Dynamic Library Design Guidelines](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW19) in [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html) for details on assigning version numbers of dynamic libraries.
    public static let currentLibraryVersion: BuildSettingsKey = "DYLIB_CURRENT_VERSION"
}

// MARK: Dynamic Library Install Name Base
extension BuildSetting {

    /// Dynamic Library Install Name Base
    ///
    /// Sets the base value for the internal `install path` (`LC_ID_DYLIB`) in a dynamic library. This will be combined with the [EXECUTABLE\_PATH](itcaec37c2a6.html#dev5a0a1bb80) to form the full install path. Setting [Dynamic Library Install Name (LD\_DYLIB\_INSTALL\_NAME)](itcaec37c2a6.html#devbb966571b) directly will override this setting. This setting defaults to the target's [Installation Directory (INSTALL\_PATH)](itcaec37c2a6.html#devabd541cd5). It is ignored when building any product other than a dynamic library.
    public static var dynamicLibraryInstallNameBase: BuildSetting { 
        BuildSetting(key: .dynamicLibraryInstallNameBase, value: "")
    }

    /// Dynamic Library Install Name Base
    ///
    /// Sets the base value for the internal `install path` (`LC_ID_DYLIB`) in a dynamic library. This will be combined with the [EXECUTABLE\_PATH](itcaec37c2a6.html#dev5a0a1bb80) to form the full install path. Setting [Dynamic Library Install Name (LD\_DYLIB\_INSTALL\_NAME)](itcaec37c2a6.html#devbb966571b) directly will override this setting. This setting defaults to the target's [Installation Directory (INSTALL\_PATH)](itcaec37c2a6.html#devabd541cd5). It is ignored when building any product other than a dynamic library.
    public static func dynamicLibraryInstallNameBase(_ value: String) -> BuildSetting { 
        BuildSetting(key: .dynamicLibraryInstallNameBase, value: "\(value)")
    }

    /// Dynamic Library Install Name Base
    ///
    /// Sets the base value for the internal `install path` (`LC_ID_DYLIB`) in a dynamic library. This will be combined with the [EXECUTABLE\_PATH](itcaec37c2a6.html#dev5a0a1bb80) to form the full install path. Setting [Dynamic Library Install Name (LD\_DYLIB\_INSTALL\_NAME)](itcaec37c2a6.html#devbb966571b) directly will override this setting. This setting defaults to the target's [Installation Directory (INSTALL\_PATH)](itcaec37c2a6.html#devabd541cd5). It is ignored when building any product other than a dynamic library.
    public static func dynamicLibraryInstallNameBase(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dynamicLibraryInstallNameBase, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dynamic Library Install Name Base
    ///
    /// Sets the base value for the internal `install path` (`LC_ID_DYLIB`) in a dynamic library. This will be combined with the [EXECUTABLE\_PATH](itcaec37c2a6.html#dev5a0a1bb80) to form the full install path. Setting [Dynamic Library Install Name (LD\_DYLIB\_INSTALL\_NAME)](itcaec37c2a6.html#devbb966571b) directly will override this setting. This setting defaults to the target's [Installation Directory (INSTALL\_PATH)](itcaec37c2a6.html#devabd541cd5). It is ignored when building any product other than a dynamic library.
    public static let dynamicLibraryInstallNameBase: BuildSettingsKey = "DYLIB_INSTALL_NAME_BASE"
}

// MARK: EMBEDDED_CONTENT_CONTAINS_SWIFT
extension BuildSetting {

    /// EMBEDDED_CONTENT_CONTAINS_SWIFT
    public static var embeddedContentContainsSwift: BuildSetting { 
        BuildSetting(key: .embeddedContentContainsSwift, value: "NO")
    }

    /// EMBEDDED_CONTENT_CONTAINS_SWIFT
    public static func embeddedContentContainsSwift(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .embeddedContentContainsSwift, value: SettingValue(booleanLiteral: value))
    }

    /// EMBEDDED_CONTENT_CONTAINS_SWIFT
    public static func embeddedContentContainsSwift(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .embeddedContentContainsSwift, inherit: key)
    }
}

extension BuildSettingsKey {

    /// EMBEDDED_CONTENT_CONTAINS_SWIFT
    public static let embeddedContentContainsSwift: BuildSettingsKey = "EMBEDDED_CONTENT_CONTAINS_SWIFT"
}

// MARK: EMBEDDED_PROFILE_NAME
extension BuildSetting {

    /// EMBEDDED_PROFILE_NAME
    public static var embeddedProfileName: BuildSetting { 
        BuildSetting(key: .embeddedProfileName, value: "")
    }

    /// EMBEDDED_PROFILE_NAME
    public static func embeddedProfileName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .embeddedProfileName, value: "\(value)")
    }

    /// EMBEDDED_PROFILE_NAME
    public static func embeddedProfileName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .embeddedProfileName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// EMBEDDED_PROFILE_NAME
    public static let embeddedProfileName: BuildSettingsKey = "EMBEDDED_PROFILE_NAME"
}

// MARK: Embed Asset Packs In Product Bundle
extension BuildSetting {

    /// Embed Asset Packs In Product Bundle
    ///
    /// Embed all the built asset packs inside the product bundle. Since this negates the performance benefits of the On Demand Resources feature, it is only useful for testing purposes when it isn't practical to use an asset pack server.
    public static var embedAssetPacksInProductBundle: BuildSetting { 
        BuildSetting(key: .embedAssetPacksInProductBundle, value: "NO")
    }

    /// Embed Asset Packs In Product Bundle
    ///
    /// Embed all the built asset packs inside the product bundle. Since this negates the performance benefits of the On Demand Resources feature, it is only useful for testing purposes when it isn't practical to use an asset pack server.
    public static func embedAssetPacksInProductBundle(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .embedAssetPacksInProductBundle, value: SettingValue(booleanLiteral: value))
    }

    /// Embed Asset Packs In Product Bundle
    ///
    /// Embed all the built asset packs inside the product bundle. Since this negates the performance benefits of the On Demand Resources feature, it is only useful for testing purposes when it isn't practical to use an asset pack server.
    public static func embedAssetPacksInProductBundle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .embedAssetPacksInProductBundle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Embed Asset Packs In Product Bundle
    ///
    /// Embed all the built asset packs inside the product bundle. Since this negates the performance benefits of the On Demand Resources feature, it is only useful for testing purposes when it isn't practical to use an asset pack server.
    public static let embedAssetPacksInProductBundle: BuildSettingsKey = "EMBED_ASSET_PACKS_IN_PRODUCT_BUNDLE"
}

// MARK: ENABLE_APPLE_KEXT_CODE_GENERATION
extension BuildSetting {

    /// ENABLE_APPLE_KEXT_CODE_GENERATION
    public static var enableAppleKextCodeGeneration: BuildSetting { 
        BuildSetting(key: .enableAppleKextCodeGeneration, value: "NO")
    }

    /// ENABLE_APPLE_KEXT_CODE_GENERATION
    public static func enableAppleKextCodeGeneration(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableAppleKextCodeGeneration, value: SettingValue(booleanLiteral: value))
    }

    /// ENABLE_APPLE_KEXT_CODE_GENERATION
    public static func enableAppleKextCodeGeneration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableAppleKextCodeGeneration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ENABLE_APPLE_KEXT_CODE_GENERATION
    public static let enableAppleKextCodeGeneration: BuildSettingsKey = "ENABLE_APPLE_KEXT_CODE_GENERATION"
}

// MARK: Enable Bitcode
extension BuildSetting {

    /// Enable Bitcode
    ///
    /// Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode.
    public static var enableBitcode: BuildSetting { 
        BuildSetting(key: .enableBitcode, value: "NO")
    }

    /// Enable Bitcode
    ///
    /// Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode.
    public static func enableBitcode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableBitcode, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Bitcode
    ///
    /// Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode.
    public static func enableBitcode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableBitcode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Bitcode
    ///
    /// Activating this setting indicates that the target or project should generate bitcode during compilation for platforms and architectures that support it. For Archive builds, bitcode will be generated in the linked binary for submission to the App Store. For other builds, the compiler and linker will check whether the code complies with the requirements for bitcode generation, but will not generate actual bitcode.
    public static let enableBitcode: BuildSettingsKey = "ENABLE_BITCODE"
}

// MARK: ENABLE_DEFAULT_HEADER_SEARCH_PATHS
extension BuildSetting {

    /// ENABLE_DEFAULT_HEADER_SEARCH_PATHS
    public static var enableDefaultHeaderSearchPaths: BuildSetting { 
        BuildSetting(key: .enableDefaultHeaderSearchPaths, value: "YES")
    }

    /// ENABLE_DEFAULT_HEADER_SEARCH_PATHS
    public static func enableDefaultHeaderSearchPaths(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableDefaultHeaderSearchPaths, value: SettingValue(booleanLiteral: value))
    }

    /// ENABLE_DEFAULT_HEADER_SEARCH_PATHS
    public static func enableDefaultHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableDefaultHeaderSearchPaths, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ENABLE_DEFAULT_HEADER_SEARCH_PATHS
    public static let enableDefaultHeaderSearchPaths: BuildSettingsKey = "ENABLE_DEFAULT_HEADER_SEARCH_PATHS"
}

// MARK: Enable Hardened Runtime
extension BuildSetting {

    /// Enable Hardened Runtime
    ///
    /// Enable hardened runtime restrictions.
    public static var enableHardenedRuntime: BuildSetting { 
        BuildSetting(key: .enableHardenedRuntime, value: "NO")
    }

    /// Enable Hardened Runtime
    ///
    /// Enable hardened runtime restrictions.
    public static func enableHardenedRuntime(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableHardenedRuntime, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Hardened Runtime
    ///
    /// Enable hardened runtime restrictions.
    public static func enableHardenedRuntime(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableHardenedRuntime, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Hardened Runtime
    ///
    /// Enable hardened runtime restrictions.
    public static let enableHardenedRuntime: BuildSettingsKey = "ENABLE_HARDENED_RUNTIME"
}

// MARK: ENABLE_HEADER_DEPENDENCIES
extension BuildSetting {

    /// ENABLE_HEADER_DEPENDENCIES
    ///
    /// Specifies whether to automatically track dependencies on included header files.
    public static var enableHeaderDependencies: BuildSetting { 
        BuildSetting(key: .enableHeaderDependencies, value: "YES")
    }

    /// ENABLE_HEADER_DEPENDENCIES
    ///
    /// Specifies whether to automatically track dependencies on included header files.
    public static func enableHeaderDependencies(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableHeaderDependencies, value: SettingValue(booleanLiteral: value))
    }

    /// ENABLE_HEADER_DEPENDENCIES
    ///
    /// Specifies whether to automatically track dependencies on included header files.
    public static func enableHeaderDependencies(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableHeaderDependencies, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ENABLE_HEADER_DEPENDENCIES
    ///
    /// Specifies whether to automatically track dependencies on included header files.
    public static let enableHeaderDependencies: BuildSettingsKey = "ENABLE_HEADER_DEPENDENCIES"
}

// MARK: Enable Incremental Distill
extension BuildSetting {

    /// Enable Incremental Distill
    ///
    /// Enabled the incremental `distill` option in the asset catalog compiler. This feature is experimental and should only be enabled with caution.
    public static var enableIncrementalDistill: BuildSetting { 
        BuildSetting(key: .enableIncrementalDistill, value: "NO")
    }

    /// Enable Incremental Distill
    ///
    /// Enabled the incremental `distill` option in the asset catalog compiler. This feature is experimental and should only be enabled with caution.
    public static func enableIncrementalDistill(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableIncrementalDistill, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Incremental Distill
    ///
    /// Enabled the incremental `distill` option in the asset catalog compiler. This feature is experimental and should only be enabled with caution.
    public static func enableIncrementalDistill(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableIncrementalDistill, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Incremental Distill
    ///
    /// Enabled the incremental `distill` option in the asset catalog compiler. This feature is experimental and should only be enabled with caution.
    public static let enableIncrementalDistill: BuildSettingsKey = "ENABLE_INCREMENTAL_DISTILL"
}

// MARK: Enable Foundation Assertions
extension BuildSetting {

    /// Enable Foundation Assertions
    ///
    /// Controls whether assertion logic provided by `NSAssert` is included in the preprocessed source code or is elided during preprocessing. Disabling assertions can improve code performance.
    public static var enableFoundationAssertions: BuildSetting { 
        BuildSetting(key: .enableFoundationAssertions, value: "YES")
    }

    /// Enable Foundation Assertions
    ///
    /// Controls whether assertion logic provided by `NSAssert` is included in the preprocessed source code or is elided during preprocessing. Disabling assertions can improve code performance.
    public static func enableFoundationAssertions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableFoundationAssertions, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Foundation Assertions
    ///
    /// Controls whether assertion logic provided by `NSAssert` is included in the preprocessed source code or is elided during preprocessing. Disabling assertions can improve code performance.
    public static func enableFoundationAssertions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableFoundationAssertions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Foundation Assertions
    ///
    /// Controls whether assertion logic provided by `NSAssert` is included in the preprocessed source code or is elided during preprocessing. Disabling assertions can improve code performance.
    public static let enableFoundationAssertions: BuildSettingsKey = "ENABLE_NS_ASSERTIONS"
}

// MARK: Build Active Resources Only
extension BuildSetting {

    /// Build Active Resources Only
    ///
    /// Omit inapplicable resources when building for a single device. For example, when building for a device with a Retina display, exclude 1x resources.
    public static var buildActiveResourcesOnly: BuildSetting { 
        BuildSetting(key: .buildActiveResourcesOnly, value: "YES")
    }

    /// Build Active Resources Only
    ///
    /// Omit inapplicable resources when building for a single device. For example, when building for a device with a Retina display, exclude 1x resources.
    public static func buildActiveResourcesOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .buildActiveResourcesOnly, value: SettingValue(booleanLiteral: value))
    }

    /// Build Active Resources Only
    ///
    /// Omit inapplicable resources when building for a single device. For example, when building for a device with a Retina display, exclude 1x resources.
    public static func buildActiveResourcesOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildActiveResourcesOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Active Resources Only
    ///
    /// Omit inapplicable resources when building for a single device. For example, when building for a device with a Retina display, exclude 1x resources.
    public static let buildActiveResourcesOnly: BuildSettingsKey = "ENABLE_ONLY_ACTIVE_RESOURCES"
}

// MARK: Enable On Demand Resources
extension BuildSetting {

    /// Enable On Demand Resources
    ///
    /// If enabled, tagged assetsfiles and asset catalog entriesare built into asset packs based on their combination of tags. Untagged resources are treated normally.
    public static var enableOnDemandResources: BuildSetting { 
        BuildSetting(key: .enableOnDemandResources, value: "NO")
    }

    /// Enable On Demand Resources
    ///
    /// If enabled, tagged assetsfiles and asset catalog entriesare built into asset packs based on their combination of tags. Untagged resources are treated normally.
    public static func enableOnDemandResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableOnDemandResources, value: SettingValue(booleanLiteral: value))
    }

    /// Enable On Demand Resources
    ///
    /// If enabled, tagged assetsfiles and asset catalog entriesare built into asset packs based on their combination of tags. Untagged resources are treated normally.
    public static func enableOnDemandResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableOnDemandResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable On Demand Resources
    ///
    /// If enabled, tagged assetsfiles and asset catalog entriesare built into asset packs based on their combination of tags. Untagged resources are treated normally.
    public static let enableOnDemandResources: BuildSettingsKey = "ENABLE_ON_DEMAND_RESOURCES"
}

// MARK: Enable Previews
extension BuildSetting {

    /// Enable Previews
    ///
    /// If enabled, the product will be built with options appropriate for supporting previews.
    public static func enablePreviews(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enablePreviews, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Previews
    ///
    /// If enabled, the product will be built with options appropriate for supporting previews.
    public static func enablePreviews(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enablePreviews, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Previews
    ///
    /// If enabled, the product will be built with options appropriate for supporting previews.
    public static let enablePreviews: BuildSettingsKey = "ENABLE_PREVIEWS"
}

// MARK: Enable Strict Checking of objc_msgSend Calls
extension BuildSetting {

    /// Enable Strict Checking of objc_msgSend Calls
    ///
    /// Controls whether `objc_msgSend` calls must be cast to the appropriate function pointer type before being called.
    public static var enableStrictCheckingOfObjcMsgsendCalls: BuildSetting { 
        BuildSetting(key: .enableStrictCheckingOfObjcMsgsendCalls, value: "NO")
    }

    /// Enable Strict Checking of objc_msgSend Calls
    ///
    /// Controls whether `objc_msgSend` calls must be cast to the appropriate function pointer type before being called.
    public static func enableStrictCheckingOfObjcMsgsendCalls(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableStrictCheckingOfObjcMsgsendCalls, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Strict Checking of objc_msgSend Calls
    ///
    /// Controls whether `objc_msgSend` calls must be cast to the appropriate function pointer type before being called.
    public static func enableStrictCheckingOfObjcMsgsendCalls(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableStrictCheckingOfObjcMsgsendCalls, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Strict Checking of objc_msgSend Calls
    ///
    /// Controls whether `objc_msgSend` calls must be cast to the appropriate function pointer type before being called.
    public static let enableStrictCheckingOfObjcMsgsendCalls: BuildSettingsKey = "ENABLE_STRICT_OBJC_MSGSEND"
}

// MARK: Enable Testability
extension BuildSetting {

    /// Enable Testability
    ///
    /// When this setting is activated, the product will be built with options appropriate for running automated tests, such as making private interfaces accessible to the tests. This may result in tests running slower than they would without testability enabled.
    public static var enableTestability: BuildSetting { 
        BuildSetting(key: .enableTestability, value: "NO")
    }

    /// Enable Testability
    ///
    /// When this setting is activated, the product will be built with options appropriate for running automated tests, such as making private interfaces accessible to the tests. This may result in tests running slower than they would without testability enabled.
    public static func enableTestability(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTestability, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Testability
    ///
    /// When this setting is activated, the product will be built with options appropriate for running automated tests, such as making private interfaces accessible to the tests. This may result in tests running slower than they would without testability enabled.
    public static func enableTestability(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTestability, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Testability
    ///
    /// When this setting is activated, the product will be built with options appropriate for running automated tests, such as making private interfaces accessible to the tests. This may result in tests running slower than they would without testability enabled.
    public static let enableTestability: BuildSettingsKey = "ENABLE_TESTABILITY"
}

// MARK: Enable Testing Search Paths
extension BuildSetting {

    /// Enable Testing Search Paths
    ///
    /// Specifies whether the build system should add the search paths necessary for compiling and linking against XCTest. This setting is enabled by default if the target is a unit test target or if the target explicitly links to the XCTest framework.
    public static var enableTestingSearchPaths: BuildSetting { 
        BuildSetting(key: .enableTestingSearchPaths, value: "NO")
    }

    /// Enable Testing Search Paths
    ///
    /// Specifies whether the build system should add the search paths necessary for compiling and linking against XCTest. This setting is enabled by default if the target is a unit test target or if the target explicitly links to the XCTest framework.
    public static func enableTestingSearchPaths(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTestingSearchPaths, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Testing Search Paths
    ///
    /// Specifies whether the build system should add the search paths necessary for compiling and linking against XCTest. This setting is enabled by default if the target is a unit test target or if the target explicitly links to the XCTest framework.
    public static func enableTestingSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTestingSearchPaths, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Testing Search Paths
    ///
    /// Specifies whether the build system should add the search paths necessary for compiling and linking against XCTest. This setting is enabled by default if the target is a unit test target or if the target explicitly links to the XCTest framework.
    public static let enableTestingSearchPaths: BuildSettingsKey = "ENABLE_TESTING_SEARCH_PATHS"
}

// MARK: Enable USDZ Compilation
extension BuildSetting {

    /// Enable USDZ Compilation
    public static var enableUsdzCompilation: BuildSetting { 
        BuildSetting(key: .enableUsdzCompilation, value: "NO")
    }

    /// Enable USDZ Compilation
    public static func enableUsdzCompilation(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableUsdzCompilation, value: SettingValue(booleanLiteral: value))
    }

    /// Enable USDZ Compilation
    public static func enableUsdzCompilation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableUsdzCompilation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable USDZ Compilation
    public static let enableUsdzCompilation: BuildSettingsKey = "ENABLE_USDZ_COMPILATION"
}

// MARK: ENTITLEMENTS_DESTINATION
extension BuildSetting {

    /// ENTITLEMENTS_DESTINATION
    public static var entitlementsDestination: BuildSetting { 
        .entitlementsDestination(.empty) 
    }

    /// ENTITLEMENTS_DESTINATION
    public static func entitlementsDestination(_ value: EntitlementsDestination) -> BuildSetting { 
        BuildSetting(key: .entitlementsDestination, value: "\(value)")
    }

    /// ENTITLEMENTS_DESTINATION
    public static func entitlementsDestination(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .entitlementsDestination, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ENTITLEMENTS_DESTINATION
    public static let entitlementsDestination: BuildSettingsKey = "ENTITLEMENTS_DESTINATION"
}

public enum EntitlementsDestination: String, Hashable, Codable, CustomStringConvertible {
    case empty = ""
    case signature = "Signature"
    case Entitlements = "__entitlements"

    public var description: String {
        rawValue
    }
}

// MARK: EXCLUDED_ARCHS
extension BuildSetting {

    /// EXCLUDED_ARCHS
    public static func excludedArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .excludedArchs, value: .array(value))
    }

    /// EXCLUDED_ARCHS
    public static func excludedArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .excludedArchs, inherit: key)
    }

    /// EXCLUDED_ARCHS
    public static func excludedArchs(_ value: String...) -> BuildSetting { 
        .excludedArchs(value)
    }
}

extension BuildSettingsKey {

    /// EXCLUDED_ARCHS
    public static let excludedArchs: BuildSettingsKey = "EXCLUDED_ARCHS"
}

// MARK: EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS
extension BuildSetting {

    /// EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS
    public static var excludedInstallsrcSubdirectoryPatterns: BuildSetting { 
        BuildSetting(key: .excludedInstallsrcSubdirectoryPatterns, value: ".DS_Store .svn .git .hg CVS")
    }

    /// EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS
    public static func excludedInstallsrcSubdirectoryPatterns(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .excludedInstallsrcSubdirectoryPatterns, value: .array(value))
    }

    /// EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS
    public static func excludedInstallsrcSubdirectoryPatterns(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .excludedInstallsrcSubdirectoryPatterns, inherit: key)
    }

    /// EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS
    public static func excludedInstallsrcSubdirectoryPatterns(_ value: String...) -> BuildSetting { 
        .excludedInstallsrcSubdirectoryPatterns(value)
    }
}

extension BuildSettingsKey {

    /// EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS
    public static let excludedInstallsrcSubdirectoryPatterns: BuildSettingsKey = "EXCLUDED_INSTALLSRC_SUBDIRECTORY_PATTERNS"
}

// MARK: Sub-Directories to Exclude in Recursive Searches
extension BuildSetting {

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static var subDirectoriesToExcludeInRecursiveSearches: BuildSetting { 
        BuildSetting(key: .subDirectoriesToExcludeInRecursiveSearches, value: "*.nib *.lproj *.framework *.gch *.xcode* *.xcassets (*) .DS_Store CVS .svn .git .hg *.pbproj *.pbxproj")
    }

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static func subDirectoriesToExcludeInRecursiveSearches(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .subDirectoriesToExcludeInRecursiveSearches, value: .array(value))
    }

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static func subDirectoriesToExcludeInRecursiveSearches(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .subDirectoriesToExcludeInRecursiveSearches, inherit: key)
    }

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static func subDirectoriesToExcludeInRecursiveSearches(_ value: String...) -> BuildSetting { 
        .subDirectoriesToExcludeInRecursiveSearches(value)
    }
}

extension BuildSettingsKey {

    /// Sub-Directories to Exclude in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to exclude when performing a recursive search. By default, this is set to `*.nib *.lproj *.framework *.gch *.xcode (*) .DS_Store CVS .svn .git .hg`. Normally, if you override this value you should include the default values via the `$(inherited)` macro.
    public static let subDirectoriesToExcludeInRecursiveSearches: BuildSettingsKey = "EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES"
}

// MARK: Excluded Source File Names
extension BuildSetting {

    /// Excluded Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _exclude_ when processing the files in the target's build phases (see also [Included Source File Names (INCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#dev278eb3050)). This setting can be used to define complex filters for which files from the phase should be built in response to other build settings; for example, a value of `*.$(CURRENT_ARCH).c` could serve to exclude particular files based on the architecture being built.
    public static var excludedSourceFileNames: BuildSetting { 
        BuildSetting(key: .excludedSourceFileNames, value: "")
    }

    /// Excluded Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _exclude_ when processing the files in the target's build phases (see also [Included Source File Names (INCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#dev278eb3050)). This setting can be used to define complex filters for which files from the phase should be built in response to other build settings; for example, a value of `*.$(CURRENT_ARCH).c` could serve to exclude particular files based on the architecture being built.
    public static func excludedSourceFileNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .excludedSourceFileNames, value: .array(value))
    }

    /// Excluded Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _exclude_ when processing the files in the target's build phases (see also [Included Source File Names (INCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#dev278eb3050)). This setting can be used to define complex filters for which files from the phase should be built in response to other build settings; for example, a value of `*.$(CURRENT_ARCH).c` could serve to exclude particular files based on the architecture being built.
    public static func excludedSourceFileNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .excludedSourceFileNames, inherit: key)
    }

    /// Excluded Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _exclude_ when processing the files in the target's build phases (see also [Included Source File Names (INCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#dev278eb3050)). This setting can be used to define complex filters for which files from the phase should be built in response to other build settings; for example, a value of `*.$(CURRENT_ARCH).c` could serve to exclude particular files based on the architecture being built.
    public static func excludedSourceFileNames(_ value: String...) -> BuildSetting { 
        .excludedSourceFileNames(value)
    }
}

extension BuildSettingsKey {

    /// Excluded Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _exclude_ when processing the files in the target's build phases (see also [Included Source File Names (INCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#dev278eb3050)). This setting can be used to define complex filters for which files from the phase should be built in response to other build settings; for example, a value of `*.$(CURRENT_ARCH).c` could serve to exclude particular files based on the architecture being built.
    public static let excludedSourceFileNames: BuildSettingsKey = "EXCLUDED_SOURCE_FILE_NAMES"
}

// MARK: EXECUTABLES_FOLDER_PATH
extension BuildSetting {

    /// EXECUTABLES_FOLDER_PATH
    ///
    /// Identifies the directory that contains additional binary files.
    public static var executablesFolderPath: BuildSetting { 
        BuildSetting(key: .executablesFolderPath, value: "")
    }

    /// EXECUTABLES_FOLDER_PATH
    ///
    /// Identifies the directory that contains additional binary files.
    public static func executablesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executablesFolderPath, value: "\(value)")
    }

    /// EXECUTABLES_FOLDER_PATH
    ///
    /// Identifies the directory that contains additional binary files.
    public static func executablesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executablesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// EXECUTABLES_FOLDER_PATH
    ///
    /// Identifies the directory that contains additional binary files.
    public static let executablesFolderPath: BuildSettingsKey = "EXECUTABLES_FOLDER_PATH"
}

// MARK: Executable Extension
extension BuildSetting {

    /// Executable Extension
    ///
    /// This is the extension used for the executable product generated by the target, which has a default value based on the product type.
    public static var executableExtension: BuildSetting { 
        BuildSetting(key: .executableExtension, value: "")
    }

    /// Executable Extension
    ///
    /// This is the extension used for the executable product generated by the target, which has a default value based on the product type.
    public static func executableExtension(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableExtension, value: "\(value)")
    }

    /// Executable Extension
    ///
    /// This is the extension used for the executable product generated by the target, which has a default value based on the product type.
    public static func executableExtension(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableExtension, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executable Extension
    ///
    /// This is the extension used for the executable product generated by the target, which has a default value based on the product type.
    public static let executableExtension: BuildSettingsKey = "EXECUTABLE_EXTENSION"
}

// MARK: EXECUTABLE_FOLDER_PATH
extension BuildSetting {

    /// EXECUTABLE_FOLDER_PATH
    ///
    /// Identifies the directory that contains the binary the target builds.
    public static var executableFolderPath: BuildSetting { 
        BuildSetting(key: .executableFolderPath, value: "")
    }

    /// EXECUTABLE_FOLDER_PATH
    ///
    /// Identifies the directory that contains the binary the target builds.
    public static func executableFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableFolderPath, value: "\(value)")
    }

    /// EXECUTABLE_FOLDER_PATH
    ///
    /// Identifies the directory that contains the binary the target builds.
    public static func executableFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// EXECUTABLE_FOLDER_PATH
    ///
    /// Identifies the directory that contains the binary the target builds.
    public static let executableFolderPath: BuildSettingsKey = "EXECUTABLE_FOLDER_PATH"
}

// MARK: EXECUTABLE_NAME
extension BuildSetting {

    /// EXECUTABLE_NAME
    ///
    /// Specifies the name of the binary the target produces.
    public static var executableName: BuildSetting { 
        BuildSetting(key: .executableName, value: "")
    }

    /// EXECUTABLE_NAME
    ///
    /// Specifies the name of the binary the target produces.
    public static func executableName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableName, value: "\(value)")
    }

    /// EXECUTABLE_NAME
    ///
    /// Specifies the name of the binary the target produces.
    public static func executableName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// EXECUTABLE_NAME
    ///
    /// Specifies the name of the binary the target produces.
    public static let executableName: BuildSettingsKey = "EXECUTABLE_NAME"
}

// MARK: EXECUTABLE_PATH
extension BuildSetting {

    /// EXECUTABLE_PATH
    ///
    /// Specifies the path to the binary the target produces within its bundle.
    public static var executablePath: BuildSetting { 
        BuildSetting(key: .executablePath, value: "")
    }

    /// EXECUTABLE_PATH
    ///
    /// Specifies the path to the binary the target produces within its bundle.
    public static func executablePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executablePath, value: "\(value)")
    }

    /// EXECUTABLE_PATH
    ///
    /// Specifies the path to the binary the target produces within its bundle.
    public static func executablePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executablePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// EXECUTABLE_PATH
    ///
    /// Specifies the path to the binary the target produces within its bundle.
    public static let executablePath: BuildSettingsKey = "EXECUTABLE_PATH"
}

// MARK: Executable Prefix
extension BuildSetting {

    /// Executable Prefix
    ///
    /// The prefix used for the executable product generated by the target, which has a default value based on the product type.
    public static var executablePrefix: BuildSetting { 
        BuildSetting(key: .executablePrefix, value: "")
    }

    /// Executable Prefix
    ///
    /// The prefix used for the executable product generated by the target, which has a default value based on the product type.
    public static func executablePrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executablePrefix, value: "\(value)")
    }

    /// Executable Prefix
    ///
    /// The prefix used for the executable product generated by the target, which has a default value based on the product type.
    public static func executablePrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executablePrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Executable Prefix
    ///
    /// The prefix used for the executable product generated by the target, which has a default value based on the product type.
    public static let executablePrefix: BuildSettingsKey = "EXECUTABLE_PREFIX"
}

// MARK: EXECUTABLE_SUFFIX
extension BuildSetting {

    /// EXECUTABLE_SUFFIX
    ///
    /// Specifies the suffix of the binary filename, including the character that separates the extension from the rest of the bundle name.
    public static var executableSuffix: BuildSetting { 
        BuildSetting(key: .executableSuffix, value: "")
    }

    /// EXECUTABLE_SUFFIX
    ///
    /// Specifies the suffix of the binary filename, including the character that separates the extension from the rest of the bundle name.
    public static func executableSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableSuffix, value: "\(value)")
    }

    /// EXECUTABLE_SUFFIX
    ///
    /// Specifies the suffix of the binary filename, including the character that separates the extension from the rest of the bundle name.
    public static func executableSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// EXECUTABLE_SUFFIX
    ///
    /// Specifies the suffix of the binary filename, including the character that separates the extension from the rest of the bundle name.
    public static let executableSuffix: BuildSettingsKey = "EXECUTABLE_SUFFIX"
}

// MARK: EXECUTABLE_VARIANT_SUFFIX
extension BuildSetting {

    /// EXECUTABLE_VARIANT_SUFFIX
    public static var executableVariantSuffix: BuildSetting { 
        BuildSetting(key: .executableVariantSuffix, value: "")
    }

    /// EXECUTABLE_VARIANT_SUFFIX
    public static func executableVariantSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .executableVariantSuffix, value: "\(value)")
    }

    /// EXECUTABLE_VARIANT_SUFFIX
    public static func executableVariantSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .executableVariantSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// EXECUTABLE_VARIANT_SUFFIX
    public static let executableVariantSuffix: BuildSettingsKey = "EXECUTABLE_VARIANT_SUFFIX"
}

// MARK: Exported Symbols File
extension BuildSetting {

    /// Exported Symbols File
    ///
    /// This is a project-relative path to a file that lists the symbols to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static var exportedSymbolsFile: BuildSetting { 
        BuildSetting(key: .exportedSymbolsFile, value: "")
    }

    /// Exported Symbols File
    ///
    /// This is a project-relative path to a file that lists the symbols to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static func exportedSymbolsFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .exportedSymbolsFile, value: "\(value)")
    }

    /// Exported Symbols File
    ///
    /// This is a project-relative path to a file that lists the symbols to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static func exportedSymbolsFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .exportedSymbolsFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Exported Symbols File
    ///
    /// This is a project-relative path to a file that lists the symbols to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static let exportedSymbolsFile: BuildSettingsKey = "EXPORTED_SYMBOLS_FILE"
}

// MARK: ExpandBuildSettings
extension BuildSetting {

    /// ExpandBuildSettings
    public static func expandbuildsettings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .expandbuildsettings, value: SettingValue(booleanLiteral: value))
    }

    /// ExpandBuildSettings
    public static func expandbuildsettings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .expandbuildsettings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ExpandBuildSettings
    public static let expandbuildsettings: BuildSettingsKey = "ExpandBuildSettings"
}

// MARK: FILE_LIST
extension BuildSetting {

    /// FILE_LIST
    public static var fileList: BuildSetting { 
        BuildSetting(key: .fileList, value: "$(OBJECT_FILE_DIR)/LinkFileList")
    }

    /// FILE_LIST
    public static func fileList(_ value: String) -> BuildSetting { 
        BuildSetting(key: .fileList, value: "\(value)")
    }

    /// FILE_LIST
    public static func fileList(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fileList, inherit: key)
    }
}

extension BuildSettingsKey {

    /// FILE_LIST
    public static let fileList: BuildSettingsKey = "FILE_LIST"
}

// MARK: FIXED_FILES_DIR
extension BuildSetting {

    /// FIXED_FILES_DIR
    public static var fixedFilesDir: BuildSetting { 
        BuildSetting(key: .fixedFilesDir, value: "$(TARGET_TEMP_DIR)/FixedFiles")
    }

    /// FIXED_FILES_DIR
    public static func fixedFilesDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .fixedFilesDir, value: "\(value)")
    }

    /// FIXED_FILES_DIR
    public static func fixedFilesDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fixedFilesDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// FIXED_FILES_DIR
    public static let fixedFilesDir: BuildSettingsKey = "FIXED_FILES_DIR"
}

// MARK: FRAMEWORKS_FOLDER_PATH
extension BuildSetting {

    /// FRAMEWORKS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products embedded frameworks.
    public static var frameworksFolderPath: BuildSetting { 
        BuildSetting(key: .frameworksFolderPath, value: "")
    }

    /// FRAMEWORKS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products embedded frameworks.
    public static func frameworksFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .frameworksFolderPath, value: "\(value)")
    }

    /// FRAMEWORKS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products embedded frameworks.
    public static func frameworksFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .frameworksFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// FRAMEWORKS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products embedded frameworks.
    public static let frameworksFolderPath: BuildSettingsKey = "FRAMEWORKS_FOLDER_PATH"
}

// MARK: Framework Search Paths
extension BuildSetting {

    /// Framework Search Paths
    ///
    /// This is a list of paths to folders containing frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. Paths are delimited by whitespace, so any paths with spaces in them must be properly quoted.
    public static var frameworkSearchPaths: BuildSetting { 
        BuildSetting(key: .frameworkSearchPaths, value: "")
    }

    /// Framework Search Paths
    ///
    /// This is a list of paths to folders containing frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. Paths are delimited by whitespace, so any paths with spaces in them must be properly quoted.
    public static func frameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .frameworkSearchPaths, value: .array(value))
    }

    /// Framework Search Paths
    ///
    /// This is a list of paths to folders containing frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. Paths are delimited by whitespace, so any paths with spaces in them must be properly quoted.
    public static func frameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .frameworkSearchPaths, inherit: key)
    }

    /// Framework Search Paths
    ///
    /// This is a list of paths to folders containing frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. Paths are delimited by whitespace, so any paths with spaces in them must be properly quoted.
    public static func frameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .frameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Framework Search Paths
    ///
    /// This is a list of paths to folders containing frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. Paths are delimited by whitespace, so any paths with spaces in them must be properly quoted.
    public static let frameworkSearchPaths: BuildSettingsKey = "FRAMEWORK_SEARCH_PATHS"
}

// MARK: Framework Version
extension BuildSetting {

    /// Framework Version
    ///
    /// Framework bundles are versioned by having contents in subfolders of a version folder that has links to the current version and its contents.
    public static var frameworkVersion: BuildSetting { 
        BuildSetting(key: .frameworkVersion, value: "A")
    }

    /// Framework Version
    ///
    /// Framework bundles are versioned by having contents in subfolders of a version folder that has links to the current version and its contents.
    public static func frameworkVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .frameworkVersion, value: "\(value)")
    }

    /// Framework Version
    ///
    /// Framework bundles are versioned by having contents in subfolders of a version folder that has links to the current version and its contents.
    public static func frameworkVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .frameworkVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Framework Version
    ///
    /// Framework bundles are versioned by having contents in subfolders of a version folder that has links to the current version and its contents.
    public static let frameworkVersion: BuildSettingsKey = "FRAMEWORK_VERSION"
}

// MARK: FULL_PRODUCT_NAME
extension BuildSetting {

    /// FULL_PRODUCT_NAME
    public static var fullProductName: BuildSetting { 
        BuildSetting(key: .fullProductName, value: "")
    }

    /// FULL_PRODUCT_NAME
    public static func fullProductName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .fullProductName, value: "\(value)")
    }

    /// FULL_PRODUCT_NAME
    public static func fullProductName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fullProductName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// FULL_PRODUCT_NAME
    public static let fullProductName: BuildSettingsKey = "FULL_PRODUCT_NAME"
}

// MARK: GCC3_VERSION
extension BuildSetting {

    /// GCC3_VERSION
    public static var gcc3Version: BuildSetting { 
        BuildSetting(key: .gcc3Version, value: "3.3")
    }

    /// GCC3_VERSION
    public static func gcc3Version(_ value: String) -> BuildSetting { 
        BuildSetting(key: .gcc3Version, value: "\(value)")
    }

    /// GCC3_VERSION
    public static func gcc3Version(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gcc3Version, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC3_VERSION
    public static let gcc3Version: BuildSettingsKey = "GCC3_VERSION"
}

// MARK: 'char' Type Is Unsigned
extension BuildSetting {

    /// 'char' Type Is Unsigned
    ///
    /// Enabling this setting causes `char` to be unsigned by default, disabling it causes `char` to be signed by default.
    public static var CharTypeIsUnsigned: BuildSetting { 
        BuildSetting(key: .CharTypeIsUnsigned, value: "NO")
    }

    /// 'char' Type Is Unsigned
    ///
    /// Enabling this setting causes `char` to be unsigned by default, disabling it causes `char` to be signed by default.
    public static func CharTypeIsUnsigned(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .CharTypeIsUnsigned, value: SettingValue(booleanLiteral: value))
    }

    /// 'char' Type Is Unsigned
    ///
    /// Enabling this setting causes `char` to be unsigned by default, disabling it causes `char` to be signed by default.
    public static func CharTypeIsUnsigned(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .CharTypeIsUnsigned, inherit: key)
    }
}

extension BuildSettingsKey {

    /// 'char' Type Is Unsigned
    ///
    /// Enabling this setting causes `char` to be unsigned by default, disabling it causes `char` to be signed by default.
    public static let CharTypeIsUnsigned: BuildSettingsKey = "GCC_CHAR_IS_UNSIGNED_CHAR"
}

// MARK: CodeWarrior/MS-Style Inline Assembly
extension BuildSetting {

    /// CodeWarrior/MS-Style Inline Assembly
    ///
    /// Enable the CodeWarrior/Microsoft syntax for inline assembly code in addition to the standard GCC syntax.
    public static var codewarriorMsStyleInlineAssembly: BuildSetting { 
        BuildSetting(key: .codewarriorMsStyleInlineAssembly, value: "YES")
    }

    /// CodeWarrior/MS-Style Inline Assembly
    ///
    /// Enable the CodeWarrior/Microsoft syntax for inline assembly code in addition to the standard GCC syntax.
    public static func codewarriorMsStyleInlineAssembly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .codewarriorMsStyleInlineAssembly, value: SettingValue(booleanLiteral: value))
    }

    /// CodeWarrior/MS-Style Inline Assembly
    ///
    /// Enable the CodeWarrior/Microsoft syntax for inline assembly code in addition to the standard GCC syntax.
    public static func codewarriorMsStyleInlineAssembly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .codewarriorMsStyleInlineAssembly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// CodeWarrior/MS-Style Inline Assembly
    ///
    /// Enable the CodeWarrior/Microsoft syntax for inline assembly code in addition to the standard GCC syntax.
    public static let codewarriorMsStyleInlineAssembly: BuildSettingsKey = "GCC_CW_ASM_SYNTAX"
}

// MARK: C Language Dialect
extension BuildSetting {

    /// C Language Dialect
    ///
    /// Choose a standard or non-standard C language dialect.

- _ANSI C:_ Accept ISO C90 and ISO C++, turning off GNU extensions that are incompatible. `-ansi` Incompatible GNU extensions include the `asm`, `inline`, and `typeof` keywords (but not the equivalent ` __asm__ `, ` __inline__ `, and ` __typeof__ ` forms), and the `//` syntax for comments. This setting also enables trigraphs.

- _C89:_ Accept ISO C90 (1990), but not GNU extensions. `-std=c89`

- _GNU89:_ Accept ISO C90 and GNU extensions. `-std=gnu89`

- _C99:_ Accept ISO C99 (1999), but not GNU extensions. `-std=c99`

- _GNU99:_ Accept ISO C99 and GNU extensions. `-std=gnu99`

- _C11:_ Accept ISO C11 (2011), but not GNU extensions. `-std=c11`

- _GNU11:_ Accept ISO C11 and GNU extensions. `-std=gnu11`

- _Compiler Default:_ Tells the compiler to use its default C language dialect. This is normally the best choice unless you have specific needs. (Currently equivalent to GNU99.)
    public static var cLanguageDialect: BuildSetting { 
        .cLanguageDialect(.compilerDefault) 
    }

    /// C Language Dialect
    ///
    /// Choose a standard or non-standard C language dialect.

- _ANSI C:_ Accept ISO C90 and ISO C++, turning off GNU extensions that are incompatible. `-ansi` Incompatible GNU extensions include the `asm`, `inline`, and `typeof` keywords (but not the equivalent ` __asm__ `, ` __inline__ `, and ` __typeof__ ` forms), and the `//` syntax for comments. This setting also enables trigraphs.

- _C89:_ Accept ISO C90 (1990), but not GNU extensions. `-std=c89`

- _GNU89:_ Accept ISO C90 and GNU extensions. `-std=gnu89`

- _C99:_ Accept ISO C99 (1999), but not GNU extensions. `-std=c99`

- _GNU99:_ Accept ISO C99 and GNU extensions. `-std=gnu99`

- _C11:_ Accept ISO C11 (2011), but not GNU extensions. `-std=c11`

- _GNU11:_ Accept ISO C11 and GNU extensions. `-std=gnu11`

- _Compiler Default:_ Tells the compiler to use its default C language dialect. This is normally the best choice unless you have specific needs. (Currently equivalent to GNU99.)
    public static func cLanguageDialect(_ value: CLanguageDialect) -> BuildSetting { 
        BuildSetting(key: .cLanguageDialect, value: "\(value)")
    }

    /// C Language Dialect
    ///
    /// Choose a standard or non-standard C language dialect.

- _ANSI C:_ Accept ISO C90 and ISO C++, turning off GNU extensions that are incompatible. `-ansi` Incompatible GNU extensions include the `asm`, `inline`, and `typeof` keywords (but not the equivalent ` __asm__ `, ` __inline__ `, and ` __typeof__ ` forms), and the `//` syntax for comments. This setting also enables trigraphs.

- _C89:_ Accept ISO C90 (1990), but not GNU extensions. `-std=c89`

- _GNU89:_ Accept ISO C90 and GNU extensions. `-std=gnu89`

- _C99:_ Accept ISO C99 (1999), but not GNU extensions. `-std=c99`

- _GNU99:_ Accept ISO C99 and GNU extensions. `-std=gnu99`

- _C11:_ Accept ISO C11 (2011), but not GNU extensions. `-std=c11`

- _GNU11:_ Accept ISO C11 and GNU extensions. `-std=gnu11`

- _Compiler Default:_ Tells the compiler to use its default C language dialect. This is normally the best choice unless you have specific needs. (Currently equivalent to GNU99.)
    public static func cLanguageDialect(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .cLanguageDialect, inherit: key)
    }
}

extension BuildSettingsKey {

    /// C Language Dialect
    ///
    /// Choose a standard or non-standard C language dialect.

- _ANSI C:_ Accept ISO C90 and ISO C++, turning off GNU extensions that are incompatible. `-ansi` Incompatible GNU extensions include the `asm`, `inline`, and `typeof` keywords (but not the equivalent ` __asm__ `, ` __inline__ `, and ` __typeof__ ` forms), and the `//` syntax for comments. This setting also enables trigraphs.

- _C89:_ Accept ISO C90 (1990), but not GNU extensions. `-std=c89`

- _GNU89:_ Accept ISO C90 and GNU extensions. `-std=gnu89`

- _C99:_ Accept ISO C99 (1999), but not GNU extensions. `-std=c99`

- _GNU99:_ Accept ISO C99 and GNU extensions. `-std=gnu99`

- _C11:_ Accept ISO C11 (2011), but not GNU extensions. `-std=c11`

- _GNU11:_ Accept ISO C11 and GNU extensions. `-std=gnu11`

- _Compiler Default:_ Tells the compiler to use its default C language dialect. This is normally the best choice unless you have specific needs. (Currently equivalent to GNU99.)
    public static let cLanguageDialect: BuildSettingsKey = "GCC_C_LANGUAGE_STANDARD"
}

public enum CLanguageDialect: String, Hashable, Codable, CustomStringConvertible {
    case ansi = "ansi"
    case c89 = "c89"
    case gnu89 = "gnu89"
    case c99 = "c99"
    case gnu99 = "gnu99"
    case c11 = "c11"
    case gnu11 = "gnu11"
    case compilerDefault = "compiler-default"

    public var description: String {
        rawValue
    }
}

// MARK: GCC_DEBUG_INFORMATION_FORMAT
extension BuildSetting {

    /// GCC_DEBUG_INFORMATION_FORMAT
    public static var gccDebugInformationFormat: BuildSetting { 
        .gccDebugInformationFormat(inherit: .debugInformationFormat) 
    }

    /// GCC_DEBUG_INFORMATION_FORMAT
    public static func gccDebugInformationFormat(_ value: GccDebugInformationFormat) -> BuildSetting { 
        BuildSetting(key: .gccDebugInformationFormat, value: "\(value)")
    }

    /// GCC_DEBUG_INFORMATION_FORMAT
    public static func gccDebugInformationFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccDebugInformationFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC_DEBUG_INFORMATION_FORMAT
    public static let gccDebugInformationFormat: BuildSettingsKey = "GCC_DEBUG_INFORMATION_FORMAT"
}

public enum GccDebugInformationFormat: String, Hashable, Codable, CustomStringConvertible {
    case dwarf = "dwarf"
    case dwarfWithDsym = "dwarf-with-dsym"

    public var description: String {
        rawValue
    }
}

// MARK: Generate Position-Dependent Code
extension BuildSetting {

    /// Generate Position-Dependent Code
    ///
    /// Faster function calls for applications. Not appropriate for shared libraries, which need to be position-independent.
    public static var generatePositionDependentCode: BuildSetting { 
        BuildSetting(key: .generatePositionDependentCode, value: "NO")
    }

    /// Generate Position-Dependent Code
    ///
    /// Faster function calls for applications. Not appropriate for shared libraries, which need to be position-independent.
    public static func generatePositionDependentCode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generatePositionDependentCode, value: SettingValue(booleanLiteral: value))
    }

    /// Generate Position-Dependent Code
    ///
    /// Faster function calls for applications. Not appropriate for shared libraries, which need to be position-independent.
    public static func generatePositionDependentCode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatePositionDependentCode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Position-Dependent Code
    ///
    /// Faster function calls for applications. Not appropriate for shared libraries, which need to be position-independent.
    public static let generatePositionDependentCode: BuildSettingsKey = "GCC_DYNAMIC_NO_PIC"
}

// MARK: Allow 'asm', 'inline', 'typeof'
extension BuildSetting {

    /// Allow 'asm', 'inline', 'typeof'
    ///
    /// Controls whether `asm`, `inline`, and `typeof` are treated as keywords or whether they can be used as identifiers.
    public static var allowAsmInlineTypeof: BuildSetting { 
        BuildSetting(key: .allowAsmInlineTypeof, value: "YES")
    }

    /// Allow 'asm', 'inline', 'typeof'
    ///
    /// Controls whether `asm`, `inline`, and `typeof` are treated as keywords or whether they can be used as identifiers.
    public static func allowAsmInlineTypeof(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .allowAsmInlineTypeof, value: SettingValue(booleanLiteral: value))
    }

    /// Allow 'asm', 'inline', 'typeof'
    ///
    /// Controls whether `asm`, `inline`, and `typeof` are treated as keywords or whether they can be used as identifiers.
    public static func allowAsmInlineTypeof(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .allowAsmInlineTypeof, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Allow 'asm', 'inline', 'typeof'
    ///
    /// Controls whether `asm`, `inline`, and `typeof` are treated as keywords or whether they can be used as identifiers.
    public static let allowAsmInlineTypeof: BuildSettingsKey = "GCC_ENABLE_ASM_KEYWORD"
}

// MARK: Recognize Builtin Functions
extension BuildSetting {

    /// Recognize Builtin Functions
    ///
    /// Controls whether builtin functions that do not begin with `__builtin_` as prefix are recognized.

GCC normally generates special code to handle certain builtin functions more efficiently; for instance, calls to `alloca` may become single instructions that adjust the stack directly, and calls to `memcpy` may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a builtin function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with `-Wformat` for bad calls to `printf`, when `printf` is built in, and `strlen` is known not to modify global memory.
    public static var recognizeBuiltinFunctions: BuildSetting { 
        BuildSetting(key: .recognizeBuiltinFunctions, value: "YES")
    }

    /// Recognize Builtin Functions
    ///
    /// Controls whether builtin functions that do not begin with `__builtin_` as prefix are recognized.

GCC normally generates special code to handle certain builtin functions more efficiently; for instance, calls to `alloca` may become single instructions that adjust the stack directly, and calls to `memcpy` may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a builtin function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with `-Wformat` for bad calls to `printf`, when `printf` is built in, and `strlen` is known not to modify global memory.
    public static func recognizeBuiltinFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .recognizeBuiltinFunctions, value: SettingValue(booleanLiteral: value))
    }

    /// Recognize Builtin Functions
    ///
    /// Controls whether builtin functions that do not begin with `__builtin_` as prefix are recognized.

GCC normally generates special code to handle certain builtin functions more efficiently; for instance, calls to `alloca` may become single instructions that adjust the stack directly, and calls to `memcpy` may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a builtin function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with `-Wformat` for bad calls to `printf`, when `printf` is built in, and `strlen` is known not to modify global memory.
    public static func recognizeBuiltinFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .recognizeBuiltinFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Recognize Builtin Functions
    ///
    /// Controls whether builtin functions that do not begin with `__builtin_` as prefix are recognized.

GCC normally generates special code to handle certain builtin functions more efficiently; for instance, calls to `alloca` may become single instructions that adjust the stack directly, and calls to `memcpy` may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a builtin function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with `-Wformat` for bad calls to `printf`, when `printf` is built in, and `strlen` is known not to modify global memory.
    public static let recognizeBuiltinFunctions: BuildSettingsKey = "GCC_ENABLE_BUILTIN_FUNCTIONS"
}

// MARK: Enable C++ Exceptions
extension BuildSetting {

    /// Enable C++ Exceptions
    ///
    /// Enable C++ exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++.
    public static var enableCppExceptions: BuildSetting { 
        BuildSetting(key: .enableCppExceptions, value: "YES")
    }

    /// Enable C++ Exceptions
    ///
    /// Enable C++ exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++.
    public static func enableCppExceptions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableCppExceptions, value: SettingValue(booleanLiteral: value))
    }

    /// Enable C++ Exceptions
    ///
    /// Enable C++ exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++.
    public static func enableCppExceptions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableCppExceptions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable C++ Exceptions
    ///
    /// Enable C++ exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++.
    public static let enableCppExceptions: BuildSettingsKey = "GCC_ENABLE_CPP_EXCEPTIONS"
}

// MARK: Enable C++ Runtime Types
extension BuildSetting {

    /// Enable C++ Runtime Types
    ///
    /// Enable generation of information about every class with virtual functions for use by the C++ runtime type identification features (`dynamic_cast` and `typeid`). If you don't use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but it will generate it as needed.
    public static var enableCppRuntimeTypes: BuildSetting { 
        BuildSetting(key: .enableCppRuntimeTypes, value: "YES")
    }

    /// Enable C++ Runtime Types
    ///
    /// Enable generation of information about every class with virtual functions for use by the C++ runtime type identification features (`dynamic_cast` and `typeid`). If you don't use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but it will generate it as needed.
    public static func enableCppRuntimeTypes(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableCppRuntimeTypes, value: SettingValue(booleanLiteral: value))
    }

    /// Enable C++ Runtime Types
    ///
    /// Enable generation of information about every class with virtual functions for use by the C++ runtime type identification features (`dynamic_cast` and `typeid`). If you don't use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but it will generate it as needed.
    public static func enableCppRuntimeTypes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableCppRuntimeTypes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable C++ Runtime Types
    ///
    /// Enable generation of information about every class with virtual functions for use by the C++ runtime type identification features (`dynamic_cast` and `typeid`). If you don't use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but it will generate it as needed.
    public static let enableCppRuntimeTypes: BuildSettingsKey = "GCC_ENABLE_CPP_RTTI"
}

// MARK: Enable Exceptions
extension BuildSetting {

    /// Enable Exceptions
    ///
    /// Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ and Objective-C that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in other languages. You may also wish to disable this option if you are compiling older programs that don't use exception handling.
    public static var enableExceptions: BuildSetting { 
        BuildSetting(key: .enableExceptions, value: "YES")
    }

    /// Enable Exceptions
    ///
    /// Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ and Objective-C that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in other languages. You may also wish to disable this option if you are compiling older programs that don't use exception handling.
    public static func enableExceptions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableExceptions, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Exceptions
    ///
    /// Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ and Objective-C that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in other languages. You may also wish to disable this option if you are compiling older programs that don't use exception handling.
    public static func enableExceptions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableExceptions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Exceptions
    ///
    /// Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC will generate frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC will enable it by default for languages like C++ and Objective-C that normally require exception handling, and disable it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in other languages. You may also wish to disable this option if you are compiling older programs that don't use exception handling.
    public static let enableExceptions: BuildSettingsKey = "GCC_ENABLE_EXCEPTIONS"
}

// MARK: Generate Floating Point Library Calls
extension BuildSetting {

    /// Generate Floating Point Library Calls
    ///
    /// Generate output containing library calls for floating point.
    public static var generateFloatingPointLibraryCalls: BuildSetting { 
        BuildSetting(key: .generateFloatingPointLibraryCalls, value: "NO")
    }

    /// Generate Floating Point Library Calls
    ///
    /// Generate output containing library calls for floating point.
    public static func generateFloatingPointLibraryCalls(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateFloatingPointLibraryCalls, value: SettingValue(booleanLiteral: value))
    }

    /// Generate Floating Point Library Calls
    ///
    /// Generate output containing library calls for floating point.
    public static func generateFloatingPointLibraryCalls(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateFloatingPointLibraryCalls, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Floating Point Library Calls
    ///
    /// Generate output containing library calls for floating point.
    public static let generateFloatingPointLibraryCalls: BuildSettingsKey = "GCC_ENABLE_FLOATING_POINT_LIBRARY_CALLS"
}

// MARK: Kernel Development Mode
extension BuildSetting {

    /// Kernel Development Mode
    ///
    /// Activating this setting enables kernel development mode.
    public static var kernelDevelopmentMode: BuildSetting { 
        BuildSetting(key: .kernelDevelopmentMode, value: "NO")
    }

    /// Kernel Development Mode
    ///
    /// Activating this setting enables kernel development mode.
    public static func kernelDevelopmentMode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .kernelDevelopmentMode, value: SettingValue(booleanLiteral: value))
    }

    /// Kernel Development Mode
    ///
    /// Activating this setting enables kernel development mode.
    public static func kernelDevelopmentMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .kernelDevelopmentMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Kernel Development Mode
    ///
    /// Activating this setting enables kernel development mode.
    public static let kernelDevelopmentMode: BuildSettingsKey = "GCC_ENABLE_KERNEL_DEVELOPMENT"
}

// MARK: Enable Objective-C Exceptions
extension BuildSetting {

    /// Enable Objective-C Exceptions
    ///
    /// This setting enables `@try`/`@catch`/`@throw` syntax for handling exceptions in Objective-C code. Only applies to Objective-C.
    public static var enableObjectiveCExceptions: BuildSetting { 
        BuildSetting(key: .enableObjectiveCExceptions, value: "YES")
    }

    /// Enable Objective-C Exceptions
    ///
    /// This setting enables `@try`/`@catch`/`@throw` syntax for handling exceptions in Objective-C code. Only applies to Objective-C.
    public static func enableObjectiveCExceptions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableObjectiveCExceptions, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Objective-C Exceptions
    ///
    /// This setting enables `@try`/`@catch`/`@throw` syntax for handling exceptions in Objective-C code. Only applies to Objective-C.
    public static func enableObjectiveCExceptions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableObjectiveCExceptions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Objective-C Exceptions
    ///
    /// This setting enables `@try`/`@catch`/`@throw` syntax for handling exceptions in Objective-C code. Only applies to Objective-C.
    public static let enableObjectiveCExceptions: BuildSettingsKey = "GCC_ENABLE_OBJC_EXCEPTIONS"
}

// MARK: Recognize Pascal Strings
extension BuildSetting {

    /// Recognize Pascal Strings
    ///
    /// Recognize and construct Pascal-style string literals. Its use in new code is discouraged.

Pascal string literals take the form `"\pstring"` . The special escape sequence `\p` denotes the Pascal length byte for the string, and will be replaced at compile time with the number of characters that follow. The `\p` may only appear at the beginning of a string literal, and may not appear in wide string literals or as an integral constant.
    public static var recognizePascalStrings: BuildSetting { 
        BuildSetting(key: .recognizePascalStrings, value: "YES")
    }

    /// Recognize Pascal Strings
    ///
    /// Recognize and construct Pascal-style string literals. Its use in new code is discouraged.

Pascal string literals take the form `"\pstring"` . The special escape sequence `\p` denotes the Pascal length byte for the string, and will be replaced at compile time with the number of characters that follow. The `\p` may only appear at the beginning of a string literal, and may not appear in wide string literals or as an integral constant.
    public static func recognizePascalStrings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .recognizePascalStrings, value: SettingValue(booleanLiteral: value))
    }

    /// Recognize Pascal Strings
    ///
    /// Recognize and construct Pascal-style string literals. Its use in new code is discouraged.

Pascal string literals take the form `"\pstring"` . The special escape sequence `\p` denotes the Pascal length byte for the string, and will be replaced at compile time with the number of characters that follow. The `\p` may only appear at the beginning of a string literal, and may not appear in wide string literals or as an integral constant.
    public static func recognizePascalStrings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .recognizePascalStrings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Recognize Pascal Strings
    ///
    /// Recognize and construct Pascal-style string literals. Its use in new code is discouraged.

Pascal string literals take the form `"\pstring"` . The special escape sequence `\p` denotes the Pascal length byte for the string, and will be replaced at compile time with the number of characters that follow. The `\p` may only appear at the beginning of a string literal, and may not appear in wide string literals or as an integral constant.
    public static let recognizePascalStrings: BuildSettingsKey = "GCC_ENABLE_PASCAL_STRINGS"
}

// MARK: Enable SSE3 Extensions
extension BuildSetting {

    /// Enable SSE3 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE3 extensions to the IA-32 architecture.
    public static var enableSse3Extensions: BuildSetting { 
        BuildSetting(key: .enableSse3Extensions, value: "NO")
    }

    /// Enable SSE3 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE3 extensions to the IA-32 architecture.
    public static func enableSse3Extensions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableSse3Extensions, value: SettingValue(booleanLiteral: value))
    }

    /// Enable SSE3 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE3 extensions to the IA-32 architecture.
    public static func enableSse3Extensions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableSse3Extensions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable SSE3 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE3 extensions to the IA-32 architecture.
    public static let enableSse3Extensions: BuildSettingsKey = "GCC_ENABLE_SSE3_EXTENSIONS"
}

// MARK: Enable SSE4.1 Extensions
extension BuildSetting {

    /// Enable SSE4.1 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE4.1 extensions to the IA-32 architecture.
    public static var enableSse41Extensions: BuildSetting { 
        BuildSetting(key: .enableSse41Extensions, value: "NO")
    }

    /// Enable SSE4.1 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE4.1 extensions to the IA-32 architecture.
    public static func enableSse41Extensions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableSse41Extensions, value: SettingValue(booleanLiteral: value))
    }

    /// Enable SSE4.1 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE4.1 extensions to the IA-32 architecture.
    public static func enableSse41Extensions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableSse41Extensions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable SSE4.1 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE4.1 extensions to the IA-32 architecture.
    public static let enableSse41Extensions: BuildSettingsKey = "GCC_ENABLE_SSE41_EXTENSIONS"
}

// MARK: Enable SSE4.2 Extensions
extension BuildSetting {

    /// Enable SSE4.2 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE4.2 extensions to the IA-32 architecture.
    public static var enableSse42Extensions: BuildSetting { 
        BuildSetting(key: .enableSse42Extensions, value: "NO")
    }

    /// Enable SSE4.2 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE4.2 extensions to the IA-32 architecture.
    public static func enableSse42Extensions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableSse42Extensions, value: SettingValue(booleanLiteral: value))
    }

    /// Enable SSE4.2 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE4.2 extensions to the IA-32 architecture.
    public static func enableSse42Extensions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableSse42Extensions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable SSE4.2 Extensions
    ///
    /// Specifies whether the binary uses the builtin functions that provide access to the SSE4.2 extensions to the IA-32 architecture.
    public static let enableSse42Extensions: BuildSettingsKey = "GCC_ENABLE_SSE42_EXTENSIONS"
}

// MARK: GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS
extension BuildSetting {

    /// GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS
    public static var gccEnableSupplementalSse3Instructions: BuildSetting { 
        BuildSetting(key: .gccEnableSupplementalSse3Instructions, value: "NO")
    }

    /// GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS
    public static func gccEnableSupplementalSse3Instructions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .gccEnableSupplementalSse3Instructions, value: SettingValue(booleanLiteral: value))
    }

    /// GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS
    public static func gccEnableSupplementalSse3Instructions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccEnableSupplementalSse3Instructions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS
    public static let gccEnableSupplementalSse3Instructions: BuildSettingsKey = "GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS"
}

// MARK: Enable Trigraphs
extension BuildSetting {

    /// Enable Trigraphs
    ///
    /// Controls whether or not trigraphs are permitted in the source code.
    public static var enableTrigraphs: BuildSetting { 
        BuildSetting(key: .enableTrigraphs, value: "NO")
    }

    /// Enable Trigraphs
    ///
    /// Controls whether or not trigraphs are permitted in the source code.
    public static func enableTrigraphs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTrigraphs, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Trigraphs
    ///
    /// Controls whether or not trigraphs are permitted in the source code.
    public static func enableTrigraphs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTrigraphs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Trigraphs
    ///
    /// Controls whether or not trigraphs are permitted in the source code.
    public static let enableTrigraphs: BuildSettingsKey = "GCC_ENABLE_TRIGRAPHS"
}

// MARK: Relax IEEE Compliance
extension BuildSetting {

    /// Relax IEEE Compliance
    ///
    /// Enables some floating point optimizations that are not IEEE754-compliant, but which usually work. Programs that require strict IEEE compliance may not work with this option.
    public static var relaxIeeeCompliance: BuildSetting { 
        BuildSetting(key: .relaxIeeeCompliance, value: "NO")
    }

    /// Relax IEEE Compliance
    ///
    /// Enables some floating point optimizations that are not IEEE754-compliant, but which usually work. Programs that require strict IEEE compliance may not work with this option.
    public static func relaxIeeeCompliance(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .relaxIeeeCompliance, value: SettingValue(booleanLiteral: value))
    }

    /// Relax IEEE Compliance
    ///
    /// Enables some floating point optimizations that are not IEEE754-compliant, but which usually work. Programs that require strict IEEE compliance may not work with this option.
    public static func relaxIeeeCompliance(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .relaxIeeeCompliance, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Relax IEEE Compliance
    ///
    /// Enables some floating point optimizations that are not IEEE754-compliant, but which usually work. Programs that require strict IEEE compliance may not work with this option.
    public static let relaxIeeeCompliance: BuildSettingsKey = "GCC_FAST_MATH"
}

// MARK: Generate Debug Symbols
extension BuildSetting {

    /// Generate Debug Symbols
    ///
    /// Enables or disables generation of debug symbols. When debug symbols are enabled, the level of detail can be controlled by the [Debug Information Format (DEBUG\_INFORMATION\_FORMAT)](itcaec37c2a6.html#dev881878d77) setting.
    public static func generateDebugSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateDebugSymbols, value: SettingValue(booleanLiteral: value))
    }

    /// Generate Debug Symbols
    ///
    /// Enables or disables generation of debug symbols. When debug symbols are enabled, the level of detail can be controlled by the [Debug Information Format (DEBUG\_INFORMATION\_FORMAT)](itcaec37c2a6.html#dev881878d77) setting.
    public static func generateDebugSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateDebugSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Debug Symbols
    ///
    /// Enables or disables generation of debug symbols. When debug symbols are enabled, the level of detail can be controlled by the [Debug Information Format (DEBUG\_INFORMATION\_FORMAT)](itcaec37c2a6.html#dev881878d77) setting.
    public static let generateDebugSymbols: BuildSettingsKey = "GCC_GENERATE_DEBUGGING_SYMBOLS"
}

// MARK: Generate Legacy Test Coverage Files
extension BuildSetting {

    /// Generate Legacy Test Coverage Files
    ///
    /// Activating this setting causes a `notes` file to be produced that the `gcov` code-coverage utility can use to show program coverage.
    public static var generateLegacyTestCoverageFiles: BuildSetting { 
        BuildSetting(key: .generateLegacyTestCoverageFiles, value: "NO")
    }

    /// Generate Legacy Test Coverage Files
    ///
    /// Activating this setting causes a `notes` file to be produced that the `gcov` code-coverage utility can use to show program coverage.
    public static func generateLegacyTestCoverageFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateLegacyTestCoverageFiles, value: SettingValue(booleanLiteral: value))
    }

    /// Generate Legacy Test Coverage Files
    ///
    /// Activating this setting causes a `notes` file to be produced that the `gcov` code-coverage utility can use to show program coverage.
    public static func generateLegacyTestCoverageFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateLegacyTestCoverageFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Legacy Test Coverage Files
    ///
    /// Activating this setting causes a `notes` file to be produced that the `gcov` code-coverage utility can use to show program coverage.
    public static let generateLegacyTestCoverageFiles: BuildSettingsKey = "GCC_GENERATE_TEST_COVERAGE_FILES"
}

// MARK: Increase Sharing of Precompiled Headers
extension BuildSetting {

    /// Increase Sharing of Precompiled Headers
    ///
    /// Enabling this option will enable increased sharing of precompiled headers among targets that share the same prefix header and precompiled header directory.

Xcode distinguishes between precompiled header (PCH) files by generating a hash value based on the command-line options to the compiler used to create the PCH. Enabling this option will exclude certain compiler options from that hash. Presently this option will exclude search path options (`-I`, `-iquote`, `-isystem`, `-F`, `-L`) from the hash.

Enabling increased sharing of PCH files carries some riskif two targets use the same prefix header but have different include paths that cause the prefix header to include different files when they are precompiled, then subtle problems may result because one target will use a PCH that was built using files included by the other target. In this case, this option must be turned off in order to enforce correctness.
    public static var increaseSharingOfPrecompiledHeaders: BuildSetting { 
        BuildSetting(key: .increaseSharingOfPrecompiledHeaders, value: "NO")
    }

    /// Increase Sharing of Precompiled Headers
    ///
    /// Enabling this option will enable increased sharing of precompiled headers among targets that share the same prefix header and precompiled header directory.

Xcode distinguishes between precompiled header (PCH) files by generating a hash value based on the command-line options to the compiler used to create the PCH. Enabling this option will exclude certain compiler options from that hash. Presently this option will exclude search path options (`-I`, `-iquote`, `-isystem`, `-F`, `-L`) from the hash.

Enabling increased sharing of PCH files carries some riskif two targets use the same prefix header but have different include paths that cause the prefix header to include different files when they are precompiled, then subtle problems may result because one target will use a PCH that was built using files included by the other target. In this case, this option must be turned off in order to enforce correctness.
    public static func increaseSharingOfPrecompiledHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .increaseSharingOfPrecompiledHeaders, value: SettingValue(booleanLiteral: value))
    }

    /// Increase Sharing of Precompiled Headers
    ///
    /// Enabling this option will enable increased sharing of precompiled headers among targets that share the same prefix header and precompiled header directory.

Xcode distinguishes between precompiled header (PCH) files by generating a hash value based on the command-line options to the compiler used to create the PCH. Enabling this option will exclude certain compiler options from that hash. Presently this option will exclude search path options (`-I`, `-iquote`, `-isystem`, `-F`, `-L`) from the hash.

Enabling increased sharing of PCH files carries some riskif two targets use the same prefix header but have different include paths that cause the prefix header to include different files when they are precompiled, then subtle problems may result because one target will use a PCH that was built using files included by the other target. In this case, this option must be turned off in order to enforce correctness.
    public static func increaseSharingOfPrecompiledHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .increaseSharingOfPrecompiledHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Increase Sharing of Precompiled Headers
    ///
    /// Enabling this option will enable increased sharing of precompiled headers among targets that share the same prefix header and precompiled header directory.

Xcode distinguishes between precompiled header (PCH) files by generating a hash value based on the command-line options to the compiler used to create the PCH. Enabling this option will exclude certain compiler options from that hash. Presently this option will exclude search path options (`-I`, `-iquote`, `-isystem`, `-F`, `-L`) from the hash.

Enabling increased sharing of PCH files carries some riskif two targets use the same prefix header but have different include paths that cause the prefix header to include different files when they are precompiled, then subtle problems may result because one target will use a PCH that was built using files included by the other target. In this case, this option must be turned off in order to enforce correctness.
    public static let increaseSharingOfPrecompiledHeaders: BuildSettingsKey = "GCC_INCREASE_PRECOMPILED_HEADER_SHARING"
}

// MARK: Inline Methods Hidden
extension BuildSetting {

    /// Inline Methods Hidden
    ///
    /// When enabled, out-of-line copies of inline methods are declared `private extern`.
    public static var inlineMethodsHidden: BuildSetting { 
        BuildSetting(key: .inlineMethodsHidden, value: "NO")
    }

    /// Inline Methods Hidden
    ///
    /// When enabled, out-of-line copies of inline methods are declared `private extern`.
    public static func inlineMethodsHidden(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inlineMethodsHidden, value: SettingValue(booleanLiteral: value))
    }

    /// Inline Methods Hidden
    ///
    /// When enabled, out-of-line copies of inline methods are declared `private extern`.
    public static func inlineMethodsHidden(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inlineMethodsHidden, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Inline Methods Hidden
    ///
    /// When enabled, out-of-line copies of inline methods are declared `private extern`.
    public static let inlineMethodsHidden: BuildSettingsKey = "GCC_INLINES_ARE_PRIVATE_EXTERN"
}

// MARK: Compile Sources As
extension BuildSetting {

    /// Compile Sources As
    ///
    /// Specifies whether to compile each source file according to its file type, or whether to treat all source files in the target as if they are of a specific language.
    public static var compileSourcesAs: BuildSetting { 
        .compileSourcesAs(.automatic) 
    }

    /// Compile Sources As
    ///
    /// Specifies whether to compile each source file according to its file type, or whether to treat all source files in the target as if they are of a specific language.
    public static func compileSourcesAs(_ value: CompileSourcesAs) -> BuildSetting { 
        BuildSetting(key: .compileSourcesAs, value: "\(value)")
    }

    /// Compile Sources As
    ///
    /// Specifies whether to compile each source file according to its file type, or whether to treat all source files in the target as if they are of a specific language.
    public static func compileSourcesAs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compileSourcesAs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compile Sources As
    ///
    /// Specifies whether to compile each source file according to its file type, or whether to treat all source files in the target as if they are of a specific language.
    public static let compileSourcesAs: BuildSettingsKey = "GCC_INPUT_FILETYPE"
}

public enum CompileSourcesAs: String, Hashable, Codable, CustomStringConvertible {
    case automatic = "automatic"
    case sourcecodeCC = "sourcecode.c.c"
    case sourcecodeCObjc = "sourcecode.c.objc"
    case sourcecodeCppCpp = "sourcecode.cpp.cpp"
    case sourcecodeCppObjcpp = "sourcecode.cpp.objcpp"

    public var description: String {
        rawValue
    }
}

// MARK: Instrument Program Flow
extension BuildSetting {

    /// Instrument Program Flow
    ///
    /// Activating this setting indicates that code should be added so program flow arcs are instrumented.
    public static var instrumentProgramFlow: BuildSetting { 
        BuildSetting(key: .instrumentProgramFlow, value: "NO")
    }

    /// Instrument Program Flow
    ///
    /// Activating this setting indicates that code should be added so program flow arcs are instrumented.
    public static func instrumentProgramFlow(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .instrumentProgramFlow, value: SettingValue(booleanLiteral: value))
    }

    /// Instrument Program Flow
    ///
    /// Activating this setting indicates that code should be added so program flow arcs are instrumented.
    public static func instrumentProgramFlow(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentProgramFlow, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Instrument Program Flow
    ///
    /// Activating this setting indicates that code should be added so program flow arcs are instrumented.
    public static let instrumentProgramFlow: BuildSettingsKey = "GCC_INSTRUMENT_PROGRAM_FLOW_ARCS"
}

// MARK: Enable Linking With Shared Libraries
extension BuildSetting {

    /// Enable Linking With Shared Libraries
    ///
    /// Enabling this option allows linking with the shared libraries. This is the default for most product types.
    public static var enableLinkingWithSharedLibraries: BuildSetting { 
        BuildSetting(key: .enableLinkingWithSharedLibraries, value: "YES")
    }

    /// Enable Linking With Shared Libraries
    ///
    /// Enabling this option allows linking with the shared libraries. This is the default for most product types.
    public static func enableLinkingWithSharedLibraries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableLinkingWithSharedLibraries, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Linking With Shared Libraries
    ///
    /// Enabling this option allows linking with the shared libraries. This is the default for most product types.
    public static func enableLinkingWithSharedLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableLinkingWithSharedLibraries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Linking With Shared Libraries
    ///
    /// Enabling this option allows linking with the shared libraries. This is the default for most product types.
    public static let enableLinkingWithSharedLibraries: BuildSettingsKey = "GCC_LINK_WITH_DYNAMIC_LIBRARIES"
}

// MARK: GCC_MACOSX_VERSION_MIN
extension BuildSetting {

    /// GCC_MACOSX_VERSION_MIN
    public static var gccMacosxVersionMin: BuildSetting { 
        BuildSetting(key: .gccMacosxVersionMin, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// GCC_MACOSX_VERSION_MIN
    public static func gccMacosxVersionMin(_ value: String) -> BuildSetting { 
        BuildSetting(key: .gccMacosxVersionMin, value: "\(value)")
    }

    /// GCC_MACOSX_VERSION_MIN
    public static func gccMacosxVersionMin(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccMacosxVersionMin, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC_MACOSX_VERSION_MIN
    public static let gccMacosxVersionMin: BuildSettingsKey = "GCC_MACOSX_VERSION_MIN"
}

// MARK: No Common Blocks
extension BuildSetting {

    /// No Common Blocks
    ///
    /// In C, allocate even uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without `extern`) in two different compilations, you will get an error when you link them.
    public static var noCommonBlocks: BuildSetting { 
        BuildSetting(key: .noCommonBlocks, value: "NO")
    }

    /// No Common Blocks
    ///
    /// In C, allocate even uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without `extern`) in two different compilations, you will get an error when you link them.
    public static func noCommonBlocks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .noCommonBlocks, value: SettingValue(booleanLiteral: value))
    }

    /// No Common Blocks
    ///
    /// In C, allocate even uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without `extern`) in two different compilations, you will get an error when you link them.
    public static func noCommonBlocks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .noCommonBlocks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// No Common Blocks
    ///
    /// In C, allocate even uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without `extern`) in two different compilations, you will get an error when you link them.
    public static let noCommonBlocks: BuildSettingsKey = "GCC_NO_COMMON_BLOCKS"
}

// MARK: GCC_OBJC_ABI_VERSION
extension BuildSetting {

    /// GCC_OBJC_ABI_VERSION
    public static var gccObjcAbiVersion: BuildSetting { 
        BuildSetting(key: .gccObjcAbiVersion, value: "$(OBJC_ABI_VERSION)")
    }

    /// GCC_OBJC_ABI_VERSION
    public static func gccObjcAbiVersion(_ value: GccObjcAbiVersion) -> BuildSetting { 
        BuildSetting(key: .gccObjcAbiVersion, value: "\(value)")
    }

    /// GCC_OBJC_ABI_VERSION
    public static func gccObjcAbiVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccObjcAbiVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC_OBJC_ABI_VERSION
    public static let gccObjcAbiVersion: BuildSettingsKey = "GCC_OBJC_ABI_VERSION"
}

public enum GccObjcAbiVersion: String, Hashable, Codable, CustomStringConvertible {
    case _1 = "1"
    case _2 = "2"

    public var description: String {
        rawValue
    }
}

// MARK: GCC_OBJC_LEGACY_DISPATCH
extension BuildSetting {

    /// GCC_OBJC_LEGACY_DISPATCH
    public static var gccObjcLegacyDispatch: BuildSetting { 
        BuildSetting(key: .gccObjcLegacyDispatch, value: "NO")
    }

    /// GCC_OBJC_LEGACY_DISPATCH
    public static func gccObjcLegacyDispatch(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .gccObjcLegacyDispatch, value: SettingValue(booleanLiteral: value))
    }

    /// GCC_OBJC_LEGACY_DISPATCH
    public static func gccObjcLegacyDispatch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccObjcLegacyDispatch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC_OBJC_LEGACY_DISPATCH
    public static let gccObjcLegacyDispatch: BuildSettingsKey = "GCC_OBJC_LEGACY_DISPATCH"
}

// MARK: GCC_OPERATION
extension BuildSetting {

    /// GCC_OPERATION
    public static var gccOperation: BuildSetting { 
        .gccOperation(.compile) 
    }

    /// GCC_OPERATION
    public static func gccOperation(_ value: GccOperation) -> BuildSetting { 
        BuildSetting(key: .gccOperation, value: "\(value)")
    }

    /// GCC_OPERATION
    public static func gccOperation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccOperation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC_OPERATION
    public static let gccOperation: BuildSettingsKey = "GCC_OPERATION"
}

public enum GccOperation: String, Hashable, Codable, CustomStringConvertible {
    case compile = "compile"
    case generatePreprocessed = "generate-preprocessed"
    case generateAssembler = "generate-assembler"
    case precompile = "precompile"
    case separateSymbols = "separate-symbols"

    public var description: String {
        rawValue
    }
}

// MARK: Optimization Level
extension BuildSetting {

    /// Optimization Level
    ///
    /// Specifies the degree to which the generated code is optimized for speed and binary size.

- _None:_ Do not optimize. `-O0` With this setting, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independentif you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you would expect from the source code.

- _Fast:_ Optimizing compilation takes somewhat more time, and a lot more memory for a large function. `-O1` With this setting, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time. In Apple's compiler, strict aliasing, block reordering, and inter-block scheduling are disabled by default when optimizing.

- _Faster:_ The compiler performs nearly all supported optimizations that do not involve a space-speed tradeoff. `-O2` With this setting, the compiler does not perform loop unrolling or function inlining, or register renaming. As compared to the `Fast` setting, this setting increases both compilation time and the performance of the generated code.

- _Fastest:_ Turns on all optimizations specified by the `Faster` setting and also turns on function inlining and register renaming options. This setting may result in a larger binary. `-O3`

- _Fastest, Smallest:_ Optimize for size. This setting enables all `Faster` optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size. `-Os`

- _Fastest, Aggressive Optimizations:_ This setting enables `Fastest` but also enables aggressive optimizations that may break strict standards compliance but should work well on well-behaved code. `-Ofast`

- _Smallest, Aggressive Size Optimizations:_ This setting enables additional size savings by isolating repetitive code patterns into a compiler generated function. `-Oz`
    public static var optimizationLevel: BuildSetting { 
        .optimizationLevel(.s) 
    }

    /// Optimization Level
    ///
    /// Specifies the degree to which the generated code is optimized for speed and binary size.

- _None:_ Do not optimize. `-O0` With this setting, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independentif you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you would expect from the source code.

- _Fast:_ Optimizing compilation takes somewhat more time, and a lot more memory for a large function. `-O1` With this setting, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time. In Apple's compiler, strict aliasing, block reordering, and inter-block scheduling are disabled by default when optimizing.

- _Faster:_ The compiler performs nearly all supported optimizations that do not involve a space-speed tradeoff. `-O2` With this setting, the compiler does not perform loop unrolling or function inlining, or register renaming. As compared to the `Fast` setting, this setting increases both compilation time and the performance of the generated code.

- _Fastest:_ Turns on all optimizations specified by the `Faster` setting and also turns on function inlining and register renaming options. This setting may result in a larger binary. `-O3`

- _Fastest, Smallest:_ Optimize for size. This setting enables all `Faster` optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size. `-Os`

- _Fastest, Aggressive Optimizations:_ This setting enables `Fastest` but also enables aggressive optimizations that may break strict standards compliance but should work well on well-behaved code. `-Ofast`

- _Smallest, Aggressive Size Optimizations:_ This setting enables additional size savings by isolating repetitive code patterns into a compiler generated function. `-Oz`
    public static func optimizationLevel(_ value: OptimizationLevel) -> BuildSetting { 
        BuildSetting(key: .optimizationLevel, value: "\(value)")
    }

    /// Optimization Level
    ///
    /// Specifies the degree to which the generated code is optimized for speed and binary size.

- _None:_ Do not optimize. `-O0` With this setting, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independentif you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you would expect from the source code.

- _Fast:_ Optimizing compilation takes somewhat more time, and a lot more memory for a large function. `-O1` With this setting, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time. In Apple's compiler, strict aliasing, block reordering, and inter-block scheduling are disabled by default when optimizing.

- _Faster:_ The compiler performs nearly all supported optimizations that do not involve a space-speed tradeoff. `-O2` With this setting, the compiler does not perform loop unrolling or function inlining, or register renaming. As compared to the `Fast` setting, this setting increases both compilation time and the performance of the generated code.

- _Fastest:_ Turns on all optimizations specified by the `Faster` setting and also turns on function inlining and register renaming options. This setting may result in a larger binary. `-O3`

- _Fastest, Smallest:_ Optimize for size. This setting enables all `Faster` optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size. `-Os`

- _Fastest, Aggressive Optimizations:_ This setting enables `Fastest` but also enables aggressive optimizations that may break strict standards compliance but should work well on well-behaved code. `-Ofast`

- _Smallest, Aggressive Size Optimizations:_ This setting enables additional size savings by isolating repetitive code patterns into a compiler generated function. `-Oz`
    public static func optimizationLevel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimizationLevel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Optimization Level
    ///
    /// Specifies the degree to which the generated code is optimized for speed and binary size.

- _None:_ Do not optimize. `-O0` With this setting, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independentif you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you would expect from the source code.

- _Fast:_ Optimizing compilation takes somewhat more time, and a lot more memory for a large function. `-O1` With this setting, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time. In Apple's compiler, strict aliasing, block reordering, and inter-block scheduling are disabled by default when optimizing.

- _Faster:_ The compiler performs nearly all supported optimizations that do not involve a space-speed tradeoff. `-O2` With this setting, the compiler does not perform loop unrolling or function inlining, or register renaming. As compared to the `Fast` setting, this setting increases both compilation time and the performance of the generated code.

- _Fastest:_ Turns on all optimizations specified by the `Faster` setting and also turns on function inlining and register renaming options. This setting may result in a larger binary. `-O3`

- _Fastest, Smallest:_ Optimize for size. This setting enables all `Faster` optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size. `-Os`

- _Fastest, Aggressive Optimizations:_ This setting enables `Fastest` but also enables aggressive optimizations that may break strict standards compliance but should work well on well-behaved code. `-Ofast`

- _Smallest, Aggressive Size Optimizations:_ This setting enables additional size savings by isolating repetitive code patterns into a compiler generated function. `-Oz`
    public static let optimizationLevel: BuildSettingsKey = "GCC_OPTIMIZATION_LEVEL"
}

public enum OptimizationLevel: String, Hashable, Codable, CustomStringConvertible {
    case _0 = "0"
    case _1 = "1"
    case _2 = "2"
    case _3 = "3"
    case s = "s"
    case fast = "fast"
    case z = "z"

    public var description: String {
        rawValue
    }
}

// MARK: GCC_PFE_FILE_C_DIALECTS
extension BuildSetting {

    /// GCC_PFE_FILE_C_DIALECTS
    public static var gccPfeFileCDialects: BuildSetting { 
        BuildSetting(key: .gccPfeFileCDialects, value: "c objective-c c++ objective-c++")
    }

    /// GCC_PFE_FILE_C_DIALECTS
    public static func gccPfeFileCDialects(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .gccPfeFileCDialects, value: .array(value))
    }

    /// GCC_PFE_FILE_C_DIALECTS
    public static func gccPfeFileCDialects(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccPfeFileCDialects, inherit: key)
    }

    /// GCC_PFE_FILE_C_DIALECTS
    public static func gccPfeFileCDialects(_ value: String...) -> BuildSetting { 
        .gccPfeFileCDialects(value)
    }
}

extension BuildSettingsKey {

    /// GCC_PFE_FILE_C_DIALECTS
    public static let gccPfeFileCDialects: BuildSettingsKey = "GCC_PFE_FILE_C_DIALECTS"
}

// MARK: Precompile Prefix Header
extension BuildSetting {

    /// Precompile Prefix Header
    ///
    /// Generates a precompiled header for the prefix header, which should reduce overall build times.

Precompiling the prefix header will be most effective if the contents of the prefix header or any file it includes change rarely. If the contents of the prefix header or any file it includes change frequently, there may be a negative impact to overall build time.
    public static var precompilePrefixHeader: BuildSetting { 
        .precompilePrefixHeader(inherit: .precompilePrefixHeader) 
    }

    /// Precompile Prefix Header
    ///
    /// Generates a precompiled header for the prefix header, which should reduce overall build times.

Precompiling the prefix header will be most effective if the contents of the prefix header or any file it includes change rarely. If the contents of the prefix header or any file it includes change frequently, there may be a negative impact to overall build time.
    public static func precompilePrefixHeader(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .precompilePrefixHeader, value: SettingValue(booleanLiteral: value))
    }

    /// Precompile Prefix Header
    ///
    /// Generates a precompiled header for the prefix header, which should reduce overall build times.

Precompiling the prefix header will be most effective if the contents of the prefix header or any file it includes change rarely. If the contents of the prefix header or any file it includes change frequently, there may be a negative impact to overall build time.
    public static func precompilePrefixHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompilePrefixHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Precompile Prefix Header
    ///
    /// Generates a precompiled header for the prefix header, which should reduce overall build times.

Precompiling the prefix header will be most effective if the contents of the prefix header or any file it includes change rarely. If the contents of the prefix header or any file it includes change frequently, there may be a negative impact to overall build time.
    public static let precompilePrefixHeader: BuildSettingsKey = "GCC_PRECOMPILE_PREFIX_HEADER"
}

// MARK: Prefix Header
extension BuildSetting {

    /// Prefix Header
    ///
    /// Implicitly include the named header. The path given should either be a project relative path or an absolute path.
    public static var prefixHeader: BuildSetting { 
        .prefixHeader(inherit: .prefixHeader) 
    }

    /// Prefix Header
    ///
    /// Implicitly include the named header. The path given should either be a project relative path or an absolute path.
    public static func prefixHeader(_ value: String) -> BuildSetting { 
        BuildSetting(key: .prefixHeader, value: "\(value)")
    }

    /// Prefix Header
    ///
    /// Implicitly include the named header. The path given should either be a project relative path or an absolute path.
    public static func prefixHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prefixHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Prefix Header
    ///
    /// Implicitly include the named header. The path given should either be a project relative path or an absolute path.
    public static let prefixHeader: BuildSettingsKey = "GCC_PREFIX_HEADER"
}

// MARK: Preprocessor Macros
extension BuildSetting {

    /// Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static var preprocessorMacros: BuildSetting { 
        BuildSetting(key: .preprocessorMacros, value: "")
    }

    /// Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func preprocessorMacros(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorMacros, value: .array(value))
    }

    /// Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func preprocessorMacros(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorMacros, inherit: key)
    }

    /// Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func preprocessorMacros(_ value: String...) -> BuildSetting { 
        .preprocessorMacros(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static let preprocessorMacros: BuildSettingsKey = "GCC_PREPROCESSOR_DEFINITIONS"
}

// MARK: Preprocessor Macros Not Used In Precompiled Headers
extension BuildSetting {

    /// Preprocessor Macros Not Used In Precompiled Headers
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are not used when precompiling a prefix header file.
    public static var preprocessorMacrosNotUsedInPrecompiledHeaders: BuildSetting { 
        BuildSetting(key: .preprocessorMacrosNotUsedInPrecompiledHeaders, value: "")
    }

    /// Preprocessor Macros Not Used In Precompiled Headers
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are not used when precompiling a prefix header file.
    public static func preprocessorMacrosNotUsedInPrecompiledHeaders(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorMacrosNotUsedInPrecompiledHeaders, value: .array(value))
    }

    /// Preprocessor Macros Not Used In Precompiled Headers
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are not used when precompiling a prefix header file.
    public static func preprocessorMacrosNotUsedInPrecompiledHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorMacrosNotUsedInPrecompiledHeaders, inherit: key)
    }

    /// Preprocessor Macros Not Used In Precompiled Headers
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are not used when precompiling a prefix header file.
    public static func preprocessorMacrosNotUsedInPrecompiledHeaders(_ value: String...) -> BuildSetting { 
        .preprocessorMacrosNotUsedInPrecompiledHeaders(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Macros Not Used In Precompiled Headers
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are not used when precompiling a prefix header file.
    public static let preprocessorMacrosNotUsedInPrecompiledHeaders: BuildSettingsKey = "GCC_PREPROCESSOR_DEFINITIONS_NOT_USED_IN_PRECOMPS"
}

// MARK: GCC_PRODUCT_TYPE_PREPROCESSOR_DEFINITIONS
extension BuildSetting {

    /// GCC_PRODUCT_TYPE_PREPROCESSOR_DEFINITIONS
    public static var gccProductTypePreprocessorDefinitions: BuildSetting { 
        BuildSetting(key: .gccProductTypePreprocessorDefinitions, value: "")
    }

    /// GCC_PRODUCT_TYPE_PREPROCESSOR_DEFINITIONS
    public static func gccProductTypePreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .gccProductTypePreprocessorDefinitions, value: .array(value))
    }

    /// GCC_PRODUCT_TYPE_PREPROCESSOR_DEFINITIONS
    public static func gccProductTypePreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccProductTypePreprocessorDefinitions, inherit: key)
    }

    /// GCC_PRODUCT_TYPE_PREPROCESSOR_DEFINITIONS
    public static func gccProductTypePreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .gccProductTypePreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// GCC_PRODUCT_TYPE_PREPROCESSOR_DEFINITIONS
    public static let gccProductTypePreprocessorDefinitions: BuildSettingsKey = "GCC_PRODUCT_TYPE_PREPROCESSOR_DEFINITIONS"
}

// MARK: Make Strings Read-Only
extension BuildSetting {

    /// Make Strings Read-Only
    ///
    /// Reuse string literals.
    public static var makeStringsReadOnly: BuildSetting { 
        BuildSetting(key: .makeStringsReadOnly, value: "YES")
    }

    /// Make Strings Read-Only
    ///
    /// Reuse string literals.
    public static func makeStringsReadOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .makeStringsReadOnly, value: SettingValue(booleanLiteral: value))
    }

    /// Make Strings Read-Only
    ///
    /// Reuse string literals.
    public static func makeStringsReadOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .makeStringsReadOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Make Strings Read-Only
    ///
    /// Reuse string literals.
    public static let makeStringsReadOnly: BuildSettingsKey = "GCC_REUSE_STRINGS"
}

// MARK: Short Enumeration Constants
extension BuildSetting {

    /// Short Enumeration Constants
    ///
    /// Make enums only as large as needed for the range of possible values.

This setting generates code that may not binary compatible with code generated without this setting or with macOS frameworks.
    public static var shortEnumerationConstants: BuildSetting { 
        BuildSetting(key: .shortEnumerationConstants, value: "NO")
    }

    /// Short Enumeration Constants
    ///
    /// Make enums only as large as needed for the range of possible values.

This setting generates code that may not binary compatible with code generated without this setting or with macOS frameworks.
    public static func shortEnumerationConstants(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .shortEnumerationConstants, value: SettingValue(booleanLiteral: value))
    }

    /// Short Enumeration Constants
    ///
    /// Make enums only as large as needed for the range of possible values.

This setting generates code that may not binary compatible with code generated without this setting or with macOS frameworks.
    public static func shortEnumerationConstants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .shortEnumerationConstants, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Short Enumeration Constants
    ///
    /// Make enums only as large as needed for the range of possible values.

This setting generates code that may not binary compatible with code generated without this setting or with macOS frameworks.
    public static let shortEnumerationConstants: BuildSettingsKey = "GCC_SHORT_ENUMS"
}

// MARK: Enforce Strict Aliasing
extension BuildSetting {

    /// Enforce Strict Aliasing
    ///
    /// Optimize code by making more aggressive assumptions about whether pointers can point to the same objects as other pointers. Programs that use pointers a lot may benefit from this, but programs that don't strictly follow the ISO C rules about the type with which an object may be accessed may behave unexpectedly.
    public static var enforceStrictAliasing: BuildSetting { 
        BuildSetting(key: .enforceStrictAliasing, value: "YES")
    }

    /// Enforce Strict Aliasing
    ///
    /// Optimize code by making more aggressive assumptions about whether pointers can point to the same objects as other pointers. Programs that use pointers a lot may benefit from this, but programs that don't strictly follow the ISO C rules about the type with which an object may be accessed may behave unexpectedly.
    public static func enforceStrictAliasing(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enforceStrictAliasing, value: SettingValue(booleanLiteral: value))
    }

    /// Enforce Strict Aliasing
    ///
    /// Optimize code by making more aggressive assumptions about whether pointers can point to the same objects as other pointers. Programs that use pointers a lot may benefit from this, but programs that don't strictly follow the ISO C rules about the type with which an object may be accessed may behave unexpectedly.
    public static func enforceStrictAliasing(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enforceStrictAliasing, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enforce Strict Aliasing
    ///
    /// Optimize code by making more aggressive assumptions about whether pointers can point to the same objects as other pointers. Programs that use pointers a lot may benefit from this, but programs that don't strictly follow the ISO C rules about the type with which an object may be accessed may behave unexpectedly.
    public static let enforceStrictAliasing: BuildSettingsKey = "GCC_STRICT_ALIASING"
}

// MARK: Symbols Hidden by Default
extension BuildSetting {

    /// Symbols Hidden by Default
    ///
    /// When enabled, all symbols are declared `private extern` unless explicitly marked to be exported using ` __attribute__ ((visibility("default")))` in code. If not enabled, all symbols are exported unless explicitly marked as `private extern`. See [Controlling Symbol Visibility](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html#//apple_ref/doc/uid/TP40001670-CJBGBHEJ) in [C++ Runtime Environment Programming Guide](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/CPPRuntimeEnv.html).
    public static var symbolsHiddenByDefault: BuildSetting { 
        BuildSetting(key: .symbolsHiddenByDefault, value: "NO")
    }

    /// Symbols Hidden by Default
    ///
    /// When enabled, all symbols are declared `private extern` unless explicitly marked to be exported using ` __attribute__ ((visibility("default")))` in code. If not enabled, all symbols are exported unless explicitly marked as `private extern`. See [Controlling Symbol Visibility](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html#//apple_ref/doc/uid/TP40001670-CJBGBHEJ) in [C++ Runtime Environment Programming Guide](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/CPPRuntimeEnv.html).
    public static func symbolsHiddenByDefault(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .symbolsHiddenByDefault, value: SettingValue(booleanLiteral: value))
    }

    /// Symbols Hidden by Default
    ///
    /// When enabled, all symbols are declared `private extern` unless explicitly marked to be exported using ` __attribute__ ((visibility("default")))` in code. If not enabled, all symbols are exported unless explicitly marked as `private extern`. See [Controlling Symbol Visibility](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html#//apple_ref/doc/uid/TP40001670-CJBGBHEJ) in [C++ Runtime Environment Programming Guide](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/CPPRuntimeEnv.html).
    public static func symbolsHiddenByDefault(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .symbolsHiddenByDefault, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Symbols Hidden by Default
    ///
    /// When enabled, all symbols are declared `private extern` unless explicitly marked to be exported using ` __attribute__ ((visibility("default")))` in code. If not enabled, all symbols are exported unless explicitly marked as `private extern`. See [Controlling Symbol Visibility](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html#//apple_ref/doc/uid/TP40001670-CJBGBHEJ) in [C++ Runtime Environment Programming Guide](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/CPPRuntimeEnv.html).
    public static let symbolsHiddenByDefault: BuildSettingsKey = "GCC_SYMBOLS_PRIVATE_EXTERN"
}

// MARK: Statics are Thread-Safe
extension BuildSetting {

    /// Statics are Thread-Safe
    ///
    /// Emits extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can disable this option to reduce code size slightly in code that doesn't need to be thread-safe.
    public static var staticsAreThreadSafe: BuildSetting { 
        BuildSetting(key: .staticsAreThreadSafe, value: "YES")
    }

    /// Statics are Thread-Safe
    ///
    /// Emits extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can disable this option to reduce code size slightly in code that doesn't need to be thread-safe.
    public static func staticsAreThreadSafe(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .staticsAreThreadSafe, value: SettingValue(booleanLiteral: value))
    }

    /// Statics are Thread-Safe
    ///
    /// Emits extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can disable this option to reduce code size slightly in code that doesn't need to be thread-safe.
    public static func staticsAreThreadSafe(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .staticsAreThreadSafe, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Statics are Thread-Safe
    ///
    /// Emits extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can disable this option to reduce code size slightly in code that doesn't need to be thread-safe.
    public static let staticsAreThreadSafe: BuildSettingsKey = "GCC_THREADSAFE_STATICS"
}

// MARK: Treat Missing Function Prototypes as Errors
extension BuildSetting {

    /// Treat Missing Function Prototypes as Errors
    ///
    /// Causes warnings about missing function prototypes to be treated as errors. Only applies to C and Objective-C.
    public static var treatMissingFunctionPrototypesAsErrors: BuildSetting { 
        BuildSetting(key: .treatMissingFunctionPrototypesAsErrors, value: "NO")
    }

    /// Treat Missing Function Prototypes as Errors
    ///
    /// Causes warnings about missing function prototypes to be treated as errors. Only applies to C and Objective-C.
    public static func treatMissingFunctionPrototypesAsErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatMissingFunctionPrototypesAsErrors, value: SettingValue(booleanLiteral: value))
    }

    /// Treat Missing Function Prototypes as Errors
    ///
    /// Causes warnings about missing function prototypes to be treated as errors. Only applies to C and Objective-C.
    public static func treatMissingFunctionPrototypesAsErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatMissingFunctionPrototypesAsErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat Missing Function Prototypes as Errors
    ///
    /// Causes warnings about missing function prototypes to be treated as errors. Only applies to C and Objective-C.
    public static let treatMissingFunctionPrototypesAsErrors: BuildSettingsKey = "GCC_TREAT_IMPLICIT_FUNCTION_DECLARATIONS_AS_ERRORS"
}

// MARK: Treat Incompatible Pointer Type Warnings as Errors
extension BuildSetting {

    /// Treat Incompatible Pointer Type Warnings as Errors
    ///
    /// Enabling this option causes warnings about incompatible pointer types to be treated as errors.
    public static var treatIncompatiblePointerTypeWarningsAsErrors: BuildSetting { 
        BuildSetting(key: .treatIncompatiblePointerTypeWarningsAsErrors, value: "NO")
    }

    /// Treat Incompatible Pointer Type Warnings as Errors
    ///
    /// Enabling this option causes warnings about incompatible pointer types to be treated as errors.
    public static func treatIncompatiblePointerTypeWarningsAsErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatIncompatiblePointerTypeWarningsAsErrors, value: SettingValue(booleanLiteral: value))
    }

    /// Treat Incompatible Pointer Type Warnings as Errors
    ///
    /// Enabling this option causes warnings about incompatible pointer types to be treated as errors.
    public static func treatIncompatiblePointerTypeWarningsAsErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatIncompatiblePointerTypeWarningsAsErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat Incompatible Pointer Type Warnings as Errors
    ///
    /// Enabling this option causes warnings about incompatible pointer types to be treated as errors.
    public static let treatIncompatiblePointerTypeWarningsAsErrors: BuildSettingsKey = "GCC_TREAT_INCOMPATIBLE_POINTER_TYPE_WARNINGS_AS_ERRORS"
}

// MARK: Treat Warnings as Errors
extension BuildSetting {

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors.
    public static var treatWarningsAsErrors: BuildSetting { 
        BuildSetting(key: .treatWarningsAsErrors, value: "NO")
    }

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors.
    public static func treatWarningsAsErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatWarningsAsErrors, value: SettingValue(booleanLiteral: value))
    }

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors.
    public static func treatWarningsAsErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatWarningsAsErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors.
    public static let treatWarningsAsErrors: BuildSettingsKey = "GCC_TREAT_WARNINGS_AS_ERRORS"
}

// MARK: Unroll Loops
extension BuildSetting {

    /// Unroll Loops
    ///
    /// Unrolls loops. Unrolling makes the code larger, but may make it faster by reducing the number of branches executed.
    public static var unrollLoops: BuildSetting { 
        BuildSetting(key: .unrollLoops, value: "NO")
    }

    /// Unroll Loops
    ///
    /// Unrolls loops. Unrolling makes the code larger, but may make it faster by reducing the number of branches executed.
    public static func unrollLoops(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unrollLoops, value: SettingValue(booleanLiteral: value))
    }

    /// Unroll Loops
    ///
    /// Unrolls loops. Unrolling makes the code larger, but may make it faster by reducing the number of branches executed.
    public static func unrollLoops(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unrollLoops, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unroll Loops
    ///
    /// Unrolls loops. Unrolling makes the code larger, but may make it faster by reducing the number of branches executed.
    public static let unrollLoops: BuildSettingsKey = "GCC_UNROLL_LOOPS"
}

// MARK: GCC_USE_GCC3_PFE_SUPPORT
extension BuildSetting {

    /// GCC_USE_GCC3_PFE_SUPPORT
    public static var gccUseGcc3PfeSupport: BuildSetting { 
        .gccUseGcc3PfeSupport(inherit: .useGcc3PfeSupport) 
    }

    /// GCC_USE_GCC3_PFE_SUPPORT
    public static func gccUseGcc3PfeSupport(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .gccUseGcc3PfeSupport, value: SettingValue(booleanLiteral: value))
    }

    /// GCC_USE_GCC3_PFE_SUPPORT
    public static func gccUseGcc3PfeSupport(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccUseGcc3PfeSupport, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC_USE_GCC3_PFE_SUPPORT
    public static let gccUseGcc3PfeSupport: BuildSettingsKey = "GCC_USE_GCC3_PFE_SUPPORT"
}

// MARK: Use Standard System Header Directory Searching
extension BuildSetting {

    /// Use Standard System Header Directory Searching
    ///
    /// Controls whether the standard system directories are searched for header files. When disabled, only the directories you have specified with `-I` options (and the directory of the current file, if appropriate) are searched.
    public static var useStandardSystemHeaderDirectorySearching: BuildSetting { 
        BuildSetting(key: .useStandardSystemHeaderDirectorySearching, value: "YES")
    }

    /// Use Standard System Header Directory Searching
    ///
    /// Controls whether the standard system directories are searched for header files. When disabled, only the directories you have specified with `-I` options (and the directory of the current file, if appropriate) are searched.
    public static func useStandardSystemHeaderDirectorySearching(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useStandardSystemHeaderDirectorySearching, value: SettingValue(booleanLiteral: value))
    }

    /// Use Standard System Header Directory Searching
    ///
    /// Controls whether the standard system directories are searched for header files. When disabled, only the directories you have specified with `-I` options (and the directory of the current file, if appropriate) are searched.
    public static func useStandardSystemHeaderDirectorySearching(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useStandardSystemHeaderDirectorySearching, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Standard System Header Directory Searching
    ///
    /// Controls whether the standard system directories are searched for header files. When disabled, only the directories you have specified with `-I` options (and the directory of the current file, if appropriate) are searched.
    public static let useStandardSystemHeaderDirectorySearching: BuildSettingsKey = "GCC_USE_STANDARD_INCLUDE_SEARCHING"
}

// MARK: Compiler for C/C++/Objective-C
extension BuildSetting {

    /// Compiler for C/C++/Objective-C
    ///
    /// The compiler to use for C, C++, and Objective-C.
    public static var compilerForCCppObjectiveC: BuildSetting { 
        BuildSetting(key: .compilerForCCppObjectiveC, value: "")
    }

    /// Compiler for C/C++/Objective-C
    ///
    /// The compiler to use for C, C++, and Objective-C.
    public static func compilerForCCppObjectiveC(_ value: CompilerVersion) -> BuildSetting { 
        BuildSetting(key: .compilerForCCppObjectiveC, value: "\(value)")
    }

    /// Compiler for C/C++/Objective-C
    ///
    /// The compiler to use for C, C++, and Objective-C.
    public static func compilerForCCppObjectiveC(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compilerForCCppObjectiveC, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compiler for C/C++/Objective-C
    ///
    /// The compiler to use for C, C++, and Objective-C.
    public static let compilerForCCppObjectiveC: BuildSettingsKey = "GCC_VERSION"
}

// MARK: GCC_VERSION_IDENTIFIER
extension BuildSetting {

    /// GCC_VERSION_IDENTIFIER
    public static var gccVersionIdentifier: BuildSetting { 
        BuildSetting(key: .gccVersionIdentifier, value: "$(GCC_VERSION:identifier)")
    }

    /// GCC_VERSION_IDENTIFIER
    public static func gccVersionIdentifier(_ value: String) -> BuildSetting { 
        BuildSetting(key: .gccVersionIdentifier, value: "\(value)")
    }

    /// GCC_VERSION_IDENTIFIER
    public static func gccVersionIdentifier(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccVersionIdentifier, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC_VERSION_IDENTIFIER
    public static let gccVersionIdentifier: BuildSettingsKey = "GCC_VERSION_IDENTIFIER"
}

// MARK: Implicit Conversion to 32 Bit Type
extension BuildSetting {

    /// Implicit Conversion to 32 Bit Type
    ///
    /// Warn if a value is implicitly converted from a 64-bit type to a 32-bit type. This is a subset of the warnings provided by -Wconversion.
    public static var implicitConversionTo32BitType: BuildSetting { 
        .implicitConversionTo32BitType(.no) 
    }

    /// Implicit Conversion to 32 Bit Type
    ///
    /// Warn if a value is implicitly converted from a 64-bit type to a 32-bit type. This is a subset of the warnings provided by -Wconversion.
    public static func implicitConversionTo32BitType(_ value: ImplicitConversionTo32BitType) -> BuildSetting { 
        BuildSetting(key: .implicitConversionTo32BitType, value: "\(value)")
    }

    /// Implicit Conversion to 32 Bit Type
    ///
    /// Warn if a value is implicitly converted from a 64-bit type to a 32-bit type. This is a subset of the warnings provided by -Wconversion.
    public static func implicitConversionTo32BitType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .implicitConversionTo32BitType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Implicit Conversion to 32 Bit Type
    ///
    /// Warn if a value is implicitly converted from a 64-bit type to a 32-bit type. This is a subset of the warnings provided by -Wconversion.
    public static let implicitConversionTo32BitType: BuildSettingsKey = "GCC_WARN_64_TO_32_BIT_CONVERSION"
}

public enum ImplicitConversionTo32BitType: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesError = "YES_ERROR"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension ImplicitConversionTo32BitType: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Deprecated Functions
extension BuildSetting {

    /// Deprecated Functions
    @available(*, deprecated, message: "Warn about the use of deprecated functions, variables, and types (as indicated by the `deprecated` attribute).")
    public static var deprecatedFunctions: BuildSetting { 
        BuildSetting(key: .deprecatedFunctions, value: "YES")
    }

    /// Deprecated Functions
    @available(*, deprecated, message: "Warn about the use of deprecated functions, variables, and types (as indicated by the `deprecated` attribute).")
    public static func deprecatedFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .deprecatedFunctions, value: SettingValue(booleanLiteral: value))
    }

    /// Deprecated Functions
    @available(*, deprecated, message: "Warn about the use of deprecated functions, variables, and types (as indicated by the `deprecated` attribute).")
    public static func deprecatedFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .deprecatedFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Deprecated Functions
    @available(*, deprecated, message: "Warn about the use of deprecated functions, variables, and types (as indicated by the `deprecated` attribute).")
    public static let deprecatedFunctions: BuildSettingsKey = "GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS"
}

// MARK: Undefined Use of offsetof Macro
extension BuildSetting {

    /// Undefined Use of offsetof Macro
    ///
    /// Unchecking this setting will suppress warnings from applying the `offsetof` macro to a non-POD type. According to the 1998 ISO C++ standard, applying `offsetof` to a non-POD type is undefined. In existing C++ implementations, however, `offsetof` typically gives meaningful results even when applied to certain kinds of non-POD types, such as a simple struct that fails to be a POD type only by virtue of having a constructor. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it.

The restrictions on `offsetof` may be relaxed in a future version of the C++ standard.
    public static var undefinedUseOfOffsetofMacro: BuildSetting { 
        BuildSetting(key: .undefinedUseOfOffsetofMacro, value: "YES")
    }

    /// Undefined Use of offsetof Macro
    ///
    /// Unchecking this setting will suppress warnings from applying the `offsetof` macro to a non-POD type. According to the 1998 ISO C++ standard, applying `offsetof` to a non-POD type is undefined. In existing C++ implementations, however, `offsetof` typically gives meaningful results even when applied to certain kinds of non-POD types, such as a simple struct that fails to be a POD type only by virtue of having a constructor. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it.

The restrictions on `offsetof` may be relaxed in a future version of the C++ standard.
    public static func undefinedUseOfOffsetofMacro(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .undefinedUseOfOffsetofMacro, value: SettingValue(booleanLiteral: value))
    }

    /// Undefined Use of offsetof Macro
    ///
    /// Unchecking this setting will suppress warnings from applying the `offsetof` macro to a non-POD type. According to the 1998 ISO C++ standard, applying `offsetof` to a non-POD type is undefined. In existing C++ implementations, however, `offsetof` typically gives meaningful results even when applied to certain kinds of non-POD types, such as a simple struct that fails to be a POD type only by virtue of having a constructor. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it.

The restrictions on `offsetof` may be relaxed in a future version of the C++ standard.
    public static func undefinedUseOfOffsetofMacro(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .undefinedUseOfOffsetofMacro, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Undefined Use of offsetof Macro
    ///
    /// Unchecking this setting will suppress warnings from applying the `offsetof` macro to a non-POD type. According to the 1998 ISO C++ standard, applying `offsetof` to a non-POD type is undefined. In existing C++ implementations, however, `offsetof` typically gives meaningful results even when applied to certain kinds of non-POD types, such as a simple struct that fails to be a POD type only by virtue of having a constructor. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it.

The restrictions on `offsetof` may be relaxed in a future version of the C++ standard.
    public static let undefinedUseOfOffsetofMacro: BuildSettingsKey = "GCC_WARN_ABOUT_INVALID_OFFSETOF_MACRO"
}

// MARK: Missing Fields in Structure Initializers
extension BuildSetting {

    /// Missing Fields in Structure Initializers
    ///
    /// Warn if a structure's initializer has some fields missing. For example, the following code would cause such a warning because `x.h` is implicitly zero:

`struct s { int f, g, h; };``struct s x = { 3, 4 };`

This option does not warn about designated initializers, so the following modification would not trigger a warning:

`struct s { int f, g, h; };``struct s x = { .f = 3, .g = 4 };`
    public static var missingFieldsInStructureInitializers: BuildSetting { 
        BuildSetting(key: .missingFieldsInStructureInitializers, value: "NO")
    }

    /// Missing Fields in Structure Initializers
    ///
    /// Warn if a structure's initializer has some fields missing. For example, the following code would cause such a warning because `x.h` is implicitly zero:

`struct s { int f, g, h; };``struct s x = { 3, 4 };`

This option does not warn about designated initializers, so the following modification would not trigger a warning:

`struct s { int f, g, h; };``struct s x = { .f = 3, .g = 4 };`
    public static func missingFieldsInStructureInitializers(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingFieldsInStructureInitializers, value: SettingValue(booleanLiteral: value))
    }

    /// Missing Fields in Structure Initializers
    ///
    /// Warn if a structure's initializer has some fields missing. For example, the following code would cause such a warning because `x.h` is implicitly zero:

`struct s { int f, g, h; };``struct s x = { 3, 4 };`

This option does not warn about designated initializers, so the following modification would not trigger a warning:

`struct s { int f, g, h; };``struct s x = { .f = 3, .g = 4 };`
    public static func missingFieldsInStructureInitializers(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingFieldsInStructureInitializers, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Fields in Structure Initializers
    ///
    /// Warn if a structure's initializer has some fields missing. For example, the following code would cause such a warning because `x.h` is implicitly zero:

`struct s { int f, g, h; };``struct s x = { 3, 4 };`

This option does not warn about designated initializers, so the following modification would not trigger a warning:

`struct s { int f, g, h; };``struct s x = { .f = 3, .g = 4 };`
    public static let missingFieldsInStructureInitializers: BuildSettingsKey = "GCC_WARN_ABOUT_MISSING_FIELD_INITIALIZERS"
}

// MARK: Missing Newline At End Of File
extension BuildSetting {

    /// Missing Newline At End Of File
    ///
    /// Warn when a source file does not end with a newline.
    public static var missingNewlineAtEndOfFile: BuildSetting { 
        BuildSetting(key: .missingNewlineAtEndOfFile, value: "NO")
    }

    /// Missing Newline At End Of File
    ///
    /// Warn when a source file does not end with a newline.
    public static func missingNewlineAtEndOfFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingNewlineAtEndOfFile, value: SettingValue(booleanLiteral: value))
    }

    /// Missing Newline At End Of File
    ///
    /// Warn when a source file does not end with a newline.
    public static func missingNewlineAtEndOfFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingNewlineAtEndOfFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Newline At End Of File
    ///
    /// Warn when a source file does not end with a newline.
    public static let missingNewlineAtEndOfFile: BuildSettingsKey = "GCC_WARN_ABOUT_MISSING_NEWLINE"
}

// MARK: Missing Function Prototypes
extension BuildSetting {

    /// Missing Function Prototypes
    ///
    /// Causes warnings to be emitted about missing prototypes.
    public static var missingFunctionPrototypes: BuildSetting { 
        BuildSetting(key: .missingFunctionPrototypes, value: "NO")
    }

    /// Missing Function Prototypes
    ///
    /// Causes warnings to be emitted about missing prototypes.
    public static func missingFunctionPrototypes(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingFunctionPrototypes, value: SettingValue(booleanLiteral: value))
    }

    /// Missing Function Prototypes
    ///
    /// Causes warnings to be emitted about missing prototypes.
    public static func missingFunctionPrototypes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingFunctionPrototypes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Function Prototypes
    ///
    /// Causes warnings to be emitted about missing prototypes.
    public static let missingFunctionPrototypes: BuildSettingsKey = "GCC_WARN_ABOUT_MISSING_PROTOTYPES"
}

// MARK: Pointer Sign Comparison
extension BuildSetting {

    /// Pointer Sign Comparison
    ///
    /// Warn when pointers passed via arguments or assigned to a variable differ in sign.
    public static var pointerSignComparison: BuildSetting { 
        BuildSetting(key: .pointerSignComparison, value: "YES")
    }

    /// Pointer Sign Comparison
    ///
    /// Warn when pointers passed via arguments or assigned to a variable differ in sign.
    public static func pointerSignComparison(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pointerSignComparison, value: SettingValue(booleanLiteral: value))
    }

    /// Pointer Sign Comparison
    ///
    /// Warn when pointers passed via arguments or assigned to a variable differ in sign.
    public static func pointerSignComparison(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pointerSignComparison, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pointer Sign Comparison
    ///
    /// Warn when pointers passed via arguments or assigned to a variable differ in sign.
    public static let pointerSignComparison: BuildSettingsKey = "GCC_WARN_ABOUT_POINTER_SIGNEDNESS"
}

// MARK: Mismatched Return Type
extension BuildSetting {

    /// Mismatched Return Type
    ///
    /// Causes warnings to be emitted when a function with a defined return type (not `void`) contains a return statement without a return-value or when it does not contain any return statements. Also emits a warning when a function with a void return type tries to return a value.
    public static var mismatchedReturnType: BuildSetting { 
        .mismatchedReturnType(.no) 
    }

    /// Mismatched Return Type
    ///
    /// Causes warnings to be emitted when a function with a defined return type (not `void`) contains a return statement without a return-value or when it does not contain any return statements. Also emits a warning when a function with a void return type tries to return a value.
    public static func mismatchedReturnType(_ value: MismatchedReturnType) -> BuildSetting { 
        BuildSetting(key: .mismatchedReturnType, value: "\(value)")
    }

    /// Mismatched Return Type
    ///
    /// Causes warnings to be emitted when a function with a defined return type (not `void`) contains a return statement without a return-value or when it does not contain any return statements. Also emits a warning when a function with a void return type tries to return a value.
    public static func mismatchedReturnType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mismatchedReturnType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mismatched Return Type
    ///
    /// Causes warnings to be emitted when a function with a defined return type (not `void`) contains a return statement without a return-value or when it does not contain any return statements. Also emits a warning when a function with a void return type tries to return a value.
    public static let mismatchedReturnType: BuildSettingsKey = "GCC_WARN_ABOUT_RETURN_TYPE"
}

public enum MismatchedReturnType: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}


extension MismatchedReturnType: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Incomplete Objective-C Protocols
extension BuildSetting {

    /// Incomplete Objective-C Protocols
    ///
    /// Warn if methods required by a protocol are not implemented in the class adopting it. Only applies to Objective-C.
    public static var incompleteObjectiveCProtocols: BuildSetting { 
        BuildSetting(key: .incompleteObjectiveCProtocols, value: "YES")
    }

    /// Incomplete Objective-C Protocols
    ///
    /// Warn if methods required by a protocol are not implemented in the class adopting it. Only applies to Objective-C.
    public static func incompleteObjectiveCProtocols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .incompleteObjectiveCProtocols, value: SettingValue(booleanLiteral: value))
    }

    /// Incomplete Objective-C Protocols
    ///
    /// Warn if methods required by a protocol are not implemented in the class adopting it. Only applies to Objective-C.
    public static func incompleteObjectiveCProtocols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .incompleteObjectiveCProtocols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Incomplete Objective-C Protocols
    ///
    /// Warn if methods required by a protocol are not implemented in the class adopting it. Only applies to Objective-C.
    public static let incompleteObjectiveCProtocols: BuildSettingsKey = "GCC_WARN_ALLOW_INCOMPLETE_PROTOCOL"
}

// MARK: Check Switch Statements
extension BuildSetting {

    /// Check Switch Statements
    ///
    /// Warn whenever a switch statement has an index of enumeral type and lacks a case for one or more of the named codes of that enumeration. The presence of a default label prevents this warning. Case labels outside the enumeration range also provoke warnings when this option is used.
    public static var checkSwitchStatements: BuildSetting { 
        BuildSetting(key: .checkSwitchStatements, value: "YES")
    }

    /// Check Switch Statements
    ///
    /// Warn whenever a switch statement has an index of enumeral type and lacks a case for one or more of the named codes of that enumeration. The presence of a default label prevents this warning. Case labels outside the enumeration range also provoke warnings when this option is used.
    public static func checkSwitchStatements(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .checkSwitchStatements, value: SettingValue(booleanLiteral: value))
    }

    /// Check Switch Statements
    ///
    /// Warn whenever a switch statement has an index of enumeral type and lacks a case for one or more of the named codes of that enumeration. The presence of a default label prevents this warning. Case labels outside the enumeration range also provoke warnings when this option is used.
    public static func checkSwitchStatements(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .checkSwitchStatements, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Check Switch Statements
    ///
    /// Warn whenever a switch statement has an index of enumeral type and lacks a case for one or more of the named codes of that enumeration. The presence of a default label prevents this warning. Case labels outside the enumeration range also provoke warnings when this option is used.
    public static let checkSwitchStatements: BuildSettingsKey = "GCC_WARN_CHECK_SWITCH_STATEMENTS"
}

// MARK: Four Character Literals
extension BuildSetting {

    /// Four Character Literals
    ///
    /// Warn about four-char literals (for example, macOS-style `OSTypes`: `'APPL'`).
    public static var fourCharacterLiterals: BuildSetting { 
        BuildSetting(key: .fourCharacterLiterals, value: "NO")
    }

    /// Four Character Literals
    ///
    /// Warn about four-char literals (for example, macOS-style `OSTypes`: `'APPL'`).
    public static func fourCharacterLiterals(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .fourCharacterLiterals, value: SettingValue(booleanLiteral: value))
    }

    /// Four Character Literals
    ///
    /// Warn about four-char literals (for example, macOS-style `OSTypes`: `'APPL'`).
    public static func fourCharacterLiterals(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fourCharacterLiterals, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Four Character Literals
    ///
    /// Warn about four-char literals (for example, macOS-style `OSTypes`: `'APPL'`).
    public static let fourCharacterLiterals: BuildSettingsKey = "GCC_WARN_FOUR_CHARACTER_CONSTANTS"
}

// MARK: Overloaded Virtual Functions
extension BuildSetting {

    /// Overloaded Virtual Functions
    ///
    /// Warn when a function declaration hides virtual functions from a base class.

For example, in the following example, the `A` class version of `f()` is hidden in `B`.

`struct A {`` virtual void f();``};``struct B: public A {`` void f(int);``};`

As a result, the following code will fail to compile.

`B* b;``b-&gt;f();`

This setting only applies to C++ and Objective-C++ sources.
    public static var overloadedVirtualFunctions: BuildSetting { 
        BuildSetting(key: .overloadedVirtualFunctions, value: "NO")
    }

    /// Overloaded Virtual Functions
    ///
    /// Warn when a function declaration hides virtual functions from a base class.

For example, in the following example, the `A` class version of `f()` is hidden in `B`.

`struct A {`` virtual void f();``};``struct B: public A {`` void f(int);``};`

As a result, the following code will fail to compile.

`B* b;``b-&gt;f();`

This setting only applies to C++ and Objective-C++ sources.
    public static func overloadedVirtualFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .overloadedVirtualFunctions, value: SettingValue(booleanLiteral: value))
    }

    /// Overloaded Virtual Functions
    ///
    /// Warn when a function declaration hides virtual functions from a base class.

For example, in the following example, the `A` class version of `f()` is hidden in `B`.

`struct A {`` virtual void f();``};``struct B: public A {`` void f(int);``};`

As a result, the following code will fail to compile.

`B* b;``b-&gt;f();`

This setting only applies to C++ and Objective-C++ sources.
    public static func overloadedVirtualFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .overloadedVirtualFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Overloaded Virtual Functions
    ///
    /// Warn when a function declaration hides virtual functions from a base class.

For example, in the following example, the `A` class version of `f()` is hidden in `B`.

`struct A {`` virtual void f();``};``struct B: public A {`` void f(int);``};`

As a result, the following code will fail to compile.

`B* b;``b-&gt;f();`

This setting only applies to C++ and Objective-C++ sources.
    public static let overloadedVirtualFunctions: BuildSettingsKey = "GCC_WARN_HIDDEN_VIRTUAL_FUNCTIONS"
}

// MARK: Inhibit All Warnings
extension BuildSetting {

    /// Inhibit All Warnings
    ///
    /// Inhibit all warning messages.
    public static var inhibitAllWarnings: BuildSetting { 
        BuildSetting(key: .inhibitAllWarnings, value: "NO")
    }

    /// Inhibit All Warnings
    ///
    /// Inhibit all warning messages.
    public static func inhibitAllWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .inhibitAllWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Inhibit All Warnings
    ///
    /// Inhibit all warning messages.
    public static func inhibitAllWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .inhibitAllWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Inhibit All Warnings
    ///
    /// Inhibit all warning messages.
    public static let inhibitAllWarnings: BuildSettingsKey = "GCC_WARN_INHIBIT_ALL_WARNINGS"
}

// MARK: Initializer Not Fully Bracketed
extension BuildSetting {

    /// Initializer Not Fully Bracketed
    ///
    /// Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for `a` is not fully bracketed, but the initializer for `b` is fully bracketed.

`int a`2``2` = { 0, 1, 2, 3 };``int b`2``2` = { { 0, 1 }, { 2, 3 } };`
    public static var initializerNotFullyBracketed: BuildSetting { 
        BuildSetting(key: .initializerNotFullyBracketed, value: "NO")
    }

    /// Initializer Not Fully Bracketed
    ///
    /// Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for `a` is not fully bracketed, but the initializer for `b` is fully bracketed.

`int a`2``2` = { 0, 1, 2, 3 };``int b`2``2` = { { 0, 1 }, { 2, 3 } };`
    public static func initializerNotFullyBracketed(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .initializerNotFullyBracketed, value: SettingValue(booleanLiteral: value))
    }

    /// Initializer Not Fully Bracketed
    ///
    /// Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for `a` is not fully bracketed, but the initializer for `b` is fully bracketed.

`int a`2``2` = { 0, 1, 2, 3 };``int b`2``2` = { { 0, 1 }, { 2, 3 } };`
    public static func initializerNotFullyBracketed(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .initializerNotFullyBracketed, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Initializer Not Fully Bracketed
    ///
    /// Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for `a` is not fully bracketed, but the initializer for `b` is fully bracketed.

`int a`2``2` = { 0, 1, 2, 3 };``int b`2``2` = { { 0, 1 }, { 2, 3 } };`
    public static let initializerNotFullyBracketed: BuildSettingsKey = "GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED"
}

// MARK: Missing Braces and Parentheses
extension BuildSetting {

    /// Missing Braces and Parentheses
    ///
    /// Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence causes confusion. Also, warn about constructions where there may be confusion as to which `if` statement an `else` branch belongs. For example:

`{`` if (a)`` if (b)`` foo ();`` else`` bar ();``}`

In C, every `else` branch belongs to the innermost possible `if` statement, which in the example above is `if (b)`. This is often not what the programmer expects, as illustrated by indentation used in the example above. This build setting causes GCC to issue a warning when there is the potential for this confusion. To eliminate the warning, add explicit braces around the innermost `if` statement so there is no way the `else` could belong to the enclosing `if`. For example:

`{`` if (a)`` {`` if (b)`` foo ();`` else`` bar ();`` }``}`
    public static var missingBracesAndParentheses: BuildSetting { 
        BuildSetting(key: .missingBracesAndParentheses, value: "YES")
    }

    /// Missing Braces and Parentheses
    ///
    /// Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence causes confusion. Also, warn about constructions where there may be confusion as to which `if` statement an `else` branch belongs. For example:

`{`` if (a)`` if (b)`` foo ();`` else`` bar ();``}`

In C, every `else` branch belongs to the innermost possible `if` statement, which in the example above is `if (b)`. This is often not what the programmer expects, as illustrated by indentation used in the example above. This build setting causes GCC to issue a warning when there is the potential for this confusion. To eliminate the warning, add explicit braces around the innermost `if` statement so there is no way the `else` could belong to the enclosing `if`. For example:

`{`` if (a)`` {`` if (b)`` foo ();`` else`` bar ();`` }``}`
    public static func missingBracesAndParentheses(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .missingBracesAndParentheses, value: SettingValue(booleanLiteral: value))
    }

    /// Missing Braces and Parentheses
    ///
    /// Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence causes confusion. Also, warn about constructions where there may be confusion as to which `if` statement an `else` branch belongs. For example:

`{`` if (a)`` if (b)`` foo ();`` else`` bar ();``}`

In C, every `else` branch belongs to the innermost possible `if` statement, which in the example above is `if (b)`. This is often not what the programmer expects, as illustrated by indentation used in the example above. This build setting causes GCC to issue a warning when there is the potential for this confusion. To eliminate the warning, add explicit braces around the innermost `if` statement so there is no way the `else` could belong to the enclosing `if`. For example:

`{`` if (a)`` {`` if (b)`` foo ();`` else`` bar ();`` }``}`
    public static func missingBracesAndParentheses(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .missingBracesAndParentheses, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Missing Braces and Parentheses
    ///
    /// Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence causes confusion. Also, warn about constructions where there may be confusion as to which `if` statement an `else` branch belongs. For example:

`{`` if (a)`` if (b)`` foo ();`` else`` bar ();``}`

In C, every `else` branch belongs to the innermost possible `if` statement, which in the example above is `if (b)`. This is often not what the programmer expects, as illustrated by indentation used in the example above. This build setting causes GCC to issue a warning when there is the potential for this confusion. To eliminate the warning, add explicit braces around the innermost `if` statement so there is no way the `else` could belong to the enclosing `if`. For example:

`{`` if (a)`` {`` if (b)`` foo ();`` else`` bar ();`` }``}`
    public static let missingBracesAndParentheses: BuildSettingsKey = "GCC_WARN_MISSING_PARENTHESES"
}

// MARK: GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR
extension BuildSetting {

    /// GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR
    public static var gccWarnMultipleDefinitionTypesForSelector: BuildSetting { 
        BuildSetting(key: .gccWarnMultipleDefinitionTypesForSelector, value: "NO")
    }

    /// GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR
    public static func gccWarnMultipleDefinitionTypesForSelector(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .gccWarnMultipleDefinitionTypesForSelector, value: SettingValue(booleanLiteral: value))
    }

    /// GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR
    public static func gccWarnMultipleDefinitionTypesForSelector(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .gccWarnMultipleDefinitionTypesForSelector, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR
    public static let gccWarnMultipleDefinitionTypesForSelector: BuildSettingsKey = "GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR"
}

// MARK: Nonvirtual Destructor
extension BuildSetting {

    /// Nonvirtual Destructor
    ///
    /// Warn when a class declares an nonvirtual destructor that should probably be virtual, because it looks like the class will be used polymorphically. This is only active for C++ or Objective-C++ sources.
    public static var nonvirtualDestructor: BuildSetting { 
        BuildSetting(key: .nonvirtualDestructor, value: "NO")
    }

    /// Nonvirtual Destructor
    ///
    /// Warn when a class declares an nonvirtual destructor that should probably be virtual, because it looks like the class will be used polymorphically. This is only active for C++ or Objective-C++ sources.
    public static func nonvirtualDestructor(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .nonvirtualDestructor, value: SettingValue(booleanLiteral: value))
    }

    /// Nonvirtual Destructor
    ///
    /// Warn when a class declares an nonvirtual destructor that should probably be virtual, because it looks like the class will be used polymorphically. This is only active for C++ or Objective-C++ sources.
    public static func nonvirtualDestructor(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nonvirtualDestructor, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Nonvirtual Destructor
    ///
    /// Warn when a class declares an nonvirtual destructor that should probably be virtual, because it looks like the class will be used polymorphically. This is only active for C++ or Objective-C++ sources.
    public static let nonvirtualDestructor: BuildSettingsKey = "GCC_WARN_NON_VIRTUAL_DESTRUCTOR"
}

// MARK: Pedantic Warnings
extension BuildSetting {

    /// Pedantic Warnings
    ///
    /// Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any `-std` option used.
    public static var pedanticWarnings: BuildSetting { 
        BuildSetting(key: .pedanticWarnings, value: "NO")
    }

    /// Pedantic Warnings
    ///
    /// Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any `-std` option used.
    public static func pedanticWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pedanticWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Pedantic Warnings
    ///
    /// Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any `-std` option used.
    public static func pedanticWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pedanticWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Pedantic Warnings
    ///
    /// Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any `-std` option used.
    public static let pedanticWarnings: BuildSettingsKey = "GCC_WARN_PEDANTIC"
}

// MARK: Hidden Local Variables
extension BuildSetting {

    /// Hidden Local Variables
    ///
    /// Warn whenever a local variable shadows another local variable, parameter or global variable or whenever a builtin function is shadowed.
    public static var hiddenLocalVariables: BuildSetting { 
        BuildSetting(key: .hiddenLocalVariables, value: "NO")
    }

    /// Hidden Local Variables
    ///
    /// Warn whenever a local variable shadows another local variable, parameter or global variable or whenever a builtin function is shadowed.
    public static func hiddenLocalVariables(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .hiddenLocalVariables, value: SettingValue(booleanLiteral: value))
    }

    /// Hidden Local Variables
    ///
    /// Warn whenever a local variable shadows another local variable, parameter or global variable or whenever a builtin function is shadowed.
    public static func hiddenLocalVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .hiddenLocalVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Hidden Local Variables
    ///
    /// Warn whenever a local variable shadows another local variable, parameter or global variable or whenever a builtin function is shadowed.
    public static let hiddenLocalVariables: BuildSettingsKey = "GCC_WARN_SHADOW"
}

// MARK: Sign Comparison
extension BuildSetting {

    /// Sign Comparison
    ///
    /// Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
    public static var signComparison: BuildSetting { 
        BuildSetting(key: .signComparison, value: "NO")
    }

    /// Sign Comparison
    ///
    /// Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
    public static func signComparison(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .signComparison, value: SettingValue(booleanLiteral: value))
    }

    /// Sign Comparison
    ///
    /// Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
    public static func signComparison(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .signComparison, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Sign Comparison
    ///
    /// Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
    public static let signComparison: BuildSettingsKey = "GCC_WARN_SIGN_COMPARE"
}

// MARK: Strict Selector Matching
extension BuildSetting {

    /// Strict Selector Matching
    ///
    /// Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type `id` or `Class`. When this setting is disabled, the compiler will omit such warnings if any differences found are confined to types that share the same size and alignment.
    public static var strictSelectorMatching: BuildSetting { 
        BuildSetting(key: .strictSelectorMatching, value: "NO")
    }

    /// Strict Selector Matching
    ///
    /// Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type `id` or `Class`. When this setting is disabled, the compiler will omit such warnings if any differences found are confined to types that share the same size and alignment.
    public static func strictSelectorMatching(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .strictSelectorMatching, value: SettingValue(booleanLiteral: value))
    }

    /// Strict Selector Matching
    ///
    /// Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type `id` or `Class`. When this setting is disabled, the compiler will omit such warnings if any differences found are confined to types that share the same size and alignment.
    public static func strictSelectorMatching(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .strictSelectorMatching, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strict Selector Matching
    ///
    /// Warn if multiple methods with differing argument and/or return types are found for a given selector when attempting to send a message using this selector to a receiver of type `id` or `Class`. When this setting is disabled, the compiler will omit such warnings if any differences found are confined to types that share the same size and alignment.
    public static let strictSelectorMatching: BuildSettingsKey = "GCC_WARN_STRICT_SELECTOR_MATCH"
}

// MARK: Typecheck Calls to printf/scanf
extension BuildSetting {

    /// Typecheck Calls to printf/scanf
    ///
    /// Check calls to `printf` and `scanf` to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.
    public static var typecheckCallsToPrintfScanf: BuildSetting { 
        BuildSetting(key: .typecheckCallsToPrintfScanf, value: "YES")
    }

    /// Typecheck Calls to printf/scanf
    ///
    /// Check calls to `printf` and `scanf` to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.
    public static func typecheckCallsToPrintfScanf(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .typecheckCallsToPrintfScanf, value: SettingValue(booleanLiteral: value))
    }

    /// Typecheck Calls to printf/scanf
    ///
    /// Check calls to `printf` and `scanf` to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.
    public static func typecheckCallsToPrintfScanf(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .typecheckCallsToPrintfScanf, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Typecheck Calls to printf/scanf
    ///
    /// Check calls to `printf` and `scanf` to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense.
    public static let typecheckCallsToPrintfScanf: BuildSettingsKey = "GCC_WARN_TYPECHECK_CALLS_TO_PRINTF"
}

// MARK: Undeclared Selector
extension BuildSetting {

    /// Undeclared Selector
    ///
    /// Warn if a `@selector(...)` expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the `@selector(...)` expression, either explicitly in an `@interface` or `@protocol` declaration, or implicitly in an `@implementation` section. This option always performs its checks as soon as a `@selector(...)` expression is found, while `-Wselector` only performs its checks in the final stage of compilation. This also enforces the coding style convention that methods and selectors must be declared before being used.
    public static var undeclaredSelector: BuildSetting { 
        BuildSetting(key: .undeclaredSelector, value: "NO")
    }

    /// Undeclared Selector
    ///
    /// Warn if a `@selector(...)` expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the `@selector(...)` expression, either explicitly in an `@interface` or `@protocol` declaration, or implicitly in an `@implementation` section. This option always performs its checks as soon as a `@selector(...)` expression is found, while `-Wselector` only performs its checks in the final stage of compilation. This also enforces the coding style convention that methods and selectors must be declared before being used.
    public static func undeclaredSelector(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .undeclaredSelector, value: SettingValue(booleanLiteral: value))
    }

    /// Undeclared Selector
    ///
    /// Warn if a `@selector(...)` expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the `@selector(...)` expression, either explicitly in an `@interface` or `@protocol` declaration, or implicitly in an `@implementation` section. This option always performs its checks as soon as a `@selector(...)` expression is found, while `-Wselector` only performs its checks in the final stage of compilation. This also enforces the coding style convention that methods and selectors must be declared before being used.
    public static func undeclaredSelector(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .undeclaredSelector, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Undeclared Selector
    ///
    /// Warn if a `@selector(...)` expression referring to an undeclared selector is found. A selector is considered undeclared if no method with that name has been declared before the `@selector(...)` expression, either explicitly in an `@interface` or `@protocol` declaration, or implicitly in an `@implementation` section. This option always performs its checks as soon as a `@selector(...)` expression is found, while `-Wselector` only performs its checks in the final stage of compilation. This also enforces the coding style convention that methods and selectors must be declared before being used.
    public static let undeclaredSelector: BuildSettingsKey = "GCC_WARN_UNDECLARED_SELECTOR"
}

// MARK: Uninitialized Variables
extension BuildSetting {

    /// Uninitialized Variables
    ///
    /// Warn if a variable might be clobbered by a `setjmp` call or if an automatic variable is used without prior initialization.

The compiler may not detect all cases where an automatic variable is initialized or all usage patterns that may lead to use prior to initialization. You can toggle between the normal uninitialized value checking or the more aggressive (conservative) checking, which finds more issues but the checking is much stricter.
    public static var uninitializedVariables: BuildSetting { 
        .uninitializedVariables(.no) 
    }

    /// Uninitialized Variables
    ///
    /// Warn if a variable might be clobbered by a `setjmp` call or if an automatic variable is used without prior initialization.

The compiler may not detect all cases where an automatic variable is initialized or all usage patterns that may lead to use prior to initialization. You can toggle between the normal uninitialized value checking or the more aggressive (conservative) checking, which finds more issues but the checking is much stricter.
    public static func uninitializedVariables(_ value: UninitializedVariables) -> BuildSetting { 
        BuildSetting(key: .uninitializedVariables, value: "\(value)")
    }

    /// Uninitialized Variables
    ///
    /// Warn if a variable might be clobbered by a `setjmp` call or if an automatic variable is used without prior initialization.

The compiler may not detect all cases where an automatic variable is initialized or all usage patterns that may lead to use prior to initialization. You can toggle between the normal uninitialized value checking or the more aggressive (conservative) checking, which finds more issues but the checking is much stricter.
    public static func uninitializedVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .uninitializedVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Uninitialized Variables
    ///
    /// Warn if a variable might be clobbered by a `setjmp` call or if an automatic variable is used without prior initialization.

The compiler may not detect all cases where an automatic variable is initialized or all usage patterns that may lead to use prior to initialization. You can toggle between the normal uninitialized value checking or the more aggressive (conservative) checking, which finds more issues but the checking is much stricter.
    public static let uninitializedVariables: BuildSettingsKey = "GCC_WARN_UNINITIALIZED_AUTOS"
}

public enum UninitializedVariables: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesAggressive = "YES_AGGRESSIVE"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension UninitializedVariables: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Unknown Pragma
extension BuildSetting {

    /// Unknown Pragma
    ///
    /// Warn when a `#pragma` directive is encountered that is not understood by GCC. If this command line option is used, warnings will even be issued for unknown pragmas in system header files. This is not the case if the warnings were only enabled by the `-Wall` command-line option.
    public static var unknownPragma: BuildSetting { 
        BuildSetting(key: .unknownPragma, value: "NO")
    }

    /// Unknown Pragma
    ///
    /// Warn when a `#pragma` directive is encountered that is not understood by GCC. If this command line option is used, warnings will even be issued for unknown pragmas in system header files. This is not the case if the warnings were only enabled by the `-Wall` command-line option.
    public static func unknownPragma(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unknownPragma, value: SettingValue(booleanLiteral: value))
    }

    /// Unknown Pragma
    ///
    /// Warn when a `#pragma` directive is encountered that is not understood by GCC. If this command line option is used, warnings will even be issued for unknown pragmas in system header files. This is not the case if the warnings were only enabled by the `-Wall` command-line option.
    public static func unknownPragma(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unknownPragma, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unknown Pragma
    ///
    /// Warn when a `#pragma` directive is encountered that is not understood by GCC. If this command line option is used, warnings will even be issued for unknown pragmas in system header files. This is not the case if the warnings were only enabled by the `-Wall` command-line option.
    public static let unknownPragma: BuildSettingsKey = "GCC_WARN_UNKNOWN_PRAGMAS"
}

// MARK: Unused Functions
extension BuildSetting {

    /// Unused Functions
    ///
    /// Warn whenever a static function is declared but not defined or a noninline static function is unused.
    public static var unusedFunctions: BuildSetting { 
        BuildSetting(key: .unusedFunctions, value: "NO")
    }

    /// Unused Functions
    ///
    /// Warn whenever a static function is declared but not defined or a noninline static function is unused.
    public static func unusedFunctions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedFunctions, value: SettingValue(booleanLiteral: value))
    }

    /// Unused Functions
    ///
    /// Warn whenever a static function is declared but not defined or a noninline static function is unused.
    public static func unusedFunctions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedFunctions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Functions
    ///
    /// Warn whenever a static function is declared but not defined or a noninline static function is unused.
    public static let unusedFunctions: BuildSettingsKey = "GCC_WARN_UNUSED_FUNCTION"
}

// MARK: Unused Labels
extension BuildSetting {

    /// Unused Labels
    ///
    /// Warn whenever a label is declared but not used.
    public static var unusedLabels: BuildSetting { 
        BuildSetting(key: .unusedLabels, value: "NO")
    }

    /// Unused Labels
    ///
    /// Warn whenever a label is declared but not used.
    public static func unusedLabels(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedLabels, value: SettingValue(booleanLiteral: value))
    }

    /// Unused Labels
    ///
    /// Warn whenever a label is declared but not used.
    public static func unusedLabels(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedLabels, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Labels
    ///
    /// Warn whenever a label is declared but not used.
    public static let unusedLabels: BuildSettingsKey = "GCC_WARN_UNUSED_LABEL"
}

// MARK: Unused Parameters
extension BuildSetting {

    /// Unused Parameters
    ///
    /// Warn whenever a function parameter is unused aside from its declaration.
    public static var unusedParameters: BuildSetting { 
        BuildSetting(key: .unusedParameters, value: "NO")
    }

    /// Unused Parameters
    ///
    /// Warn whenever a function parameter is unused aside from its declaration.
    public static func unusedParameters(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedParameters, value: SettingValue(booleanLiteral: value))
    }

    /// Unused Parameters
    ///
    /// Warn whenever a function parameter is unused aside from its declaration.
    public static func unusedParameters(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedParameters, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Parameters
    ///
    /// Warn whenever a function parameter is unused aside from its declaration.
    public static let unusedParameters: BuildSettingsKey = "GCC_WARN_UNUSED_PARAMETER"
}

// MARK: Unused Values
extension BuildSetting {

    /// Unused Values
    ///
    /// Warn whenever a statement computes a result that is explicitly not used.
    public static var unusedValues: BuildSetting { 
        BuildSetting(key: .unusedValues, value: "YES")
    }

    /// Unused Values
    ///
    /// Warn whenever a statement computes a result that is explicitly not used.
    public static func unusedValues(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedValues, value: SettingValue(booleanLiteral: value))
    }

    /// Unused Values
    ///
    /// Warn whenever a statement computes a result that is explicitly not used.
    public static func unusedValues(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedValues, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Values
    ///
    /// Warn whenever a statement computes a result that is explicitly not used.
    public static let unusedValues: BuildSettingsKey = "GCC_WARN_UNUSED_VALUE"
}

// MARK: Unused Variables
extension BuildSetting {

    /// Unused Variables
    ///
    /// Warn whenever a local variable or nonconstant static variable is unused aside from its declaration.
    public static var unusedVariables: BuildSetting { 
        BuildSetting(key: .unusedVariables, value: "NO")
    }

    /// Unused Variables
    ///
    /// Warn whenever a local variable or nonconstant static variable is unused aside from its declaration.
    public static func unusedVariables(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unusedVariables, value: SettingValue(booleanLiteral: value))
    }

    /// Unused Variables
    ///
    /// Warn whenever a local variable or nonconstant static variable is unused aside from its declaration.
    public static func unusedVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unusedVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unused Variables
    ///
    /// Warn whenever a local variable or nonconstant static variable is unused aside from its declaration.
    public static let unusedVariables: BuildSettingsKey = "GCC_WARN_UNUSED_VARIABLE"
}

// MARK: GENERATED_MODULEMAP_DIR
extension BuildSetting {

    /// GENERATED_MODULEMAP_DIR
    public static var generatedModulemapDir: BuildSetting { 
        BuildSetting(key: .generatedModulemapDir, value: "$(OBJROOT)/GeneratedModuleMaps$(EFFECTIVE_PLATFORM_NAME)")
    }

    /// GENERATED_MODULEMAP_DIR
    public static func generatedModulemapDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .generatedModulemapDir, value: "\(value)")
    }

    /// GENERATED_MODULEMAP_DIR
    public static func generatedModulemapDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatedModulemapDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GENERATED_MODULEMAP_DIR
    public static let generatedModulemapDir: BuildSettingsKey = "GENERATED_MODULEMAP_DIR"
}

// MARK: Perform Single-Object Prelink
extension BuildSetting {

    /// Perform Single-Object Prelink
    ///
    /// Activating this setting will cause the object files built by a target to be prelinked using `ld -r` into a single object file, and that object file will then be linked into the final product. This is useful to force the linker to resolve symbols and link the object files into a single module before building a static library. Also, a separate set of link flags can be applied to the prelink allowing additional control over, for instance, exported symbols.
    public static var performSingleObjectPrelink: BuildSetting { 
        BuildSetting(key: .performSingleObjectPrelink, value: "NO")
    }

    /// Perform Single-Object Prelink
    ///
    /// Activating this setting will cause the object files built by a target to be prelinked using `ld -r` into a single object file, and that object file will then be linked into the final product. This is useful to force the linker to resolve symbols and link the object files into a single module before building a static library. Also, a separate set of link flags can be applied to the prelink allowing additional control over, for instance, exported symbols.
    public static func performSingleObjectPrelink(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .performSingleObjectPrelink, value: SettingValue(booleanLiteral: value))
    }

    /// Perform Single-Object Prelink
    ///
    /// Activating this setting will cause the object files built by a target to be prelinked using `ld -r` into a single object file, and that object file will then be linked into the final product. This is useful to force the linker to resolve symbols and link the object files into a single module before building a static library. Also, a separate set of link flags can be applied to the prelink allowing additional control over, for instance, exported symbols.
    public static func performSingleObjectPrelink(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .performSingleObjectPrelink, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Perform Single-Object Prelink
    ///
    /// Activating this setting will cause the object files built by a target to be prelinked using `ld -r` into a single object file, and that object file will then be linked into the final product. This is useful to force the linker to resolve symbols and link the object files into a single module before building a static library. Also, a separate set of link flags can be applied to the prelink allowing additional control over, for instance, exported symbols.
    public static let performSingleObjectPrelink: BuildSettingsKey = "GENERATE_MASTER_OBJECT_FILE"
}

// MARK: Force Package Info Generation
extension BuildSetting {

    /// Force Package Info Generation
    ///
    /// Forces the `PkgInfo` file to be written to wrapped products even if this file is not expected.
    public static var forcePackageInfoGeneration: BuildSetting { 
        BuildSetting(key: .forcePackageInfoGeneration, value: "NO")
    }

    /// Force Package Info Generation
    ///
    /// Forces the `PkgInfo` file to be written to wrapped products even if this file is not expected.
    public static func forcePackageInfoGeneration(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .forcePackageInfoGeneration, value: SettingValue(booleanLiteral: value))
    }

    /// Force Package Info Generation
    ///
    /// Forces the `PkgInfo` file to be written to wrapped products even if this file is not expected.
    public static func forcePackageInfoGeneration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .forcePackageInfoGeneration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Force Package Info Generation
    ///
    /// Forces the `PkgInfo` file to be written to wrapped products even if this file is not expected.
    public static let forcePackageInfoGeneration: BuildSettingsKey = "GENERATE_PKGINFO_FILE"
}

// MARK: Generate Profiling Code
extension BuildSetting {

    /// Generate Profiling Code
    ///
    /// Activating this setting will cause the compiler and linker to generate profiling code. For example, GCC will generate code suitable for use with `gprof(1)`.
    public static var generateProfilingCode: BuildSetting { 
        BuildSetting(key: .generateProfilingCode, value: "NO")
    }

    /// Generate Profiling Code
    ///
    /// Activating this setting will cause the compiler and linker to generate profiling code. For example, GCC will generate code suitable for use with `gprof(1)`.
    public static func generateProfilingCode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateProfilingCode, value: SettingValue(booleanLiteral: value))
    }

    /// Generate Profiling Code
    ///
    /// Activating this setting will cause the compiler and linker to generate profiling code. For example, GCC will generate code suitable for use with `gprof(1)`.
    public static func generateProfilingCode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateProfilingCode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Profiling Code
    ///
    /// Activating this setting will cause the compiler and linker to generate profiling code. For example, GCC will generate code suitable for use with `gprof(1)`.
    public static let generateProfilingCode: BuildSettingsKey = "GENERATE_PROFILING_CODE"
}

// MARK: Enable Text-Based Stubs Generation
extension BuildSetting {

    /// Enable Text-Based Stubs Generation
    ///
    /// Enables the generation of Text-Based stubs for dynamic libraries and frameworks.
    public static var enableTextBasedStubsGeneration: BuildSetting { 
        BuildSetting(key: .enableTextBasedStubsGeneration, value: "NO")
    }

    /// Enable Text-Based Stubs Generation
    ///
    /// Enables the generation of Text-Based stubs for dynamic libraries and frameworks.
    public static func enableTextBasedStubsGeneration(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTextBasedStubsGeneration, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Text-Based Stubs Generation
    ///
    /// Enables the generation of Text-Based stubs for dynamic libraries and frameworks.
    public static func enableTextBasedStubsGeneration(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTextBasedStubsGeneration, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Text-Based Stubs Generation
    ///
    /// Enables the generation of Text-Based stubs for dynamic libraries and frameworks.
    public static let enableTextBasedStubsGeneration: BuildSettingsKey = "GENERATE_TEXT_BASED_STUBS"
}

// MARK: GLOBAL_CFLAGS
extension BuildSetting {

    /// GLOBAL_CFLAGS
    public static var globalCflags: BuildSetting { 
        BuildSetting(key: .globalCflags, value: "")
    }

    /// GLOBAL_CFLAGS
    public static func globalCflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .globalCflags, value: .array(value))
    }

    /// GLOBAL_CFLAGS
    public static func globalCflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .globalCflags, inherit: key)
    }

    /// GLOBAL_CFLAGS
    public static func globalCflags(_ value: String...) -> BuildSetting { 
        .globalCflags(value)
    }
}

extension BuildSettingsKey {

    /// GLOBAL_CFLAGS
    public static let globalCflags: BuildSettingsKey = "GLOBAL_CFLAGS"
}

// MARK: GeneratedPkgInfoFile
extension BuildSetting {

    /// GeneratedPkgInfoFile
    public static func generatedpkginfofile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .generatedpkginfofile, value: "\(value)")
    }

    /// GeneratedPkgInfoFile
    public static func generatedpkginfofile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatedpkginfofile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// GeneratedPkgInfoFile
    public static let generatedpkginfofile: BuildSettingsKey = "GeneratedPkgInfoFile"
}

// MARK: HEADERMAP_FILE_FORMAT
extension BuildSetting {

    /// HEADERMAP_FILE_FORMAT
    public static var headermapFileFormat: BuildSetting { 
        .headermapFileFormat(.traditional) 
    }

    /// HEADERMAP_FILE_FORMAT
    public static func headermapFileFormat(_ value: HeadermapFileFormat) -> BuildSetting { 
        BuildSetting(key: .headermapFileFormat, value: "\(value)")
    }

    /// HEADERMAP_FILE_FORMAT
    public static func headermapFileFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapFileFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// HEADERMAP_FILE_FORMAT
    public static let headermapFileFormat: BuildSettingsKey = "HEADERMAP_FILE_FORMAT"
}

public enum HeadermapFileFormat: String, Hashable, Codable, CustomStringConvertible {
    case traditional = "traditional"

    public var description: String {
        rawValue
    }
}

// MARK: HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT
extension BuildSetting {

    /// HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the target being built.
    public static var headermapIncludesFlatEntriesForTargetBeingBuilt: BuildSetting { 
        BuildSetting(key: .headermapIncludesFlatEntriesForTargetBeingBuilt, value: "YES")
    }

    /// HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the target being built.
    public static func headermapIncludesFlatEntriesForTargetBeingBuilt(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapIncludesFlatEntriesForTargetBeingBuilt, value: SettingValue(booleanLiteral: value))
    }

    /// HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the target being built.
    public static func headermapIncludesFlatEntriesForTargetBeingBuilt(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapIncludesFlatEntriesForTargetBeingBuilt, inherit: key)
    }
}

extension BuildSettingsKey {

    /// HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the target being built.
    public static let headermapIncludesFlatEntriesForTargetBeingBuilt: BuildSettingsKey = "HEADERMAP_INCLUDES_FLAT_ENTRIES_FOR_TARGET_BEING_BUILT"
}

// MARK: HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES
extension BuildSetting {

    /// HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES
    ///
    /// Specifies whether the header map contains a framework-name/path entry for every header in the target being built, including targets that do not build frameworks.
    public static var headermapIncludesFrameworkEntriesForAllProductTypes: BuildSetting { 
        BuildSetting(key: .headermapIncludesFrameworkEntriesForAllProductTypes, value: "YES")
    }

    /// HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES
    ///
    /// Specifies whether the header map contains a framework-name/path entry for every header in the target being built, including targets that do not build frameworks.
    public static func headermapIncludesFrameworkEntriesForAllProductTypes(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapIncludesFrameworkEntriesForAllProductTypes, value: SettingValue(booleanLiteral: value))
    }

    /// HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES
    ///
    /// Specifies whether the header map contains a framework-name/path entry for every header in the target being built, including targets that do not build frameworks.
    public static func headermapIncludesFrameworkEntriesForAllProductTypes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapIncludesFrameworkEntriesForAllProductTypes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES
    ///
    /// Specifies whether the header map contains a framework-name/path entry for every header in the target being built, including targets that do not build frameworks.
    public static let headermapIncludesFrameworkEntriesForAllProductTypes: BuildSettingsKey = "HEADERMAP_INCLUDES_FRAMEWORK_ENTRIES_FOR_ALL_PRODUCT_TYPES"
}

// MARK: HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS
extension BuildSetting {

    /// HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS
    public static var headermapIncludesNonpublicNonprivateHeaders: BuildSetting { 
        .headermapIncludesNonpublicNonprivateHeaders(inherit: .headermapIncludesProjectHeaders) 
    }

    /// HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS
    public static func headermapIncludesNonpublicNonprivateHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapIncludesNonpublicNonprivateHeaders, value: SettingValue(booleanLiteral: value))
    }

    /// HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS
    public static func headermapIncludesNonpublicNonprivateHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapIncludesNonpublicNonprivateHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS
    public static let headermapIncludesNonpublicNonprivateHeaders: BuildSettingsKey = "HEADERMAP_INCLUDES_NONPUBLIC_NONPRIVATE_HEADERS"
}

// MARK: HEADERMAP_INCLUDES_PROJECT_HEADERS
extension BuildSetting {

    /// HEADERMAP_INCLUDES_PROJECT_HEADERS
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the project, regardless of the headers target membership.
    public static var headermapIncludesProjectHeaders: BuildSetting { 
        BuildSetting(key: .headermapIncludesProjectHeaders, value: "YES")
    }

    /// HEADERMAP_INCLUDES_PROJECT_HEADERS
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the project, regardless of the headers target membership.
    public static func headermapIncludesProjectHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapIncludesProjectHeaders, value: SettingValue(booleanLiteral: value))
    }

    /// HEADERMAP_INCLUDES_PROJECT_HEADERS
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the project, regardless of the headers target membership.
    public static func headermapIncludesProjectHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapIncludesProjectHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// HEADERMAP_INCLUDES_PROJECT_HEADERS
    ///
    /// Specifies whether the header map contains a name/path entry for every header in the project, regardless of the headers target membership.
    public static let headermapIncludesProjectHeaders: BuildSettingsKey = "HEADERMAP_INCLUDES_PROJECT_HEADERS"
}

// MARK: HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES
extension BuildSetting {

    /// HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES
    public static var headermapUsesFrameworkPrefixEntries: BuildSetting { 
        BuildSetting(key: .headermapUsesFrameworkPrefixEntries, value: "YES")
    }

    /// HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES
    public static func headermapUsesFrameworkPrefixEntries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapUsesFrameworkPrefixEntries, value: SettingValue(booleanLiteral: value))
    }

    /// HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES
    public static func headermapUsesFrameworkPrefixEntries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapUsesFrameworkPrefixEntries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES
    public static let headermapUsesFrameworkPrefixEntries: BuildSettingsKey = "HEADERMAP_USES_FRAMEWORK_PREFIX_ENTRIES"
}

// MARK: HEADERMAP_USES_VFS
extension BuildSetting {

    /// HEADERMAP_USES_VFS
    public static var headermapUsesVfs: BuildSetting { 
        .headermapUsesVfs(inherit: .definesModule) 
    }

    /// HEADERMAP_USES_VFS
    public static func headermapUsesVfs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .headermapUsesVfs, value: SettingValue(booleanLiteral: value))
    }

    /// HEADERMAP_USES_VFS
    public static func headermapUsesVfs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headermapUsesVfs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// HEADERMAP_USES_VFS
    public static let headermapUsesVfs: BuildSettingsKey = "HEADERMAP_USES_VFS"
}

// MARK: Header Search Paths
extension BuildSetting {

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static var headerSearchPaths: BuildSetting { 
        BuildSetting(key: .headerSearchPaths, value: "")
    }

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func headerSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .headerSearchPaths, value: .array(value))
    }

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func headerSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headerSearchPaths, inherit: key)
    }

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func headerSearchPaths(_ value: String...) -> BuildSetting { 
        .headerSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static let headerSearchPaths: BuildSettingsKey = "HEADER_SEARCH_PATHS"
}

// MARK: HIDE_BITCODE_SYMBOLS
extension BuildSetting {

    /// HIDE_BITCODE_SYMBOLS
    public static var hideBitcodeSymbols: BuildSetting { 
        BuildSetting(key: .hideBitcodeSymbols, value: "YES")
    }

    /// HIDE_BITCODE_SYMBOLS
    public static func hideBitcodeSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .hideBitcodeSymbols, value: SettingValue(booleanLiteral: value))
    }

    /// HIDE_BITCODE_SYMBOLS
    public static func hideBitcodeSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .hideBitcodeSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// HIDE_BITCODE_SYMBOLS
    public static let hideBitcodeSymbols: BuildSettingsKey = "HIDE_BITCODE_SYMBOLS"
}

// MARK: HOME
extension BuildSetting {

    /// HOME
    public static func home(_ value: String) -> BuildSetting { 
        BuildSetting(key: .home, value: "\(value)")
    }

    /// HOME
    public static func home(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .home, inherit: key)
    }
}

extension BuildSettingsKey {

    /// HOME
    public static let home: BuildSettingsKey = "HOME"
}

// MARK: Auto-Activate Custom Fonts
extension BuildSetting {

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the XIB compiler to add custom fonts to the application's `Info.plist`, which will cause the fonts to activate upon application launch.
    public static var autoActivateCustomFonts: BuildSetting { 
        BuildSetting(key: .autoActivateCustomFonts, value: "YES")
    }

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the XIB compiler to add custom fonts to the application's `Info.plist`, which will cause the fonts to activate upon application launch.
    public static func autoActivateCustomFonts(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .autoActivateCustomFonts, value: SettingValue(booleanLiteral: value))
    }

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the XIB compiler to add custom fonts to the application's `Info.plist`, which will cause the fonts to activate upon application launch.
    public static func autoActivateCustomFonts(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .autoActivateCustomFonts, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the XIB compiler to add custom fonts to the application's `Info.plist`, which will cause the fonts to activate upon application launch.
    public static let autoActivateCustomFonts: BuildSettingsKey = "IBC_COMPILER_AUTO_ACTIVATE_CUSTOM_FONTS"
}

// MARK: IBC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
extension BuildSetting {

    /// IBC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
    public static var ibcCompilerUseNibarchivesForMacos: BuildSetting { 
        BuildSetting(key: .ibcCompilerUseNibarchivesForMacos, value: "")
    }

    /// IBC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
    public static func ibcCompilerUseNibarchivesForMacos(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ibcCompilerUseNibarchivesForMacos, value: "\(value)")
    }

    /// IBC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
    public static func ibcCompilerUseNibarchivesForMacos(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibcCompilerUseNibarchivesForMacos, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IBC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
    public static let ibcCompilerUseNibarchivesForMacos: BuildSettingsKey = "IBC_COMPILER_USE_NIBARCHIVES_FOR_MACOS"
}

// MARK: Show Errors
extension BuildSetting {

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of XIB files.
    public static var showErrors: BuildSetting { 
        BuildSetting(key: .showErrors, value: "YES")
    }

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of XIB files.
    public static func showErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showErrors, value: SettingValue(booleanLiteral: value))
    }

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of XIB files.
    public static func showErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of XIB files.
    public static let showErrors: BuildSettingsKey = "IBC_ERRORS"
}

// MARK: Flatten Compiled XIB Files
extension BuildSetting {

    /// Flatten Compiled XIB Files
    ///
    /// If enabled, compile XIB files into flattened (non-wrapper) NIB files. After flattening, the resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable in Interface Builder.
    public static var flattenCompiledXibFiles: BuildSetting { 
        BuildSetting(key: .flattenCompiledXibFiles, value: "YES")
    }

    /// Flatten Compiled XIB Files
    ///
    /// If enabled, compile XIB files into flattened (non-wrapper) NIB files. After flattening, the resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable in Interface Builder.
    public static func flattenCompiledXibFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .flattenCompiledXibFiles, value: SettingValue(booleanLiteral: value))
    }

    /// Flatten Compiled XIB Files
    ///
    /// If enabled, compile XIB files into flattened (non-wrapper) NIB files. After flattening, the resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable in Interface Builder.
    public static func flattenCompiledXibFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .flattenCompiledXibFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Flatten Compiled XIB Files
    ///
    /// If enabled, compile XIB files into flattened (non-wrapper) NIB files. After flattening, the resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable in Interface Builder.
    public static let flattenCompiledXibFiles: BuildSettingsKey = "IBC_FLATTEN_NIBS"
}

// MARK: Default Module
extension BuildSetting {

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static var defaultModule: BuildSetting { 
        .defaultModule(inherit: .productModuleName) 
    }

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static func defaultModule(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultModule, value: "\(value)")
    }

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static func defaultModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static let defaultModule: BuildSettingsKey = "IBC_MODULE"
}

// MARK: Show Notices
extension BuildSetting {

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of XIB files.
    public static var showNotices: BuildSetting { 
        BuildSetting(key: .showNotices, value: "YES")
    }

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of XIB files.
    public static func showNotices(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showNotices, value: SettingValue(booleanLiteral: value))
    }

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of XIB files.
    public static func showNotices(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showNotices, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of XIB files.
    public static let showNotices: BuildSettingsKey = "IBC_NOTICES"
}

// MARK: Other Interface Builder Compiler Flags
extension BuildSetting {

    /// Other Interface Builder Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static var otherInterfaceBuilderCompilerFlags: BuildSetting { 
        BuildSetting(key: .otherInterfaceBuilderCompilerFlags, value: "")
    }

    /// Other Interface Builder Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherInterfaceBuilderCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherInterfaceBuilderCompilerFlags, value: .array(value))
    }

    /// Other Interface Builder Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherInterfaceBuilderCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherInterfaceBuilderCompilerFlags, inherit: key)
    }

    /// Other Interface Builder Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherInterfaceBuilderCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherInterfaceBuilderCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Interface Builder Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static let otherInterfaceBuilderCompilerFlags: BuildSettingsKey = "IBC_OTHER_FLAGS"
}

// MARK: Overriding Plug-In and Framework Directory
extension BuildSetting {

    /// Overriding Plug-In and Framework Directory
    ///
    /// Instructs Interface Builder to load frameworks and Interface Builder plugins from the specified directory. Setting this value to `$(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)` will ensure that Interface Builder will load frameworks and plug-ins from the built products directory of the current build configuration.
    public static func overridingPlugInAndFrameworkDirectory(_ value: String) -> BuildSetting { 
        BuildSetting(key: .overridingPlugInAndFrameworkDirectory, value: "\(value)")
    }

    /// Overriding Plug-In and Framework Directory
    ///
    /// Instructs Interface Builder to load frameworks and Interface Builder plugins from the specified directory. Setting this value to `$(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)` will ensure that Interface Builder will load frameworks and plug-ins from the built products directory of the current build configuration.
    public static func overridingPlugInAndFrameworkDirectory(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .overridingPlugInAndFrameworkDirectory, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Overriding Plug-In and Framework Directory
    ///
    /// Instructs Interface Builder to load frameworks and Interface Builder plugins from the specified directory. Setting this value to `$(BUILD_DIR)/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)` will ensure that Interface Builder will load frameworks and plug-ins from the built products directory of the current build configuration.
    public static let overridingPlugInAndFrameworkDirectory: BuildSettingsKey = "IBC_OVERRIDING_PLUGINS_AND_FRAMEWORKS_DIR"
}

// MARK: Plug-Ins
extension BuildSetting {

    /// Plug-Ins
    ///
    /// A list of paths to Interface Builder plugins to load when compiling XIB files.
    public static var plugIns: BuildSetting { 
        BuildSetting(key: .plugIns, value: "")
    }

    /// Plug-Ins
    ///
    /// A list of paths to Interface Builder plugins to load when compiling XIB files.
    public static func plugIns(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .plugIns, value: .array(value))
    }

    /// Plug-Ins
    ///
    /// A list of paths to Interface Builder plugins to load when compiling XIB files.
    public static func plugIns(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .plugIns, inherit: key)
    }

    /// Plug-Ins
    ///
    /// A list of paths to Interface Builder plugins to load when compiling XIB files.
    public static func plugIns(_ value: String...) -> BuildSetting { 
        .plugIns(value)
    }
}

extension BuildSettingsKey {

    /// Plug-Ins
    ///
    /// A list of paths to Interface Builder plugins to load when compiling XIB files.
    public static let plugIns: BuildSettingsKey = "IBC_PLUGINS"
}

// MARK: Plug-In Search Paths
extension BuildSetting {

    /// Plug-In Search Paths
    ///
    /// A list of paths to be searched for Interface Builder plug-ins to load when compiling XIB files.
    public static var plugInSearchPaths: BuildSetting { 
        BuildSetting(key: .plugInSearchPaths, value: "")
    }

    /// Plug-In Search Paths
    ///
    /// A list of paths to be searched for Interface Builder plug-ins to load when compiling XIB files.
    public static func plugInSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .plugInSearchPaths, value: .array(value))
    }

    /// Plug-In Search Paths
    ///
    /// A list of paths to be searched for Interface Builder plug-ins to load when compiling XIB files.
    public static func plugInSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .plugInSearchPaths, inherit: key)
    }

    /// Plug-In Search Paths
    ///
    /// A list of paths to be searched for Interface Builder plug-ins to load when compiling XIB files.
    public static func plugInSearchPaths(_ value: String...) -> BuildSetting { 
        .plugInSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Plug-In Search Paths
    ///
    /// A list of paths to be searched for Interface Builder plug-ins to load when compiling XIB files.
    public static let plugInSearchPaths: BuildSettingsKey = "IBC_PLUGIN_SEARCH_PATHS"
}

// MARK: IBC_REGIONS_AND_STRINGS_FILES
extension BuildSetting {

    /// IBC_REGIONS_AND_STRINGS_FILES
    public static var ibcRegionsAndStringsFiles: BuildSetting { 
        BuildSetting(key: .ibcRegionsAndStringsFiles, value: "")
    }

    /// IBC_REGIONS_AND_STRINGS_FILES
    public static func ibcRegionsAndStringsFiles(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ibcRegionsAndStringsFiles, value: .array(value))
    }

    /// IBC_REGIONS_AND_STRINGS_FILES
    public static func ibcRegionsAndStringsFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibcRegionsAndStringsFiles, inherit: key)
    }

    /// IBC_REGIONS_AND_STRINGS_FILES
    public static func ibcRegionsAndStringsFiles(_ value: String...) -> BuildSetting { 
        .ibcRegionsAndStringsFiles(value)
    }
}

extension BuildSettingsKey {

    /// IBC_REGIONS_AND_STRINGS_FILES
    public static let ibcRegionsAndStringsFiles: BuildSettingsKey = "IBC_REGIONS_AND_STRINGS_FILES"
}

// MARK: Strip NIB Files
extension BuildSetting {

    /// Strip NIB Files
    ///
    /// Strips an Interface Builder NIB to reduce its size for deployment. The resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable by Interface Builder.
    public static var stripNibFiles: BuildSetting { 
        .stripNibFiles(inherit: .flattenCompiledXibFiles) 
    }

    /// Strip NIB Files
    ///
    /// Strips an Interface Builder NIB to reduce its size for deployment. The resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable by Interface Builder.
    public static func stripNibFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripNibFiles, value: SettingValue(booleanLiteral: value))
    }

    /// Strip NIB Files
    ///
    /// Strips an Interface Builder NIB to reduce its size for deployment. The resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable by Interface Builder.
    public static func stripNibFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripNibFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip NIB Files
    ///
    /// Strips an Interface Builder NIB to reduce its size for deployment. The resulting NIB is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting NIB file remains editable by Interface Builder.
    public static let stripNibFiles: BuildSettingsKey = "IBC_STRIP_NIBS"
}

// MARK: Show Warnings
extension BuildSetting {

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of XIB files.
    public static var showWarnings: BuildSetting { 
        BuildSetting(key: .showWarnings, value: "YES")
    }

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of XIB files.
    public static func showWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of XIB files.
    public static func showWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of XIB files.
    public static let showWarnings: BuildSettingsKey = "IBC_WARNINGS"
}

// MARK: Auto-Activate Custom Fonts
extension BuildSetting {

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the Storyboard compiler to add custom fonts to the application's `Info.plist` that will cause the fonts to activate upon application launch.
    public static var autoActivateCustomFonts: BuildSetting { 
        BuildSetting(key: .autoActivateCustomFonts, value: "YES")
    }

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the Storyboard compiler to add custom fonts to the application's `Info.plist` that will cause the fonts to activate upon application launch.
    public static func autoActivateCustomFonts(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .autoActivateCustomFonts, value: SettingValue(booleanLiteral: value))
    }

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the Storyboard compiler to add custom fonts to the application's `Info.plist` that will cause the fonts to activate upon application launch.
    public static func autoActivateCustomFonts(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .autoActivateCustomFonts, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Auto-Activate Custom Fonts
    ///
    /// Instructs the Storyboard compiler to add custom fonts to the application's `Info.plist` that will cause the fonts to activate upon application launch.
    public static let autoActivateCustomFonts: BuildSettingsKey = "IBSC_COMPILER_AUTO_ACTIVATE_CUSTOM_FONTS"
}

// MARK: IBSC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
extension BuildSetting {

    /// IBSC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
    public static var ibscCompilerUseNibarchivesForMacos: BuildSetting { 
        BuildSetting(key: .ibscCompilerUseNibarchivesForMacos, value: "")
    }

    /// IBSC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
    public static func ibscCompilerUseNibarchivesForMacos(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ibscCompilerUseNibarchivesForMacos, value: "\(value)")
    }

    /// IBSC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
    public static func ibscCompilerUseNibarchivesForMacos(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibscCompilerUseNibarchivesForMacos, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IBSC_COMPILER_USE_NIBARCHIVES_FOR_MACOS
    public static let ibscCompilerUseNibarchivesForMacos: BuildSettingsKey = "IBSC_COMPILER_USE_NIBARCHIVES_FOR_MACOS"
}

// MARK: Show Errors
extension BuildSetting {

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of Storyboard files.
    public static var showErrors: BuildSetting { 
        BuildSetting(key: .showErrors, value: "YES")
    }

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of Storyboard files.
    public static func showErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showErrors, value: SettingValue(booleanLiteral: value))
    }

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of Storyboard files.
    public static func showErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Errors
    ///
    /// Show errors encountered during the compilation of Storyboard files.
    public static let showErrors: BuildSettingsKey = "IBSC_ERRORS"
}

// MARK: Flatten Compiled Storyboard Files
extension BuildSetting {

    /// Flatten Compiled Storyboard Files
    ///
    /// Compiles a Storyboard file into flattened (non-wrapper) Storyboard file. After flattening, the resulting Storyboard is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting Storyboard file remains editable in Interface Builder.
    public static var flattenCompiledStoryboardFiles: BuildSetting { 
        BuildSetting(key: .flattenCompiledStoryboardFiles, value: "YES")
    }

    /// Flatten Compiled Storyboard Files
    ///
    /// Compiles a Storyboard file into flattened (non-wrapper) Storyboard file. After flattening, the resulting Storyboard is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting Storyboard file remains editable in Interface Builder.
    public static func flattenCompiledStoryboardFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .flattenCompiledStoryboardFiles, value: SettingValue(booleanLiteral: value))
    }

    /// Flatten Compiled Storyboard Files
    ///
    /// Compiles a Storyboard file into flattened (non-wrapper) Storyboard file. After flattening, the resulting Storyboard is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting Storyboard file remains editable in Interface Builder.
    public static func flattenCompiledStoryboardFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .flattenCompiledStoryboardFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Flatten Compiled Storyboard Files
    ///
    /// Compiles a Storyboard file into flattened (non-wrapper) Storyboard file. After flattening, the resulting Storyboard is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting Storyboard file remains editable in Interface Builder.
    public static let flattenCompiledStoryboardFiles: BuildSettingsKey = "IBSC_FLATTEN_NIBS"
}

// MARK: Default Module
extension BuildSetting {

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static var defaultModule: BuildSetting { 
        .defaultModule(inherit: .productModuleName) 
    }

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static func defaultModule(_ value: String) -> BuildSetting { 
        BuildSetting(key: .defaultModule, value: "\(value)")
    }

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static func defaultModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .defaultModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Default Module
    ///
    /// Defines the module name for Swift classes referenced without a specific module name.
    public static let defaultModule: BuildSettingsKey = "IBSC_MODULE"
}

// MARK: Show Notices
extension BuildSetting {

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of Storyboard files.
    public static var showNotices: BuildSetting { 
        BuildSetting(key: .showNotices, value: "YES")
    }

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of Storyboard files.
    public static func showNotices(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showNotices, value: SettingValue(booleanLiteral: value))
    }

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of Storyboard files.
    public static func showNotices(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showNotices, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Notices
    ///
    /// Show notices encountered during the compilation of Storyboard files.
    public static let showNotices: BuildSettingsKey = "IBSC_NOTICES"
}

// MARK: Other Storyboard Compiler Flags
extension BuildSetting {

    /// Other Storyboard Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static var otherStoryboardCompilerFlags: BuildSetting { 
        BuildSetting(key: .otherStoryboardCompilerFlags, value: "")
    }

    /// Other Storyboard Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherStoryboardCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherStoryboardCompilerFlags, value: .array(value))
    }

    /// Other Storyboard Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherStoryboardCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherStoryboardCompilerFlags, inherit: key)
    }

    /// Other Storyboard Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static func otherStoryboardCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherStoryboardCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Storyboard Compiler Flags
    ///
    /// A list of additional flags to pass to the Interface Builder Compiler. Use this setting if Xcode does not already provide UI for a particular Interface Builder Compiler flag.
    public static let otherStoryboardCompilerFlags: BuildSettingsKey = "IBSC_OTHER_FLAGS"
}

// MARK: IBSC_REGIONS_AND_STRINGS_FILES
extension BuildSetting {

    /// IBSC_REGIONS_AND_STRINGS_FILES
    public static var ibscRegionsAndStringsFiles: BuildSetting { 
        .ibscRegionsAndStringsFiles(inherit: .ibcRegionsAndStringsFiles) 
    }

    /// IBSC_REGIONS_AND_STRINGS_FILES
    public static func ibscRegionsAndStringsFiles(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ibscRegionsAndStringsFiles, value: .array(value))
    }

    /// IBSC_REGIONS_AND_STRINGS_FILES
    public static func ibscRegionsAndStringsFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ibscRegionsAndStringsFiles, inherit: key)
    }

    /// IBSC_REGIONS_AND_STRINGS_FILES
    public static func ibscRegionsAndStringsFiles(_ value: String...) -> BuildSetting { 
        .ibscRegionsAndStringsFiles(value)
    }
}

extension BuildSettingsKey {

    /// IBSC_REGIONS_AND_STRINGS_FILES
    public static let ibscRegionsAndStringsFiles: BuildSettingsKey = "IBSC_REGIONS_AND_STRINGS_FILES"
}

// MARK: Strip Storyboardc Files
extension BuildSetting {

    /// Strip Storyboardc Files
    ///
    /// Strips an editable Interface Builder storyboardc file to reduce its size for deployment. The resulting storyboardc is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting storyboardc file remains editable by Interface Builder.
    public static var stripStoryboardcFiles: BuildSetting { 
        .stripStoryboardcFiles(inherit: .flattenCompiledStoryboardFiles) 
    }

    /// Strip Storyboardc Files
    ///
    /// Strips an editable Interface Builder storyboardc file to reduce its size for deployment. The resulting storyboardc is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting storyboardc file remains editable by Interface Builder.
    public static func stripStoryboardcFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripStoryboardcFiles, value: SettingValue(booleanLiteral: value))
    }

    /// Strip Storyboardc Files
    ///
    /// Strips an editable Interface Builder storyboardc file to reduce its size for deployment. The resulting storyboardc is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting storyboardc file remains editable by Interface Builder.
    public static func stripStoryboardcFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripStoryboardcFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Storyboardc Files
    ///
    /// Strips an editable Interface Builder storyboardc file to reduce its size for deployment. The resulting storyboardc is more compact but no longer editable by Interface Builder. When this option is disabled, the resulting storyboardc file remains editable by Interface Builder.
    public static let stripStoryboardcFiles: BuildSettingsKey = "IBSC_STRIP_NIBS"
}

// MARK: Show Warnings
extension BuildSetting {

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of Storyboard files.
    public static var showWarnings: BuildSetting { 
        BuildSetting(key: .showWarnings, value: "YES")
    }

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of Storyboard files.
    public static func showWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of Storyboard files.
    public static func showWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Warnings
    ///
    /// Show warnings encountered during the compilation of Storyboard files.
    public static let showWarnings: BuildSettingsKey = "IBSC_WARNINGS"
}

// MARK: ICONV
extension BuildSetting {

    /// ICONV
    public static var iconv: BuildSetting { 
        BuildSetting(key: .iconv, value: "/usr/bin/iconv")
    }

    /// ICONV
    public static func iconv(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iconv, value: "\(value)")
    }

    /// ICONV
    public static func iconv(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iconv, inherit: key)
    }
}

extension BuildSettingsKey {

    /// ICONV
    public static let iconv: BuildSettingsKey = "ICONV"
}

// MARK: IIG_CXX_LANGUAGE_STANDARD
extension BuildSetting {

    /// IIG_CXX_LANGUAGE_STANDARD
    public static var iigCxxLanguageStandard: BuildSetting { 
        .iigCxxLanguageStandard(inherit: .cppLanguageDialect) 
    }

    /// IIG_CXX_LANGUAGE_STANDARD
    public static func iigCxxLanguageStandard(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigCxxLanguageStandard, value: "\(value)")
    }

    /// IIG_CXX_LANGUAGE_STANDARD
    public static func iigCxxLanguageStandard(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigCxxLanguageStandard, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IIG_CXX_LANGUAGE_STANDARD
    public static let iigCxxLanguageStandard: BuildSettingsKey = "IIG_CXX_LANGUAGE_STANDARD"
}

// MARK: IIG_DERIVED_FILE_DIR
extension BuildSetting {

    /// IIG_DERIVED_FILE_DIR
    public static var iigDerivedFileDir: BuildSetting { 
        BuildSetting(key: .iigDerivedFileDir, value: "$(DERIVED_FILE_DIR)/$(IIG_FRAMEWORK_NAME)")
    }

    /// IIG_DERIVED_FILE_DIR
    public static func iigDerivedFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigDerivedFileDir, value: "\(value)")
    }

    /// IIG_DERIVED_FILE_DIR
    public static func iigDerivedFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigDerivedFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IIG_DERIVED_FILE_DIR
    public static let iigDerivedFileDir: BuildSettingsKey = "IIG_DERIVED_FILE_DIR"
}

// MARK: IIG_FRAMEWORK_NAME
extension BuildSetting {

    /// IIG_FRAMEWORK_NAME
    public static var iigFrameworkName: BuildSetting { 
        .iigFrameworkName(inherit: .productName) 
    }

    /// IIG_FRAMEWORK_NAME
    public static func iigFrameworkName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigFrameworkName, value: "\(value)")
    }

    /// IIG_FRAMEWORK_NAME
    public static func iigFrameworkName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigFrameworkName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IIG_FRAMEWORK_NAME
    public static let iigFrameworkName: BuildSettingsKey = "IIG_FRAMEWORK_NAME"
}

// MARK: IIG_HEADERS_DIR
extension BuildSetting {

    /// IIG_HEADERS_DIR
    public static var iigHeadersDir: BuildSetting { 
        .iigHeadersDir(inherit: .iigDerivedFileDir) 
    }

    /// IIG_HEADERS_DIR
    public static func iigHeadersDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigHeadersDir, value: "\(value)")
    }

    /// IIG_HEADERS_DIR
    public static func iigHeadersDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigHeadersDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IIG_HEADERS_DIR
    public static let iigHeadersDir: BuildSettingsKey = "IIG_HEADERS_DIR"
}

// MARK: IIG_IMPLEMENTATION_DIR
extension BuildSetting {

    /// IIG_IMPLEMENTATION_DIR
    public static var iigImplementationDir: BuildSetting { 
        .iigImplementationDir(inherit: .iigDerivedFileDir) 
    }

    /// IIG_IMPLEMENTATION_DIR
    public static func iigImplementationDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .iigImplementationDir, value: "\(value)")
    }

    /// IIG_IMPLEMENTATION_DIR
    public static func iigImplementationDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigImplementationDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// IIG_IMPLEMENTATION_DIR
    public static let iigImplementationDir: BuildSettingsKey = "IIG_IMPLEMENTATION_DIR"
}

// MARK: IIG_PREPROCESSOR_DEFINITIONS
extension BuildSetting {

    /// IIG_PREPROCESSOR_DEFINITIONS
    public static var iigPreprocessorDefinitions: BuildSetting { 
        BuildSetting(key: .iigPreprocessorDefinitions, value: "__IIG=1")
    }

    /// IIG_PREPROCESSOR_DEFINITIONS
    public static func iigPreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .iigPreprocessorDefinitions, value: .array(value))
    }

    /// IIG_PREPROCESSOR_DEFINITIONS
    public static func iigPreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .iigPreprocessorDefinitions, inherit: key)
    }

    /// IIG_PREPROCESSOR_DEFINITIONS
    public static func iigPreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .iigPreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// IIG_PREPROCESSOR_DEFINITIONS
    public static let iigPreprocessorDefinitions: BuildSettingsKey = "IIG_PREPROCESSOR_DEFINITIONS"
}

// MARK: Sub-Directories to Include in Recursive Searches
extension BuildSetting {

    /// Sub-Directories to Include in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to include when performing a recursive search. By default, this is empty and is only customized when you want to provide exceptions to the list of filename patterns provided in [Sub-Directories to Exclude in Recursive Searches (EXCLUDED\_RECURSIVE\_SEARCH\_PATH\_SUBDIRECTORIES)](itcaec37c2a6.html#dev454fb3164).
    public static var subDirectoriesToIncludeInRecursiveSearches: BuildSetting { 
        BuildSetting(key: .subDirectoriesToIncludeInRecursiveSearches, value: "")
    }

    /// Sub-Directories to Include in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to include when performing a recursive search. By default, this is empty and is only customized when you want to provide exceptions to the list of filename patterns provided in [Sub-Directories to Exclude in Recursive Searches (EXCLUDED\_RECURSIVE\_SEARCH\_PATH\_SUBDIRECTORIES)](itcaec37c2a6.html#dev454fb3164).
    public static func subDirectoriesToIncludeInRecursiveSearches(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .subDirectoriesToIncludeInRecursiveSearches, value: .array(value))
    }

    /// Sub-Directories to Include in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to include when performing a recursive search. By default, this is empty and is only customized when you want to provide exceptions to the list of filename patterns provided in [Sub-Directories to Exclude in Recursive Searches (EXCLUDED\_RECURSIVE\_SEARCH\_PATH\_SUBDIRECTORIES)](itcaec37c2a6.html#dev454fb3164).
    public static func subDirectoriesToIncludeInRecursiveSearches(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .subDirectoriesToIncludeInRecursiveSearches, inherit: key)
    }

    /// Sub-Directories to Include in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to include when performing a recursive search. By default, this is empty and is only customized when you want to provide exceptions to the list of filename patterns provided in [Sub-Directories to Exclude in Recursive Searches (EXCLUDED\_RECURSIVE\_SEARCH\_PATH\_SUBDIRECTORIES)](itcaec37c2a6.html#dev454fb3164).
    public static func subDirectoriesToIncludeInRecursiveSearches(_ value: String...) -> BuildSetting { 
        .subDirectoriesToIncludeInRecursiveSearches(value)
    }
}

extension BuildSettingsKey {

    /// Sub-Directories to Include in Recursive Searches
    ///
    /// This is a list of `fnmatch()`-style patterns of file or directory names to include when performing a recursive search. By default, this is empty and is only customized when you want to provide exceptions to the list of filename patterns provided in [Sub-Directories to Exclude in Recursive Searches (EXCLUDED\_RECURSIVE\_SEARCH\_PATH\_SUBDIRECTORIES)](itcaec37c2a6.html#dev454fb3164).
    public static let subDirectoriesToIncludeInRecursiveSearches: BuildSettingsKey = "INCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES"
}

// MARK: Included Source File Names
extension BuildSetting {

    /// Included Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _include_ when processing the files in the target's build phases. This setting is only useful when combined with [Excluded Source File Names (EXCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#devd20926192), and can be used to define complex filters for which files from the phase should be built in response to other build settings.
    public static var includedSourceFileNames: BuildSetting { 
        BuildSetting(key: .includedSourceFileNames, value: "")
    }

    /// Included Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _include_ when processing the files in the target's build phases. This setting is only useful when combined with [Excluded Source File Names (EXCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#devd20926192), and can be used to define complex filters for which files from the phase should be built in response to other build settings.
    public static func includedSourceFileNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .includedSourceFileNames, value: .array(value))
    }

    /// Included Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _include_ when processing the files in the target's build phases. This setting is only useful when combined with [Excluded Source File Names (EXCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#devd20926192), and can be used to define complex filters for which files from the phase should be built in response to other build settings.
    public static func includedSourceFileNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .includedSourceFileNames, inherit: key)
    }

    /// Included Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _include_ when processing the files in the target's build phases. This setting is only useful when combined with [Excluded Source File Names (EXCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#devd20926192), and can be used to define complex filters for which files from the phase should be built in response to other build settings.
    public static func includedSourceFileNames(_ value: String...) -> BuildSetting { 
        .includedSourceFileNames(value)
    }
}

extension BuildSettingsKey {

    /// Included Source File Names
    ///
    /// A list of patterns (as defined by `fnmatch(3)`) specifying the names of source files to explicitly _include_ when processing the files in the target's build phases. This setting is only useful when combined with [Excluded Source File Names (EXCLUDED\_SOURCE\_FILE\_NAMES)](itcaec37c2a6.html#devd20926192), and can be used to define complex filters for which files from the phase should be built in response to other build settings.
    public static let includedSourceFileNames: BuildSettingsKey = "INCLUDED_SOURCE_FILE_NAMES"
}

// MARK: Expand Build Settings in Info.plist File
extension BuildSetting {

    /// Expand Build Settings in Info.plist File
    ///
    /// Expand build settings in the `Info.plist` file.
    public static var expandBuildSettingsInInfoPlistFile: BuildSetting { 
        BuildSetting(key: .expandBuildSettingsInInfoPlistFile, value: "YES")
    }

    /// Expand Build Settings in Info.plist File
    ///
    /// Expand build settings in the `Info.plist` file.
    public static func expandBuildSettingsInInfoPlistFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .expandBuildSettingsInInfoPlistFile, value: SettingValue(booleanLiteral: value))
    }

    /// Expand Build Settings in Info.plist File
    ///
    /// Expand build settings in the `Info.plist` file.
    public static func expandBuildSettingsInInfoPlistFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .expandBuildSettingsInInfoPlistFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Expand Build Settings in Info.plist File
    ///
    /// Expand build settings in the `Info.plist` file.
    public static let expandBuildSettingsInInfoPlistFile: BuildSettingsKey = "INFOPLIST_EXPAND_BUILD_SETTINGS"
}

// MARK: Info.plist File
extension BuildSetting {

    /// Info.plist File
    ///
    /// The project-relative path to the property list file that contains the `Info.plist` information used by bundles. For details on information property list files, see [Information Property List Files](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigFiles.html#//apple_ref/doc/uid/20002091-CJBJIEDH) in [Runtime Configuration Guidelines](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/000-Introduction/introduction.html).
    public static var infoPlistFile: BuildSetting { 
        BuildSetting(key: .infoPlistFile, value: "")
    }

    /// Info.plist File
    ///
    /// The project-relative path to the property list file that contains the `Info.plist` information used by bundles. For details on information property list files, see [Information Property List Files](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigFiles.html#//apple_ref/doc/uid/20002091-CJBJIEDH) in [Runtime Configuration Guidelines](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/000-Introduction/introduction.html).
    public static func infoPlistFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .infoPlistFile, value: "\(value)")
    }

    /// Info.plist File
    ///
    /// The project-relative path to the property list file that contains the `Info.plist` information used by bundles. For details on information property list files, see [Information Property List Files](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigFiles.html#//apple_ref/doc/uid/20002091-CJBJIEDH) in [Runtime Configuration Guidelines](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/000-Introduction/introduction.html).
    public static func infoPlistFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Info.plist File
    ///
    /// The project-relative path to the property list file that contains the `Info.plist` information used by bundles. For details on information property list files, see [Information Property List Files](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigFiles.html#//apple_ref/doc/uid/20002091-CJBJIEDH) in [Runtime Configuration Guidelines](https://developer.apple.com/library/content/documentation/MacOSX/Conceptual/BPRuntimeConfig/000-Introduction/introduction.html).
    public static let infoPlistFile: BuildSettingsKey = "INFOPLIST_FILE"
}

// MARK: Info.plist Other Preprocessor Flags
extension BuildSetting {

    /// Info.plist Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when preprocessing the `Info.plist` file.
    public static var infoPlistOtherPreprocessorFlags: BuildSetting { 
        BuildSetting(key: .infoPlistOtherPreprocessorFlags, value: "")
    }

    /// Info.plist Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when preprocessing the `Info.plist` file.
    public static func infoPlistOtherPreprocessorFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .infoPlistOtherPreprocessorFlags, value: .array(value))
    }

    /// Info.plist Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when preprocessing the `Info.plist` file.
    public static func infoPlistOtherPreprocessorFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistOtherPreprocessorFlags, inherit: key)
    }

    /// Info.plist Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when preprocessing the `Info.plist` file.
    public static func infoPlistOtherPreprocessorFlags(_ value: String...) -> BuildSetting { 
        .infoPlistOtherPreprocessorFlags(value)
    }
}

extension BuildSettingsKey {

    /// Info.plist Other Preprocessor Flags
    ///
    /// Other flags to pass to the C preprocessor when preprocessing the `Info.plist` file.
    public static let infoPlistOtherPreprocessorFlags: BuildSettingsKey = "INFOPLIST_OTHER_PREPROCESSOR_FLAGS"
}

// MARK: Info.plist Output Encoding
extension BuildSetting {

    /// Info.plist Output Encoding
    ///
    /// Specifies the output encoding for the output `Info.plist`. The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static var infoPlistOutputEncoding: BuildSetting { 
        .infoPlistOutputEncoding(.sameAsInput) 
    }

    /// Info.plist Output Encoding
    ///
    /// Specifies the output encoding for the output `Info.plist`. The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static func infoPlistOutputEncoding(_ value: InfoPlistOutputEncoding) -> BuildSetting { 
        BuildSetting(key: .infoPlistOutputEncoding, value: "\(value)")
    }

    /// Info.plist Output Encoding
    ///
    /// Specifies the output encoding for the output `Info.plist`. The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static func infoPlistOutputEncoding(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistOutputEncoding, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Info.plist Output Encoding
    ///
    /// Specifies the output encoding for the output `Info.plist`. The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static let infoPlistOutputEncoding: BuildSettingsKey = "INFOPLIST_OUTPUT_FORMAT"
}

public enum InfoPlistOutputEncoding: String, Hashable, Codable, CustomStringConvertible {
    case sameAsInput = "same-as-input"
    case xml = "XML"
    case binary = "binary"

    public var description: String {
        rawValue
    }
}

// MARK: INFOPLIST_PATH
extension BuildSetting {

    /// INFOPLIST_PATH
    ///
    /// Specifies the path to the bundles information property list file.
    public static var infoplistPath: BuildSetting { 
        BuildSetting(key: .infoplistPath, value: "")
    }

    /// INFOPLIST_PATH
    ///
    /// Specifies the path to the bundles information property list file.
    public static func infoplistPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .infoplistPath, value: "\(value)")
    }

    /// INFOPLIST_PATH
    ///
    /// Specifies the path to the bundles information property list file.
    public static func infoplistPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoplistPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// INFOPLIST_PATH
    ///
    /// Specifies the path to the bundles information property list file.
    public static let infoplistPath: BuildSettingsKey = "INFOPLIST_PATH"
}

// MARK: Info.plist Preprocessor Prefix File
extension BuildSetting {

    /// Info.plist Preprocessor Prefix File
    ///
    /// Implicitly include the given file when preprocessing the `Info.plist` file. The path given should either be a project relative path or an absolute path.
    public static var infoPlistPreprocessorPrefixFile: BuildSetting { 
        BuildSetting(key: .infoPlistPreprocessorPrefixFile, value: "")
    }

    /// Info.plist Preprocessor Prefix File
    ///
    /// Implicitly include the given file when preprocessing the `Info.plist` file. The path given should either be a project relative path or an absolute path.
    public static func infoPlistPreprocessorPrefixFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .infoPlistPreprocessorPrefixFile, value: "\(value)")
    }

    /// Info.plist Preprocessor Prefix File
    ///
    /// Implicitly include the given file when preprocessing the `Info.plist` file. The path given should either be a project relative path or an absolute path.
    public static func infoPlistPreprocessorPrefixFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistPreprocessorPrefixFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Info.plist Preprocessor Prefix File
    ///
    /// Implicitly include the given file when preprocessing the `Info.plist` file. The path given should either be a project relative path or an absolute path.
    public static let infoPlistPreprocessorPrefixFile: BuildSettingsKey = "INFOPLIST_PREFIX_HEADER"
}

// MARK: Preprocess Info.plist File
extension BuildSetting {

    /// Preprocess Info.plist File
    ///
    /// Preprocess the `Info.plist` file using the C Preprocessor.
    public static var preprocessInfoPlistFile: BuildSetting { 
        BuildSetting(key: .preprocessInfoPlistFile, value: "NO")
    }

    /// Preprocess Info.plist File
    ///
    /// Preprocess the `Info.plist` file using the C Preprocessor.
    public static func preprocessInfoPlistFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .preprocessInfoPlistFile, value: SettingValue(booleanLiteral: value))
    }

    /// Preprocess Info.plist File
    ///
    /// Preprocess the `Info.plist` file using the C Preprocessor.
    public static func preprocessInfoPlistFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessInfoPlistFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Preprocess Info.plist File
    ///
    /// Preprocess the `Info.plist` file using the C Preprocessor.
    public static let preprocessInfoPlistFile: BuildSettingsKey = "INFOPLIST_PREPROCESS"
}

// MARK: Info.plist Preprocessor Definitions
extension BuildSetting {

    /// Info.plist Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing the `Info.plist` file.
    public static var infoPlistPreprocessorDefinitions: BuildSetting { 
        BuildSetting(key: .infoPlistPreprocessorDefinitions, value: "")
    }

    /// Info.plist Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing the `Info.plist` file.
    public static func infoPlistPreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .infoPlistPreprocessorDefinitions, value: .array(value))
    }

    /// Info.plist Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing the `Info.plist` file.
    public static func infoPlistPreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoPlistPreprocessorDefinitions, inherit: key)
    }

    /// Info.plist Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing the `Info.plist` file.
    public static func infoPlistPreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .infoPlistPreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// Info.plist Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`. These macros are used when preprocessing the `Info.plist` file.
    public static let infoPlistPreprocessorDefinitions: BuildSettingsKey = "INFOPLIST_PREPROCESSOR_DEFINITIONS"
}

// MARK: INFOSTRINGS_PATH
extension BuildSetting {

    /// INFOSTRINGS_PATH
    ///
    /// Specifies the file that contains the bundles localized strings file.
    public static var infostringsPath: BuildSetting { 
        BuildSetting(key: .infostringsPath, value: "")
    }

    /// INFOSTRINGS_PATH
    ///
    /// Specifies the file that contains the bundles localized strings file.
    public static func infostringsPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .infostringsPath, value: "\(value)")
    }

    /// INFOSTRINGS_PATH
    ///
    /// Specifies the file that contains the bundles localized strings file.
    public static func infostringsPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infostringsPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// INFOSTRINGS_PATH
    ///
    /// Specifies the file that contains the bundles localized strings file.
    public static let infostringsPath: BuildSettingsKey = "INFOSTRINGS_PATH"
}

// MARK: Initialization Routine
extension BuildSetting {

    /// Initialization Routine
    ///
    /// This is the name of the routine to use for initialization.
    public static var initializationRoutine: BuildSetting { 
        BuildSetting(key: .initializationRoutine, value: "")
    }

    /// Initialization Routine
    ///
    /// This is the name of the routine to use for initialization.
    public static func initializationRoutine(_ value: String) -> BuildSetting { 
        BuildSetting(key: .initializationRoutine, value: "\(value)")
    }

    /// Initialization Routine
    ///
    /// This is the name of the routine to use for initialization.
    public static func initializationRoutine(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .initializationRoutine, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Initialization Routine
    ///
    /// This is the name of the routine to use for initialization.
    public static let initializationRoutine: BuildSettingsKey = "INIT_ROUTINE"
}

// MARK: Enable Text-Based Stubs Inlining
extension BuildSetting {

    /// Enable Text-Based Stubs Inlining
    ///
    /// Enables private framework inlining for Text-Based Stubs.
    public static var enableTextBasedStubsInlining: BuildSetting { 
        BuildSetting(key: .enableTextBasedStubsInlining, value: "NO")
    }

    /// Enable Text-Based Stubs Inlining
    ///
    /// Enables private framework inlining for Text-Based Stubs.
    public static func enableTextBasedStubsInlining(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableTextBasedStubsInlining, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Text-Based Stubs Inlining
    ///
    /// Enables private framework inlining for Text-Based Stubs.
    public static func enableTextBasedStubsInlining(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableTextBasedStubsInlining, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Text-Based Stubs Inlining
    ///
    /// Enables private framework inlining for Text-Based Stubs.
    public static let enableTextBasedStubsInlining: BuildSettingsKey = "INLINE_PRIVATE_FRAMEWORKS"
}

// MARK: Perform Copy Files Phases During `installhdrs`
extension BuildSetting {

    /// Perform Copy Files Phases During `installhdrs`
    ///
    /// Specifies whether the targets Copy Files build phases are executed in `installhdr` builds.
    public static var performCopyFilesPhasesDuringInstallhdrs: BuildSetting { 
        BuildSetting(key: .performCopyFilesPhasesDuringInstallhdrs, value: "NO")
    }

    /// Perform Copy Files Phases During `installhdrs`
    ///
    /// Specifies whether the targets Copy Files build phases are executed in `installhdr` builds.
    public static func performCopyFilesPhasesDuringInstallhdrs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .performCopyFilesPhasesDuringInstallhdrs, value: SettingValue(booleanLiteral: value))
    }

    /// Perform Copy Files Phases During `installhdrs`
    ///
    /// Specifies whether the targets Copy Files build phases are executed in `installhdr` builds.
    public static func performCopyFilesPhasesDuringInstallhdrs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .performCopyFilesPhasesDuringInstallhdrs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Perform Copy Files Phases During `installhdrs`
    ///
    /// Specifies whether the targets Copy Files build phases are executed in `installhdr` builds.
    public static let performCopyFilesPhasesDuringInstallhdrs: BuildSettingsKey = "INSTALLHDRS_COPY_PHASE"
}

// MARK: Perform Shell Script Phases During `installhdrs`
extension BuildSetting {

    /// Perform Shell Script Phases During `installhdrs`
    ///
    /// Specifies whether the targets Run Script build phases are executed in `installhdr` builds. See [Active Build Action (ACTION)](itcaec37c2a6.html#dev9697f81df) for details on `installhdr` builds.
    public static var performShellScriptPhasesDuringInstallhdrs: BuildSetting { 
        BuildSetting(key: .performShellScriptPhasesDuringInstallhdrs, value: "NO")
    }

    /// Perform Shell Script Phases During `installhdrs`
    ///
    /// Specifies whether the targets Run Script build phases are executed in `installhdr` builds. See [Active Build Action (ACTION)](itcaec37c2a6.html#dev9697f81df) for details on `installhdr` builds.
    public static func performShellScriptPhasesDuringInstallhdrs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .performShellScriptPhasesDuringInstallhdrs, value: SettingValue(booleanLiteral: value))
    }

    /// Perform Shell Script Phases During `installhdrs`
    ///
    /// Specifies whether the targets Run Script build phases are executed in `installhdr` builds. See [Active Build Action (ACTION)](itcaec37c2a6.html#dev9697f81df) for details on `installhdr` builds.
    public static func performShellScriptPhasesDuringInstallhdrs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .performShellScriptPhasesDuringInstallhdrs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Perform Shell Script Phases During `installhdrs`
    ///
    /// Specifies whether the targets Run Script build phases are executed in `installhdr` builds. See [Active Build Action (ACTION)](itcaec37c2a6.html#dev9697f81df) for details on `installhdr` builds.
    public static let performShellScriptPhasesDuringInstallhdrs: BuildSettingsKey = "INSTALLHDRS_SCRIPT_PHASE"
}

// MARK: INSTALL_DIR
extension BuildSetting {

    /// INSTALL_DIR
    ///
    /// Identifies the directory in the developers filesystem into which the *installed* product is placed.
    public static var installDir: BuildSetting { 
        BuildSetting(key: .installDir, value: "$(DSTROOT)$(INSTALL_PATH)")
    }

    /// INSTALL_DIR
    ///
    /// Identifies the directory in the developers filesystem into which the *installed* product is placed.
    public static func installDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installDir, value: "\(value)")
    }

    /// INSTALL_DIR
    ///
    /// Identifies the directory in the developers filesystem into which the *installed* product is placed.
    public static func installDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// INSTALL_DIR
    ///
    /// Identifies the directory in the developers filesystem into which the *installed* product is placed.
    public static let installDir: BuildSettingsKey = "INSTALL_DIR"
}

// MARK: Install Group
extension BuildSetting {

    /// Install Group
    ///
    /// The group name or `gid` for installed products.
    public static var installGroup: BuildSetting { 
        BuildSetting(key: .installGroup, value: "$(GROUP)")
    }

    /// Install Group
    ///
    /// The group name or `gid` for installed products.
    public static func installGroup(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installGroup, value: "\(value)")
    }

    /// Install Group
    ///
    /// The group name or `gid` for installed products.
    public static func installGroup(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installGroup, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Install Group
    ///
    /// The group name or `gid` for installed products.
    public static let installGroup: BuildSettingsKey = "INSTALL_GROUP"
}

// MARK: Install Permissions
extension BuildSetting {

    /// Install Permissions
    ///
    /// Permissions used for installed product files.
    public static var installPermissions: BuildSetting { 
        BuildSetting(key: .installPermissions, value: "u+w,go-w,a+rX")
    }

    /// Install Permissions
    ///
    /// Permissions used for installed product files.
    public static func installPermissions(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installPermissions, value: "\(value)")
    }

    /// Install Permissions
    ///
    /// Permissions used for installed product files.
    public static func installPermissions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installPermissions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Install Permissions
    ///
    /// Permissions used for installed product files.
    public static let installPermissions: BuildSettingsKey = "INSTALL_MODE_FLAG"
}

// MARK: Install Owner
extension BuildSetting {

    /// Install Owner
    ///
    /// The owner name or `uid` for installed products.
    public static var installOwner: BuildSetting { 
        .installOwner(inherit: .user) 
    }

    /// Install Owner
    ///
    /// The owner name or `uid` for installed products.
    public static func installOwner(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installOwner, value: "\(value)")
    }

    /// Install Owner
    ///
    /// The owner name or `uid` for installed products.
    public static func installOwner(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installOwner, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Install Owner
    ///
    /// The owner name or `uid` for installed products.
    public static let installOwner: BuildSettingsKey = "INSTALL_OWNER"
}

// MARK: Installation Directory
extension BuildSetting {

    /// Installation Directory
    ///
    /// The directory in which to install the build products. This path is prepended by the [Installation Build Products Location (DSTROOT)](itcaec37c2a6.html#dev438d356c2).
    public static var installationDirectory: BuildSetting { 
        BuildSetting(key: .installationDirectory, value: "")
    }

    /// Installation Directory
    ///
    /// The directory in which to install the build products. This path is prepended by the [Installation Build Products Location (DSTROOT)](itcaec37c2a6.html#dev438d356c2).
    public static func installationDirectory(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installationDirectory, value: "\(value)")
    }

    /// Installation Directory
    ///
    /// The directory in which to install the build products. This path is prepended by the [Installation Build Products Location (DSTROOT)](itcaec37c2a6.html#dev438d356c2).
    public static func installationDirectory(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installationDirectory, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Installation Directory
    ///
    /// The directory in which to install the build products. This path is prepended by the [Installation Build Products Location (DSTROOT)](itcaec37c2a6.html#dev438d356c2).
    public static let installationDirectory: BuildSettingsKey = "INSTALL_PATH"
}

// MARK: INSTALL_ROOT
extension BuildSetting {

    /// INSTALL_ROOT
    public static var installRoot: BuildSetting { 
        .installRoot(inherit: .installationBuildProductsLocation) 
    }

    /// INSTALL_ROOT
    public static func installRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .installRoot, value: "\(value)")
    }

    /// INSTALL_ROOT
    public static func installRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// INSTALL_ROOT
    public static let installRoot: BuildSettingsKey = "INSTALL_ROOT"
}

// MARK: INSTRUMENTS_PACKAGE_BUILDER
extension BuildSetting {

    /// INSTRUMENTS_PACKAGE_BUILDER
    public static var instrumentsPackageBuilder: BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilder, value: "instrumentbuilder")
    }

    /// INSTRUMENTS_PACKAGE_BUILDER
    public static func instrumentsPackageBuilder(_ value: String) -> BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilder, value: "\(value)")
    }

    /// INSTRUMENTS_PACKAGE_BUILDER
    public static func instrumentsPackageBuilder(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentsPackageBuilder, inherit: key)
    }
}

extension BuildSettingsKey {

    /// INSTRUMENTS_PACKAGE_BUILDER
    public static let instrumentsPackageBuilder: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER"
}

// MARK: INSTRUMENTS_PACKAGE_BUILDER_DEPENDENCY_INFO_FILE
extension BuildSetting {

    /// INSTRUMENTS_PACKAGE_BUILDER_DEPENDENCY_INFO_FILE
    public static var instrumentsPackageBuilderDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilderDependencyInfoFile, value: "$(TARGET_TEMP_DIR)/instruments-package-builder.dependencies")
    }

    /// INSTRUMENTS_PACKAGE_BUILDER_DEPENDENCY_INFO_FILE
    public static func instrumentsPackageBuilderDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilderDependencyInfoFile, value: "\(value)")
    }

    /// INSTRUMENTS_PACKAGE_BUILDER_DEPENDENCY_INFO_FILE
    public static func instrumentsPackageBuilderDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentsPackageBuilderDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// INSTRUMENTS_PACKAGE_BUILDER_DEPENDENCY_INFO_FILE
    public static let instrumentsPackageBuilderDependencyInfoFile: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_DEPENDENCY_INFO_FILE"
}

// MARK: Linked Instruments Packages
extension BuildSetting {

    /// Linked Instruments Packages
    public static var linkedInstrumentsPackages: BuildSetting { 
        BuildSetting(key: .linkedInstrumentsPackages, value: "")
    }

    /// Linked Instruments Packages
    public static func linkedInstrumentsPackages(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .linkedInstrumentsPackages, value: .array(value))
    }

    /// Linked Instruments Packages
    public static func linkedInstrumentsPackages(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkedInstrumentsPackages, inherit: key)
    }

    /// Linked Instruments Packages
    public static func linkedInstrumentsPackages(_ value: String...) -> BuildSetting { 
        .linkedInstrumentsPackages(value)
    }
}

extension BuildSettingsKey {

    /// Linked Instruments Packages
    public static let linkedInstrumentsPackages: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_LINKED_PACKAGES"
}

// MARK: Disable Standard Instruments Package Search Path
extension BuildSetting {

    /// Disable Standard Instruments Package Search Path
    public static var disableStandardInstrumentsPackageSearchPath: BuildSetting { 
        BuildSetting(key: .disableStandardInstrumentsPackageSearchPath, value: "NO")
    }

    /// Disable Standard Instruments Package Search Path
    public static func disableStandardInstrumentsPackageSearchPath(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .disableStandardInstrumentsPackageSearchPath, value: SettingValue(booleanLiteral: value))
    }

    /// Disable Standard Instruments Package Search Path
    public static func disableStandardInstrumentsPackageSearchPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .disableStandardInstrumentsPackageSearchPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Disable Standard Instruments Package Search Path
    public static let disableStandardInstrumentsPackageSearchPath: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_NO_SYSTEM_SEARCH"
}

// MARK: Instruments Package Builder Search Paths
extension BuildSetting {

    /// Instruments Package Builder Search Paths
    public static var instrumentsPackageBuilderSearchPaths: BuildSetting { 
        .instrumentsPackageBuilderSearchPaths(inherit: .builtProductsDir) 
    }

    /// Instruments Package Builder Search Paths
    public static func instrumentsPackageBuilderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .instrumentsPackageBuilderSearchPaths, value: .array(value))
    }

    /// Instruments Package Builder Search Paths
    public static func instrumentsPackageBuilderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentsPackageBuilderSearchPaths, inherit: key)
    }

    /// Instruments Package Builder Search Paths
    public static func instrumentsPackageBuilderSearchPaths(_ value: String...) -> BuildSetting { 
        .instrumentsPackageBuilderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Instruments Package Builder Search Paths
    public static let instrumentsPackageBuilderSearchPaths: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_SEARCH_PATHS"
}

// MARK: Instruments Package Version
extension BuildSetting {

    /// Instruments Package Version
    public static var instrumentsPackageVersion: BuildSetting { 
        BuildSetting(key: .instrumentsPackageVersion, value: "")
    }

    /// Instruments Package Version
    public static func instrumentsPackageVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .instrumentsPackageVersion, value: "\(value)")
    }

    /// Instruments Package Version
    public static func instrumentsPackageVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .instrumentsPackageVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Instruments Package Version
    public static let instrumentsPackageVersion: BuildSettingsKey = "INSTRUMENTS_PACKAGE_BUILDER_VERSION_OVERRIDE"
}

// MARK: Intent Class Generation Language
extension BuildSetting {

    /// Intent Class Generation Language
    ///
    /// The Source-code language to use for generated Intent class. By default "Automatic" will analyze your project to determine the correct language. Adjust this setting to explicitly select "Swift" or "Objective-C".
    public static var intentClassGenerationLanguage: BuildSetting { 
        .intentClassGenerationLanguage(.automatic) 
    }

    /// Intent Class Generation Language
    ///
    /// The Source-code language to use for generated Intent class. By default "Automatic" will analyze your project to determine the correct language. Adjust this setting to explicitly select "Swift" or "Objective-C".
    public static func intentClassGenerationLanguage(_ value: IntentClassGenerationLanguage) -> BuildSetting { 
        BuildSetting(key: .intentClassGenerationLanguage, value: "\(value)")
    }

    /// Intent Class Generation Language
    ///
    /// The Source-code language to use for generated Intent class. By default "Automatic" will analyze your project to determine the correct language. Adjust this setting to explicitly select "Swift" or "Objective-C".
    public static func intentClassGenerationLanguage(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .intentClassGenerationLanguage, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Intent Class Generation Language
    ///
    /// The Source-code language to use for generated Intent class. By default "Automatic" will analyze your project to determine the correct language. Adjust this setting to explicitly select "Swift" or "Objective-C".
    public static let intentClassGenerationLanguage: BuildSettingsKey = "INTENTS_CODEGEN_LANGUAGE"
}

public enum IntentClassGenerationLanguage: String, Hashable, Codable, CustomStringConvertible {
    case swift = "Swift"
    case objectiveC = "Objective-C"
    case automatic = "Automatic"

    public var description: String {
        rawValue
    }
}

// MARK: Building for Mac Catalyst
extension BuildSetting {

    /// Building for Mac Catalyst
    ///
    /// Indicates whether the target is building for Mac Catalyst. This build setting is intended for use in shell scripts and build setting composition and should be considered read-only.
    public static func buildingForMacCatalyst(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .buildingForMacCatalyst, value: SettingValue(booleanLiteral: value))
    }

    /// Building for Mac Catalyst
    ///
    /// Indicates whether the target is building for Mac Catalyst. This build setting is intended for use in shell scripts and build setting composition and should be considered read-only.
    public static func buildingForMacCatalyst(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildingForMacCatalyst, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Building for Mac Catalyst
    ///
    /// Indicates whether the target is building for Mac Catalyst. This build setting is intended for use in shell scripts and build setting composition and should be considered read-only.
    public static let buildingForMacCatalyst: BuildSettingsKey = "IS_MACCATALYST"
}

// MARK: InfoPlistPath
extension BuildSetting {

    /// InfoPlistPath
    public static func infoplistpath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .infoplistpath, value: "\(value)")
    }

    /// InfoPlistPath
    public static func infoplistpath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .infoplistpath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// InfoPlistPath
    public static let infoplistpath: BuildSettingsKey = "InfoPlistPath"
}

// MARK: JAVAC_DEFAULT_FLAGS
extension BuildSetting {

    /// JAVAC_DEFAULT_FLAGS
    public static var javacDefaultFlags: BuildSetting { 
        BuildSetting(key: .javacDefaultFlags, value: "-J-Xms64m -J-XX:NewSize=4M -J-Dfile.encoding=UTF8")
    }

    /// JAVAC_DEFAULT_FLAGS
    public static func javacDefaultFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javacDefaultFlags, value: .array(value))
    }

    /// JAVAC_DEFAULT_FLAGS
    public static func javacDefaultFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javacDefaultFlags, inherit: key)
    }

    /// JAVAC_DEFAULT_FLAGS
    public static func javacDefaultFlags(_ value: String...) -> BuildSetting { 
        .javacDefaultFlags(value)
    }
}

extension BuildSettingsKey {

    /// JAVAC_DEFAULT_FLAGS
    public static let javacDefaultFlags: BuildSettingsKey = "JAVAC_DEFAULT_FLAGS"
}

// MARK: JAVA_APP_STUB
extension BuildSetting {

    /// JAVA_APP_STUB
    public static var javaAppStub: BuildSetting { 
        BuildSetting(key: .javaAppStub, value: "$(SYSTEM_LIBRARY_DIR)/Frameworks/JavaVM.framework/Resources/MacOS/JavaApplicationStub")
    }

    /// JAVA_APP_STUB
    public static func javaAppStub(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaAppStub, value: "\(value)")
    }

    /// JAVA_APP_STUB
    public static func javaAppStub(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaAppStub, inherit: key)
    }
}

extension BuildSettingsKey {

    /// JAVA_APP_STUB
    public static let javaAppStub: BuildSettingsKey = "JAVA_APP_STUB"
}

// MARK: JAVA_ARCHIVE_CLASSES
extension BuildSetting {

    /// JAVA_ARCHIVE_CLASSES
    public static var javaArchiveClasses: BuildSetting { 
        BuildSetting(key: .javaArchiveClasses, value: "YES")
    }

    /// JAVA_ARCHIVE_CLASSES
    public static func javaArchiveClasses(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .javaArchiveClasses, value: SettingValue(booleanLiteral: value))
    }

    /// JAVA_ARCHIVE_CLASSES
    public static func javaArchiveClasses(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaArchiveClasses, inherit: key)
    }
}

extension BuildSettingsKey {

    /// JAVA_ARCHIVE_CLASSES
    public static let javaArchiveClasses: BuildSettingsKey = "JAVA_ARCHIVE_CLASSES"
}

// MARK: JAVA_ARCHIVE_TYPE
extension BuildSetting {

    /// JAVA_ARCHIVE_TYPE
    public static var javaArchiveType: BuildSetting { 
        BuildSetting(key: .javaArchiveType, value: "JAR")
    }

    /// JAVA_ARCHIVE_TYPE
    public static func javaArchiveType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaArchiveType, value: "\(value)")
    }

    /// JAVA_ARCHIVE_TYPE
    public static func javaArchiveType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaArchiveType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// JAVA_ARCHIVE_TYPE
    public static let javaArchiveType: BuildSettingsKey = "JAVA_ARCHIVE_TYPE"
}

// MARK: JAVA_COMPILER
extension BuildSetting {

    /// JAVA_COMPILER
    public static var javaCompiler: BuildSetting { 
        BuildSetting(key: .javaCompiler, value: "/usr/bin/javac")
    }

    /// JAVA_COMPILER
    public static func javaCompiler(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaCompiler, value: "\(value)")
    }

    /// JAVA_COMPILER
    public static func javaCompiler(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaCompiler, inherit: key)
    }
}

extension BuildSettingsKey {

    /// JAVA_COMPILER
    public static let javaCompiler: BuildSettingsKey = "JAVA_COMPILER"
}

// MARK: JAVA_FOLDER_PATH
extension BuildSetting {

    /// JAVA_FOLDER_PATH
    public static var javaFolderPath: BuildSetting { 
        BuildSetting(key: .javaFolderPath, value: "")
    }

    /// JAVA_FOLDER_PATH
    public static func javaFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaFolderPath, value: "\(value)")
    }

    /// JAVA_FOLDER_PATH
    public static func javaFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// JAVA_FOLDER_PATH
    public static let javaFolderPath: BuildSettingsKey = "JAVA_FOLDER_PATH"
}

// MARK: JAVA_FRAMEWORK_JARS
extension BuildSetting {

    /// JAVA_FRAMEWORK_JARS
    public static var javaFrameworkJars: BuildSetting { 
        BuildSetting(key: .javaFrameworkJars, value: "")
    }

    /// JAVA_FRAMEWORK_JARS
    public static func javaFrameworkJars(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javaFrameworkJars, value: .array(value))
    }

    /// JAVA_FRAMEWORK_JARS
    public static func javaFrameworkJars(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaFrameworkJars, inherit: key)
    }

    /// JAVA_FRAMEWORK_JARS
    public static func javaFrameworkJars(_ value: String...) -> BuildSetting { 
        .javaFrameworkJars(value)
    }
}

extension BuildSettingsKey {

    /// JAVA_FRAMEWORK_JARS
    public static let javaFrameworkJars: BuildSettingsKey = "JAVA_FRAMEWORK_JARS"
}

// MARK: JAVA_FRAMEWORK_RESOURCES_DIRS
extension BuildSetting {

    /// JAVA_FRAMEWORK_RESOURCES_DIRS
    public static var javaFrameworkResourcesDirs: BuildSetting { 
        BuildSetting(key: .javaFrameworkResourcesDirs, value: "Resources")
    }

    /// JAVA_FRAMEWORK_RESOURCES_DIRS
    public static func javaFrameworkResourcesDirs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javaFrameworkResourcesDirs, value: .array(value))
    }

    /// JAVA_FRAMEWORK_RESOURCES_DIRS
    public static func javaFrameworkResourcesDirs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaFrameworkResourcesDirs, inherit: key)
    }

    /// JAVA_FRAMEWORK_RESOURCES_DIRS
    public static func javaFrameworkResourcesDirs(_ value: String...) -> BuildSetting { 
        .javaFrameworkResourcesDirs(value)
    }
}

extension BuildSettingsKey {

    /// JAVA_FRAMEWORK_RESOURCES_DIRS
    public static let javaFrameworkResourcesDirs: BuildSettingsKey = "JAVA_FRAMEWORK_RESOURCES_DIRS"
}

// MARK: JAVA_JAR_FLAGS
extension BuildSetting {

    /// JAVA_JAR_FLAGS
    public static var javaJarFlags: BuildSetting { 
        BuildSetting(key: .javaJarFlags, value: "cv")
    }

    /// JAVA_JAR_FLAGS
    public static func javaJarFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javaJarFlags, value: .array(value))
    }

    /// JAVA_JAR_FLAGS
    public static func javaJarFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaJarFlags, inherit: key)
    }

    /// JAVA_JAR_FLAGS
    public static func javaJarFlags(_ value: String...) -> BuildSetting { 
        .javaJarFlags(value)
    }
}

extension BuildSettingsKey {

    /// JAVA_JAR_FLAGS
    public static let javaJarFlags: BuildSettingsKey = "JAVA_JAR_FLAGS"
}

// MARK: JAVA_SOURCE_SUBDIR
extension BuildSetting {

    /// JAVA_SOURCE_SUBDIR
    public static var javaSourceSubdir: BuildSetting { 
        BuildSetting(key: .javaSourceSubdir, value: ".")
    }

    /// JAVA_SOURCE_SUBDIR
    public static func javaSourceSubdir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .javaSourceSubdir, value: "\(value)")
    }

    /// JAVA_SOURCE_SUBDIR
    public static func javaSourceSubdir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaSourceSubdir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// JAVA_SOURCE_SUBDIR
    public static let javaSourceSubdir: BuildSettingsKey = "JAVA_SOURCE_SUBDIR"
}

// MARK: JAVA_USE_DEPENDENCIES
extension BuildSetting {

    /// JAVA_USE_DEPENDENCIES
    public static var javaUseDependencies: BuildSetting { 
        BuildSetting(key: .javaUseDependencies, value: "YES")
    }

    /// JAVA_USE_DEPENDENCIES
    public static func javaUseDependencies(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .javaUseDependencies, value: SettingValue(booleanLiteral: value))
    }

    /// JAVA_USE_DEPENDENCIES
    public static func javaUseDependencies(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaUseDependencies, inherit: key)
    }
}

extension BuildSettingsKey {

    /// JAVA_USE_DEPENDENCIES
    public static let javaUseDependencies: BuildSettingsKey = "JAVA_USE_DEPENDENCIES"
}

// MARK: JAVA_ZIP_FLAGS
extension BuildSetting {

    /// JAVA_ZIP_FLAGS
    public static var javaZipFlags: BuildSetting { 
        BuildSetting(key: .javaZipFlags, value: "-urg")
    }

    /// JAVA_ZIP_FLAGS
    public static func javaZipFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .javaZipFlags, value: .array(value))
    }

    /// JAVA_ZIP_FLAGS
    public static func javaZipFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .javaZipFlags, inherit: key)
    }

    /// JAVA_ZIP_FLAGS
    public static func javaZipFlags(_ value: String...) -> BuildSetting { 
        .javaZipFlags(value)
    }
}

extension BuildSettingsKey {

    /// JAVA_ZIP_FLAGS
    public static let javaZipFlags: BuildSettingsKey = "JAVA_ZIP_FLAGS"
}

// MARK: JIKES_DEFAULT_FLAGS
extension BuildSetting {

    /// JIKES_DEFAULT_FLAGS
    public static var jikesDefaultFlags: BuildSetting { 
        BuildSetting(key: .jikesDefaultFlags, value: "+E +OLDCSO")
    }

    /// JIKES_DEFAULT_FLAGS
    public static func jikesDefaultFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .jikesDefaultFlags, value: .array(value))
    }

    /// JIKES_DEFAULT_FLAGS
    public static func jikesDefaultFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .jikesDefaultFlags, inherit: key)
    }

    /// JIKES_DEFAULT_FLAGS
    public static func jikesDefaultFlags(_ value: String...) -> BuildSetting { 
        .jikesDefaultFlags(value)
    }
}

extension BuildSettingsKey {

    /// JIKES_DEFAULT_FLAGS
    public static let jikesDefaultFlags: BuildSettingsKey = "JIKES_DEFAULT_FLAGS"
}

// MARK: Preserve Private External Symbols
extension BuildSetting {

    /// Preserve Private External Symbols
    ///
    /// Activating this setting will preserve private external symbols, rather than turning them into static symbols. This setting is also respected when performing a single-object prelink.
    public static var preservePrivateExternalSymbols: BuildSetting { 
        BuildSetting(key: .preservePrivateExternalSymbols, value: "NO")
    }

    /// Preserve Private External Symbols
    ///
    /// Activating this setting will preserve private external symbols, rather than turning them into static symbols. This setting is also respected when performing a single-object prelink.
    public static func preservePrivateExternalSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .preservePrivateExternalSymbols, value: SettingValue(booleanLiteral: value))
    }

    /// Preserve Private External Symbols
    ///
    /// Activating this setting will preserve private external symbols, rather than turning them into static symbols. This setting is also respected when performing a single-object prelink.
    public static func preservePrivateExternalSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preservePrivateExternalSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Preserve Private External Symbols
    ///
    /// Activating this setting will preserve private external symbols, rather than turning them into static symbols. This setting is also respected when performing a single-object prelink.
    public static let preservePrivateExternalSymbols: BuildSettingsKey = "KEEP_PRIVATE_EXTERNS"
}

// MARK: KEXT_CFLAGS
extension BuildSetting {

    /// KEXT_CFLAGS
    public static var kextCflags: BuildSetting { 
        BuildSetting(key: .kextCflags, value: "")
    }

    /// KEXT_CFLAGS
    public static func kextCflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .kextCflags, value: .array(value))
    }

    /// KEXT_CFLAGS
    public static func kextCflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .kextCflags, inherit: key)
    }

    /// KEXT_CFLAGS
    public static func kextCflags(_ value: String...) -> BuildSetting { 
        .kextCflags(value)
    }
}

extension BuildSettingsKey {

    /// KEXT_CFLAGS
    public static let kextCflags: BuildSettingsKey = "KEXT_CFLAGS"
}

// MARK: KEXT_CPLUSPLUSFLAGS
extension BuildSetting {

    /// KEXT_CPLUSPLUSFLAGS
    public static var kextCplusplusflags: BuildSetting { 
        .kextCplusplusflags(inherit: .kextCflags) 
    }

    /// KEXT_CPLUSPLUSFLAGS
    public static func kextCplusplusflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .kextCplusplusflags, value: .array(value))
    }

    /// KEXT_CPLUSPLUSFLAGS
    public static func kextCplusplusflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .kextCplusplusflags, inherit: key)
    }

    /// KEXT_CPLUSPLUSFLAGS
    public static func kextCplusplusflags(_ value: String...) -> BuildSetting { 
        .kextCplusplusflags(value)
    }
}

extension BuildSettingsKey {

    /// KEXT_CPLUSPLUSFLAGS
    public static let kextCplusplusflags: BuildSettingsKey = "KEXT_CPLUSPLUSFLAGS"
}

// MARK: LD_ADDITIONAL_DEPLOYMENT_TARGET_FLAGS
extension BuildSetting {

    /// LD_ADDITIONAL_DEPLOYMENT_TARGET_FLAGS
    public static func ldAdditionalDeploymentTargetFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ldAdditionalDeploymentTargetFlags, value: .array(value))
    }

    /// LD_ADDITIONAL_DEPLOYMENT_TARGET_FLAGS
    public static func ldAdditionalDeploymentTargetFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldAdditionalDeploymentTargetFlags, inherit: key)
    }

    /// LD_ADDITIONAL_DEPLOYMENT_TARGET_FLAGS
    public static func ldAdditionalDeploymentTargetFlags(_ value: String...) -> BuildSetting { 
        .ldAdditionalDeploymentTargetFlags(value)
    }
}

extension BuildSettingsKey {

    /// LD_ADDITIONAL_DEPLOYMENT_TARGET_FLAGS
    public static let ldAdditionalDeploymentTargetFlags: BuildSettingsKey = "LD_ADDITIONAL_DEPLOYMENT_TARGET_FLAGS"
}

// MARK: LD_BITCODE_GENERATION_MODE
extension BuildSetting {

    /// LD_BITCODE_GENERATION_MODE
    public static var ldBitcodeGenerationMode: BuildSetting { 
        .ldBitcodeGenerationMode(inherit: .bitcodeGenerationMode) 
    }

    /// LD_BITCODE_GENERATION_MODE
    public static func ldBitcodeGenerationMode(_ value: LdBitcodeGenerationMode) -> BuildSetting { 
        BuildSetting(key: .ldBitcodeGenerationMode, value: "\(value)")
    }

    /// LD_BITCODE_GENERATION_MODE
    public static func ldBitcodeGenerationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldBitcodeGenerationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_BITCODE_GENERATION_MODE
    public static let ldBitcodeGenerationMode: BuildSettingsKey = "LD_BITCODE_GENERATION_MODE"
}

public enum LdBitcodeGenerationMode: String, Hashable, Codable, CustomStringConvertible {
    case marker = "marker"
    case bitcode = "bitcode"

    public var description: String {
        rawValue
    }
}

// MARK: LD_DEBUG_VARIANT
extension BuildSetting {

    /// LD_DEBUG_VARIANT
    public static var ldDebugVariant: BuildSetting { 
        BuildSetting(key: .ldDebugVariant, value: "YES")
    }

    /// LD_DEBUG_VARIANT
    public static func ldDebugVariant(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldDebugVariant, value: SettingValue(booleanLiteral: value))
    }

    /// LD_DEBUG_VARIANT
    public static func ldDebugVariant(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldDebugVariant, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_DEBUG_VARIANT
    public static let ldDebugVariant: BuildSettingsKey = "LD_DEBUG_VARIANT"
}

// MARK: Path to Linker Dependency Info File
extension BuildSetting {

    /// Path to Linker Dependency Info File
    ///
    /// This setting defines the path to which the linker should emit information about what files it used as inputs and generated. Xcode uses this information for its dependency tracking. Setting the value of this setting to empty will disable passing this option to the linker.
    public static var pathToLinkerDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .pathToLinkerDependencyInfoFile, value: "$(OBJECT_FILE_DIR_$(CURRENT_VARIANT))/$(CURRENT_ARCH)/$(PRODUCT_NAME)_dependency_info.dat")
    }

    /// Path to Linker Dependency Info File
    ///
    /// This setting defines the path to which the linker should emit information about what files it used as inputs and generated. Xcode uses this information for its dependency tracking. Setting the value of this setting to empty will disable passing this option to the linker.
    public static func pathToLinkerDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pathToLinkerDependencyInfoFile, value: "\(value)")
    }

    /// Path to Linker Dependency Info File
    ///
    /// This setting defines the path to which the linker should emit information about what files it used as inputs and generated. Xcode uses this information for its dependency tracking. Setting the value of this setting to empty will disable passing this option to the linker.
    public static func pathToLinkerDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pathToLinkerDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Path to Linker Dependency Info File
    ///
    /// This setting defines the path to which the linker should emit information about what files it used as inputs and generated. Xcode uses this information for its dependency tracking. Setting the value of this setting to empty will disable passing this option to the linker.
    public static let pathToLinkerDependencyInfoFile: BuildSettingsKey = "LD_DEPENDENCY_INFO_FILE"
}

// MARK: LD_DEPLOYMENT_TARGET
extension BuildSetting {

    /// LD_DEPLOYMENT_TARGET
    public static var ldDeploymentTarget: BuildSetting { 
        BuildSetting(key: .ldDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// LD_DEPLOYMENT_TARGET
    public static func ldDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ldDeploymentTarget, value: "\(value)")
    }

    /// LD_DEPLOYMENT_TARGET
    public static func ldDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_DEPLOYMENT_TARGET
    public static let ldDeploymentTarget: BuildSettingsKey = "LD_DEPLOYMENT_TARGET"
}

// MARK: LD_DONT_RUN_DEDUPLICATION
extension BuildSetting {

    /// LD_DONT_RUN_DEDUPLICATION
    public static var ldDontRunDeduplication: BuildSetting { 
        BuildSetting(key: .ldDontRunDeduplication, value: "YES")
    }

    /// LD_DONT_RUN_DEDUPLICATION
    public static func ldDontRunDeduplication(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldDontRunDeduplication, value: SettingValue(booleanLiteral: value))
    }

    /// LD_DONT_RUN_DEDUPLICATION
    public static func ldDontRunDeduplication(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldDontRunDeduplication, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_DONT_RUN_DEDUPLICATION
    public static let ldDontRunDeduplication: BuildSettingsKey = "LD_DONT_RUN_DEDUPLICATION"
}

// MARK: Dynamic Library Allowable Clients
extension BuildSetting {

    /// Dynamic Library Allowable Clients
    ///
    /// This setting restricts the clients allowed to link a dylib by passing `-allowable_client` to the linker for each supplied value.
    public static var dynamicLibraryAllowableClients: BuildSetting { 
        BuildSetting(key: .dynamicLibraryAllowableClients, value: "")
    }

    /// Dynamic Library Allowable Clients
    ///
    /// This setting restricts the clients allowed to link a dylib by passing `-allowable_client` to the linker for each supplied value.
    public static func dynamicLibraryAllowableClients(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .dynamicLibraryAllowableClients, value: .array(value))
    }

    /// Dynamic Library Allowable Clients
    ///
    /// This setting restricts the clients allowed to link a dylib by passing `-allowable_client` to the linker for each supplied value.
    public static func dynamicLibraryAllowableClients(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dynamicLibraryAllowableClients, inherit: key)
    }

    /// Dynamic Library Allowable Clients
    ///
    /// This setting restricts the clients allowed to link a dylib by passing `-allowable_client` to the linker for each supplied value.
    public static func dynamicLibraryAllowableClients(_ value: String...) -> BuildSetting { 
        .dynamicLibraryAllowableClients(value)
    }
}

extension BuildSettingsKey {

    /// Dynamic Library Allowable Clients
    ///
    /// This setting restricts the clients allowed to link a dylib by passing `-allowable_client` to the linker for each supplied value.
    public static let dynamicLibraryAllowableClients: BuildSettingsKey = "LD_DYLIB_ALLOWABLE_CLIENTS"
}

// MARK: Dynamic Library Install Name
extension BuildSetting {

    /// Dynamic Library Install Name
    ///
    /// Sets an internal `install path` (`LC_ID_DYLIB`) in a dynamic library. Any clients linked against the library will record that path as the way `dyld` should locate this library. If this option is not specified, then the `-o` path will be used. This setting is ignored when building any product other than a dynamic library. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static var dynamicLibraryInstallName: BuildSetting { 
        BuildSetting(key: .dynamicLibraryInstallName, value: "")
    }

    /// Dynamic Library Install Name
    ///
    /// Sets an internal `install path` (`LC_ID_DYLIB`) in a dynamic library. Any clients linked against the library will record that path as the way `dyld` should locate this library. If this option is not specified, then the `-o` path will be used. This setting is ignored when building any product other than a dynamic library. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func dynamicLibraryInstallName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .dynamicLibraryInstallName, value: "\(value)")
    }

    /// Dynamic Library Install Name
    ///
    /// Sets an internal `install path` (`LC_ID_DYLIB`) in a dynamic library. Any clients linked against the library will record that path as the way `dyld` should locate this library. If this option is not specified, then the `-o` path will be used. This setting is ignored when building any product other than a dynamic library. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func dynamicLibraryInstallName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .dynamicLibraryInstallName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Dynamic Library Install Name
    ///
    /// Sets an internal `install path` (`LC_ID_DYLIB`) in a dynamic library. Any clients linked against the library will record that path as the way `dyld` should locate this library. If this option is not specified, then the `-o` path will be used. This setting is ignored when building any product other than a dynamic library. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static let dynamicLibraryInstallName: BuildSettingsKey = "LD_DYLIB_INSTALL_NAME"
}

// MARK: LD_ENTITLEMENTS_SECTION
extension BuildSetting {

    /// LD_ENTITLEMENTS_SECTION
    public static var ldEntitlementsSection: BuildSetting { 
        BuildSetting(key: .ldEntitlementsSection, value: "")
    }

    /// LD_ENTITLEMENTS_SECTION
    public static func ldEntitlementsSection(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ldEntitlementsSection, value: "\(value)")
    }

    /// LD_ENTITLEMENTS_SECTION
    public static func ldEntitlementsSection(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldEntitlementsSection, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_ENTITLEMENTS_SECTION
    public static let ldEntitlementsSection: BuildSettingsKey = "LD_ENTITLEMENTS_SECTION"
}

// MARK: LD_EXPORT_GLOBAL_SYMBOLS
extension BuildSetting {

    /// LD_EXPORT_GLOBAL_SYMBOLS
    public static var ldExportGlobalSymbols: BuildSetting { 
        BuildSetting(key: .ldExportGlobalSymbols, value: "NO")
    }

    /// LD_EXPORT_GLOBAL_SYMBOLS
    public static func ldExportGlobalSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldExportGlobalSymbols, value: SettingValue(booleanLiteral: value))
    }

    /// LD_EXPORT_GLOBAL_SYMBOLS
    public static func ldExportGlobalSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldExportGlobalSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_EXPORT_GLOBAL_SYMBOLS
    public static let ldExportGlobalSymbols: BuildSettingsKey = "LD_EXPORT_GLOBAL_SYMBOLS"
}

// MARK: LD_FINAL_OUTPUT_FILE
extension BuildSetting {

    /// LD_FINAL_OUTPUT_FILE
    public static var ldFinalOutputFile: BuildSetting { 
        BuildSetting(key: .ldFinalOutputFile, value: "$(INSTALL_PATH)/$(EXECUTABLE_PATH)")
    }

    /// LD_FINAL_OUTPUT_FILE
    public static func ldFinalOutputFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ldFinalOutputFile, value: "\(value)")
    }

    /// LD_FINAL_OUTPUT_FILE
    public static func ldFinalOutputFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldFinalOutputFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_FINAL_OUTPUT_FILE
    public static let ldFinalOutputFile: BuildSettingsKey = "LD_FINAL_OUTPUT_FILE"
}

// MARK: LD_FLAGS
extension BuildSetting {

    /// LD_FLAGS
    public static var ldFlags: BuildSetting { 
        BuildSetting(key: .ldFlags, value: "")
    }

    /// LD_FLAGS
    public static func ldFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ldFlags, value: .array(value))
    }

    /// LD_FLAGS
    public static func ldFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldFlags, inherit: key)
    }

    /// LD_FLAGS
    public static func ldFlags(_ value: String...) -> BuildSetting { 
        .ldFlags(value)
    }
}

extension BuildSettingsKey {

    /// LD_FLAGS
    public static let ldFlags: BuildSettingsKey = "LD_FLAGS"
}

// MARK: LD_GENERATE_BITCODE_SYMBOL_MAP
extension BuildSetting {

    /// LD_GENERATE_BITCODE_SYMBOL_MAP
    public static var ldGenerateBitcodeSymbolMap: BuildSetting { 
        .ldGenerateBitcodeSymbolMap(inherit: .hideBitcodeSymbols) 
    }

    /// LD_GENERATE_BITCODE_SYMBOL_MAP
    public static func ldGenerateBitcodeSymbolMap(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldGenerateBitcodeSymbolMap, value: SettingValue(booleanLiteral: value))
    }

    /// LD_GENERATE_BITCODE_SYMBOL_MAP
    public static func ldGenerateBitcodeSymbolMap(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldGenerateBitcodeSymbolMap, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_GENERATE_BITCODE_SYMBOL_MAP
    public static let ldGenerateBitcodeSymbolMap: BuildSettingsKey = "LD_GENERATE_BITCODE_SYMBOL_MAP"
}

// MARK: Write Link Map File
extension BuildSetting {

    /// Write Link Map File
    ///
    /// Activating this setting will cause the linker to write a map file to disk, which details all symbols and their addresses in the output image. The path to the map file is defined by the [Path to Link Map File (LD\_MAP\_FILE\_PATH)](itcaec37c2a6.html#dev0f5aa9fe1) setting.
    public static var writeLinkMapFile: BuildSetting { 
        BuildSetting(key: .writeLinkMapFile, value: "NO")
    }

    /// Write Link Map File
    ///
    /// Activating this setting will cause the linker to write a map file to disk, which details all symbols and their addresses in the output image. The path to the map file is defined by the [Path to Link Map File (LD\_MAP\_FILE\_PATH)](itcaec37c2a6.html#dev0f5aa9fe1) setting.
    public static func writeLinkMapFile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .writeLinkMapFile, value: SettingValue(booleanLiteral: value))
    }

    /// Write Link Map File
    ///
    /// Activating this setting will cause the linker to write a map file to disk, which details all symbols and their addresses in the output image. The path to the map file is defined by the [Path to Link Map File (LD\_MAP\_FILE\_PATH)](itcaec37c2a6.html#dev0f5aa9fe1) setting.
    public static func writeLinkMapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .writeLinkMapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Write Link Map File
    ///
    /// Activating this setting will cause the linker to write a map file to disk, which details all symbols and their addresses in the output image. The path to the map file is defined by the [Path to Link Map File (LD\_MAP\_FILE\_PATH)](itcaec37c2a6.html#dev0f5aa9fe1) setting.
    public static let writeLinkMapFile: BuildSettingsKey = "LD_GENERATE_MAP_FILE"
}

// MARK: LD_HIDE_BITCODE_SYMBOLS
extension BuildSetting {

    /// LD_HIDE_BITCODE_SYMBOLS
    public static var ldHideBitcodeSymbols: BuildSetting { 
        .ldHideBitcodeSymbols(inherit: .hideBitcodeSymbols) 
    }

    /// LD_HIDE_BITCODE_SYMBOLS
    public static func ldHideBitcodeSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldHideBitcodeSymbols, value: SettingValue(booleanLiteral: value))
    }

    /// LD_HIDE_BITCODE_SYMBOLS
    public static func ldHideBitcodeSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldHideBitcodeSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_HIDE_BITCODE_SYMBOLS
    public static let ldHideBitcodeSymbols: BuildSettingsKey = "LD_HIDE_BITCODE_SYMBOLS"
}

// MARK: LD_LTO_OBJECT_FILE
extension BuildSetting {

    /// LD_LTO_OBJECT_FILE
    public static var ldLtoObjectFile: BuildSetting { 
        BuildSetting(key: .ldLtoObjectFile, value: "$(OBJECT_FILE_DIR_$(CURRENT_VARIANT))/$(CURRENT_ARCH)/$(PRODUCT_NAME)_lto.o")
    }

    /// LD_LTO_OBJECT_FILE
    public static func ldLtoObjectFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .ldLtoObjectFile, value: "\(value)")
    }

    /// LD_LTO_OBJECT_FILE
    public static func ldLtoObjectFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldLtoObjectFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_LTO_OBJECT_FILE
    public static let ldLtoObjectFile: BuildSettingsKey = "LD_LTO_OBJECT_FILE"
}

// MARK: Path to Link Map File
extension BuildSetting {

    /// Path to Link Map File
    ///
    /// This setting defines the path to the map file written by the linker when the [Write Link Map File (LD\_GENERATE\_MAP\_FILE)](itcaec37c2a6.html#devc1145996b) setting is activated. By default, a separate file will be written for each architecture and build variant, and these will be generated in the Intermediates directory for the target whose product is being linked.
    public static var pathToLinkMapFile: BuildSetting { 
        BuildSetting(key: .pathToLinkMapFile, value: "$(TARGET_TEMP_DIR)/$(PRODUCT_NAME)-LinkMap-$(CURRENT_VARIANT)-$(CURRENT_ARCH).txt")
    }

    /// Path to Link Map File
    ///
    /// This setting defines the path to the map file written by the linker when the [Write Link Map File (LD\_GENERATE\_MAP\_FILE)](itcaec37c2a6.html#devc1145996b) setting is activated. By default, a separate file will be written for each architecture and build variant, and these will be generated in the Intermediates directory for the target whose product is being linked.
    public static func pathToLinkMapFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pathToLinkMapFile, value: "\(value)")
    }

    /// Path to Link Map File
    ///
    /// This setting defines the path to the map file written by the linker when the [Write Link Map File (LD\_GENERATE\_MAP\_FILE)](itcaec37c2a6.html#devc1145996b) setting is activated. By default, a separate file will be written for each architecture and build variant, and these will be generated in the Intermediates directory for the target whose product is being linked.
    public static func pathToLinkMapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pathToLinkMapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Path to Link Map File
    ///
    /// This setting defines the path to the map file written by the linker when the [Write Link Map File (LD\_GENERATE\_MAP\_FILE)](itcaec37c2a6.html#devc1145996b) setting is activated. By default, a separate file will be written for each architecture and build variant, and these will be generated in the Intermediates directory for the target whose product is being linked.
    public static let pathToLinkMapFile: BuildSettingsKey = "LD_MAP_FILE_PATH"
}

// MARK: Generate Position-Dependent Executable
extension BuildSetting {

    /// Generate Position-Dependent Executable
    ///
    /// Activating this setting will prevent Xcode from building a main executable that is position independent (PIE). When targeting macOS 10.7 or later, PIE is the default for main executables, so activating this setting will change that behavior. When targeting OS X 10.6 or earlier, or when building for i386, PIE is not the default, so activating this setting does nothing.

You cannot create a PIE from `.o` files compiled with `-mdynamic-no-pic`. Using PIE means the codegen is less optimal, but the address randomization adds some security.
    public static var generatePositionDependentExecutable: BuildSetting { 
        BuildSetting(key: .generatePositionDependentExecutable, value: "NO")
    }

    /// Generate Position-Dependent Executable
    ///
    /// Activating this setting will prevent Xcode from building a main executable that is position independent (PIE). When targeting macOS 10.7 or later, PIE is the default for main executables, so activating this setting will change that behavior. When targeting OS X 10.6 or earlier, or when building for i386, PIE is not the default, so activating this setting does nothing.

You cannot create a PIE from `.o` files compiled with `-mdynamic-no-pic`. Using PIE means the codegen is less optimal, but the address randomization adds some security.
    public static func generatePositionDependentExecutable(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generatePositionDependentExecutable, value: SettingValue(booleanLiteral: value))
    }

    /// Generate Position-Dependent Executable
    ///
    /// Activating this setting will prevent Xcode from building a main executable that is position independent (PIE). When targeting macOS 10.7 or later, PIE is the default for main executables, so activating this setting will change that behavior. When targeting OS X 10.6 or earlier, or when building for i386, PIE is not the default, so activating this setting does nothing.

You cannot create a PIE from `.o` files compiled with `-mdynamic-no-pic`. Using PIE means the codegen is less optimal, but the address randomization adds some security.
    public static func generatePositionDependentExecutable(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatePositionDependentExecutable, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Position-Dependent Executable
    ///
    /// Activating this setting will prevent Xcode from building a main executable that is position independent (PIE). When targeting macOS 10.7 or later, PIE is the default for main executables, so activating this setting will change that behavior. When targeting OS X 10.6 or earlier, or when building for i386, PIE is not the default, so activating this setting does nothing.

You cannot create a PIE from `.o` files compiled with `-mdynamic-no-pic`. Using PIE means the codegen is less optimal, but the address randomization adds some security.
    public static let generatePositionDependentExecutable: BuildSettingsKey = "LD_NO_PIE"
}

// MARK: LD_OBJC_ABI_VERSION
extension BuildSetting {

    /// LD_OBJC_ABI_VERSION
    public static var ldObjcAbiVersion: BuildSetting { 
        BuildSetting(key: .ldObjcAbiVersion, value: "$(OBJC_ABI_VERSION)")
    }

    /// LD_OBJC_ABI_VERSION
    public static func ldObjcAbiVersion(_ value: LdObjcAbiVersion) -> BuildSetting { 
        BuildSetting(key: .ldObjcAbiVersion, value: "\(value)")
    }

    /// LD_OBJC_ABI_VERSION
    public static func ldObjcAbiVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldObjcAbiVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_OBJC_ABI_VERSION
    public static let ldObjcAbiVersion: BuildSettingsKey = "LD_OBJC_ABI_VERSION"
}

public enum LdObjcAbiVersion: String, Hashable, Codable, CustomStringConvertible {
    case _1 = "1"
    case _2 = "2"

    public var description: String {
        rawValue
    }
}

// MARK: Quote Linker Arguments
extension BuildSetting {

    /// Quote Linker Arguments
    ///
    /// This setting controls whether arguments to the linker should be quoted using `-Xlinker`. By default, Xcode invokes the linker by invoking the driver of the compiler used to build the source files in the target, and passing `-Xlinker` to quote arguments will cause the compiler driver to pass them through to the linker (rather than trying to evaluate them within the driver). By default, this setting is enabled. Disabling it will cause Xcode to not use `-Xlinker` to pass arguments to the linker. Disabling this setting is useful if the target has instructed Xcode to use an alternate linker (for example, by setting the `LD` setting to the path to another linker) and that alternate linker does not recognize `-Xlinker`.
    public static var quoteLinkerArguments: BuildSetting { 
        BuildSetting(key: .quoteLinkerArguments, value: "YES")
    }

    /// Quote Linker Arguments
    ///
    /// This setting controls whether arguments to the linker should be quoted using `-Xlinker`. By default, Xcode invokes the linker by invoking the driver of the compiler used to build the source files in the target, and passing `-Xlinker` to quote arguments will cause the compiler driver to pass them through to the linker (rather than trying to evaluate them within the driver). By default, this setting is enabled. Disabling it will cause Xcode to not use `-Xlinker` to pass arguments to the linker. Disabling this setting is useful if the target has instructed Xcode to use an alternate linker (for example, by setting the `LD` setting to the path to another linker) and that alternate linker does not recognize `-Xlinker`.
    public static func quoteLinkerArguments(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .quoteLinkerArguments, value: SettingValue(booleanLiteral: value))
    }

    /// Quote Linker Arguments
    ///
    /// This setting controls whether arguments to the linker should be quoted using `-Xlinker`. By default, Xcode invokes the linker by invoking the driver of the compiler used to build the source files in the target, and passing `-Xlinker` to quote arguments will cause the compiler driver to pass them through to the linker (rather than trying to evaluate them within the driver). By default, this setting is enabled. Disabling it will cause Xcode to not use `-Xlinker` to pass arguments to the linker. Disabling this setting is useful if the target has instructed Xcode to use an alternate linker (for example, by setting the `LD` setting to the path to another linker) and that alternate linker does not recognize `-Xlinker`.
    public static func quoteLinkerArguments(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .quoteLinkerArguments, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Quote Linker Arguments
    ///
    /// This setting controls whether arguments to the linker should be quoted using `-Xlinker`. By default, Xcode invokes the linker by invoking the driver of the compiler used to build the source files in the target, and passing `-Xlinker` to quote arguments will cause the compiler driver to pass them through to the linker (rather than trying to evaluate them within the driver). By default, this setting is enabled. Disabling it will cause Xcode to not use `-Xlinker` to pass arguments to the linker. Disabling this setting is useful if the target has instructed Xcode to use an alternate linker (for example, by setting the `LD` setting to the path to another linker) and that alternate linker does not recognize `-Xlinker`.
    public static let quoteLinkerArguments: BuildSettingsKey = "LD_QUOTE_LINKER_ARGUMENTS_FOR_COMPILER_DRIVER"
}

// MARK: Runpath Search Paths
extension BuildSetting {

    /// Runpath Search Paths
    ///
    /// This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static var runpathSearchPaths: BuildSetting { 
        BuildSetting(key: .runpathSearchPaths, value: "")
    }

    /// Runpath Search Paths
    ///
    /// This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func runpathSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .runpathSearchPaths, value: .array(value))
    }

    /// Runpath Search Paths
    ///
    /// This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func runpathSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .runpathSearchPaths, inherit: key)
    }

    /// Runpath Search Paths
    ///
    /// This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static func runpathSearchPaths(_ value: String...) -> BuildSetting { 
        .runpathSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Runpath Search Paths
    ///
    /// This is a list of paths to be added to the `runpath` search path list for the image being created. At runtime, `dyld` uses the `runpath` when searching for dylibs whose load path begins with `@rpath/`. See [Dynamic Library Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html).
    public static let runpathSearchPaths: BuildSettingsKey = "LD_RUNPATH_SEARCH_PATHS"
}

// MARK: LD_TARGET_TRIPLE_ARCHS
extension BuildSetting {

    /// LD_TARGET_TRIPLE_ARCHS
    public static var ldTargetTripleArchs: BuildSetting { 
        .ldTargetTripleArchs(inherit: .currentArch) 
    }

    /// LD_TARGET_TRIPLE_ARCHS
    public static func ldTargetTripleArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ldTargetTripleArchs, value: .array(value))
    }

    /// LD_TARGET_TRIPLE_ARCHS
    public static func ldTargetTripleArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldTargetTripleArchs, inherit: key)
    }

    /// LD_TARGET_TRIPLE_ARCHS
    public static func ldTargetTripleArchs(_ value: String...) -> BuildSetting { 
        .ldTargetTripleArchs(value)
    }
}

extension BuildSettingsKey {

    /// LD_TARGET_TRIPLE_ARCHS
    public static let ldTargetTripleArchs: BuildSettingsKey = "LD_TARGET_TRIPLE_ARCHS"
}

// MARK: LD_TARGET_TRIPLE_VARIANTS
extension BuildSetting {

    /// LD_TARGET_TRIPLE_VARIANTS
    public static func ldTargetTripleVariants(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .ldTargetTripleVariants, value: .array(value))
    }

    /// LD_TARGET_TRIPLE_VARIANTS
    public static func ldTargetTripleVariants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldTargetTripleVariants, inherit: key)
    }

    /// LD_TARGET_TRIPLE_VARIANTS
    public static func ldTargetTripleVariants(_ value: String...) -> BuildSetting { 
        .ldTargetTripleVariants(value)
    }
}

extension BuildSettingsKey {

    /// LD_TARGET_TRIPLE_VARIANTS
    public static let ldTargetTripleVariants: BuildSettingsKey = "LD_TARGET_TRIPLE_VARIANTS"
}

// MARK: LD_THREAD_SANITIZER
extension BuildSetting {

    /// LD_THREAD_SANITIZER
    public static var ldThreadSanitizer: BuildSetting { 
        BuildSetting(key: .ldThreadSanitizer, value: "$(ENABLE_THREAD_SANITIZER)")
    }

    /// LD_THREAD_SANITIZER
    public static func ldThreadSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldThreadSanitizer, value: SettingValue(booleanLiteral: value))
    }

    /// LD_THREAD_SANITIZER
    public static func ldThreadSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldThreadSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_THREAD_SANITIZER
    public static let ldThreadSanitizer: BuildSettingsKey = "LD_THREAD_SANITIZER"
}

// MARK: LD_VERIFY_BITCODE
extension BuildSetting {

    /// LD_VERIFY_BITCODE
    public static var ldVerifyBitcode: BuildSetting { 
        BuildSetting(key: .ldVerifyBitcode, value: "YES")
    }

    /// LD_VERIFY_BITCODE
    public static func ldVerifyBitcode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ldVerifyBitcode, value: SettingValue(booleanLiteral: value))
    }

    /// LD_VERIFY_BITCODE
    public static func ldVerifyBitcode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ldVerifyBitcode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LD_VERIFY_BITCODE
    public static let ldVerifyBitcode: BuildSettingsKey = "LD_VERIFY_BITCODE"
}

// MARK: LEX
extension BuildSetting {

    /// LEX
    public static var lex: BuildSetting { 
        BuildSetting(key: .lex, value: "lex")
    }

    /// LEX
    public static func lex(_ value: String) -> BuildSetting { 
        BuildSetting(key: .lex, value: "\(value)")
    }

    /// LEX
    public static func lex(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .lex, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LEX
    public static let lex: BuildSettingsKey = "LEX"
}

// MARK: Other Lex Flags
extension BuildSetting {

    /// Other Lex Flags
    ///
    /// Space-separated list of additional flags to pass to `lex`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `lex` flag.
    public static var otherLexFlags: BuildSetting { 
        BuildSetting(key: .otherLexFlags, value: "")
    }

    /// Other Lex Flags
    ///
    /// Space-separated list of additional flags to pass to `lex`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `lex` flag.
    public static func otherLexFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherLexFlags, value: .array(value))
    }

    /// Other Lex Flags
    ///
    /// Space-separated list of additional flags to pass to `lex`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `lex` flag.
    public static func otherLexFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherLexFlags, inherit: key)
    }

    /// Other Lex Flags
    ///
    /// Space-separated list of additional flags to pass to `lex`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `lex` flag.
    public static func otherLexFlags(_ value: String...) -> BuildSetting { 
        .otherLexFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Lex Flags
    ///
    /// Space-separated list of additional flags to pass to `lex`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `lex` flag.
    public static let otherLexFlags: BuildSettingsKey = "LEXFLAGS"
}

// MARK: Generate Case-Insensitive Scanner
extension BuildSetting {

    /// Generate Case-Insensitive Scanner
    ///
    /// Enabling this option causes `lex` to generate a case-insensitive scanner. The case of letters given in the `lex` input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in `yytext` will have the preserved case (for example, it will not be folded).
    public static var generateCaseInsensitiveScanner: BuildSetting { 
        BuildSetting(key: .generateCaseInsensitiveScanner, value: "NO")
    }

    /// Generate Case-Insensitive Scanner
    ///
    /// Enabling this option causes `lex` to generate a case-insensitive scanner. The case of letters given in the `lex` input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in `yytext` will have the preserved case (for example, it will not be folded).
    public static func generateCaseInsensitiveScanner(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateCaseInsensitiveScanner, value: SettingValue(booleanLiteral: value))
    }

    /// Generate Case-Insensitive Scanner
    ///
    /// Enabling this option causes `lex` to generate a case-insensitive scanner. The case of letters given in the `lex` input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in `yytext` will have the preserved case (for example, it will not be folded).
    public static func generateCaseInsensitiveScanner(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateCaseInsensitiveScanner, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Case-Insensitive Scanner
    ///
    /// Enabling this option causes `lex` to generate a case-insensitive scanner. The case of letters given in the `lex` input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in `yytext` will have the preserved case (for example, it will not be folded).
    public static let generateCaseInsensitiveScanner: BuildSettingsKey = "LEX_CASE_INSENSITIVE_SCANNER"
}

// MARK: Insert #line Directives
extension BuildSetting {

    /// Insert #line Directives
    ///
    /// Enabling this option instructs `lex` to insert `#line` directives so error messages in the actions will be correctly located with respect to either the original `lex` input file (if the errors are due to code in the input file), or `lex.yy.c` (if the errors are `lex`'s fault). This option is enabled by default; disabling it passes a flag to `lex` to not insert `#line` directives.
    public static var insertLineDirectives: BuildSetting { 
        BuildSetting(key: .insertLineDirectives, value: "YES")
    }

    /// Insert #line Directives
    ///
    /// Enabling this option instructs `lex` to insert `#line` directives so error messages in the actions will be correctly located with respect to either the original `lex` input file (if the errors are due to code in the input file), or `lex.yy.c` (if the errors are `lex`'s fault). This option is enabled by default; disabling it passes a flag to `lex` to not insert `#line` directives.
    public static func insertLineDirectives(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .insertLineDirectives, value: SettingValue(booleanLiteral: value))
    }

    /// Insert #line Directives
    ///
    /// Enabling this option instructs `lex` to insert `#line` directives so error messages in the actions will be correctly located with respect to either the original `lex` input file (if the errors are due to code in the input file), or `lex.yy.c` (if the errors are `lex`'s fault). This option is enabled by default; disabling it passes a flag to `lex` to not insert `#line` directives.
    public static func insertLineDirectives(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .insertLineDirectives, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Insert #line Directives
    ///
    /// Enabling this option instructs `lex` to insert `#line` directives so error messages in the actions will be correctly located with respect to either the original `lex` input file (if the errors are due to code in the input file), or `lex.yy.c` (if the errors are `lex`'s fault). This option is enabled by default; disabling it passes a flag to `lex` to not insert `#line` directives.
    public static let insertLineDirectives: BuildSettingsKey = "LEX_INSERT_LINE_DIRECTIVES"
}

// MARK: Suppress Default Rule
extension BuildSetting {

    /// Suppress Default Rule
    ///
    /// Enabling this option causes the default rule (that unmatched scanner input is echoed to `stdout`) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner's rule set.
    public static var suppressDefaultRule: BuildSetting { 
        BuildSetting(key: .suppressDefaultRule, value: "NO")
    }

    /// Suppress Default Rule
    ///
    /// Enabling this option causes the default rule (that unmatched scanner input is echoed to `stdout`) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner's rule set.
    public static func suppressDefaultRule(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressDefaultRule, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress Default Rule
    ///
    /// Enabling this option causes the default rule (that unmatched scanner input is echoed to `stdout`) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner's rule set.
    public static func suppressDefaultRule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressDefaultRule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress Default Rule
    ///
    /// Enabling this option causes the default rule (that unmatched scanner input is echoed to `stdout`) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner's rule set.
    public static let suppressDefaultRule: BuildSettingsKey = "LEX_SUPPRESS_DEFAULT_RULE"
}

// MARK: Suppress Warning Messages
extension BuildSetting {

    /// Suppress Warning Messages
    ///
    /// Enabling this option causes `lex` to suppress its warning messages.
    public static var suppressWarningMessages: BuildSetting { 
        BuildSetting(key: .suppressWarningMessages, value: "NO")
    }

    /// Suppress Warning Messages
    ///
    /// Enabling this option causes `lex` to suppress its warning messages.
    public static func suppressWarningMessages(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressWarningMessages, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress Warning Messages
    ///
    /// Enabling this option causes `lex` to suppress its warning messages.
    public static func suppressWarningMessages(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressWarningMessages, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress Warning Messages
    ///
    /// Enabling this option causes `lex` to suppress its warning messages.
    public static let suppressWarningMessages: BuildSettingsKey = "LEX_SUPPRESS_WARNINGS"
}

// MARK: LIBRARY_DEXT_INSTALL_PATH
extension BuildSetting {

    /// LIBRARY_DEXT_INSTALL_PATH
    public static var libraryDextInstallPath: BuildSetting { 
        BuildSetting(key: .libraryDextInstallPath, value: "$(LOCAL_LIBRARY_DIR)/DriverExtensions")
    }

    /// LIBRARY_DEXT_INSTALL_PATH
    public static func libraryDextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libraryDextInstallPath, value: "\(value)")
    }

    /// LIBRARY_DEXT_INSTALL_PATH
    public static func libraryDextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libraryDextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LIBRARY_DEXT_INSTALL_PATH
    public static let libraryDextInstallPath: BuildSettingsKey = "LIBRARY_DEXT_INSTALL_PATH"
}

// MARK: LIBRARY_FLAG_NOSPACE
extension BuildSetting {

    /// LIBRARY_FLAG_NOSPACE
    public static var libraryFlagNospace: BuildSetting { 
        BuildSetting(key: .libraryFlagNospace, value: "YES")
    }

    /// LIBRARY_FLAG_NOSPACE
    public static func libraryFlagNospace(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .libraryFlagNospace, value: SettingValue(booleanLiteral: value))
    }

    /// LIBRARY_FLAG_NOSPACE
    public static func libraryFlagNospace(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libraryFlagNospace, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LIBRARY_FLAG_NOSPACE
    public static let libraryFlagNospace: BuildSettingsKey = "LIBRARY_FLAG_NOSPACE"
}

// MARK: LIBRARY_FLAG_PREFIX
extension BuildSetting {

    /// LIBRARY_FLAG_PREFIX
    public static var libraryFlagPrefix: BuildSetting { 
        BuildSetting(key: .libraryFlagPrefix, value: "")
    }

    /// LIBRARY_FLAG_PREFIX
    public static func libraryFlagPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libraryFlagPrefix, value: "\(value)")
    }

    /// LIBRARY_FLAG_PREFIX
    public static func libraryFlagPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libraryFlagPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LIBRARY_FLAG_PREFIX
    public static let libraryFlagPrefix: BuildSettingsKey = "LIBRARY_FLAG_PREFIX"
}

// MARK: LIBRARY_KEXT_INSTALL_PATH
extension BuildSetting {

    /// LIBRARY_KEXT_INSTALL_PATH
    public static var libraryKextInstallPath: BuildSetting { 
        BuildSetting(key: .libraryKextInstallPath, value: "$(LOCAL_LIBRARY_DIR)/Extensions")
    }

    /// LIBRARY_KEXT_INSTALL_PATH
    public static func libraryKextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libraryKextInstallPath, value: "\(value)")
    }

    /// LIBRARY_KEXT_INSTALL_PATH
    public static func libraryKextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libraryKextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LIBRARY_KEXT_INSTALL_PATH
    public static let libraryKextInstallPath: BuildSettingsKey = "LIBRARY_KEXT_INSTALL_PATH"
}

// MARK: Library Search Paths
extension BuildSetting {

    /// Library Search Paths
    ///
    /// This is a list of paths to folders to be searched by the linker for libraries used by the product. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static var librarySearchPaths: BuildSetting { 
        BuildSetting(key: .librarySearchPaths, value: "")
    }

    /// Library Search Paths
    ///
    /// This is a list of paths to folders to be searched by the linker for libraries used by the product. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func librarySearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .librarySearchPaths, value: .array(value))
    }

    /// Library Search Paths
    ///
    /// This is a list of paths to folders to be searched by the linker for libraries used by the product. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func librarySearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .librarySearchPaths, inherit: key)
    }

    /// Library Search Paths
    ///
    /// This is a list of paths to folders to be searched by the linker for libraries used by the product. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func librarySearchPaths(_ value: String...) -> BuildSetting { 
        .librarySearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Library Search Paths
    ///
    /// This is a list of paths to folders to be searched by the linker for libraries used by the product. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static let librarySearchPaths: BuildSettingsKey = "LIBRARY_SEARCH_PATHS"
}

// MARK: LIBTOOL
extension BuildSetting {

    /// LIBTOOL
    public static var libtool: BuildSetting { 
        BuildSetting(key: .libtool, value: "libtool")
    }

    /// LIBTOOL
    public static func libtool(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libtool, value: "\(value)")
    }

    /// LIBTOOL
    public static func libtool(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libtool, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LIBTOOL
    public static let libtool: BuildSettingsKey = "LIBTOOL"
}

// MARK: LIBTOOL_DEPENDENCY_INFO_FILE
extension BuildSetting {

    /// LIBTOOL_DEPENDENCY_INFO_FILE
    public static var libtoolDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .libtoolDependencyInfoFile, value: "$(OBJECT_FILE_DIR_$(CURRENT_VARIANT))/$(CURRENT_ARCH)/$(PRODUCT_NAME)_libtool_dependency_info.dat")
    }

    /// LIBTOOL_DEPENDENCY_INFO_FILE
    public static func libtoolDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libtoolDependencyInfoFile, value: "\(value)")
    }

    /// LIBTOOL_DEPENDENCY_INFO_FILE
    public static func libtoolDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libtoolDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LIBTOOL_DEPENDENCY_INFO_FILE
    public static let libtoolDependencyInfoFile: BuildSettingsKey = "LIBTOOL_DEPENDENCY_INFO_FILE"
}

// MARK: LIBTOOL_DEPLOYMENT_TARGET
extension BuildSetting {

    /// LIBTOOL_DEPLOYMENT_TARGET
    public static var libtoolDeploymentTarget: BuildSetting { 
        BuildSetting(key: .libtoolDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// LIBTOOL_DEPLOYMENT_TARGET
    public static func libtoolDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .libtoolDeploymentTarget, value: "\(value)")
    }

    /// LIBTOOL_DEPLOYMENT_TARGET
    public static func libtoolDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libtoolDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LIBTOOL_DEPLOYMENT_TARGET
    public static let libtoolDeploymentTarget: BuildSettingsKey = "LIBTOOL_DEPLOYMENT_TARGET"
}

// MARK: LIBTOOL_DETERMINISTIC_MODE
extension BuildSetting {

    /// LIBTOOL_DETERMINISTIC_MODE
    public static var libtoolDeterministicMode: BuildSetting { 
        BuildSetting(key: .libtoolDeterministicMode, value: "YES")
    }

    /// LIBTOOL_DETERMINISTIC_MODE
    public static func libtoolDeterministicMode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .libtoolDeterministicMode, value: SettingValue(booleanLiteral: value))
    }

    /// LIBTOOL_DETERMINISTIC_MODE
    public static func libtoolDeterministicMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .libtoolDeterministicMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LIBTOOL_DETERMINISTIC_MODE
    public static let libtoolDeterministicMode: BuildSettingsKey = "LIBTOOL_DETERMINISTIC_MODE"
}

// MARK: Display Mangled Names
extension BuildSetting {

    /// Display Mangled Names
    ///
    /// Activating this setting causes the linker to display mangled names for C++ symbols. Normally, this is not recommended, but turning it on can help to diagnose and solve C++ link errors.
    public static var displayMangledNames: BuildSetting { 
        BuildSetting(key: .displayMangledNames, value: "NO")
    }

    /// Display Mangled Names
    ///
    /// Activating this setting causes the linker to display mangled names for C++ symbols. Normally, this is not recommended, but turning it on can help to diagnose and solve C++ link errors.
    public static func displayMangledNames(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .displayMangledNames, value: SettingValue(booleanLiteral: value))
    }

    /// Display Mangled Names
    ///
    /// Activating this setting causes the linker to display mangled names for C++ symbols. Normally, this is not recommended, but turning it on can help to diagnose and solve C++ link errors.
    public static func displayMangledNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .displayMangledNames, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Display Mangled Names
    ///
    /// Activating this setting causes the linker to display mangled names for C++ symbols. Normally, this is not recommended, but turning it on can help to diagnose and solve C++ link errors.
    public static let displayMangledNames: BuildSettingsKey = "LINKER_DISPLAYS_MANGLED_NAMES"
}

// MARK: LINKER_LIBRARY_FLAGS
extension BuildSetting {

    /// LINKER_LIBRARY_FLAGS
    public static var linkerLibraryFlags: BuildSetting { 
        BuildSetting(key: .linkerLibraryFlags, value: "")
    }

    /// LINKER_LIBRARY_FLAGS
    public static func linkerLibraryFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .linkerLibraryFlags, value: .array(value))
    }

    /// LINKER_LIBRARY_FLAGS
    public static func linkerLibraryFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkerLibraryFlags, inherit: key)
    }

    /// LINKER_LIBRARY_FLAGS
    public static func linkerLibraryFlags(_ value: String...) -> BuildSetting { 
        .linkerLibraryFlags(value)
    }
}

extension BuildSettingsKey {

    /// LINKER_LIBRARY_FLAGS
    public static let linkerLibraryFlags: BuildSettingsKey = "LINKER_LIBRARY_FLAGS"
}

// MARK: Link With Standard Libraries
extension BuildSetting {

    /// Link With Standard Libraries
    ///
    /// When this setting is enabled, the compiler driver will automatically pass its standard libraries to the linker to use during linking. If desired, this flag can be used to disable linking with the standard libraries, and then individual libraries can be passed as [Other Linker Flags (OTHER\_LDFLAGS)](itcaec37c2a6.html#dev4fc8ef90a).
    public static var linkWithStandardLibraries: BuildSetting { 
        BuildSetting(key: .linkWithStandardLibraries, value: "YES")
    }

    /// Link With Standard Libraries
    ///
    /// When this setting is enabled, the compiler driver will automatically pass its standard libraries to the linker to use during linking. If desired, this flag can be used to disable linking with the standard libraries, and then individual libraries can be passed as [Other Linker Flags (OTHER\_LDFLAGS)](itcaec37c2a6.html#dev4fc8ef90a).
    public static func linkWithStandardLibraries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .linkWithStandardLibraries, value: SettingValue(booleanLiteral: value))
    }

    /// Link With Standard Libraries
    ///
    /// When this setting is enabled, the compiler driver will automatically pass its standard libraries to the linker to use during linking. If desired, this flag can be used to disable linking with the standard libraries, and then individual libraries can be passed as [Other Linker Flags (OTHER\_LDFLAGS)](itcaec37c2a6.html#dev4fc8ef90a).
    public static func linkWithStandardLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkWithStandardLibraries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Link With Standard Libraries
    ///
    /// When this setting is enabled, the compiler driver will automatically pass its standard libraries to the linker to use during linking. If desired, this flag can be used to disable linking with the standard libraries, and then individual libraries can be passed as [Other Linker Flags (OTHER\_LDFLAGS)](itcaec37c2a6.html#dev4fc8ef90a).
    public static let linkWithStandardLibraries: BuildSettingsKey = "LINK_WITH_STANDARD_LIBRARIES"
}

// MARK: LLVM_IMPLICIT_AGGRESSIVE_OPTIMIZATIONS
extension BuildSetting {

    /// LLVM_IMPLICIT_AGGRESSIVE_OPTIMIZATIONS
    public static var llvmImplicitAggressiveOptimizations: BuildSetting { 
        BuildSetting(key: .llvmImplicitAggressiveOptimizations, value: "$(LLVM_OPTIMIZATION_LEVEL_VAL_$(GCC_OPTIMIZATION_LEVEL))")
    }

    /// LLVM_IMPLICIT_AGGRESSIVE_OPTIMIZATIONS
    public static func llvmImplicitAggressiveOptimizations(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .llvmImplicitAggressiveOptimizations, value: SettingValue(booleanLiteral: value))
    }

    /// LLVM_IMPLICIT_AGGRESSIVE_OPTIMIZATIONS
    public static func llvmImplicitAggressiveOptimizations(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmImplicitAggressiveOptimizations, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_IMPLICIT_AGGRESSIVE_OPTIMIZATIONS
    public static let llvmImplicitAggressiveOptimizations: BuildSettingsKey = "LLVM_IMPLICIT_AGGRESSIVE_OPTIMIZATIONS"
}

// MARK: Link-Time Optimization
extension BuildSetting {

    /// Link-Time Optimization
    ///
    /// Enabling this setting allows optimization across file boundaries during linking.

- _No:_ Disabled. Do not use link-time optimization.

- _Monolithic Link-Time Optimization:_ This mode performs monolithic link-time optimization of binaries, combining all executable code into a single unit and running aggressive compiler optimizations.

- _Incremental Link-Time Optimization:_ This mode performs partitioned link-time optimization of binaries, inlining between compilation units and running aggressive compiler optimizations on each unit in parallel. This enables fast incremental builds and uses less memory than Monolithic LTO.
    public static var linkTimeOptimization: BuildSetting { 
        .linkTimeOptimization(.no) 
    }

    /// Link-Time Optimization
    ///
    /// Enabling this setting allows optimization across file boundaries during linking.

- _No:_ Disabled. Do not use link-time optimization.

- _Monolithic Link-Time Optimization:_ This mode performs monolithic link-time optimization of binaries, combining all executable code into a single unit and running aggressive compiler optimizations.

- _Incremental Link-Time Optimization:_ This mode performs partitioned link-time optimization of binaries, inlining between compilation units and running aggressive compiler optimizations on each unit in parallel. This enables fast incremental builds and uses less memory than Monolithic LTO.
    public static func linkTimeOptimization(_ value: LinkTimeOptimization) -> BuildSetting { 
        BuildSetting(key: .linkTimeOptimization, value: "\(value)")
    }

    /// Link-Time Optimization
    ///
    /// Enabling this setting allows optimization across file boundaries during linking.

- _No:_ Disabled. Do not use link-time optimization.

- _Monolithic Link-Time Optimization:_ This mode performs monolithic link-time optimization of binaries, combining all executable code into a single unit and running aggressive compiler optimizations.

- _Incremental Link-Time Optimization:_ This mode performs partitioned link-time optimization of binaries, inlining between compilation units and running aggressive compiler optimizations on each unit in parallel. This enables fast incremental builds and uses less memory than Monolithic LTO.
    public static func linkTimeOptimization(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .linkTimeOptimization, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Link-Time Optimization
    ///
    /// Enabling this setting allows optimization across file boundaries during linking.

- _No:_ Disabled. Do not use link-time optimization.

- _Monolithic Link-Time Optimization:_ This mode performs monolithic link-time optimization of binaries, combining all executable code into a single unit and running aggressive compiler optimizations.

- _Incremental Link-Time Optimization:_ This mode performs partitioned link-time optimization of binaries, inlining between compilation units and running aggressive compiler optimizations on each unit in parallel. This enables fast incremental builds and uses less memory than Monolithic LTO.
    public static let linkTimeOptimization: BuildSettingsKey = "LLVM_LTO"
}

public enum LinkTimeOptimization: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case yesThin = "YES_THIN"
    case no = "NO"

    public var description: String {
        rawValue
    }
}


extension LinkTimeOptimization: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: LLVM_OPTIMIZATION_LEVEL_VAL_0
extension BuildSetting {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_0
    public static var llvmOptimizationLevelVal0: BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelVal0, value: "NO")
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_0
    public static func llvmOptimizationLevelVal0(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelVal0, value: SettingValue(booleanLiteral: value))
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_0
    public static func llvmOptimizationLevelVal0(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmOptimizationLevelVal0, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_0
    public static let llvmOptimizationLevelVal0: BuildSettingsKey = "LLVM_OPTIMIZATION_LEVEL_VAL_0"
}

// MARK: LLVM_OPTIMIZATION_LEVEL_VAL_1
extension BuildSetting {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_1
    public static var llvmOptimizationLevelVal1: BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelVal1, value: "NO")
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_1
    public static func llvmOptimizationLevelVal1(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelVal1, value: SettingValue(booleanLiteral: value))
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_1
    public static func llvmOptimizationLevelVal1(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmOptimizationLevelVal1, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_1
    public static let llvmOptimizationLevelVal1: BuildSettingsKey = "LLVM_OPTIMIZATION_LEVEL_VAL_1"
}

// MARK: LLVM_OPTIMIZATION_LEVEL_VAL_2
extension BuildSetting {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_2
    public static var llvmOptimizationLevelVal2: BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelVal2, value: "NO")
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_2
    public static func llvmOptimizationLevelVal2(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelVal2, value: SettingValue(booleanLiteral: value))
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_2
    public static func llvmOptimizationLevelVal2(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmOptimizationLevelVal2, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_2
    public static let llvmOptimizationLevelVal2: BuildSettingsKey = "LLVM_OPTIMIZATION_LEVEL_VAL_2"
}

// MARK: LLVM_OPTIMIZATION_LEVEL_VAL_3
extension BuildSetting {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_3
    public static var llvmOptimizationLevelVal3: BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelVal3, value: "NO")
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_3
    public static func llvmOptimizationLevelVal3(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelVal3, value: SettingValue(booleanLiteral: value))
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_3
    public static func llvmOptimizationLevelVal3(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmOptimizationLevelVal3, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_3
    public static let llvmOptimizationLevelVal3: BuildSettingsKey = "LLVM_OPTIMIZATION_LEVEL_VAL_3"
}

// MARK: LLVM_OPTIMIZATION_LEVEL_VAL_fast
extension BuildSetting {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_fast
    public static var llvmOptimizationLevelValFast: BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelValFast, value: "YES")
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_fast
    public static func llvmOptimizationLevelValFast(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelValFast, value: SettingValue(booleanLiteral: value))
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_fast
    public static func llvmOptimizationLevelValFast(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmOptimizationLevelValFast, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_fast
    public static let llvmOptimizationLevelValFast: BuildSettingsKey = "LLVM_OPTIMIZATION_LEVEL_VAL_fast"
}

// MARK: LLVM_OPTIMIZATION_LEVEL_VAL_s
extension BuildSetting {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_s
    public static var llvmOptimizationLevelValS: BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelValS, value: "NO")
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_s
    public static func llvmOptimizationLevelValS(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelValS, value: SettingValue(booleanLiteral: value))
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_s
    public static func llvmOptimizationLevelValS(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmOptimizationLevelValS, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_s
    public static let llvmOptimizationLevelValS: BuildSettingsKey = "LLVM_OPTIMIZATION_LEVEL_VAL_s"
}

// MARK: LLVM_OPTIMIZATION_LEVEL_VAL_z
extension BuildSetting {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_z
    public static var llvmOptimizationLevelValZ: BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelValZ, value: "NO")
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_z
    public static func llvmOptimizationLevelValZ(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .llvmOptimizationLevelValZ, value: SettingValue(booleanLiteral: value))
    }

    /// LLVM_OPTIMIZATION_LEVEL_VAL_z
    public static func llvmOptimizationLevelValZ(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmOptimizationLevelValZ, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_OPTIMIZATION_LEVEL_VAL_z
    public static let llvmOptimizationLevelValZ: BuildSettingsKey = "LLVM_OPTIMIZATION_LEVEL_VAL_z"
}

// MARK: LLVM_TARGET_TRIPLE_OS_VERSION
extension BuildSetting {

    /// LLVM_TARGET_TRIPLE_OS_VERSION
    public static var llvmTargetTripleOsVersion: BuildSetting { 
        BuildSetting(key: .llvmTargetTripleOsVersion, value: "$(SWIFT_PLATFORM_TARGET_PREFIX)$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// LLVM_TARGET_TRIPLE_OS_VERSION
    public static func llvmTargetTripleOsVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .llvmTargetTripleOsVersion, value: "\(value)")
    }

    /// LLVM_TARGET_TRIPLE_OS_VERSION
    public static func llvmTargetTripleOsVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmTargetTripleOsVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_TARGET_TRIPLE_OS_VERSION
    public static let llvmTargetTripleOsVersion: BuildSettingsKey = "LLVM_TARGET_TRIPLE_OS_VERSION"
}

// MARK: LLVM_TARGET_TRIPLE_SUFFIX
extension BuildSetting {

    /// LLVM_TARGET_TRIPLE_SUFFIX
    public static var llvmTargetTripleSuffix: BuildSetting { 
        BuildSetting(key: .llvmTargetTripleSuffix, value: "")
    }

    /// LLVM_TARGET_TRIPLE_SUFFIX
    public static func llvmTargetTripleSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .llvmTargetTripleSuffix, value: "\(value)")
    }

    /// LLVM_TARGET_TRIPLE_SUFFIX
    public static func llvmTargetTripleSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmTargetTripleSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_TARGET_TRIPLE_SUFFIX
    public static let llvmTargetTripleSuffix: BuildSettingsKey = "LLVM_TARGET_TRIPLE_SUFFIX"
}

// MARK: LLVM_TARGET_TRIPLE_VENDOR
extension BuildSetting {

    /// LLVM_TARGET_TRIPLE_VENDOR
    public static var llvmTargetTripleVendor: BuildSetting { 
        BuildSetting(key: .llvmTargetTripleVendor, value: "apple")
    }

    /// LLVM_TARGET_TRIPLE_VENDOR
    public static func llvmTargetTripleVendor(_ value: String) -> BuildSetting { 
        BuildSetting(key: .llvmTargetTripleVendor, value: "\(value)")
    }

    /// LLVM_TARGET_TRIPLE_VENDOR
    public static func llvmTargetTripleVendor(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .llvmTargetTripleVendor, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LLVM_TARGET_TRIPLE_VENDOR
    public static let llvmTargetTripleVendor: BuildSettingsKey = "LLVM_TARGET_TRIPLE_VENDOR"
}

// MARK: LOCALIZABLE_CONTENT_DIR
extension BuildSetting {

    /// LOCALIZABLE_CONTENT_DIR
    public static var localizableContentDir: BuildSetting { 
        BuildSetting(key: .localizableContentDir, value: "")
    }

    /// LOCALIZABLE_CONTENT_DIR
    public static func localizableContentDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .localizableContentDir, value: "\(value)")
    }

    /// LOCALIZABLE_CONTENT_DIR
    public static func localizableContentDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .localizableContentDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LOCALIZABLE_CONTENT_DIR
    public static let localizableContentDir: BuildSettingsKey = "LOCALIZABLE_CONTENT_DIR"
}

// MARK: LOCALIZED_RESOURCES_FOLDER_PATH
extension BuildSetting {

    /// LOCALIZED_RESOURCES_FOLDER_PATH
    public static var localizedResourcesFolderPath: BuildSetting { 
        BuildSetting(key: .localizedResourcesFolderPath, value: "")
    }

    /// LOCALIZED_RESOURCES_FOLDER_PATH
    public static func localizedResourcesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .localizedResourcesFolderPath, value: "\(value)")
    }

    /// LOCALIZED_RESOURCES_FOLDER_PATH
    public static func localizedResourcesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .localizedResourcesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LOCALIZED_RESOURCES_FOLDER_PATH
    public static let localizedResourcesFolderPath: BuildSettingsKey = "LOCALIZED_RESOURCES_FOLDER_PATH"
}

// MARK: Localized String Macro Names
extension BuildSetting {

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static var localizedStringMacroNames: BuildSetting { 
        BuildSetting(key: .localizedStringMacroNames, value: "NSLocalizedString CFCopyLocalizedString")
    }

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static func localizedStringMacroNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .localizedStringMacroNames, value: .array(value))
    }

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static func localizedStringMacroNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .localizedStringMacroNames, inherit: key)
    }

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static func localizedStringMacroNames(_ value: String...) -> BuildSetting { 
        .localizedStringMacroNames(value)
    }
}

extension BuildSettingsKey {

    /// Localized String Macro Names
    ///
    /// The base names for NSLocalizedString-like macros or functions used to produce localized strings in source code. The default base names of NSLocalizedString and CFCopyLocalizedString are always considered, even if this setting is empty.
    public static let localizedStringMacroNames: BuildSettingsKey = "LOCALIZED_STRING_MACRO_NAMES"
}

// MARK: Localized String Swift UI Support
extension BuildSetting {

    /// Localized String Swift UI Support
    ///
    /// When enabled, literal strings passed to the Text() initializer from Swift UI will be extracted during localization export.
    public static var localizedStringSwiftUiSupport: BuildSetting { 
        BuildSetting(key: .localizedStringSwiftUiSupport, value: "YES")
    }

    /// Localized String Swift UI Support
    ///
    /// When enabled, literal strings passed to the Text() initializer from Swift UI will be extracted during localization export.
    public static func localizedStringSwiftUiSupport(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .localizedStringSwiftUiSupport, value: SettingValue(booleanLiteral: value))
    }

    /// Localized String Swift UI Support
    ///
    /// When enabled, literal strings passed to the Text() initializer from Swift UI will be extracted during localization export.
    public static func localizedStringSwiftUiSupport(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .localizedStringSwiftUiSupport, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Localized String Swift UI Support
    ///
    /// When enabled, literal strings passed to the Text() initializer from Swift UI will be extracted during localization export.
    public static let localizedStringSwiftUiSupport: BuildSettingsKey = "LOCALIZED_STRING_SWIFTUI_SUPPORT"
}

// MARK: LOCROOT
extension BuildSetting {

    /// LOCROOT
    public static var locroot: BuildSetting { 
        BuildSetting(key: .locroot, value: "")
    }

    /// LOCROOT
    public static func locroot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .locroot, value: "\(value)")
    }

    /// LOCROOT
    public static func locroot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .locroot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LOCROOT
    public static let locroot: BuildSettingsKey = "LOCROOT"
}

// MARK: LOCSYMROOT
extension BuildSetting {

    /// LOCSYMROOT
    public static var locsymroot: BuildSetting { 
        BuildSetting(key: .locsymroot, value: "")
    }

    /// LOCSYMROOT
    public static func locsymroot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .locsymroot, value: "\(value)")
    }

    /// LOCSYMROOT
    public static func locsymroot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .locsymroot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LOCSYMROOT
    public static let locsymroot: BuildSettingsKey = "LOCSYMROOT"
}

// MARK: LOGNAME
extension BuildSetting {

    /// LOGNAME
    public static func logname(_ value: String) -> BuildSetting { 
        BuildSetting(key: .logname, value: "\(value)")
    }

    /// LOGNAME
    public static func logname(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .logname, inherit: key)
    }
}

extension BuildSettingsKey {

    /// LOGNAME
    public static let logname: BuildSettingsKey = "LOGNAME"
}

// MARK: Mach-O Type
extension BuildSetting {

    /// Mach-O Type
    ///
    /// This setting determines the format of the produced binary and how it can be linked when building other binaries. For information on binary types, see [Building Mach-O Files](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/building_files.html#//apple_ref/doc/uid/TP40001828-SW1) in [Mach-O Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html).

- _Executable:_ Executables and standalone binaries and cannot be linked. `mh_execute`

- _Dynamic Library:_ Dynamic libraries are linked at build time and loaded automatically when needed. `mh_dylib`

- _Bundle:_ Bundle libraries are loaded explicitly at run time. `mh_bundle`

- _Static Library:_ Static libraries are linked at build time and loaded at execution time. `staticlib`

- _Relocatable Object File:_ Object files are single-module files that are linked at build time. `mh_object`
    public static var machOType: BuildSetting { 
        BuildSetting(key: .machOType, value: "")
    }

    /// Mach-O Type
    ///
    /// This setting determines the format of the produced binary and how it can be linked when building other binaries. For information on binary types, see [Building Mach-O Files](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/building_files.html#//apple_ref/doc/uid/TP40001828-SW1) in [Mach-O Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html).

- _Executable:_ Executables and standalone binaries and cannot be linked. `mh_execute`

- _Dynamic Library:_ Dynamic libraries are linked at build time and loaded automatically when needed. `mh_dylib`

- _Bundle:_ Bundle libraries are loaded explicitly at run time. `mh_bundle`

- _Static Library:_ Static libraries are linked at build time and loaded at execution time. `staticlib`

- _Relocatable Object File:_ Object files are single-module files that are linked at build time. `mh_object`
    public static func machOType(_ value: MachOType) -> BuildSetting { 
        BuildSetting(key: .machOType, value: "\(value)")
    }

    /// Mach-O Type
    ///
    /// This setting determines the format of the produced binary and how it can be linked when building other binaries. For information on binary types, see [Building Mach-O Files](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/building_files.html#//apple_ref/doc/uid/TP40001828-SW1) in [Mach-O Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html).

- _Executable:_ Executables and standalone binaries and cannot be linked. `mh_execute`

- _Dynamic Library:_ Dynamic libraries are linked at build time and loaded automatically when needed. `mh_dylib`

- _Bundle:_ Bundle libraries are loaded explicitly at run time. `mh_bundle`

- _Static Library:_ Static libraries are linked at build time and loaded at execution time. `staticlib`

- _Relocatable Object File:_ Object files are single-module files that are linked at build time. `mh_object`
    public static func machOType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .machOType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Mach-O Type
    ///
    /// This setting determines the format of the produced binary and how it can be linked when building other binaries. For information on binary types, see [Building Mach-O Files](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/building_files.html#//apple_ref/doc/uid/TP40001828-SW1) in [Mach-O Programming Topics](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html).

- _Executable:_ Executables and standalone binaries and cannot be linked. `mh_execute`

- _Dynamic Library:_ Dynamic libraries are linked at build time and loaded automatically when needed. `mh_dylib`

- _Bundle:_ Bundle libraries are loaded explicitly at run time. `mh_bundle`

- _Static Library:_ Static libraries are linked at build time and loaded at execution time. `staticlib`

- _Relocatable Object File:_ Object files are single-module files that are linked at build time. `mh_object`
    public static let machOType: BuildSettingsKey = "MACH_O_TYPE"
}

public enum MachOType: String, Hashable, Codable, CustomStringConvertible {
    case mhExecute = "mh_execute"
    case mhDylib = "mh_dylib"
    case mhBundle = "mh_bundle"
    case staticlib = "staticlib"
    case mhObject = "mh_object"

    public var description: String {
        rawValue
    }
}

// MARK: MACOS_CREATOR
extension BuildSetting {

    /// MACOS_CREATOR
    public static var macosCreator: BuildSetting { 
        BuildSetting(key: .macosCreator, value: "")
    }

    /// MACOS_CREATOR
    public static func macosCreator(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macosCreator, value: "\(value)")
    }

    /// MACOS_CREATOR
    public static func macosCreator(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macosCreator, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MACOS_CREATOR
    public static let macosCreator: BuildSettingsKey = "MACOS_CREATOR"
}

// MARK: MACOS_CREATOR_ARG
extension BuildSetting {

    /// MACOS_CREATOR_ARG
    public static var macosCreatorArg: BuildSetting { 
        BuildSetting(key: .macosCreatorArg, value: "")
    }

    /// MACOS_CREATOR_ARG
    public static func macosCreatorArg(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macosCreatorArg, value: "\(value)")
    }

    /// MACOS_CREATOR_ARG
    public static func macosCreatorArg(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macosCreatorArg, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MACOS_CREATOR_ARG
    public static let macosCreatorArg: BuildSettingsKey = "MACOS_CREATOR_ARG"
}

// MARK: MACOS_TYPE
extension BuildSetting {

    /// MACOS_TYPE
    public static var macosType: BuildSetting { 
        BuildSetting(key: .macosType, value: "")
    }

    /// MACOS_TYPE
    public static func macosType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macosType, value: "\(value)")
    }

    /// MACOS_TYPE
    public static func macosType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macosType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MACOS_TYPE
    public static let macosType: BuildSettingsKey = "MACOS_TYPE"
}

// MARK: MACOS_TYPE_ARG
extension BuildSetting {

    /// MACOS_TYPE_ARG
    public static var macosTypeArg: BuildSetting { 
        BuildSetting(key: .macosTypeArg, value: "")
    }

    /// MACOS_TYPE_ARG
    public static func macosTypeArg(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macosTypeArg, value: "\(value)")
    }

    /// MACOS_TYPE_ARG
    public static func macosTypeArg(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macosTypeArg, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MACOS_TYPE_ARG
    public static let macosTypeArg: BuildSettingsKey = "MACOS_TYPE_ARG"
}

// MARK: MAC_OS_X_VERSION_MAX_ALLOWED
extension BuildSetting {

    /// MAC_OS_X_VERSION_MAX_ALLOWED
    public static func macOsXVersionMaxAllowed(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macOsXVersionMaxAllowed, value: "\(value)")
    }

    /// MAC_OS_X_VERSION_MAX_ALLOWED
    public static func macOsXVersionMaxAllowed(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macOsXVersionMaxAllowed, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MAC_OS_X_VERSION_MAX_ALLOWED
    public static let macOsXVersionMaxAllowed: BuildSettingsKey = "MAC_OS_X_VERSION_MAX_ALLOWED"
}

// MARK: MAC_OS_X_VERSION_MIN_REQUIRED
extension BuildSetting {

    /// MAC_OS_X_VERSION_MIN_REQUIRED
    public static func macOsXVersionMinRequired(_ value: String) -> BuildSetting { 
        BuildSetting(key: .macOsXVersionMinRequired, value: "\(value)")
    }

    /// MAC_OS_X_VERSION_MIN_REQUIRED
    public static func macOsXVersionMinRequired(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .macOsXVersionMinRequired, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MAC_OS_X_VERSION_MIN_REQUIRED
    public static let macOsXVersionMinRequired: BuildSettingsKey = "MAC_OS_X_VERSION_MIN_REQUIRED"
}

// MARK: MAPC_MODULE
extension BuildSetting {

    /// MAPC_MODULE
    public static var mapcModule: BuildSetting { 
        .mapcModule(inherit: .productModuleName) 
    }

    /// MAPC_MODULE
    public static func mapcModule(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mapcModule, value: "\(value)")
    }

    /// MAPC_MODULE
    public static func mapcModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mapcModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MAPC_MODULE
    public static let mapcModule: BuildSettingsKey = "MAPC_MODULE"
}

// MARK: Suppress all mapc warnings
extension BuildSetting {

    /// Suppress all mapc warnings
    ///
    /// Compile `.xcmappingmodel` files into `.cdm` without reporting warnings.
    public static var suppressAllMapcWarnings: BuildSetting { 
        BuildSetting(key: .suppressAllMapcWarnings, value: "NO")
    }

    /// Suppress all mapc warnings
    ///
    /// Compile `.xcmappingmodel` files into `.cdm` without reporting warnings.
    public static func suppressAllMapcWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressAllMapcWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress all mapc warnings
    ///
    /// Compile `.xcmappingmodel` files into `.cdm` without reporting warnings.
    public static func suppressAllMapcWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressAllMapcWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress all mapc warnings
    ///
    /// Compile `.xcmappingmodel` files into `.cdm` without reporting warnings.
    public static let suppressAllMapcWarnings: BuildSettingsKey = "MAPC_NO_WARNINGS"
}

// MARK: Marketing Version
extension BuildSetting {

    /// Marketing Version
    ///
    /// This setting defines the user-visible version of the project. The value corresponds to the `CFBundleShortVersionString` key in your app's Info.plist.
    public static var marketingVersion: BuildSetting { 
        BuildSetting(key: .marketingVersion, value: "")
    }

    /// Marketing Version
    ///
    /// This setting defines the user-visible version of the project. The value corresponds to the `CFBundleShortVersionString` key in your app's Info.plist.
    public static func marketingVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .marketingVersion, value: "\(value)")
    }

    /// Marketing Version
    ///
    /// This setting defines the user-visible version of the project. The value corresponds to the `CFBundleShortVersionString` key in your app's Info.plist.
    public static func marketingVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .marketingVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Marketing Version
    ///
    /// This setting defines the user-visible version of the project. The value corresponds to the `CFBundleShortVersionString` key in your app's Info.plist.
    public static let marketingVersion: BuildSettingsKey = "MARKETING_VERSION"
}

// MARK: METAL_LIBRARY_FILE_BASE
extension BuildSetting {

    /// METAL_LIBRARY_FILE_BASE
    public static var metalLibraryFileBase: BuildSetting { 
        BuildSetting(key: .metalLibraryFileBase, value: "default")
    }

    /// METAL_LIBRARY_FILE_BASE
    public static func metalLibraryFileBase(_ value: String) -> BuildSetting { 
        BuildSetting(key: .metalLibraryFileBase, value: "\(value)")
    }

    /// METAL_LIBRARY_FILE_BASE
    public static func metalLibraryFileBase(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .metalLibraryFileBase, inherit: key)
    }
}

extension BuildSettingsKey {

    /// METAL_LIBRARY_FILE_BASE
    public static let metalLibraryFileBase: BuildSettingsKey = "METAL_LIBRARY_FILE_BASE"
}

// MARK: METAL_LIBRARY_OUTPUT_DIR
extension BuildSetting {

    /// METAL_LIBRARY_OUTPUT_DIR
    public static var metalLibraryOutputDir: BuildSetting { 
        BuildSetting(key: .metalLibraryOutputDir, value: "$(TARGET_BUILD_DIR)/$(UNLOCALIZED_RESOURCES_FOLDER_PATH)")
    }

    /// METAL_LIBRARY_OUTPUT_DIR
    public static func metalLibraryOutputDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .metalLibraryOutputDir, value: "\(value)")
    }

    /// METAL_LIBRARY_OUTPUT_DIR
    public static func metalLibraryOutputDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .metalLibraryOutputDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// METAL_LIBRARY_OUTPUT_DIR
    public static let metalLibraryOutputDir: BuildSettingsKey = "METAL_LIBRARY_OUTPUT_DIR"
}

// MARK: MIG_DEPLOYMENT_TARGET
extension BuildSetting {

    /// MIG_DEPLOYMENT_TARGET
    public static var migDeploymentTarget: BuildSetting { 
        BuildSetting(key: .migDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// MIG_DEPLOYMENT_TARGET
    public static func migDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .migDeploymentTarget, value: "\(value)")
    }

    /// MIG_DEPLOYMENT_TARGET
    public static func migDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .migDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MIG_DEPLOYMENT_TARGET
    public static let migDeploymentTarget: BuildSettingsKey = "MIG_DEPLOYMENT_TARGET"
}

// MARK: Module Map File
extension BuildSetting {

    /// Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for the compiler. If empty, it will be automatically generated for appropriate products when [Defines Module (DEFINES\_MODULE)](itcaec37c2a6.html#dev82471c743) is enabled.
    public static var moduleMapFile: BuildSetting { 
        BuildSetting(key: .moduleMapFile, value: "")
    }

    /// Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for the compiler. If empty, it will be automatically generated for appropriate products when [Defines Module (DEFINES\_MODULE)](itcaec37c2a6.html#dev82471c743) is enabled.
    public static func moduleMapFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleMapFile, value: "\(value)")
    }

    /// Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for the compiler. If empty, it will be automatically generated for appropriate products when [Defines Module (DEFINES\_MODULE)](itcaec37c2a6.html#dev82471c743) is enabled.
    public static func moduleMapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleMapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for the compiler. If empty, it will be automatically generated for appropriate products when [Defines Module (DEFINES\_MODULE)](itcaec37c2a6.html#dev82471c743) is enabled.
    public static let moduleMapFile: BuildSettingsKey = "MODULEMAP_FILE"
}

// MARK: Private Module Map File
extension BuildSetting {

    /// Private Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for private headers.
    public static var privateModuleMapFile: BuildSetting { 
        BuildSetting(key: .privateModuleMapFile, value: "")
    }

    /// Private Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for private headers.
    public static func privateModuleMapFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .privateModuleMapFile, value: "\(value)")
    }

    /// Private Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for private headers.
    public static func privateModuleMapFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .privateModuleMapFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Private Module Map File
    ///
    /// This is the project-relative path to the LLVM module map file that defines the module structure for private headers.
    public static let privateModuleMapFile: BuildSettingsKey = "MODULEMAP_PRIVATE_FILE"
}

// MARK: MODULES_FOLDER_PATH
extension BuildSetting {

    /// MODULES_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products Clang module maps and Swift module content.
    public static var modulesFolderPath: BuildSetting { 
        BuildSetting(key: .modulesFolderPath, value: "")
    }

    /// MODULES_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products Clang module maps and Swift module content.
    public static func modulesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .modulesFolderPath, value: "\(value)")
    }

    /// MODULES_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products Clang module maps and Swift module content.
    public static func modulesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .modulesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MODULES_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products Clang module maps and Swift module content.
    public static let modulesFolderPath: BuildSettingsKey = "MODULES_FOLDER_PATH"
}

// MARK: MODULE_CACHE_DIR
extension BuildSetting {

    /// MODULE_CACHE_DIR
    ///
    /// Absolute path of folder in which compiler stores its cached modulesthis cache is a performance improvement.
    public static var moduleCacheDir: BuildSetting { 
        BuildSetting(key: .moduleCacheDir, value: "$(DERIVED_DATA_DIR)/ModuleCache.noindex")
    }

    /// MODULE_CACHE_DIR
    ///
    /// Absolute path of folder in which compiler stores its cached modulesthis cache is a performance improvement.
    public static func moduleCacheDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleCacheDir, value: "\(value)")
    }

    /// MODULE_CACHE_DIR
    ///
    /// Absolute path of folder in which compiler stores its cached modulesthis cache is a performance improvement.
    public static func moduleCacheDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleCacheDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MODULE_CACHE_DIR
    ///
    /// Absolute path of folder in which compiler stores its cached modulesthis cache is a performance improvement.
    public static let moduleCacheDir: BuildSettingsKey = "MODULE_CACHE_DIR"
}

// MARK: Module Identifier
extension BuildSetting {

    /// Module Identifier
    ///
    /// This is the identifier of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static var moduleIdentifier: BuildSetting { 
        BuildSetting(key: .moduleIdentifier, value: "")
    }

    /// Module Identifier
    ///
    /// This is the identifier of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static func moduleIdentifier(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleIdentifier, value: "\(value)")
    }

    /// Module Identifier
    ///
    /// This is the identifier of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static func moduleIdentifier(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleIdentifier, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Identifier
    ///
    /// This is the identifier of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static let moduleIdentifier: BuildSettingsKey = "MODULE_NAME"
}

// MARK: Module Start Routine
extension BuildSetting {

    /// Module Start Routine
    ///
    /// This defines the name of the kernel module start routine. This is only used when building kernel extensions.
    public static var moduleStartRoutine: BuildSetting { 
        BuildSetting(key: .moduleStartRoutine, value: "")
    }

    /// Module Start Routine
    ///
    /// This defines the name of the kernel module start routine. This is only used when building kernel extensions.
    public static func moduleStartRoutine(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleStartRoutine, value: "\(value)")
    }

    /// Module Start Routine
    ///
    /// This defines the name of the kernel module start routine. This is only used when building kernel extensions.
    public static func moduleStartRoutine(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleStartRoutine, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Start Routine
    ///
    /// This defines the name of the kernel module start routine. This is only used when building kernel extensions.
    public static let moduleStartRoutine: BuildSettingsKey = "MODULE_START"
}

// MARK: Module Stop Routine
extension BuildSetting {

    /// Module Stop Routine
    ///
    /// This defines the name of the kernel module stop routine. This is only used when building kernel extensions.
    public static var moduleStopRoutine: BuildSetting { 
        BuildSetting(key: .moduleStopRoutine, value: "")
    }

    /// Module Stop Routine
    ///
    /// This defines the name of the kernel module stop routine. This is only used when building kernel extensions.
    public static func moduleStopRoutine(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleStopRoutine, value: "\(value)")
    }

    /// Module Stop Routine
    ///
    /// This defines the name of the kernel module stop routine. This is only used when building kernel extensions.
    public static func moduleStopRoutine(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleStopRoutine, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Stop Routine
    ///
    /// This defines the name of the kernel module stop routine. This is only used when building kernel extensions.
    public static let moduleStopRoutine: BuildSettingsKey = "MODULE_STOP"
}

// MARK: Module Version
extension BuildSetting {

    /// Module Version
    ///
    /// This is the version of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static var moduleVersion: BuildSetting { 
        BuildSetting(key: .moduleVersion, value: "")
    }

    /// Module Version
    ///
    /// This is the version of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static func moduleVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .moduleVersion, value: "\(value)")
    }

    /// Module Version
    ///
    /// This is the version of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static func moduleVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .moduleVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Module Version
    ///
    /// This is the version of the kernel module listed in the generated stub. This is only used when building kernel extensions.
    public static let moduleVersion: BuildSettingsKey = "MODULE_VERSION"
}

// MARK: MOMC_MODULE
extension BuildSetting {

    /// MOMC_MODULE
    public static var momcModule: BuildSetting { 
        .momcModule(inherit: .productModuleName) 
    }

    /// MOMC_MODULE
    public static func momcModule(_ value: String) -> BuildSetting { 
        BuildSetting(key: .momcModule, value: "\(value)")
    }

    /// MOMC_MODULE
    public static func momcModule(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .momcModule, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MOMC_MODULE
    public static let momcModule: BuildSettingsKey = "MOMC_MODULE"
}

// MARK: Suppress momc warnings for delete rules
extension BuildSetting {

    /// Suppress momc warnings for delete rules
    ///
    /// Suppress managed object model compiler (`momc`) warnings for delete rules during the compilation of `.xcdatamodel(d)` files.
    public static var suppressMomcWarningsForDeleteRules: BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsForDeleteRules, value: "NO")
    }

    /// Suppress momc warnings for delete rules
    ///
    /// Suppress managed object model compiler (`momc`) warnings for delete rules during the compilation of `.xcdatamodel(d)` files.
    public static func suppressMomcWarningsForDeleteRules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsForDeleteRules, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress momc warnings for delete rules
    ///
    /// Suppress managed object model compiler (`momc`) warnings for delete rules during the compilation of `.xcdatamodel(d)` files.
    public static func suppressMomcWarningsForDeleteRules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressMomcWarningsForDeleteRules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress momc warnings for delete rules
    ///
    /// Suppress managed object model compiler (`momc`) warnings for delete rules during the compilation of `.xcdatamodel(d)` files.
    public static let suppressMomcWarningsForDeleteRules: BuildSettingsKey = "MOMC_NO_DELETE_RULE_WARNINGS"
}

// MARK: Suppress momc warnings on missing inverse relationships
extension BuildSetting {

    /// Suppress momc warnings on missing inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on missing inverse relationships during the compilation of `.xcdatamodel(d)` files
    public static var suppressMomcWarningsOnMissingInverseRelationships: BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsOnMissingInverseRelationships, value: "NO")
    }

    /// Suppress momc warnings on missing inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on missing inverse relationships during the compilation of `.xcdatamodel(d)` files
    public static func suppressMomcWarningsOnMissingInverseRelationships(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsOnMissingInverseRelationships, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress momc warnings on missing inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on missing inverse relationships during the compilation of `.xcdatamodel(d)` files
    public static func suppressMomcWarningsOnMissingInverseRelationships(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressMomcWarningsOnMissingInverseRelationships, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress momc warnings on missing inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on missing inverse relationships during the compilation of `.xcdatamodel(d)` files
    public static let suppressMomcWarningsOnMissingInverseRelationships: BuildSettingsKey = "MOMC_NO_INVERSE_RELATIONSHIP_WARNINGS"
}

// MARK: Suppress momc warnings for entities with more than 100 properties
extension BuildSetting {

    /// Suppress momc warnings for entities with more than 100 properties
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on entities with more than 100 properties during the compilation of `.xcdatamodel(d)` files.
    public static var suppressMomcWarningsForEntitiesWithMoreThan100Properties: BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsForEntitiesWithMoreThan100Properties, value: "NO")
    }

    /// Suppress momc warnings for entities with more than 100 properties
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on entities with more than 100 properties during the compilation of `.xcdatamodel(d)` files.
    public static func suppressMomcWarningsForEntitiesWithMoreThan100Properties(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressMomcWarningsForEntitiesWithMoreThan100Properties, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress momc warnings for entities with more than 100 properties
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on entities with more than 100 properties during the compilation of `.xcdatamodel(d)` files.
    public static func suppressMomcWarningsForEntitiesWithMoreThan100Properties(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressMomcWarningsForEntitiesWithMoreThan100Properties, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress momc warnings for entities with more than 100 properties
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on entities with more than 100 properties during the compilation of `.xcdatamodel(d)` files.
    public static let suppressMomcWarningsForEntitiesWithMoreThan100Properties: BuildSettingsKey = "MOMC_NO_MAX_PROPERTY_COUNT_WARNINGS"
}

// MARK: Suppress all momc warnings
extension BuildSetting {

    /// Suppress all momc warnings
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output during the compilation of `.xcdatamodel(d)` files
    public static var suppressAllMomcWarnings: BuildSetting { 
        BuildSetting(key: .suppressAllMomcWarnings, value: "NO")
    }

    /// Suppress all momc warnings
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output during the compilation of `.xcdatamodel(d)` files
    public static func suppressAllMomcWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressAllMomcWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress all momc warnings
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output during the compilation of `.xcdatamodel(d)` files
    public static func suppressAllMomcWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressAllMomcWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress all momc warnings
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output during the compilation of `.xcdatamodel(d)` files
    public static let suppressAllMomcWarnings: BuildSettingsKey = "MOMC_NO_WARNINGS"
}

// MARK: MOMC_OUTPUT_SUFFIX
extension BuildSetting {

    /// MOMC_OUTPUT_SUFFIX
    public static var momcOutputSuffix: BuildSetting { 
        BuildSetting(key: .momcOutputSuffix, value: "$(MOMC_OUTPUT_SUFFIX_$(InputFileSuffix:identifier))")
    }

    /// MOMC_OUTPUT_SUFFIX
    public static func momcOutputSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .momcOutputSuffix, value: "\(value)")
    }

    /// MOMC_OUTPUT_SUFFIX
    public static func momcOutputSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .momcOutputSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MOMC_OUTPUT_SUFFIX
    public static let momcOutputSuffix: BuildSettingsKey = "MOMC_OUTPUT_SUFFIX"
}

// MARK: MOMC_OUTPUT_SUFFIX__xcdatamodel
extension BuildSetting {

    /// MOMC_OUTPUT_SUFFIX__xcdatamodel
    public static var momcOutputSuffixXcdatamodel: BuildSetting { 
        BuildSetting(key: .momcOutputSuffixXcdatamodel, value: ".mom")
    }

    /// MOMC_OUTPUT_SUFFIX__xcdatamodel
    public static func momcOutputSuffixXcdatamodel(_ value: String) -> BuildSetting { 
        BuildSetting(key: .momcOutputSuffixXcdatamodel, value: "\(value)")
    }

    /// MOMC_OUTPUT_SUFFIX__xcdatamodel
    public static func momcOutputSuffixXcdatamodel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .momcOutputSuffixXcdatamodel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MOMC_OUTPUT_SUFFIX__xcdatamodel
    public static let momcOutputSuffixXcdatamodel: BuildSettingsKey = "MOMC_OUTPUT_SUFFIX__xcdatamodel"
}

// MARK: MOMC_OUTPUT_SUFFIX__xcdatamodeld
extension BuildSetting {

    /// MOMC_OUTPUT_SUFFIX__xcdatamodeld
    public static var momcOutputSuffixXcdatamodeld: BuildSetting { 
        BuildSetting(key: .momcOutputSuffixXcdatamodeld, value: ".momd")
    }

    /// MOMC_OUTPUT_SUFFIX__xcdatamodeld
    public static func momcOutputSuffixXcdatamodeld(_ value: String) -> BuildSetting { 
        BuildSetting(key: .momcOutputSuffixXcdatamodeld, value: "\(value)")
    }

    /// MOMC_OUTPUT_SUFFIX__xcdatamodeld
    public static func momcOutputSuffixXcdatamodeld(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .momcOutputSuffixXcdatamodeld, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MOMC_OUTPUT_SUFFIX__xcdatamodeld
    public static let momcOutputSuffixXcdatamodeld: BuildSettingsKey = "MOMC_OUTPUT_SUFFIX__xcdatamodeld"
}

// MARK: Suppress momc error on transient inverse relationships
extension BuildSetting {

    /// Suppress momc error on transient inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on transient inverse relationships during the compilation of `.xcdatamodel(d)` files. This is only intended to be used on 10.4.x created models that compiled properly in 10.4.x before the error was introduced in 10.5
    public static var suppressMomcErrorOnTransientInverseRelationships: BuildSetting { 
        BuildSetting(key: .suppressMomcErrorOnTransientInverseRelationships, value: "NO")
    }

    /// Suppress momc error on transient inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on transient inverse relationships during the compilation of `.xcdatamodel(d)` files. This is only intended to be used on 10.4.x created models that compiled properly in 10.4.x before the error was introduced in 10.5
    public static func suppressMomcErrorOnTransientInverseRelationships(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressMomcErrorOnTransientInverseRelationships, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress momc error on transient inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on transient inverse relationships during the compilation of `.xcdatamodel(d)` files. This is only intended to be used on 10.4.x created models that compiled properly in 10.4.x before the error was introduced in 10.5
    public static func suppressMomcErrorOnTransientInverseRelationships(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressMomcErrorOnTransientInverseRelationships, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress momc error on transient inverse relationships
    ///
    /// Suppress managed object model compiler (`momc`) warnings from output on transient inverse relationships during the compilation of `.xcdatamodel(d)` files. This is only intended to be used on 10.4.x created models that compiled properly in 10.4.x before the error was introduced in 10.5
    public static let suppressMomcErrorOnTransientInverseRelationships: BuildSettingsKey = "MOMC_SUPPRESS_INVERSE_TRANSIENT_ERROR"
}

// MARK: MTLCOMPILER_DEPENDENCY_INFO_FILE
extension BuildSetting {

    /// MTLCOMPILER_DEPENDENCY_INFO_FILE
    public static var mtlcompilerDependencyInfoFile: BuildSetting { 
        BuildSetting(key: .mtlcompilerDependencyInfoFile, value: "$(TARGET_TEMP_DIR)/Metal/$(InputFileBase)$(InputFileBaseUniquefier).dat")
    }

    /// MTLCOMPILER_DEPENDENCY_INFO_FILE
    public static func mtlcompilerDependencyInfoFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlcompilerDependencyInfoFile, value: "\(value)")
    }

    /// MTLCOMPILER_DEPENDENCY_INFO_FILE
    public static func mtlcompilerDependencyInfoFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlcompilerDependencyInfoFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTLCOMPILER_DEPENDENCY_INFO_FILE
    public static let mtlcompilerDependencyInfoFile: BuildSettingsKey = "MTLCOMPILER_DEPENDENCY_INFO_FILE"
}

// MARK: MTLCOMPILER_OUTPUT_FILE
extension BuildSetting {

    /// MTLCOMPILER_OUTPUT_FILE
    public static var mtlcompilerOutputFile: BuildSetting { 
        BuildSetting(key: .mtlcompilerOutputFile, value: "$(TARGET_TEMP_DIR)/Metal/$(InputFileBase)$(InputFileBaseUniquefier).air")
    }

    /// MTLCOMPILER_OUTPUT_FILE
    public static func mtlcompilerOutputFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlcompilerOutputFile, value: "\(value)")
    }

    /// MTLCOMPILER_OUTPUT_FILE
    public static func mtlcompilerOutputFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlcompilerOutputFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTLCOMPILER_OUTPUT_FILE
    public static let mtlcompilerOutputFile: BuildSettingsKey = "MTLCOMPILER_OUTPUT_FILE"
}

// MARK: MTLLINKER_ALTERNATE_LINKER
extension BuildSetting {

    /// MTLLINKER_ALTERNATE_LINKER
    public static func mtllinkerAlternateLinker(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtllinkerAlternateLinker, value: "\(value)")
    }

    /// MTLLINKER_ALTERNATE_LINKER
    public static func mtllinkerAlternateLinker(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtllinkerAlternateLinker, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTLLINKER_ALTERNATE_LINKER
    public static let mtllinkerAlternateLinker: BuildSettingsKey = "MTLLINKER_ALTERNATE_LINKER"
}

// MARK: Other Metal Linker Flags
extension BuildSetting {

    /// Other Metal Linker Flags
    ///
    /// Space-separated list of metal linker flags
    public static var otherMetalLinkerFlags: BuildSetting { 
        BuildSetting(key: .otherMetalLinkerFlags, value: "")
    }

    /// Other Metal Linker Flags
    ///
    /// Space-separated list of metal linker flags
    public static func otherMetalLinkerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherMetalLinkerFlags, value: .array(value))
    }

    /// Other Metal Linker Flags
    ///
    /// Space-separated list of metal linker flags
    public static func otherMetalLinkerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherMetalLinkerFlags, inherit: key)
    }

    /// Other Metal Linker Flags
    ///
    /// Space-separated list of metal linker flags
    public static func otherMetalLinkerFlags(_ value: String...) -> BuildSetting { 
        .otherMetalLinkerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Metal Linker Flags
    ///
    /// Space-separated list of metal linker flags
    public static let otherMetalLinkerFlags: BuildSettingsKey = "MTLLINKER_FLAGS"
}

// MARK: MTLLINKER_INCLUDE_SOURCE
extension BuildSetting {

    /// MTLLINKER_INCLUDE_SOURCE
    public static func mtllinkerIncludeSource(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtllinkerIncludeSource, value: "\(value)")
    }

    /// MTLLINKER_INCLUDE_SOURCE
    public static func mtllinkerIncludeSource(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtllinkerIncludeSource, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTLLINKER_INCLUDE_SOURCE
    public static let mtllinkerIncludeSource: BuildSettingsKey = "MTLLINKER_INCLUDE_SOURCE"
}

// MARK: MTLLINKER_OUTPUT_FILE
extension BuildSetting {

    /// MTLLINKER_OUTPUT_FILE
    public static var mtllinkerOutputFile: BuildSetting { 
        BuildSetting(key: .mtllinkerOutputFile, value: "$(METAL_LIBRARY_OUTPUT_DIR)/$(METAL_LIBRARY_FILE_BASE).metallib")
    }

    /// MTLLINKER_OUTPUT_FILE
    public static func mtllinkerOutputFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtllinkerOutputFile, value: "\(value)")
    }

    /// MTLLINKER_OUTPUT_FILE
    public static func mtllinkerOutputFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtllinkerOutputFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTLLINKER_OUTPUT_FILE
    public static let mtllinkerOutputFile: BuildSettingsKey = "MTLLINKER_OUTPUT_FILE"
}

// MARK: MTLLINKER_TARGET_TRIPLE
extension BuildSetting {

    /// MTLLINKER_TARGET_TRIPLE
    public static var mtllinkerTargetTriple: BuildSetting { 
        BuildSetting(key: .mtllinkerTargetTriple, value: "air64-$(LLVM_TARGET_TRIPLE_VENDOR)-$(LLVM_TARGET_TRIPLE_OS_VERSION)$(LLVM_TARGET_TRIPLE_SUFFIX)")
    }

    /// MTLLINKER_TARGET_TRIPLE
    public static func mtllinkerTargetTriple(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtllinkerTargetTriple, value: "\(value)")
    }

    /// MTLLINKER_TARGET_TRIPLE
    public static func mtllinkerTargetTriple(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtllinkerTargetTriple, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTLLINKER_TARGET_TRIPLE
    public static let mtllinkerTargetTriple: BuildSettingsKey = "MTLLINKER_TARGET_TRIPLE"
}

// MARK: Other Metal Compiler Flags
extension BuildSetting {

    /// Other Metal Compiler Flags
    ///
    /// Space-separated list of compiler flags
    public static var otherMetalCompilerFlags: BuildSetting { 
        BuildSetting(key: .otherMetalCompilerFlags, value: "")
    }

    /// Other Metal Compiler Flags
    ///
    /// Space-separated list of compiler flags
    public static func otherMetalCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherMetalCompilerFlags, value: .array(value))
    }

    /// Other Metal Compiler Flags
    ///
    /// Space-separated list of compiler flags
    public static func otherMetalCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherMetalCompilerFlags, inherit: key)
    }

    /// Other Metal Compiler Flags
    ///
    /// Space-separated list of compiler flags
    public static func otherMetalCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherMetalCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Metal Compiler Flags
    ///
    /// Space-separated list of compiler flags
    public static let otherMetalCompilerFlags: BuildSettingsKey = "MTL_COMPILER_FLAGS"
}

// MARK: Produce Debugging Information
extension BuildSetting {

    /// Produce Debugging Information
    ///
    /// Debugging information is required for shader debugging and profiling.
    public static var produceDebuggingInformation: BuildSetting { 
        BuildSetting(key: .produceDebuggingInformation, value: "NO")
    }

    /// Produce Debugging Information
    ///
    /// Debugging information is required for shader debugging and profiling.
    public static func produceDebuggingInformation(_ value: ProduceDebuggingInformation) -> BuildSetting { 
        BuildSetting(key: .produceDebuggingInformation, value: "\(value)")
    }

    /// Produce Debugging Information
    ///
    /// Debugging information is required for shader debugging and profiling.
    public static func produceDebuggingInformation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .produceDebuggingInformation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Produce Debugging Information
    ///
    /// Debugging information is required for shader debugging and profiling.
    public static let produceDebuggingInformation: BuildSettingsKey = "MTL_ENABLE_DEBUG_INFO"
}

// MARK: Enable Index-While-Building Functionality (Metal)
extension BuildSetting {

    /// Enable Index-While-Building Functionality (Metal)
    ///
    /// Control whether the compiler should emit index data while building.
    public static var enableIndexWhileBuildingFunctionalityMetal: BuildSetting { 
        BuildSetting(key: .enableIndexWhileBuildingFunctionalityMetal, value: "$(INDEX_ENABLE_DATA_STORE)")
    }

    /// Enable Index-While-Building Functionality (Metal)
    ///
    /// Control whether the compiler should emit index data while building.
    public static func enableIndexWhileBuildingFunctionalityMetal(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableIndexWhileBuildingFunctionalityMetal, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Index-While-Building Functionality (Metal)
    ///
    /// Control whether the compiler should emit index data while building.
    public static func enableIndexWhileBuildingFunctionalityMetal(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableIndexWhileBuildingFunctionalityMetal, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Index-While-Building Functionality (Metal)
    ///
    /// Control whether the compiler should emit index data while building.
    public static let enableIndexWhileBuildingFunctionalityMetal: BuildSettingsKey = "MTL_ENABLE_INDEX_STORE"
}

// MARK: Enable Modules (Metal)
extension BuildSetting {

    /// Enable Modules (Metal)
    ///
    /// Enables the use of modules. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static var enableModulesMetal: BuildSetting { 
        BuildSetting(key: .enableModulesMetal, value: "NO")
    }

    /// Enable Modules (Metal)
    ///
    /// Enables the use of modules. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static func enableModulesMetal(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableModulesMetal, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Modules (Metal)
    ///
    /// Enables the use of modules. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static func enableModulesMetal(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableModulesMetal, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Modules (Metal)
    ///
    /// Enables the use of modules. System headers are imported as semantic modules instead of raw headers. This can result in faster builds and project indexing.
    public static let enableModulesMetal: BuildSettingsKey = "MTL_ENABLE_MODULES"
}

// MARK: Enable Fast Math
extension BuildSetting {

    /// Enable Fast Math
    ///
    /// Enable optimizations for floating-point arithmetic that may violate the IEEE 754 standard and disable the high precision variant of math functions for single and half precision floating-point.
    public static var enableFastMath: BuildSetting { 
        BuildSetting(key: .enableFastMath, value: "YES")
    }

    /// Enable Fast Math
    ///
    /// Enable optimizations for floating-point arithmetic that may violate the IEEE 754 standard and disable the high precision variant of math functions for single and half precision floating-point.
    public static func enableFastMath(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .enableFastMath, value: SettingValue(booleanLiteral: value))
    }

    /// Enable Fast Math
    ///
    /// Enable optimizations for floating-point arithmetic that may violate the IEEE 754 standard and disable the high precision variant of math functions for single and half precision floating-point.
    public static func enableFastMath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableFastMath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Fast Math
    ///
    /// Enable optimizations for floating-point arithmetic that may violate the IEEE 754 standard and disable the high precision variant of math functions for single and half precision floating-point.
    public static let enableFastMath: BuildSettingsKey = "MTL_FAST_MATH"
}

// MARK: MTL_FRAMEWORK_SEARCH_PATH_BUILT_PRODUCTS_DIR
extension BuildSetting {

    /// MTL_FRAMEWORK_SEARCH_PATH_BUILT_PRODUCTS_DIR
    public static func mtlFrameworkSearchPathBuiltProductsDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlFrameworkSearchPathBuiltProductsDir, value: "\(value)")
    }

    /// MTL_FRAMEWORK_SEARCH_PATH_BUILT_PRODUCTS_DIR
    public static func mtlFrameworkSearchPathBuiltProductsDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlFrameworkSearchPathBuiltProductsDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTL_FRAMEWORK_SEARCH_PATH_BUILT_PRODUCTS_DIR
    public static let mtlFrameworkSearchPathBuiltProductsDir: BuildSettingsKey = "MTL_FRAMEWORK_SEARCH_PATH_BUILT_PRODUCTS_DIR"
}

// MARK: Header Search Paths
extension BuildSetting {

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling Metal. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. `MTL_HEADER_SEARCH_PATHS, -I`
    public static var headerSearchPaths: BuildSetting { 
        BuildSetting(key: .headerSearchPaths, value: "")
    }

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling Metal. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. `MTL_HEADER_SEARCH_PATHS, -I`
    public static func headerSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .headerSearchPaths, value: .array(value))
    }

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling Metal. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. `MTL_HEADER_SEARCH_PATHS, -I`
    public static func headerSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .headerSearchPaths, inherit: key)
    }

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling Metal. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. `MTL_HEADER_SEARCH_PATHS, -I`
    public static func headerSearchPaths(_ value: String...) -> BuildSetting { 
        .headerSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported header files when compiling Metal. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. `MTL_HEADER_SEARCH_PATHS, -I`
    public static let headerSearchPaths: BuildSettingsKey = "MTL_HEADER_SEARCH_PATHS"
}

// MARK: MTL_HEADER_SEARCH_PATH_BUILT_PRODUCTS_DIR
extension BuildSetting {

    /// MTL_HEADER_SEARCH_PATH_BUILT_PRODUCTS_DIR
    public static func mtlHeaderSearchPathBuiltProductsDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlHeaderSearchPathBuiltProductsDir, value: "\(value)")
    }

    /// MTL_HEADER_SEARCH_PATH_BUILT_PRODUCTS_DIR
    public static func mtlHeaderSearchPathBuiltProductsDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlHeaderSearchPathBuiltProductsDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTL_HEADER_SEARCH_PATH_BUILT_PRODUCTS_DIR
    public static let mtlHeaderSearchPathBuiltProductsDir: BuildSettingsKey = "MTL_HEADER_SEARCH_PATH_BUILT_PRODUCTS_DIR"
}

// MARK: Ignore Warnings
extension BuildSetting {

    /// Ignore Warnings
    ///
    /// Enabling this option causes all warnings to be ignored. `MTL_IGNORE_WARNINGS, -W`
    public static var ignoreWarnings: BuildSetting { 
        BuildSetting(key: .ignoreWarnings, value: "NO")
    }

    /// Ignore Warnings
    ///
    /// Enabling this option causes all warnings to be ignored. `MTL_IGNORE_WARNINGS, -W`
    public static func ignoreWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .ignoreWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Ignore Warnings
    ///
    /// Enabling this option causes all warnings to be ignored. `MTL_IGNORE_WARNINGS, -W`
    public static func ignoreWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .ignoreWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Ignore Warnings
    ///
    /// Enabling this option causes all warnings to be ignored. `MTL_IGNORE_WARNINGS, -W`
    public static let ignoreWarnings: BuildSettingsKey = "MTL_IGNORE_WARNINGS"
}

// MARK: MTL_INDEX_STORE_PATH
extension BuildSetting {

    /// MTL_INDEX_STORE_PATH
    public static var mtlIndexStorePath: BuildSetting { 
        BuildSetting(key: .mtlIndexStorePath, value: "$(INDEX_DATA_STORE_DIR)")
    }

    /// MTL_INDEX_STORE_PATH
    public static func mtlIndexStorePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlIndexStorePath, value: "\(value)")
    }

    /// MTL_INDEX_STORE_PATH
    public static func mtlIndexStorePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlIndexStorePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTL_INDEX_STORE_PATH
    public static let mtlIndexStorePath: BuildSettingsKey = "MTL_INDEX_STORE_PATH"
}

// MARK: Metal Language Revision
extension BuildSetting {

    /// Metal Language Revision
    ///
    /// Determine the language revision to use. A value for this option must be provided.
    public static var metalLanguageRevision: BuildSetting { 
        BuildSetting(key: .metalLanguageRevision, value: "UseDeploymentTarget")
    }

    /// Metal Language Revision
    ///
    /// Determine the language revision to use. A value for this option must be provided.
    public static func metalLanguageRevision(_ value: MetalLanguageRevision) -> BuildSetting { 
        BuildSetting(key: .metalLanguageRevision, value: "\(value)")
    }

    /// Metal Language Revision
    ///
    /// Determine the language revision to use. A value for this option must be provided.
    public static func metalLanguageRevision(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .metalLanguageRevision, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Metal Language Revision
    ///
    /// Determine the language revision to use. A value for this option must be provided.
    public static let metalLanguageRevision: BuildSettingsKey = "MTL_LANGUAGE_REVISION"
}

// MARK: MTL_LANGUAGE_REVISION_dialect
extension BuildSetting {

    /// MTL_LANGUAGE_REVISION_dialect
    public static var mtlLanguageRevisionDialect: BuildSetting { 
        BuildSetting(key: .mtlLanguageRevisionDialect, value: "ios")
    }

    /// MTL_LANGUAGE_REVISION_dialect
    public static func mtlLanguageRevisionDialect(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlLanguageRevisionDialect, value: "\(value)")
    }

    /// MTL_LANGUAGE_REVISION_dialect
    public static func mtlLanguageRevisionDialect(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlLanguageRevisionDialect, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTL_LANGUAGE_REVISION_dialect
    public static let mtlLanguageRevisionDialect: BuildSettingsKey = "MTL_LANGUAGE_REVISION_dialect"
}

// MARK: MTL_LANGUAGE_REVISION_optgen
extension BuildSetting {

    /// MTL_LANGUAGE_REVISION_optgen
    public static var mtlLanguageRevisionOptgen: BuildSetting { 
        .mtlLanguageRevisionOptgen(inherit: .metalLanguageRevision) 
    }

    /// MTL_LANGUAGE_REVISION_optgen
    public static func mtlLanguageRevisionOptgen(_ value: MtlLanguageRevisionOptgen) -> BuildSetting { 
        BuildSetting(key: .mtlLanguageRevisionOptgen, value: "\(value)")
    }

    /// MTL_LANGUAGE_REVISION_optgen
    public static func mtlLanguageRevisionOptgen(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlLanguageRevisionOptgen, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTL_LANGUAGE_REVISION_optgen
    public static let mtlLanguageRevisionOptgen: BuildSettingsKey = "MTL_LANGUAGE_REVISION_optgen"
}

// MARK: Preprocessor Definitions
extension BuildSetting {

    /// Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form "foo" or "foo=bar".
    public static func preprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorDefinitions, value: .array(value))
    }

    /// Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form "foo" or "foo=bar".
    public static func preprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorDefinitions, inherit: key)
    }

    /// Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form "foo" or "foo=bar".
    public static func preprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .preprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Definitions
    ///
    /// Space-separated list of preprocessor macros of the form "foo" or "foo=bar".
    public static let preprocessorDefinitions: BuildSettingsKey = "MTL_PREPROCESSOR_DEFINITIONS"
}

// MARK: MTL_TARGET_TRIPLE
extension BuildSetting {

    /// MTL_TARGET_TRIPLE
    public static var mtlTargetTriple: BuildSetting { 
        BuildSetting(key: .mtlTargetTriple, value: "air64-$(LLVM_TARGET_TRIPLE_VENDOR)-$(LLVM_TARGET_TRIPLE_OS_VERSION)$(LLVM_TARGET_TRIPLE_SUFFIX)")
    }

    /// MTL_TARGET_TRIPLE
    public static func mtlTargetTriple(_ value: String) -> BuildSetting { 
        BuildSetting(key: .mtlTargetTriple, value: "\(value)")
    }

    /// MTL_TARGET_TRIPLE
    public static func mtlTargetTriple(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .mtlTargetTriple, inherit: key)
    }
}

extension BuildSettingsKey {

    /// MTL_TARGET_TRIPLE
    public static let mtlTargetTriple: BuildSettingsKey = "MTL_TARGET_TRIPLE"
}

// MARK: Treat Warnings as Errors
extension BuildSetting {

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors. `MTL_TREAT_WARNINGS_AS_ERRORS, -Werror`
    public static var treatWarningsAsErrors: BuildSetting { 
        BuildSetting(key: .treatWarningsAsErrors, value: "NO")
    }

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors. `MTL_TREAT_WARNINGS_AS_ERRORS, -Werror`
    public static func treatWarningsAsErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatWarningsAsErrors, value: SettingValue(booleanLiteral: value))
    }

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors. `MTL_TREAT_WARNINGS_AS_ERRORS, -Werror`
    public static func treatWarningsAsErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatWarningsAsErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat Warnings as Errors
    ///
    /// Enabling this option causes all warnings to be treated as errors. `MTL_TREAT_WARNINGS_AS_ERRORS, -Werror`
    public static let treatWarningsAsErrors: BuildSettingsKey = "MTL_TREAT_WARNINGS_AS_ERRORS"
}

// MARK: Other Nasm Flags
extension BuildSetting {

    /// Other Nasm Flags
    ///
    /// Space-separated list of additional flags to pass to the `nasm` assembler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `nasm` flag.
    public static var otherNasmFlags: BuildSetting { 
        BuildSetting(key: .otherNasmFlags, value: "")
    }

    /// Other Nasm Flags
    ///
    /// Space-separated list of additional flags to pass to the `nasm` assembler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `nasm` flag.
    public static func otherNasmFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherNasmFlags, value: .array(value))
    }

    /// Other Nasm Flags
    ///
    /// Space-separated list of additional flags to pass to the `nasm` assembler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `nasm` flag.
    public static func otherNasmFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherNasmFlags, inherit: key)
    }

    /// Other Nasm Flags
    ///
    /// Space-separated list of additional flags to pass to the `nasm` assembler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `nasm` flag.
    public static func otherNasmFlags(_ value: String...) -> BuildSetting { 
        .otherNasmFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Nasm Flags
    ///
    /// Space-separated list of additional flags to pass to the `nasm` assembler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `nasm` flag.
    public static let otherNasmFlags: BuildSettingsKey = "NASM_OTHER_FLAGS"
}

// MARK: NASM_OUTPUT_FILE_FORMAT
extension BuildSetting {

    /// NASM_OUTPUT_FILE_FORMAT
    public static var nasmOutputFileFormat: BuildSetting { 
        BuildSetting(key: .nasmOutputFileFormat, value: "macho")
    }

    /// NASM_OUTPUT_FILE_FORMAT
    public static func nasmOutputFileFormat(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nasmOutputFileFormat, value: "\(value)")
    }

    /// NASM_OUTPUT_FILE_FORMAT
    public static func nasmOutputFileFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nasmOutputFileFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// NASM_OUTPUT_FILE_FORMAT
    public static let nasmOutputFileFormat: BuildSettingsKey = "NASM_OUTPUT_FILE_FORMAT"
}

// MARK: Nasm Preinclude File
extension BuildSetting {

    /// Nasm Preinclude File
    ///
    /// Specifies a file to be preincluded, before the main source file starts to be processed.
    public static var nasmPreincludeFile: BuildSetting { 
        BuildSetting(key: .nasmPreincludeFile, value: "")
    }

    /// Nasm Preinclude File
    ///
    /// Specifies a file to be preincluded, before the main source file starts to be processed.
    public static func nasmPreincludeFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nasmPreincludeFile, value: "\(value)")
    }

    /// Nasm Preinclude File
    ///
    /// Specifies a file to be preincluded, before the main source file starts to be processed.
    public static func nasmPreincludeFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nasmPreincludeFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Nasm Preinclude File
    ///
    /// Specifies a file to be preincluded, before the main source file starts to be processed.
    public static let nasmPreincludeFile: BuildSettingsKey = "NASM_PREINCLUDE_FILE"
}

// MARK: NATIVE_ARCH
extension BuildSetting {

    /// NATIVE_ARCH
    ///
    /// Identifies the architecture on which the build is being performed.
    public static func nativeArch(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nativeArch, value: "\(value)")
    }

    /// NATIVE_ARCH
    ///
    /// Identifies the architecture on which the build is being performed.
    public static func nativeArch(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nativeArch, inherit: key)
    }
}

extension BuildSettingsKey {

    /// NATIVE_ARCH
    ///
    /// Identifies the architecture on which the build is being performed.
    public static let nativeArch: BuildSettingsKey = "NATIVE_ARCH"
}

// MARK: NATIVE_ARCH_32_BIT
extension BuildSetting {

    /// NATIVE_ARCH_32_BIT
    public static func nativeArch32Bit(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nativeArch32Bit, value: "\(value)")
    }

    /// NATIVE_ARCH_32_BIT
    public static func nativeArch32Bit(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nativeArch32Bit, inherit: key)
    }
}

extension BuildSettingsKey {

    /// NATIVE_ARCH_32_BIT
    public static let nativeArch32Bit: BuildSettingsKey = "NATIVE_ARCH_32_BIT"
}

// MARK: NATIVE_ARCH_64_BIT
extension BuildSetting {

    /// NATIVE_ARCH_64_BIT
    public static func nativeArch64Bit(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nativeArch64Bit, value: "\(value)")
    }

    /// NATIVE_ARCH_64_BIT
    public static func nativeArch64Bit(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nativeArch64Bit, inherit: key)
    }
}

extension BuildSettingsKey {

    /// NATIVE_ARCH_64_BIT
    public static let nativeArch64Bit: BuildSettingsKey = "NATIVE_ARCH_64_BIT"
}

// MARK: NATIVE_ARCH_ACTUAL
extension BuildSetting {

    /// NATIVE_ARCH_ACTUAL
    public static func nativeArchActual(_ value: String) -> BuildSetting { 
        BuildSetting(key: .nativeArchActual, value: "\(value)")
    }

    /// NATIVE_ARCH_ACTUAL
    public static func nativeArchActual(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .nativeArchActual, inherit: key)
    }
}

extension BuildSettingsKey {

    /// NATIVE_ARCH_ACTUAL
    public static let nativeArchActual: BuildSettingsKey = "NATIVE_ARCH_ACTUAL"
}

// MARK: NO_COMMON
extension BuildSetting {

    /// NO_COMMON
    public static var noCommon: BuildSetting { 
        BuildSetting(key: .noCommon, value: "YES")
    }

    /// NO_COMMON
    public static func noCommon(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .noCommon, value: SettingValue(booleanLiteral: value))
    }

    /// NO_COMMON
    public static func noCommon(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .noCommon, inherit: key)
    }
}

extension BuildSettingsKey {

    /// NO_COMMON
    public static let noCommon: BuildSettingsKey = "NO_COMMON"
}

// MARK: OBJECT_FILE_DIR
extension BuildSetting {

    /// OBJECT_FILE_DIR
    public static var objectFileDir: BuildSetting { 
        BuildSetting(key: .objectFileDir, value: "$(TARGET_TEMP_DIR)/Objects")
    }

    /// OBJECT_FILE_DIR
    public static func objectFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .objectFileDir, value: "\(value)")
    }

    /// OBJECT_FILE_DIR
    public static func objectFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objectFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OBJECT_FILE_DIR
    public static let objectFileDir: BuildSettingsKey = "OBJECT_FILE_DIR"
}

// MARK: Intermediate Build Files Path
extension BuildSetting {

    /// Intermediate Build Files Path
    ///
    /// The path where intermediate files will be placed during a build. Intermediate files include generated sources, object files, etc. Shell script build phases can place and access files here, as well. Typically this path is not set per target, but is set per project or per user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static var intermediateBuildFilesPath: BuildSetting { 
        .intermediateBuildFilesPath(inherit: .buildProductsPath) 
    }

    /// Intermediate Build Files Path
    ///
    /// The path where intermediate files will be placed during a build. Intermediate files include generated sources, object files, etc. Shell script build phases can place and access files here, as well. Typically this path is not set per target, but is set per project or per user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static func intermediateBuildFilesPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .intermediateBuildFilesPath, value: "\(value)")
    }

    /// Intermediate Build Files Path
    ///
    /// The path where intermediate files will be placed during a build. Intermediate files include generated sources, object files, etc. Shell script build phases can place and access files here, as well. Typically this path is not set per target, but is set per project or per user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static func intermediateBuildFilesPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .intermediateBuildFilesPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Intermediate Build Files Path
    ///
    /// The path where intermediate files will be placed during a build. Intermediate files include generated sources, object files, etc. Shell script build phases can place and access files here, as well. Typically this path is not set per target, but is set per project or per user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static let intermediateBuildFilesPath: BuildSettingsKey = "OBJROOT"
}

// MARK: Build Active Architecture Only
extension BuildSetting {

    /// Build Active Architecture Only
    ///
    /// If enabled, only the active architecture is built. This setting will be ignored when building with a run destination which does not define a specific architecture, such as a 'Generic Device' run destination.
    public static var buildActiveArchitectureOnly: BuildSetting { 
        BuildSetting(key: .buildActiveArchitectureOnly, value: "NO")
    }

    /// Build Active Architecture Only
    ///
    /// If enabled, only the active architecture is built. This setting will be ignored when building with a run destination which does not define a specific architecture, such as a 'Generic Device' run destination.
    public static func buildActiveArchitectureOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .buildActiveArchitectureOnly, value: SettingValue(booleanLiteral: value))
    }

    /// Build Active Architecture Only
    ///
    /// If enabled, only the active architecture is built. This setting will be ignored when building with a run destination which does not define a specific architecture, such as a 'Generic Device' run destination.
    public static func buildActiveArchitectureOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildActiveArchitectureOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Active Architecture Only
    ///
    /// If enabled, only the active architecture is built. This setting will be ignored when building with a run destination which does not define a specific architecture, such as a 'Generic Device' run destination.
    public static let buildActiveArchitectureOnly: BuildSettingsKey = "ONLY_ACTIVE_ARCH"
}

// MARK: On Demand Resources Initial Install Tags
extension BuildSetting {

    /// On Demand Resources Initial Install Tags
    ///
    /// Defined a set of initial On Demand Resources tags to be downloaded and installed with your application.
    public static func onDemandResourcesInitialInstallTags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .onDemandResourcesInitialInstallTags, value: .array(value))
    }

    /// On Demand Resources Initial Install Tags
    ///
    /// Defined a set of initial On Demand Resources tags to be downloaded and installed with your application.
    public static func onDemandResourcesInitialInstallTags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .onDemandResourcesInitialInstallTags, inherit: key)
    }

    /// On Demand Resources Initial Install Tags
    ///
    /// Defined a set of initial On Demand Resources tags to be downloaded and installed with your application.
    public static func onDemandResourcesInitialInstallTags(_ value: String...) -> BuildSetting { 
        .onDemandResourcesInitialInstallTags(value)
    }
}

extension BuildSettingsKey {

    /// On Demand Resources Initial Install Tags
    ///
    /// Defined a set of initial On Demand Resources tags to be downloaded and installed with your application.
    public static let onDemandResourcesInitialInstallTags: BuildSettingsKey = "ON_DEMAND_RESOURCES_INITIAL_INSTALL_TAGS"
}

// MARK: On Demand Resources Prefetch Order
extension BuildSetting {

    /// On Demand Resources Prefetch Order
    ///
    /// Once your app is installed, this defined a set of On Demand Resources tags that should be downloaded. These tags are downloaded after the initial installation of your application, and will be downloaded in the order the tags provided in the list from first to last.
    public static func onDemandResourcesPrefetchOrder(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .onDemandResourcesPrefetchOrder, value: .array(value))
    }

    /// On Demand Resources Prefetch Order
    ///
    /// Once your app is installed, this defined a set of On Demand Resources tags that should be downloaded. These tags are downloaded after the initial installation of your application, and will be downloaded in the order the tags provided in the list from first to last.
    public static func onDemandResourcesPrefetchOrder(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .onDemandResourcesPrefetchOrder, inherit: key)
    }

    /// On Demand Resources Prefetch Order
    ///
    /// Once your app is installed, this defined a set of On Demand Resources tags that should be downloaded. These tags are downloaded after the initial installation of your application, and will be downloaded in the order the tags provided in the list from first to last.
    public static func onDemandResourcesPrefetchOrder(_ value: String...) -> BuildSetting { 
        .onDemandResourcesPrefetchOrder(value)
    }
}

extension BuildSettingsKey {

    /// On Demand Resources Prefetch Order
    ///
    /// Once your app is installed, this defined a set of On Demand Resources tags that should be downloaded. These tags are downloaded after the initial installation of your application, and will be downloaded in the order the tags provided in the list from first to last.
    public static let onDemandResourcesPrefetchOrder: BuildSettingsKey = "ON_DEMAND_RESOURCES_PREFETCH_ORDER"
}

// MARK: OPENCLC
extension BuildSetting {

    /// OPENCLC
    public static var openclc: BuildSetting { 
        BuildSetting(key: .openclc, value: "/System/Library/Frameworks/OpenCL.framework/Libraries/openclc")
    }

    /// OPENCLC
    public static func openclc(_ value: String) -> BuildSetting { 
        BuildSetting(key: .openclc, value: "\(value)")
    }

    /// OPENCLC
    public static func openclc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OPENCLC
    public static let openclc: BuildSettingsKey = "OPENCLC"
}

// MARK: OpenCL Architectures
extension BuildSetting {

    /// OpenCL Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform.
    public static var openclArchitectures: BuildSetting { 
        BuildSetting(key: .openclArchitectures, value: "i386 x86_64 gpu_32 gpu_64")
    }

    /// OpenCL Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform.
    public static func openclArchitectures(_ value: OpenCLArchitectures) -> BuildSetting { 
        BuildSetting(key: .openclArchitectures, value: "\(value)")
    }

    /// OpenCL Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform.
    public static func openclArchitectures(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclArchitectures, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OpenCL Architectures
    ///
    /// A list of the architectures for which the product will be built. This is usually set to a predefined build setting provided by the platform.
    public static let openclArchitectures: BuildSettingsKey = "OPENCL_ARCHS"
}

// MARK: Auto-vectorizer
extension BuildSetting {

    /// Auto-vectorizer
    ///
    /// Auto-vectorizes the `OpenCL` kernels for the CPU. This setting takes effect only for the CPU. This makes it possible to write a single kernel that is portable and performant across CPUs and GPUs.
    public static var autoVectorizer: BuildSetting { 
        BuildSetting(key: .autoVectorizer, value: "YES")
    }

    /// Auto-vectorizer
    ///
    /// Auto-vectorizes the `OpenCL` kernels for the CPU. This setting takes effect only for the CPU. This makes it possible to write a single kernel that is portable and performant across CPUs and GPUs.
    public static func autoVectorizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .autoVectorizer, value: SettingValue(booleanLiteral: value))
    }

    /// Auto-vectorizer
    ///
    /// Auto-vectorizes the `OpenCL` kernels for the CPU. This setting takes effect only for the CPU. This makes it possible to write a single kernel that is portable and performant across CPUs and GPUs.
    public static func autoVectorizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .autoVectorizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Auto-vectorizer
    ///
    /// Auto-vectorizes the `OpenCL` kernels for the CPU. This setting takes effect only for the CPU. This makes it possible to write a single kernel that is portable and performant across CPUs and GPUs.
    public static let autoVectorizer: BuildSettingsKey = "OPENCL_AUTO_VECTORIZE_ENABLE"
}

// MARK: OpenCL Compiler Version
extension BuildSetting {

    /// OpenCL Compiler Version
    ///
    /// The `OpenCL` C compiler version supported by the platform.
    public static var openclCompilerVersion: BuildSetting { 
        .openclCompilerVersion(.cl11) 
    }

    /// OpenCL Compiler Version
    ///
    /// The `OpenCL` C compiler version supported by the platform.
    public static func openclCompilerVersion(_ value: OpenclCompilerVersion) -> BuildSetting { 
        BuildSetting(key: .openclCompilerVersion, value: "\(value)")
    }

    /// OpenCL Compiler Version
    ///
    /// The `OpenCL` C compiler version supported by the platform.
    public static func openclCompilerVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclCompilerVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OpenCL Compiler Version
    ///
    /// The `OpenCL` C compiler version supported by the platform.
    public static let openclCompilerVersion: BuildSettingsKey = "OPENCL_COMPILER_VERSION"
}

public enum OpenclCompilerVersion: String, Hashable, Codable, CustomStringConvertible {
    case cl12 = "CL1.2"
    case cl11 = "CL1.1"

    public var description: String {
        rawValue
    }
}

// MARK: Flush denorms to zero
extension BuildSetting {

    /// Flush denorms to zero
    ///
    /// This option controls how single precision and double precision denormalized numbers are handled. If specified as a build option, the single precision denormalized numbers may be flushed to zero; double precision denormalized numbers may also be flushed to zero if the optional extension for double precision is supported. This is intended to be a performance hint and the `OpenCL` compiler can choose not to flush denorms to zero if the device supports single precision (or double precision) denormalized numbers.

This option is ignored for single precision numbers if the device does not support single precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_SINGLE_FP_CONFIG`.

This option is ignored for double precision numbers if the device does not support double precision or if it does support double precision but not double precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_DOUBLE_FP_CONFIG`.

This flag only applies for scalar and vector single precision floating-point variables and computations on these floating-point variables inside a program. It does not apply to reading from or writing to image objects.
    public static var flushDenormsToZero: BuildSetting { 
        BuildSetting(key: .flushDenormsToZero, value: "NO")
    }

    /// Flush denorms to zero
    ///
    /// This option controls how single precision and double precision denormalized numbers are handled. If specified as a build option, the single precision denormalized numbers may be flushed to zero; double precision denormalized numbers may also be flushed to zero if the optional extension for double precision is supported. This is intended to be a performance hint and the `OpenCL` compiler can choose not to flush denorms to zero if the device supports single precision (or double precision) denormalized numbers.

This option is ignored for single precision numbers if the device does not support single precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_SINGLE_FP_CONFIG`.

This option is ignored for double precision numbers if the device does not support double precision or if it does support double precision but not double precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_DOUBLE_FP_CONFIG`.

This flag only applies for scalar and vector single precision floating-point variables and computations on these floating-point variables inside a program. It does not apply to reading from or writing to image objects.
    public static func flushDenormsToZero(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .flushDenormsToZero, value: SettingValue(booleanLiteral: value))
    }

    /// Flush denorms to zero
    ///
    /// This option controls how single precision and double precision denormalized numbers are handled. If specified as a build option, the single precision denormalized numbers may be flushed to zero; double precision denormalized numbers may also be flushed to zero if the optional extension for double precision is supported. This is intended to be a performance hint and the `OpenCL` compiler can choose not to flush denorms to zero if the device supports single precision (or double precision) denormalized numbers.

This option is ignored for single precision numbers if the device does not support single precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_SINGLE_FP_CONFIG`.

This option is ignored for double precision numbers if the device does not support double precision or if it does support double precision but not double precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_DOUBLE_FP_CONFIG`.

This flag only applies for scalar and vector single precision floating-point variables and computations on these floating-point variables inside a program. It does not apply to reading from or writing to image objects.
    public static func flushDenormsToZero(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .flushDenormsToZero, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Flush denorms to zero
    ///
    /// This option controls how single precision and double precision denormalized numbers are handled. If specified as a build option, the single precision denormalized numbers may be flushed to zero; double precision denormalized numbers may also be flushed to zero if the optional extension for double precision is supported. This is intended to be a performance hint and the `OpenCL` compiler can choose not to flush denorms to zero if the device supports single precision (or double precision) denormalized numbers.

This option is ignored for single precision numbers if the device does not support single precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_SINGLE_FP_CONFIG`.

This option is ignored for double precision numbers if the device does not support double precision or if it does support double precision but not double precision denormalized numbers, for example, `CL_FP_DENORM` bit is not set in `CL_DEVICE_DOUBLE_FP_CONFIG`.

This flag only applies for scalar and vector single precision floating-point variables and computations on these floating-point variables inside a program. It does not apply to reading from or writing to image objects.
    public static let flushDenormsToZero: BuildSettingsKey = "OPENCL_DENORMS_ARE_ZERO"
}

// MARK: Double as single
extension BuildSetting {

    /// Double as single
    ///
    /// Treat double precision floating-point expression as a single precision floating-point expression. This option is available for GPUs only.
    public static var doubleAsSingle: BuildSetting { 
        BuildSetting(key: .doubleAsSingle, value: "NO")
    }

    /// Double as single
    ///
    /// Treat double precision floating-point expression as a single precision floating-point expression. This option is available for GPUs only.
    public static func doubleAsSingle(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .doubleAsSingle, value: SettingValue(booleanLiteral: value))
    }

    /// Double as single
    ///
    /// Treat double precision floating-point expression as a single precision floating-point expression. This option is available for GPUs only.
    public static func doubleAsSingle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .doubleAsSingle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Double as single
    ///
    /// Treat double precision floating-point expression as a single precision floating-point expression. This option is available for GPUs only.
    public static let doubleAsSingle: BuildSettingsKey = "OPENCL_DOUBLE_AS_SINGLE"
}

// MARK: Relax IEEE Compliance
extension BuildSetting {

    /// Relax IEEE Compliance
    ///
    /// This allows optimizations for floating-point arithmetic that may violate the IEEE 754 standard and the `OpenCL` numerical compliance requirements defined in in section 7.4 for single-precision floating-point, section 9.3.9 for double-precision floating-point, and edge case behavior in section 7.5 of the `OpenCL` 1.1 specification.

This is intended to be a performance optimization.

This option causes the preprocessor macro ` __FAST_RELAXED_MATH__ ` to be defined in the `OpenCL` program.
    public static var relaxIeeeCompliance: BuildSetting { 
        BuildSetting(key: .relaxIeeeCompliance, value: "NO")
    }

    /// Relax IEEE Compliance
    ///
    /// This allows optimizations for floating-point arithmetic that may violate the IEEE 754 standard and the `OpenCL` numerical compliance requirements defined in in section 7.4 for single-precision floating-point, section 9.3.9 for double-precision floating-point, and edge case behavior in section 7.5 of the `OpenCL` 1.1 specification.

This is intended to be a performance optimization.

This option causes the preprocessor macro ` __FAST_RELAXED_MATH__ ` to be defined in the `OpenCL` program.
    public static func relaxIeeeCompliance(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .relaxIeeeCompliance, value: SettingValue(booleanLiteral: value))
    }

    /// Relax IEEE Compliance
    ///
    /// This allows optimizations for floating-point arithmetic that may violate the IEEE 754 standard and the `OpenCL` numerical compliance requirements defined in in section 7.4 for single-precision floating-point, section 9.3.9 for double-precision floating-point, and edge case behavior in section 7.5 of the `OpenCL` 1.1 specification.

This is intended to be a performance optimization.

This option causes the preprocessor macro ` __FAST_RELAXED_MATH__ ` to be defined in the `OpenCL` program.
    public static func relaxIeeeCompliance(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .relaxIeeeCompliance, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Relax IEEE Compliance
    ///
    /// This allows optimizations for floating-point arithmetic that may violate the IEEE 754 standard and the `OpenCL` numerical compliance requirements defined in in section 7.4 for single-precision floating-point, section 9.3.9 for double-precision floating-point, and edge case behavior in section 7.5 of the `OpenCL` 1.1 specification.

This is intended to be a performance optimization.

This option causes the preprocessor macro ` __FAST_RELAXED_MATH__ ` to be defined in the `OpenCL` program.
    public static let relaxIeeeCompliance: BuildSettingsKey = "OPENCL_FAST_RELAXED_MATH"
}

// MARK: Use MAD
extension BuildSetting {

    /// Use MAD
    ///
    /// Allow `a * b + c` to be replaced by a `mad` instruction. The `mad` computes `a * b + c` with reduced accuracy. For example, some `OpenCL` devices implement `mad` as truncate the result of `a * b` before adding it to `c`.

This is intended to be a performance optimization.
    public static var useMad: BuildSetting { 
        BuildSetting(key: .useMad, value: "NO")
    }

    /// Use MAD
    ///
    /// Allow `a * b + c` to be replaced by a `mad` instruction. The `mad` computes `a * b + c` with reduced accuracy. For example, some `OpenCL` devices implement `mad` as truncate the result of `a * b` before adding it to `c`.

This is intended to be a performance optimization.
    public static func useMad(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useMad, value: SettingValue(booleanLiteral: value))
    }

    /// Use MAD
    ///
    /// Allow `a * b + c` to be replaced by a `mad` instruction. The `mad` computes `a * b + c` with reduced accuracy. For example, some `OpenCL` devices implement `mad` as truncate the result of `a * b` before adding it to `c`.

This is intended to be a performance optimization.
    public static func useMad(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useMad, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use MAD
    ///
    /// Allow `a * b + c` to be replaced by a `mad` instruction. The `mad` computes `a * b + c` with reduced accuracy. For example, some `OpenCL` devices implement `mad` as truncate the result of `a * b` before adding it to `c`.

This is intended to be a performance optimization.
    public static let useMad: BuildSettingsKey = "OPENCL_MAD_ENABLE"
}

// MARK: Optimization Level
extension BuildSetting {

    /// Optimization Level
    ///
    /// - _None:_ Do not optimize. `-O0` With this setting, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you would expect from the source code.

- _Fast:_ Optimizing compilation takes somewhat more time, and a lot more memory for a large function. `-O, -O1` With this setting, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time. In Apple's compiler, strict aliasing, block reordering, and inter-block scheduling are disabled by default when optimizing.

- _Faster:_ The compiler performs nearly all supported optimizations that do not involve a space-speed tradeoff. `-O2` With this setting, the compiler does not perform loop unrolling or function inlining, or register renaming. As compared to the `Fast` setting, this setting increases both compilation time and the performance of the generated code.

- _Fastest:_ Turns on all optimizations specified by the `Faster` setting and also turns on function inlining and register renaming options. This setting may result in a larger binary. `-O3`

- _Fastest, smallest:_ Optimize for size. This setting enables all `Faster` optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size. `-Os`
    public static var optimizationLevel: BuildSetting { 
        .optimizationLevel(.s) 
    }

    /// Optimization Level
    ///
    /// - _None:_ Do not optimize. `-O0` With this setting, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you would expect from the source code.

- _Fast:_ Optimizing compilation takes somewhat more time, and a lot more memory for a large function. `-O, -O1` With this setting, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time. In Apple's compiler, strict aliasing, block reordering, and inter-block scheduling are disabled by default when optimizing.

- _Faster:_ The compiler performs nearly all supported optimizations that do not involve a space-speed tradeoff. `-O2` With this setting, the compiler does not perform loop unrolling or function inlining, or register renaming. As compared to the `Fast` setting, this setting increases both compilation time and the performance of the generated code.

- _Fastest:_ Turns on all optimizations specified by the `Faster` setting and also turns on function inlining and register renaming options. This setting may result in a larger binary. `-O3`

- _Fastest, smallest:_ Optimize for size. This setting enables all `Faster` optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size. `-Os`
    public static func optimizationLevel(_ value: OptimizationLevel) -> BuildSetting { 
        BuildSetting(key: .optimizationLevel, value: "\(value)")
    }

    /// Optimization Level
    ///
    /// - _None:_ Do not optimize. `-O0` With this setting, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you would expect from the source code.

- _Fast:_ Optimizing compilation takes somewhat more time, and a lot more memory for a large function. `-O, -O1` With this setting, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time. In Apple's compiler, strict aliasing, block reordering, and inter-block scheduling are disabled by default when optimizing.

- _Faster:_ The compiler performs nearly all supported optimizations that do not involve a space-speed tradeoff. `-O2` With this setting, the compiler does not perform loop unrolling or function inlining, or register renaming. As compared to the `Fast` setting, this setting increases both compilation time and the performance of the generated code.

- _Fastest:_ Turns on all optimizations specified by the `Faster` setting and also turns on function inlining and register renaming options. This setting may result in a larger binary. `-O3`

- _Fastest, smallest:_ Optimize for size. This setting enables all `Faster` optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size. `-Os`
    public static func optimizationLevel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimizationLevel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Optimization Level
    ///
    /// - _None:_ Do not optimize. `-O0` With this setting, the compiler's goal is to reduce the cost of compilation and to make debugging produce the expected results. Statements are independent: if you stop the program with a breakpoint between statements, you can then assign a new value to any variable or change the program counter to any other statement in the function and get exactly the results you would expect from the source code.

- _Fast:_ Optimizing compilation takes somewhat more time, and a lot more memory for a large function. `-O, -O1` With this setting, the compiler tries to reduce code size and execution time, without performing any optimizations that take a great deal of compilation time. In Apple's compiler, strict aliasing, block reordering, and inter-block scheduling are disabled by default when optimizing.

- _Faster:_ The compiler performs nearly all supported optimizations that do not involve a space-speed tradeoff. `-O2` With this setting, the compiler does not perform loop unrolling or function inlining, or register renaming. As compared to the `Fast` setting, this setting increases both compilation time and the performance of the generated code.

- _Fastest:_ Turns on all optimizations specified by the `Faster` setting and also turns on function inlining and register renaming options. This setting may result in a larger binary. `-O3`

- _Fastest, smallest:_ Optimize for size. This setting enables all `Faster` optimizations that do not typically increase code size. It also performs further optimizations designed to reduce code size. `-Os`
    public static let optimizationLevel: BuildSettingsKey = "OPENCL_OPTIMIZATION_LEVEL"
}

// MARK: OpenCL Other Flags
extension BuildSetting {

    /// OpenCL Other Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular compiler flag.
    public static func openclOtherFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .openclOtherFlags, value: .array(value))
    }

    /// OpenCL Other Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular compiler flag.
    public static func openclOtherFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclOtherFlags, inherit: key)
    }

    /// OpenCL Other Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular compiler flag.
    public static func openclOtherFlags(_ value: String...) -> BuildSetting { 
        .openclOtherFlags(value)
    }
}

extension BuildSettingsKey {

    /// OpenCL Other Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular compiler flag.
    public static let openclOtherFlags: BuildSettingsKey = "OPENCL_OTHER_BC_FLAGS"
}

// MARK: OpenCL Preprocessor Macros
extension BuildSetting {

    /// OpenCL Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func openclPreprocessorMacros(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .openclPreprocessorMacros, value: .array(value))
    }

    /// OpenCL Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func openclPreprocessorMacros(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .openclPreprocessorMacros, inherit: key)
    }

    /// OpenCL Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static func openclPreprocessorMacros(_ value: String...) -> BuildSetting { 
        .openclPreprocessorMacros(value)
    }
}

extension BuildSettingsKey {

    /// OpenCL Preprocessor Macros
    ///
    /// Space-separated list of preprocessor macros of the form `foo` or `foo=bar`.
    public static let openclPreprocessorMacros: BuildSettingsKey = "OPENCL_PREPROCESSOR_DEFINITIONS"
}

// MARK: OPTIMIZATION_CFLAGS
extension BuildSetting {

    /// OPTIMIZATION_CFLAGS
    public static var optimizationCflags: BuildSetting { 
        BuildSetting(key: .optimizationCflags, value: "")
    }

    /// OPTIMIZATION_CFLAGS
    public static func optimizationCflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .optimizationCflags, value: .array(value))
    }

    /// OPTIMIZATION_CFLAGS
    public static func optimizationCflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimizationCflags, inherit: key)
    }

    /// OPTIMIZATION_CFLAGS
    public static func optimizationCflags(_ value: String...) -> BuildSetting { 
        .optimizationCflags(value)
    }
}

extension BuildSettingsKey {

    /// OPTIMIZATION_CFLAGS
    public static let optimizationCflags: BuildSettingsKey = "OPTIMIZATION_CFLAGS"
}

// MARK: Order File
extension BuildSetting {

    /// Order File
    ///
    /// The path to a file that alters the order in which functions and data are laid out.

For each section in the output file, any symbol in that section that are specified in the order file is moved to the start of its section and laid out in the same order as in the order file. Order files are text files with one symbol name per line. Lines starting with a `#` are comments. A symbol name may be optionally preceded with its object file leafname and a colon (for example, `foo.o:_foo`). This is useful for static functions/data that occur in multiple files. A symbol name may also be optionally preceded with the architecture (for example, `ppc:_foo` or `ppc:foo.o:_foo`). This enables you to have one order file that works for multiple architectures. Literal C-strings may be ordered by quoting the string in the order file (for example, `"Hello, world\n"`).

Generally you should not specify an order file in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static var orderFile: BuildSetting { 
        BuildSetting(key: .orderFile, value: "")
    }

    /// Order File
    ///
    /// The path to a file that alters the order in which functions and data are laid out.

For each section in the output file, any symbol in that section that are specified in the order file is moved to the start of its section and laid out in the same order as in the order file. Order files are text files with one symbol name per line. Lines starting with a `#` are comments. A symbol name may be optionally preceded with its object file leafname and a colon (for example, `foo.o:_foo`). This is useful for static functions/data that occur in multiple files. A symbol name may also be optionally preceded with the architecture (for example, `ppc:_foo` or `ppc:foo.o:_foo`). This enables you to have one order file that works for multiple architectures. Literal C-strings may be ordered by quoting the string in the order file (for example, `"Hello, world\n"`).

Generally you should not specify an order file in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func orderFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .orderFile, value: "\(value)")
    }

    /// Order File
    ///
    /// The path to a file that alters the order in which functions and data are laid out.

For each section in the output file, any symbol in that section that are specified in the order file is moved to the start of its section and laid out in the same order as in the order file. Order files are text files with one symbol name per line. Lines starting with a `#` are comments. A symbol name may be optionally preceded with its object file leafname and a colon (for example, `foo.o:_foo`). This is useful for static functions/data that occur in multiple files. A symbol name may also be optionally preceded with the architecture (for example, `ppc:_foo` or `ppc:foo.o:_foo`). This enables you to have one order file that works for multiple architectures. Literal C-strings may be ordered by quoting the string in the order file (for example, `"Hello, world\n"`).

Generally you should not specify an order file in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func orderFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .orderFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Order File
    ///
    /// The path to a file that alters the order in which functions and data are laid out.

For each section in the output file, any symbol in that section that are specified in the order file is moved to the start of its section and laid out in the same order as in the order file. Order files are text files with one symbol name per line. Lines starting with a `#` are comments. A symbol name may be optionally preceded with its object file leafname and a colon (for example, `foo.o:_foo`). This is useful for static functions/data that occur in multiple files. A symbol name may also be optionally preceded with the architecture (for example, `ppc:_foo` or `ppc:foo.o:_foo`). This enables you to have one order file that works for multiple architectures. Literal C-strings may be ordered by quoting the string in the order file (for example, `"Hello, world\n"`).

Generally you should not specify an order file in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static let orderFile: BuildSettingsKey = "ORDER_FILE"
}

// MARK: OSAC
extension BuildSetting {

    /// OSAC
    public static var osac: BuildSetting { 
        BuildSetting(key: .osac, value: "/usr/bin/osacompile")
    }

    /// OSAC
    public static func osac(_ value: String) -> BuildSetting { 
        BuildSetting(key: .osac, value: "\(value)")
    }

    /// OSAC
    public static func osac(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .osac, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OSAC
    public static let osac: BuildSettingsKey = "OSAC"
}

// MARK: Save as Execute-Only
extension BuildSetting {

    /// Save as Execute-Only
    ///
    /// Saves the output script in execute-only form; the script can be run, but cannot be opened in Script Editor or Xcode. With this option turned off, a user may see the original script source by opening the script.
    public static var saveAsExecuteOnly: BuildSetting { 
        BuildSetting(key: .saveAsExecuteOnly, value: "NO")
    }

    /// Save as Execute-Only
    ///
    /// Saves the output script in execute-only form; the script can be run, but cannot be opened in Script Editor or Xcode. With this option turned off, a user may see the original script source by opening the script.
    public static func saveAsExecuteOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .saveAsExecuteOnly, value: SettingValue(booleanLiteral: value))
    }

    /// Save as Execute-Only
    ///
    /// Saves the output script in execute-only form; the script can be run, but cannot be opened in Script Editor or Xcode. With this option turned off, a user may see the original script source by opening the script.
    public static func saveAsExecuteOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .saveAsExecuteOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Save as Execute-Only
    ///
    /// Saves the output script in execute-only form; the script can be run, but cannot be opened in Script Editor or Xcode. With this option turned off, a user may see the original script source by opening the script.
    public static let saveAsExecuteOnly: BuildSettingsKey = "OSACOMPILE_EXECUTE_ONLY"
}

// MARK: Other C Flags
extension BuildSetting {

    /// Other C Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C and Objective-C files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular C or Objective-C compiler flag.
    public static func otherCFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherCFlags, value: .array(value))
    }

    /// Other C Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C and Objective-C files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular C or Objective-C compiler flag.
    public static func otherCFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherCFlags, inherit: key)
    }

    /// Other C Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C and Objective-C files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular C or Objective-C compiler flag.
    public static func otherCFlags(_ value: String...) -> BuildSetting { 
        .otherCFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other C Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C and Objective-C files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular C or Objective-C compiler flag.
    public static let otherCFlags: BuildSettingsKey = "OTHER_CFLAGS"
}

// MARK: Other Code Signing Flags
extension BuildSetting {

    /// Other Code Signing Flags
    ///
    /// A list of additional options to pass to `codesign(1)`.
    public static var otherCodeSigningFlags: BuildSetting { 
        BuildSetting(key: .otherCodeSigningFlags, value: "")
    }

    /// Other Code Signing Flags
    ///
    /// A list of additional options to pass to `codesign(1)`.
    public static func otherCodeSigningFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherCodeSigningFlags, value: .array(value))
    }

    /// Other Code Signing Flags
    ///
    /// A list of additional options to pass to `codesign(1)`.
    public static func otherCodeSigningFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherCodeSigningFlags, inherit: key)
    }

    /// Other Code Signing Flags
    ///
    /// A list of additional options to pass to `codesign(1)`.
    public static func otherCodeSigningFlags(_ value: String...) -> BuildSetting { 
        .otherCodeSigningFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Code Signing Flags
    ///
    /// A list of additional options to pass to `codesign(1)`.
    public static let otherCodeSigningFlags: BuildSettingsKey = "OTHER_CODE_SIGN_FLAGS"
}

// MARK: Other C++ Flags
extension BuildSetting {

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static var otherCppFlags: BuildSetting { 
        .otherCppFlags(inherit: .otherCFlags) 
    }

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static func otherCppFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherCppFlags, value: .array(value))
    }

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static func otherCppFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherCppFlags, inherit: key)
    }

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static func otherCppFlags(_ value: String...) -> BuildSetting { 
        .otherCppFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other C++ Flags
    ///
    /// Space-separated list of additional flags to pass to the compiler for C++ and Objective-C++ files. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a C++ or Objective-C++ compiler flag.
    public static let otherCppFlags: BuildSettingsKey = "OTHER_CPLUSPLUSFLAGS"
}

// MARK: Other IIG C Flags
extension BuildSetting {

    /// Other IIG C Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` invocation of clang. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static var otherIigCFlags: BuildSetting { 
        BuildSetting(key: .otherIigCFlags, value: "")
    }

    /// Other IIG C Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` invocation of clang. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigCFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherIigCFlags, value: .array(value))
    }

    /// Other IIG C Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` invocation of clang. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigCFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherIigCFlags, inherit: key)
    }

    /// Other IIG C Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` invocation of clang. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigCFlags(_ value: String...) -> BuildSetting { 
        .otherIigCFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other IIG C Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` invocation of clang. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static let otherIigCFlags: BuildSettingsKey = "OTHER_IIG_CFLAGS"
}

// MARK: Other IIG Flags
extension BuildSetting {

    /// Other IIG Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static var otherIigFlags: BuildSetting { 
        BuildSetting(key: .otherIigFlags, value: "")
    }

    /// Other IIG Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherIigFlags, value: .array(value))
    }

    /// Other IIG Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherIigFlags, inherit: key)
    }

    /// Other IIG Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static func otherIigFlags(_ value: String...) -> BuildSetting { 
        .otherIigFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other IIG Flags
    ///
    /// Space-separated list of additional flags to pass to the `iig` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `iig` flag
    public static let otherIigFlags: BuildSettingsKey = "OTHER_IIG_FLAGS"
}

// MARK: Other Linker Flags
extension BuildSetting {

    /// Other Linker Flags
    ///
    /// Options defined in this setting are passed to invocations of the linker.
    public static var otherLinkerFlags: BuildSetting { 
        BuildSetting(key: .otherLinkerFlags, value: "")
    }

    /// Other Linker Flags
    ///
    /// Options defined in this setting are passed to invocations of the linker.
    public static func otherLinkerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherLinkerFlags, value: .array(value))
    }

    /// Other Linker Flags
    ///
    /// Options defined in this setting are passed to invocations of the linker.
    public static func otherLinkerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherLinkerFlags, inherit: key)
    }

    /// Other Linker Flags
    ///
    /// Options defined in this setting are passed to invocations of the linker.
    public static func otherLinkerFlags(_ value: String...) -> BuildSetting { 
        .otherLinkerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Linker Flags
    ///
    /// Options defined in this setting are passed to invocations of the linker.
    public static let otherLinkerFlags: BuildSettingsKey = "OTHER_LDFLAGS"
}

// MARK: OTHER_LDRFLAGS
extension BuildSetting {

    /// OTHER_LDRFLAGS
    public static var otherLdrflags: BuildSetting { 
        .otherLdrflags(inherit: .otherLinkerFlags) 
    }

    /// OTHER_LDRFLAGS
    public static func otherLdrflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherLdrflags, value: .array(value))
    }

    /// OTHER_LDRFLAGS
    public static func otherLdrflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherLdrflags, inherit: key)
    }

    /// OTHER_LDRFLAGS
    public static func otherLdrflags(_ value: String...) -> BuildSetting { 
        .otherLdrflags(value)
    }
}

extension BuildSettingsKey {

    /// OTHER_LDRFLAGS
    public static let otherLdrflags: BuildSettingsKey = "OTHER_LDRFLAGS"
}

// MARK: Other Librarian Flags
extension BuildSetting {

    /// Other Librarian Flags
    ///
    /// Options defined in this setting are passed to all invocations of the archive librarian, which is used to generate static libraries.
    public static var otherLibrarianFlags: BuildSetting { 
        BuildSetting(key: .otherLibrarianFlags, value: "")
    }

    /// Other Librarian Flags
    ///
    /// Options defined in this setting are passed to all invocations of the archive librarian, which is used to generate static libraries.
    public static func otherLibrarianFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherLibrarianFlags, value: .array(value))
    }

    /// Other Librarian Flags
    ///
    /// Options defined in this setting are passed to all invocations of the archive librarian, which is used to generate static libraries.
    public static func otherLibrarianFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherLibrarianFlags, inherit: key)
    }

    /// Other Librarian Flags
    ///
    /// Options defined in this setting are passed to all invocations of the archive librarian, which is used to generate static libraries.
    public static func otherLibrarianFlags(_ value: String...) -> BuildSetting { 
        .otherLibrarianFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Librarian Flags
    ///
    /// Options defined in this setting are passed to all invocations of the archive librarian, which is used to generate static libraries.
    public static let otherLibrarianFlags: BuildSettingsKey = "OTHER_LIBTOOLFLAGS"
}

// MARK: Other MiG Flags
extension BuildSetting {

    /// Other MiG Flags
    ///
    /// Space-separated list of additional flags to pass to `mig`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `mig` flag.
    public static var otherMigFlags: BuildSetting { 
        BuildSetting(key: .otherMigFlags, value: "")
    }

    /// Other MiG Flags
    ///
    /// Space-separated list of additional flags to pass to `mig`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `mig` flag.
    public static func otherMigFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherMigFlags, value: .array(value))
    }

    /// Other MiG Flags
    ///
    /// Space-separated list of additional flags to pass to `mig`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `mig` flag.
    public static func otherMigFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherMigFlags, inherit: key)
    }

    /// Other MiG Flags
    ///
    /// Space-separated list of additional flags to pass to `mig`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `mig` flag.
    public static func otherMigFlags(_ value: String...) -> BuildSetting { 
        .otherMigFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other MiG Flags
    ///
    /// Space-separated list of additional flags to pass to `mig`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `mig` flag.
    public static let otherMigFlags: BuildSettingsKey = "OTHER_MIGFLAGS"
}

// MARK: Other OSACompile Flags
extension BuildSetting {

    /// Other OSACompile Flags
    ///
    /// Space-separated list of additional flags to pass to `osacompile`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `osacompile` flag.
    public static var otherOsacompileFlags: BuildSetting { 
        BuildSetting(key: .otherOsacompileFlags, value: "")
    }

    /// Other OSACompile Flags
    ///
    /// Space-separated list of additional flags to pass to `osacompile`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `osacompile` flag.
    public static func otherOsacompileFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherOsacompileFlags, value: .array(value))
    }

    /// Other OSACompile Flags
    ///
    /// Space-separated list of additional flags to pass to `osacompile`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `osacompile` flag.
    public static func otherOsacompileFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherOsacompileFlags, inherit: key)
    }

    /// Other OSACompile Flags
    ///
    /// Space-separated list of additional flags to pass to `osacompile`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `osacompile` flag.
    public static func otherOsacompileFlags(_ value: String...) -> BuildSetting { 
        .otherOsacompileFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other OSACompile Flags
    ///
    /// Space-separated list of additional flags to pass to `osacompile`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `osacompile` flag.
    public static let otherOsacompileFlags: BuildSettingsKey = "OTHER_OSACOMPILEFLAGS"
}

// MARK: OTHER_OSAFLAGS
extension BuildSetting {

    /// OTHER_OSAFLAGS
    public static var otherOsaflags: BuildSetting { 
        BuildSetting(key: .otherOsaflags, value: "")
    }

    /// OTHER_OSAFLAGS
    public static func otherOsaflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherOsaflags, value: .array(value))
    }

    /// OTHER_OSAFLAGS
    public static func otherOsaflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherOsaflags, inherit: key)
    }

    /// OTHER_OSAFLAGS
    public static func otherOsaflags(_ value: String...) -> BuildSetting { 
        .otherOsaflags(value)
    }
}

extension BuildSettingsKey {

    /// OTHER_OSAFLAGS
    public static let otherOsaflags: BuildSettingsKey = "OTHER_OSAFLAGS"
}

// MARK: OTHER_PRECOMP_CFLAGS
extension BuildSetting {

    /// OTHER_PRECOMP_CFLAGS
    public static var otherPrecompCflags: BuildSetting { 
        BuildSetting(key: .otherPrecompCflags, value: "")
    }

    /// OTHER_PRECOMP_CFLAGS
    public static func otherPrecompCflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherPrecompCflags, value: .array(value))
    }

    /// OTHER_PRECOMP_CFLAGS
    public static func otherPrecompCflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherPrecompCflags, inherit: key)
    }

    /// OTHER_PRECOMP_CFLAGS
    public static func otherPrecompCflags(_ value: String...) -> BuildSetting { 
        .otherPrecompCflags(value)
    }
}

extension BuildSettingsKey {

    /// OTHER_PRECOMP_CFLAGS
    public static let otherPrecompCflags: BuildSettingsKey = "OTHER_PRECOMP_CFLAGS"
}

// MARK: Other Reality Composer Project Compiler flags
extension BuildSetting {

    /// Other Reality Composer Project Compiler flags
    public static var otherRealityComposerProjectCompilerFlags: BuildSetting { 
        BuildSetting(key: .otherRealityComposerProjectCompilerFlags, value: "")
    }

    /// Other Reality Composer Project Compiler flags
    public static func otherRealityComposerProjectCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherRealityComposerProjectCompilerFlags, value: .array(value))
    }

    /// Other Reality Composer Project Compiler flags
    public static func otherRealityComposerProjectCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherRealityComposerProjectCompilerFlags, inherit: key)
    }

    /// Other Reality Composer Project Compiler flags
    public static func otherRealityComposerProjectCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherRealityComposerProjectCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Reality Composer Project Compiler flags
    public static let otherRealityComposerProjectCompilerFlags: BuildSettingsKey = "OTHER_RCPROJECT_FLAGS"
}

// MARK: OTHER_RESMERGERFLAGS
extension BuildSetting {

    /// OTHER_RESMERGERFLAGS
    public static var otherResmergerflags: BuildSetting { 
        BuildSetting(key: .otherResmergerflags, value: "")
    }

    /// OTHER_RESMERGERFLAGS
    public static func otherResmergerflags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherResmergerflags, value: .array(value))
    }

    /// OTHER_RESMERGERFLAGS
    public static func otherResmergerflags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherResmergerflags, inherit: key)
    }

    /// OTHER_RESMERGERFLAGS
    public static func otherResmergerflags(_ value: String...) -> BuildSetting { 
        .otherResmergerflags(value)
    }
}

extension BuildSettingsKey {

    /// OTHER_RESMERGERFLAGS
    public static let otherResmergerflags: BuildSettingsKey = "OTHER_RESMERGERFLAGS"
}

// MARK: Other Rez Flags
extension BuildSetting {

    /// Other Rez Flags
    ///
    /// Space-separated list of additional flags to pass to the `Rez` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `Rez` flag.
    public static var otherRezFlags: BuildSetting { 
        BuildSetting(key: .otherRezFlags, value: "")
    }

    /// Other Rez Flags
    ///
    /// Space-separated list of additional flags to pass to the `Rez` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `Rez` flag.
    public static func otherRezFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherRezFlags, value: .array(value))
    }

    /// Other Rez Flags
    ///
    /// Space-separated list of additional flags to pass to the `Rez` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `Rez` flag.
    public static func otherRezFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherRezFlags, inherit: key)
    }

    /// Other Rez Flags
    ///
    /// Space-separated list of additional flags to pass to the `Rez` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `Rez` flag.
    public static func otherRezFlags(_ value: String...) -> BuildSetting { 
        .otherRezFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Rez Flags
    ///
    /// Space-separated list of additional flags to pass to the `Rez` compiler. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a particular `Rez` flag.
    public static let otherRezFlags: BuildSettingsKey = "OTHER_REZFLAGS"
}

// MARK: Other Skybox Compiler Flags
extension BuildSetting {

    /// Other Skybox Compiler Flags
    public static var otherSkyboxCompilerFlags: BuildSetting { 
        BuildSetting(key: .otherSkyboxCompilerFlags, value: "")
    }

    /// Other Skybox Compiler Flags
    public static func otherSkyboxCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherSkyboxCompilerFlags, value: .array(value))
    }

    /// Other Skybox Compiler Flags
    public static func otherSkyboxCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherSkyboxCompilerFlags, inherit: key)
    }

    /// Other Skybox Compiler Flags
    public static func otherSkyboxCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherSkyboxCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Skybox Compiler Flags
    public static let otherSkyboxCompilerFlags: BuildSettingsKey = "OTHER_SKYBOX_FLAGS"
}

// MARK: OTHER_SWIFT_ABI_CHECKER_FLAGS
extension BuildSetting {

    /// OTHER_SWIFT_ABI_CHECKER_FLAGS
    public static func otherSwiftAbiCheckerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherSwiftAbiCheckerFlags, value: .array(value))
    }

    /// OTHER_SWIFT_ABI_CHECKER_FLAGS
    public static func otherSwiftAbiCheckerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherSwiftAbiCheckerFlags, inherit: key)
    }

    /// OTHER_SWIFT_ABI_CHECKER_FLAGS
    public static func otherSwiftAbiCheckerFlags(_ value: String...) -> BuildSetting { 
        .otherSwiftAbiCheckerFlags(value)
    }
}

extension BuildSettingsKey {

    /// OTHER_SWIFT_ABI_CHECKER_FLAGS
    public static let otherSwiftAbiCheckerFlags: BuildSettingsKey = "OTHER_SWIFT_ABI_CHECKER_FLAGS"
}

// MARK: Other Swift Flags
extension BuildSetting {

    /// Other Swift Flags
    ///
    /// A list of additional flags to pass to the Swift compiler.
    public static func otherSwiftFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherSwiftFlags, value: .array(value))
    }

    /// Other Swift Flags
    ///
    /// A list of additional flags to pass to the Swift compiler.
    public static func otherSwiftFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherSwiftFlags, inherit: key)
    }

    /// Other Swift Flags
    ///
    /// A list of additional flags to pass to the Swift compiler.
    public static func otherSwiftFlags(_ value: String...) -> BuildSetting { 
        .otherSwiftFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Swift Flags
    ///
    /// A list of additional flags to pass to the Swift compiler.
    public static let otherSwiftFlags: BuildSettingsKey = "OTHER_SWIFT_FLAGS"
}

// MARK: OTHER_SWIFT_STDLIB_TOOL_FLAGS
extension BuildSetting {

    /// OTHER_SWIFT_STDLIB_TOOL_FLAGS
    public static var otherSwiftStdlibToolFlags: BuildSetting { 
        BuildSetting(key: .otherSwiftStdlibToolFlags, value: "")
    }

    /// OTHER_SWIFT_STDLIB_TOOL_FLAGS
    public static func otherSwiftStdlibToolFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherSwiftStdlibToolFlags, value: .array(value))
    }

    /// OTHER_SWIFT_STDLIB_TOOL_FLAGS
    public static func otherSwiftStdlibToolFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherSwiftStdlibToolFlags, inherit: key)
    }

    /// OTHER_SWIFT_STDLIB_TOOL_FLAGS
    public static func otherSwiftStdlibToolFlags(_ value: String...) -> BuildSetting { 
        .otherSwiftStdlibToolFlags(value)
    }
}

extension BuildSettingsKey {

    /// OTHER_SWIFT_STDLIB_TOOL_FLAGS
    public static let otherSwiftStdlibToolFlags: BuildSettingsKey = "OTHER_SWIFT_STDLIB_TOOL_FLAGS"
}

// MARK: Other Text-Based InstallAPI Flags
extension BuildSetting {

    /// Other Text-Based InstallAPI Flags
    ///
    /// Options defined in this setting are passed to invocations of the `Text-Based InstallAPI` tool.
    public static var otherTextBasedInstallapiFlags: BuildSetting { 
        BuildSetting(key: .otherTextBasedInstallapiFlags, value: "")
    }

    /// Other Text-Based InstallAPI Flags
    ///
    /// Options defined in this setting are passed to invocations of the `Text-Based InstallAPI` tool.
    public static func otherTextBasedInstallapiFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherTextBasedInstallapiFlags, value: .array(value))
    }

    /// Other Text-Based InstallAPI Flags
    ///
    /// Options defined in this setting are passed to invocations of the `Text-Based InstallAPI` tool.
    public static func otherTextBasedInstallapiFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherTextBasedInstallapiFlags, inherit: key)
    }

    /// Other Text-Based InstallAPI Flags
    ///
    /// Options defined in this setting are passed to invocations of the `Text-Based InstallAPI` tool.
    public static func otherTextBasedInstallapiFlags(_ value: String...) -> BuildSetting { 
        .otherTextBasedInstallapiFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Text-Based InstallAPI Flags
    ///
    /// Options defined in this setting are passed to invocations of the `Text-Based InstallAPI` tool.
    public static let otherTextBasedInstallapiFlags: BuildSettingsKey = "OTHER_TAPI_FLAGS"
}

// MARK: Other USDZ Compiler Flags
extension BuildSetting {

    /// Other USDZ Compiler Flags
    public static var otherUsdzCompilerFlags: BuildSetting { 
        BuildSetting(key: .otherUsdzCompilerFlags, value: "")
    }

    /// Other USDZ Compiler Flags
    public static func otherUsdzCompilerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherUsdzCompilerFlags, value: .array(value))
    }

    /// Other USDZ Compiler Flags
    public static func otherUsdzCompilerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherUsdzCompilerFlags, inherit: key)
    }

    /// Other USDZ Compiler Flags
    public static func otherUsdzCompilerFlags(_ value: String...) -> BuildSetting { 
        .otherUsdzCompilerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other USDZ Compiler Flags
    public static let otherUsdzCompilerFlags: BuildSettingsKey = "OTHER_USDZ_FLAGS"
}

// MARK: OutputFormat
extension BuildSetting {

    /// OutputFormat
    public static var outputformat: BuildSetting { 
        .outputformat(.sameAsInput) 
    }

    /// OutputFormat
    public static func outputformat(_ value: Outputformat) -> BuildSetting { 
        BuildSetting(key: .outputformat, value: "\(value)")
    }

    /// OutputFormat
    public static func outputformat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .outputformat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// OutputFormat
    public static let outputformat: BuildSettingsKey = "OutputFormat"
}

public enum Outputformat: String, Hashable, Codable, CustomStringConvertible {
    case sameAsInput = "same-as-input"
    case openstep = "openstep"
    case xml = "XML"
    case xml = "xml"
    case binary = "binary"

    public var description: String {
        rawValue
    }
}

// MARK: PACKAGE_TYPE
extension BuildSetting {

    /// PACKAGE_TYPE
    ///
    /// Uniform type identifier. Identifies the type of the product the target builds. Some products may be made up of a single binary or archive. Others may comprise several files, which are grouped under a single directory. These container directories are known as *bundles*.
    public static var packageType: BuildSetting { 
        BuildSetting(key: .packageType, value: "")
    }

    /// PACKAGE_TYPE
    ///
    /// Uniform type identifier. Identifies the type of the product the target builds. Some products may be made up of a single binary or archive. Others may comprise several files, which are grouped under a single directory. These container directories are known as *bundles*.
    public static func packageType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .packageType, value: "\(value)")
    }

    /// PACKAGE_TYPE
    ///
    /// Uniform type identifier. Identifies the type of the product the target builds. Some products may be made up of a single binary or archive. Others may comprise several files, which are grouped under a single directory. These container directories are known as *bundles*.
    public static func packageType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .packageType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PACKAGE_TYPE
    ///
    /// Uniform type identifier. Identifies the type of the product the target builds. Some products may be made up of a single binary or archive. Others may comprise several files, which are grouped under a single directory. These container directories are known as *bundles*.
    public static let packageType: BuildSettingsKey = "PACKAGE_TYPE"
}

// MARK: PASCAL_STRINGS
extension BuildSetting {

    /// PASCAL_STRINGS
    public static var pascalStrings: BuildSetting { 
        BuildSetting(key: .pascalStrings, value: "YES")
    }

    /// PASCAL_STRINGS
    public static func pascalStrings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pascalStrings, value: SettingValue(booleanLiteral: value))
    }

    /// PASCAL_STRINGS
    public static func pascalStrings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pascalStrings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PASCAL_STRINGS
    public static let pascalStrings: BuildSettingsKey = "PASCAL_STRINGS"
}

// MARK: PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES
extension BuildSetting {

    /// PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES
    public static var pathPrefixesExcludedFromHeaderDependencies: BuildSetting { 
        BuildSetting(key: .pathPrefixesExcludedFromHeaderDependencies, value: "/usr/include /usr/local/include /System/Library/Frameworks /System/Library/PrivateFrameworks $(SYSTEM_DEVELOPER_DIR)/Headers $(SYSTEM_DEVELOPER_DIR)/SDKs $(SYSTEM_DEVELOPER_DIR)/Platforms")
    }

    /// PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES
    public static func pathPrefixesExcludedFromHeaderDependencies(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .pathPrefixesExcludedFromHeaderDependencies, value: .array(value))
    }

    /// PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES
    public static func pathPrefixesExcludedFromHeaderDependencies(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pathPrefixesExcludedFromHeaderDependencies, inherit: key)
    }

    /// PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES
    public static func pathPrefixesExcludedFromHeaderDependencies(_ value: String...) -> BuildSetting { 
        .pathPrefixesExcludedFromHeaderDependencies(value)
    }
}

extension BuildSettingsKey {

    /// PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES
    public static let pathPrefixesExcludedFromHeaderDependencies: BuildSettingsKey = "PATH_PREFIXES_EXCLUDED_FROM_HEADER_DEPENDENCIES"
}

// MARK: PBDEVELOPMENTPLIST_PATH
extension BuildSetting {

    /// PBDEVELOPMENTPLIST_PATH
    public static var pbdevelopmentplistPath: BuildSetting { 
        BuildSetting(key: .pbdevelopmentplistPath, value: "")
    }

    /// PBDEVELOPMENTPLIST_PATH
    public static func pbdevelopmentplistPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pbdevelopmentplistPath, value: "\(value)")
    }

    /// PBDEVELOPMENTPLIST_PATH
    public static func pbdevelopmentplistPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbdevelopmentplistPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PBDEVELOPMENTPLIST_PATH
    public static let pbdevelopmentplistPath: BuildSettingsKey = "PBDEVELOPMENTPLIST_PATH"
}

// MARK: PBXCP_BITCODE_STRIP_MODE
extension BuildSetting {

    /// PBXCP_BITCODE_STRIP_MODE
    public static var pbxcpBitcodeStripMode: BuildSetting { 
        BuildSetting(key: .pbxcpBitcodeStripMode, value: "")
    }

    /// PBXCP_BITCODE_STRIP_MODE
    public static func pbxcpBitcodeStripMode(_ value: PbxcpBitcodeStripMode) -> BuildSetting { 
        BuildSetting(key: .pbxcpBitcodeStripMode, value: "\(value)")
    }

    /// PBXCP_BITCODE_STRIP_MODE
    public static func pbxcpBitcodeStripMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpBitcodeStripMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PBXCP_BITCODE_STRIP_MODE
    public static let pbxcpBitcodeStripMode: BuildSettingsKey = "PBXCP_BITCODE_STRIP_MODE"
}

public enum PbxcpBitcodeStripMode: String, Hashable, Codable, CustomStringConvertible {
    case none = "none"
    case replaceWithMarker = "replace-with-marker"
    case all = "all"

    public var description: String {
        rawValue
    }
}

// MARK: PBXCP_BITCODE_STRIP_TOOL
extension BuildSetting {

    /// PBXCP_BITCODE_STRIP_TOOL
    public static var pbxcpBitcodeStripTool: BuildSetting { 
        BuildSetting(key: .pbxcpBitcodeStripTool, value: "")
    }

    /// PBXCP_BITCODE_STRIP_TOOL
    public static func pbxcpBitcodeStripTool(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pbxcpBitcodeStripTool, value: "\(value)")
    }

    /// PBXCP_BITCODE_STRIP_TOOL
    public static func pbxcpBitcodeStripTool(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpBitcodeStripTool, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PBXCP_BITCODE_STRIP_TOOL
    public static let pbxcpBitcodeStripTool: BuildSettingsKey = "PBXCP_BITCODE_STRIP_TOOL"
}

// MARK: PBXCP_IGNORE_MISSING_INPUTS
extension BuildSetting {

    /// PBXCP_IGNORE_MISSING_INPUTS
    public static var pbxcpIgnoreMissingInputs: BuildSetting { 
        BuildSetting(key: .pbxcpIgnoreMissingInputs, value: "NO")
    }

    /// PBXCP_IGNORE_MISSING_INPUTS
    public static func pbxcpIgnoreMissingInputs(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pbxcpIgnoreMissingInputs, value: SettingValue(booleanLiteral: value))
    }

    /// PBXCP_IGNORE_MISSING_INPUTS
    public static func pbxcpIgnoreMissingInputs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpIgnoreMissingInputs, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PBXCP_IGNORE_MISSING_INPUTS
    public static let pbxcpIgnoreMissingInputs: BuildSettingsKey = "PBXCP_IGNORE_MISSING_INPUTS"
}

// MARK: PBXCP_STRIP_BITCODE
extension BuildSetting {

    /// PBXCP_STRIP_BITCODE
    public static var pbxcpStripBitcode: BuildSetting { 
        BuildSetting(key: .pbxcpStripBitcode, value: "NO")
    }

    /// PBXCP_STRIP_BITCODE
    public static func pbxcpStripBitcode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .pbxcpStripBitcode, value: SettingValue(booleanLiteral: value))
    }

    /// PBXCP_STRIP_BITCODE
    public static func pbxcpStripBitcode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpStripBitcode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PBXCP_STRIP_BITCODE
    public static let pbxcpStripBitcode: BuildSettingsKey = "PBXCP_STRIP_BITCODE"
}

// MARK: PBXCP_STRIP_TOOL
extension BuildSetting {

    /// PBXCP_STRIP_TOOL
    public static var pbxcpStripTool: BuildSetting { 
        BuildSetting(key: .pbxcpStripTool, value: "")
    }

    /// PBXCP_STRIP_TOOL
    public static func pbxcpStripTool(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pbxcpStripTool, value: "\(value)")
    }

    /// PBXCP_STRIP_TOOL
    public static func pbxcpStripTool(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pbxcpStripTool, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PBXCP_STRIP_TOOL
    public static let pbxcpStripTool: BuildSettingsKey = "PBXCP_STRIP_TOOL"
}

// MARK: PER_STYLE_BUILD_DIRECTORIES
extension BuildSetting {

    /// PER_STYLE_BUILD_DIRECTORIES
    public static var perStyleBuildDirectories: BuildSetting { 
        BuildSetting(key: .perStyleBuildDirectories, value: "YES")
    }

    /// PER_STYLE_BUILD_DIRECTORIES
    public static func perStyleBuildDirectories(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .perStyleBuildDirectories, value: SettingValue(booleanLiteral: value))
    }

    /// PER_STYLE_BUILD_DIRECTORIES
    public static func perStyleBuildDirectories(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .perStyleBuildDirectories, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PER_STYLE_BUILD_DIRECTORIES
    public static let perStyleBuildDirectories: BuildSettingsKey = "PER_STYLE_BUILD_DIRECTORIES"
}

// MARK: PFE_FILE_C_DIALECTS
extension BuildSetting {

    /// PFE_FILE_C_DIALECTS
    public static var pfeFileCDialects: BuildSetting { 
        BuildSetting(key: .pfeFileCDialects, value: "")
    }

    /// PFE_FILE_C_DIALECTS
    public static func pfeFileCDialects(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .pfeFileCDialects, value: .array(value))
    }

    /// PFE_FILE_C_DIALECTS
    public static func pfeFileCDialects(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pfeFileCDialects, inherit: key)
    }

    /// PFE_FILE_C_DIALECTS
    public static func pfeFileCDialects(_ value: String...) -> BuildSetting { 
        .pfeFileCDialects(value)
    }
}

extension BuildSettingsKey {

    /// PFE_FILE_C_DIALECTS
    public static let pfeFileCDialects: BuildSettingsKey = "PFE_FILE_C_DIALECTS"
}

// MARK: PKGINFO_PATH
extension BuildSetting {

    /// PKGINFO_PATH
    public static var pkginfoPath: BuildSetting { 
        BuildSetting(key: .pkginfoPath, value: "")
    }

    /// PKGINFO_PATH
    public static func pkginfoPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pkginfoPath, value: "\(value)")
    }

    /// PKGINFO_PATH
    public static func pkginfoPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pkginfoPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PKGINFO_PATH
    public static let pkginfoPath: BuildSettingsKey = "PKGINFO_PATH"
}

// MARK: PLATFORM_NAME
extension BuildSetting {

    /// PLATFORM_NAME
    public static func platformName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .platformName, value: "\(value)")
    }

    /// PLATFORM_NAME
    public static func platformName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .platformName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PLATFORM_NAME
    public static let platformName: BuildSettingsKey = "PLATFORM_NAME"
}

// MARK: Property List Output Encoding
extension BuildSetting {

    /// Property List Output Encoding
    ///
    /// Specifies the output encoding for property list files (`.plist`). The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static var propertyListOutputEncoding: BuildSetting { 
        .propertyListOutputEncoding(.sameAsInput) 
    }

    /// Property List Output Encoding
    ///
    /// Specifies the output encoding for property list files (`.plist`). The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static func propertyListOutputEncoding(_ value: PropertyListOutputEncoding) -> BuildSetting { 
        BuildSetting(key: .propertyListOutputEncoding, value: "\(value)")
    }

    /// Property List Output Encoding
    ///
    /// Specifies the output encoding for property list files (`.plist`). The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static func propertyListOutputEncoding(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .propertyListOutputEncoding, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Property List Output Encoding
    ///
    /// Specifies the output encoding for property list files (`.plist`). The output encodings can be `binary` or `XML`. By default, the output encoding will be unchanged from the input.
    public static let propertyListOutputEncoding: BuildSettingsKey = "PLIST_FILE_OUTPUT_FORMAT"
}

public enum PropertyListOutputEncoding: String, Hashable, Codable, CustomStringConvertible {
    case sameAsInput = "same-as-input"
    case xml = "XML"
    case binary = "binary"

    public var description: String {
        rawValue
    }
}

// MARK: PLUGINS_FOLDER_PATH
extension BuildSetting {

    /// PLUGINS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products plugins.
    public static var pluginsFolderPath: BuildSetting { 
        BuildSetting(key: .pluginsFolderPath, value: "")
    }

    /// PLUGINS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products plugins.
    public static func pluginsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pluginsFolderPath, value: "\(value)")
    }

    /// PLUGINS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products plugins.
    public static func pluginsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pluginsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PLUGINS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products plugins.
    public static let pluginsFolderPath: BuildSettingsKey = "PLUGINS_FOLDER_PATH"
}

// MARK: PRECOMPILE_PREFIX_HEADER
extension BuildSetting {

    /// PRECOMPILE_PREFIX_HEADER
    public static var precompilePrefixHeader: BuildSetting { 
        BuildSetting(key: .precompilePrefixHeader, value: "")
    }

    /// PRECOMPILE_PREFIX_HEADER
    public static func precompilePrefixHeader(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .precompilePrefixHeader, value: SettingValue(booleanLiteral: value))
    }

    /// PRECOMPILE_PREFIX_HEADER
    public static func precompilePrefixHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompilePrefixHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PRECOMPILE_PREFIX_HEADER
    public static let precompilePrefixHeader: BuildSettingsKey = "PRECOMPILE_PREFIX_HEADER"
}

// MARK: Precompiled Header Uses Files From Build Directory
extension BuildSetting {

    /// Precompiled Header Uses Files From Build Directory
    ///
    /// This setting allows for better control of sharing precompiled prefix header files between projects. By default, Xcode assumes that the prefix header file may include header files from the build directory if the build directory is outside of the project directory. Xcode cannot determine this ahead of time since other projects may not have been built into the shared build directory at the time the information is needed.

If your prefix file never includes files from the build directory you may set this to `NO` to improve sharing of precompiled headers. If the prefix does use files from a build directory that is inside your project directory, you may set this to `YES` to avoid unintended sharing that may result in build failures.
    public static var precompiledHeaderUsesFilesFromBuildDirectory: BuildSetting { 
        BuildSetting(key: .precompiledHeaderUsesFilesFromBuildDirectory, value: "YES")
    }

    /// Precompiled Header Uses Files From Build Directory
    ///
    /// This setting allows for better control of sharing precompiled prefix header files between projects. By default, Xcode assumes that the prefix header file may include header files from the build directory if the build directory is outside of the project directory. Xcode cannot determine this ahead of time since other projects may not have been built into the shared build directory at the time the information is needed.

If your prefix file never includes files from the build directory you may set this to `NO` to improve sharing of precompiled headers. If the prefix does use files from a build directory that is inside your project directory, you may set this to `YES` to avoid unintended sharing that may result in build failures.
    public static func precompiledHeaderUsesFilesFromBuildDirectory(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .precompiledHeaderUsesFilesFromBuildDirectory, value: SettingValue(booleanLiteral: value))
    }

    /// Precompiled Header Uses Files From Build Directory
    ///
    /// This setting allows for better control of sharing precompiled prefix header files between projects. By default, Xcode assumes that the prefix header file may include header files from the build directory if the build directory is outside of the project directory. Xcode cannot determine this ahead of time since other projects may not have been built into the shared build directory at the time the information is needed.

If your prefix file never includes files from the build directory you may set this to `NO` to improve sharing of precompiled headers. If the prefix does use files from a build directory that is inside your project directory, you may set this to `YES` to avoid unintended sharing that may result in build failures.
    public static func precompiledHeaderUsesFilesFromBuildDirectory(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompiledHeaderUsesFilesFromBuildDirectory, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Precompiled Header Uses Files From Build Directory
    ///
    /// This setting allows for better control of sharing precompiled prefix header files between projects. By default, Xcode assumes that the prefix header file may include header files from the build directory if the build directory is outside of the project directory. Xcode cannot determine this ahead of time since other projects may not have been built into the shared build directory at the time the information is needed.

If your prefix file never includes files from the build directory you may set this to `NO` to improve sharing of precompiled headers. If the prefix does use files from a build directory that is inside your project directory, you may set this to `YES` to avoid unintended sharing that may result in build failures.
    public static let precompiledHeaderUsesFilesFromBuildDirectory: BuildSettingsKey = "PRECOMPS_INCLUDE_HEADERS_FROM_BUILT_PRODUCTS_DIR"
}

// MARK: PRECOMP_DESTINATION_DIR
extension BuildSetting {

    /// PRECOMP_DESTINATION_DIR
    public static var precompDestinationDir: BuildSetting { 
        BuildSetting(key: .precompDestinationDir, value: "$(TARGET_TEMP_DIR)/PrefixHeaders")
    }

    /// PRECOMP_DESTINATION_DIR
    public static func precompDestinationDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .precompDestinationDir, value: "\(value)")
    }

    /// PRECOMP_DESTINATION_DIR
    public static func precompDestinationDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompDestinationDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PRECOMP_DESTINATION_DIR
    public static let precompDestinationDir: BuildSettingsKey = "PRECOMP_DESTINATION_DIR"
}

// MARK: PREFIX_CFLAG_BASE
extension BuildSetting {

    /// PREFIX_CFLAG_BASE
    public static var prefixCflagBase: BuildSetting { 
        BuildSetting(key: .prefixCflagBase, value: "")
    }

    /// PREFIX_CFLAG_BASE
    public static func prefixCflagBase(_ value: String) -> BuildSetting { 
        BuildSetting(key: .prefixCflagBase, value: "\(value)")
    }

    /// PREFIX_CFLAG_BASE
    public static func prefixCflagBase(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prefixCflagBase, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PREFIX_CFLAG_BASE
    public static let prefixCflagBase: BuildSettingsKey = "PREFIX_CFLAG_BASE"
}

// MARK: PREFIX_FLAGS
extension BuildSetting {

    /// PREFIX_FLAGS
    public static var prefixFlags: BuildSetting { 
        BuildSetting(key: .prefixFlags, value: "")
    }

    /// PREFIX_FLAGS
    public static func prefixFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .prefixFlags, value: .array(value))
    }

    /// PREFIX_FLAGS
    public static func prefixFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prefixFlags, inherit: key)
    }

    /// PREFIX_FLAGS
    public static func prefixFlags(_ value: String...) -> BuildSetting { 
        .prefixFlags(value)
    }
}

extension BuildSettingsKey {

    /// PREFIX_FLAGS
    public static let prefixFlags: BuildSettingsKey = "PREFIX_FLAGS"
}

// MARK: PREFIX_HEADER
extension BuildSetting {

    /// PREFIX_HEADER
    public static var prefixHeader: BuildSetting { 
        BuildSetting(key: .prefixHeader, value: "")
    }

    /// PREFIX_HEADER
    public static func prefixHeader(_ value: String) -> BuildSetting { 
        BuildSetting(key: .prefixHeader, value: "\(value)")
    }

    /// PREFIX_HEADER
    public static func prefixHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prefixHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PREFIX_HEADER
    public static let prefixHeader: BuildSettingsKey = "PREFIX_HEADER"
}

// MARK: PREFIX_REFERENCE
extension BuildSetting {

    /// PREFIX_REFERENCE
    public static var prefixReference: BuildSetting { 
        BuildSetting(key: .prefixReference, value: "")
    }

    /// PREFIX_REFERENCE
    public static func prefixReference(_ value: String) -> BuildSetting { 
        BuildSetting(key: .prefixReference, value: "\(value)")
    }

    /// PREFIX_REFERENCE
    public static func prefixReference(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prefixReference, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PREFIX_REFERENCE
    public static let prefixReference: BuildSettingsKey = "PREFIX_REFERENCE"
}

// MARK: Single-Object Prelink Flags
extension BuildSetting {

    /// Single-Object Prelink Flags
    ///
    /// Additional flags to pass when performing a single-object prelink.
    public static var singleObjectPrelinkFlags: BuildSetting { 
        BuildSetting(key: .singleObjectPrelinkFlags, value: "")
    }

    /// Single-Object Prelink Flags
    ///
    /// Additional flags to pass when performing a single-object prelink.
    public static func singleObjectPrelinkFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .singleObjectPrelinkFlags, value: .array(value))
    }

    /// Single-Object Prelink Flags
    ///
    /// Additional flags to pass when performing a single-object prelink.
    public static func singleObjectPrelinkFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .singleObjectPrelinkFlags, inherit: key)
    }

    /// Single-Object Prelink Flags
    ///
    /// Additional flags to pass when performing a single-object prelink.
    public static func singleObjectPrelinkFlags(_ value: String...) -> BuildSetting { 
        .singleObjectPrelinkFlags(value)
    }
}

extension BuildSettingsKey {

    /// Single-Object Prelink Flags
    ///
    /// Additional flags to pass when performing a single-object prelink.
    public static let singleObjectPrelinkFlags: BuildSettingsKey = "PRELINK_FLAGS"
}

// MARK: Prelink libraries
extension BuildSetting {

    /// Prelink libraries
    ///
    /// Additional libraries to pass when performing a single-object prelink.
    public static var prelinkLibraries: BuildSetting { 
        BuildSetting(key: .prelinkLibraries, value: "")
    }

    /// Prelink libraries
    ///
    /// Additional libraries to pass when performing a single-object prelink.
    public static func prelinkLibraries(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .prelinkLibraries, value: .array(value))
    }

    /// Prelink libraries
    ///
    /// Additional libraries to pass when performing a single-object prelink.
    public static func prelinkLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .prelinkLibraries, inherit: key)
    }

    /// Prelink libraries
    ///
    /// Additional libraries to pass when performing a single-object prelink.
    public static func prelinkLibraries(_ value: String...) -> BuildSetting { 
        .prelinkLibraries(value)
    }
}

extension BuildSettingsKey {

    /// Prelink libraries
    ///
    /// Additional libraries to pass when performing a single-object prelink.
    public static let prelinkLibraries: BuildSettingsKey = "PRELINK_LIBS"
}

// MARK: Don't Dead-Strip Inits and Terms
extension BuildSetting {

    /// Don't Dead-Strip Inits and Terms
    ///
    /// Activating this setting, in combination with the [Dead Code Stripping (DEAD\_CODE\_STRIPPING)](itcaec37c2a6.html#dev9ed8cb7ad) (`-dead_strip`) option, causes the `-no_dead_strip_inits_and_terms` flag to be passed to `ld(1)` via `cc(1)` to disable dead code stripping for initialization and termination routines. This option should not be used without the aforementioned [Dead Code Stripping (DEAD\_CODE\_STRIPPING)](itcaec37c2a6.html#dev9ed8cb7ad) option.
    public static var donTDeadStripInitsAndTerms: BuildSetting { 
        BuildSetting(key: .donTDeadStripInitsAndTerms, value: "NO")
    }

    /// Don't Dead-Strip Inits and Terms
    ///
    /// Activating this setting, in combination with the [Dead Code Stripping (DEAD\_CODE\_STRIPPING)](itcaec37c2a6.html#dev9ed8cb7ad) (`-dead_strip`) option, causes the `-no_dead_strip_inits_and_terms` flag to be passed to `ld(1)` via `cc(1)` to disable dead code stripping for initialization and termination routines. This option should not be used without the aforementioned [Dead Code Stripping (DEAD\_CODE\_STRIPPING)](itcaec37c2a6.html#dev9ed8cb7ad) option.
    public static func donTDeadStripInitsAndTerms(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .donTDeadStripInitsAndTerms, value: SettingValue(booleanLiteral: value))
    }

    /// Don't Dead-Strip Inits and Terms
    ///
    /// Activating this setting, in combination with the [Dead Code Stripping (DEAD\_CODE\_STRIPPING)](itcaec37c2a6.html#dev9ed8cb7ad) (`-dead_strip`) option, causes the `-no_dead_strip_inits_and_terms` flag to be passed to `ld(1)` via `cc(1)` to disable dead code stripping for initialization and termination routines. This option should not be used without the aforementioned [Dead Code Stripping (DEAD\_CODE\_STRIPPING)](itcaec37c2a6.html#dev9ed8cb7ad) option.
    public static func donTDeadStripInitsAndTerms(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .donTDeadStripInitsAndTerms, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Don't Dead-Strip Inits and Terms
    ///
    /// Activating this setting, in combination with the [Dead Code Stripping (DEAD\_CODE\_STRIPPING)](itcaec37c2a6.html#dev9ed8cb7ad) (`-dead_strip`) option, causes the `-no_dead_strip_inits_and_terms` flag to be passed to `ld(1)` via `cc(1)` to disable dead code stripping for initialization and termination routines. This option should not be used without the aforementioned [Dead Code Stripping (DEAD\_CODE\_STRIPPING)](itcaec37c2a6.html#dev9ed8cb7ad) option.
    public static let donTDeadStripInitsAndTerms: BuildSettingsKey = "PRESERVE_DEAD_CODE_INITS_AND_TERMS"
}

// MARK: Private Headers Folder Path
extension BuildSetting {

    /// Private Headers Folder Path
    ///
    /// The location to copy the private headers to during building, relative to the built products folder.
    public static var privateHeadersFolderPath: BuildSetting { 
        BuildSetting(key: .privateHeadersFolderPath, value: "")
    }

    /// Private Headers Folder Path
    ///
    /// The location to copy the private headers to during building, relative to the built products folder.
    public static func privateHeadersFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .privateHeadersFolderPath, value: "\(value)")
    }

    /// Private Headers Folder Path
    ///
    /// The location to copy the private headers to during building, relative to the built products folder.
    public static func privateHeadersFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .privateHeadersFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Private Headers Folder Path
    ///
    /// The location to copy the private headers to during building, relative to the built products folder.
    public static let privateHeadersFolderPath: BuildSettingsKey = "PRIVATE_HEADERS_FOLDER_PATH"
}

// MARK: Product Bundle Identifier
extension BuildSetting {

    /// Product Bundle Identifier
    ///
    /// A string that uniquely identifies the bundle. The string should be in reverse DNS format using only alphanumeric characters (`A-Z`, `a-z`, `0-9`), the dot (`.`), and the hyphen (`-`). This value is used as the `CFBundleIdentifier` in the `Info.plist` of the built bundle.
    public static var productBundleIdentifier: BuildSetting { 
        BuildSetting(key: .productBundleIdentifier, value: "")
    }

    /// Product Bundle Identifier
    ///
    /// A string that uniquely identifies the bundle. The string should be in reverse DNS format using only alphanumeric characters (`A-Z`, `a-z`, `0-9`), the dot (`.`), and the hyphen (`-`). This value is used as the `CFBundleIdentifier` in the `Info.plist` of the built bundle.
    public static func productBundleIdentifier(_ value: String) -> BuildSetting { 
        BuildSetting(key: .productBundleIdentifier, value: "\(value)")
    }

    /// Product Bundle Identifier
    ///
    /// A string that uniquely identifies the bundle. The string should be in reverse DNS format using only alphanumeric characters (`A-Z`, `a-z`, `0-9`), the dot (`.`), and the hyphen (`-`). This value is used as the `CFBundleIdentifier` in the `Info.plist` of the built bundle.
    public static func productBundleIdentifier(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productBundleIdentifier, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Product Bundle Identifier
    ///
    /// A string that uniquely identifies the bundle. The string should be in reverse DNS format using only alphanumeric characters (`A-Z`, `a-z`, `0-9`), the dot (`.`), and the hyphen (`-`). This value is used as the `CFBundleIdentifier` in the `Info.plist` of the built bundle.
    public static let productBundleIdentifier: BuildSettingsKey = "PRODUCT_BUNDLE_IDENTIFIER"
}

// MARK: PRODUCT_DEFINITION_PLIST
extension BuildSetting {

    /// PRODUCT_DEFINITION_PLIST
    ///
    /// Path to a file specifying additional requirements for a product archive.
    public static var productDefinitionPlist: BuildSetting { 
        BuildSetting(key: .productDefinitionPlist, value: "")
    }

    /// PRODUCT_DEFINITION_PLIST
    ///
    /// Path to a file specifying additional requirements for a product archive.
    public static func productDefinitionPlist(_ value: String) -> BuildSetting { 
        BuildSetting(key: .productDefinitionPlist, value: "\(value)")
    }

    /// PRODUCT_DEFINITION_PLIST
    ///
    /// Path to a file specifying additional requirements for a product archive.
    public static func productDefinitionPlist(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productDefinitionPlist, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PRODUCT_DEFINITION_PLIST
    ///
    /// Path to a file specifying additional requirements for a product archive.
    public static let productDefinitionPlist: BuildSettingsKey = "PRODUCT_DEFINITION_PLIST"
}

// MARK: Product Module Name
extension BuildSetting {

    /// Product Module Name
    ///
    /// The name to use for the source code module constructed for this target, and which will be used to import the module in implementation source files. Must be a valid identifier.
    public static var productModuleName: BuildSetting { 
        BuildSetting(key: .productModuleName, value: "$(PRODUCT_NAME:c99extidentifier)")
    }

    /// Product Module Name
    ///
    /// The name to use for the source code module constructed for this target, and which will be used to import the module in implementation source files. Must be a valid identifier.
    public static func productModuleName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .productModuleName, value: "\(value)")
    }

    /// Product Module Name
    ///
    /// The name to use for the source code module constructed for this target, and which will be used to import the module in implementation source files. Must be a valid identifier.
    public static func productModuleName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productModuleName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Product Module Name
    ///
    /// The name to use for the source code module constructed for this target, and which will be used to import the module in implementation source files. Must be a valid identifier.
    public static let productModuleName: BuildSettingsKey = "PRODUCT_MODULE_NAME"
}

// MARK: Product Name
extension BuildSetting {

    /// Product Name
    ///
    /// This is the basename of the product generated by the target.
    public static var productName: BuildSetting { 
        BuildSetting(key: .productName, value: "")
    }

    /// Product Name
    ///
    /// This is the basename of the product generated by the target.
    public static func productName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .productName, value: "\(value)")
    }

    /// Product Name
    ///
    /// This is the basename of the product generated by the target.
    public static func productName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Product Name
    ///
    /// This is the basename of the product generated by the target.
    public static let productName: BuildSettingsKey = "PRODUCT_NAME"
}

// MARK: PRODUCT_TYPE
extension BuildSetting {

    /// PRODUCT_TYPE
    public static var productType: BuildSetting { 
        BuildSetting(key: .productType, value: "")
    }

    /// PRODUCT_TYPE
    public static func productType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .productType, value: "\(value)")
    }

    /// PRODUCT_TYPE
    public static func productType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PRODUCT_TYPE
    public static let productType: BuildSettingsKey = "PRODUCT_TYPE"
}

// MARK: PRODUCT_TYPE_FRAMEWORK_SEARCH_PATHS
extension BuildSetting {

    /// PRODUCT_TYPE_FRAMEWORK_SEARCH_PATHS
    public static func productTypeFrameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .productTypeFrameworkSearchPaths, value: .array(value))
    }

    /// PRODUCT_TYPE_FRAMEWORK_SEARCH_PATHS
    public static func productTypeFrameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productTypeFrameworkSearchPaths, inherit: key)
    }

    /// PRODUCT_TYPE_FRAMEWORK_SEARCH_PATHS
    public static func productTypeFrameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .productTypeFrameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// PRODUCT_TYPE_FRAMEWORK_SEARCH_PATHS
    public static let productTypeFrameworkSearchPaths: BuildSettingsKey = "PRODUCT_TYPE_FRAMEWORK_SEARCH_PATHS"
}

// MARK: PRODUCT_TYPE_LIBRARY_SEARCH_PATHS
extension BuildSetting {

    /// PRODUCT_TYPE_LIBRARY_SEARCH_PATHS
    public static func productTypeLibrarySearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .productTypeLibrarySearchPaths, value: .array(value))
    }

    /// PRODUCT_TYPE_LIBRARY_SEARCH_PATHS
    public static func productTypeLibrarySearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productTypeLibrarySearchPaths, inherit: key)
    }

    /// PRODUCT_TYPE_LIBRARY_SEARCH_PATHS
    public static func productTypeLibrarySearchPaths(_ value: String...) -> BuildSetting { 
        .productTypeLibrarySearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// PRODUCT_TYPE_LIBRARY_SEARCH_PATHS
    public static let productTypeLibrarySearchPaths: BuildSettingsKey = "PRODUCT_TYPE_LIBRARY_SEARCH_PATHS"
}

// MARK: PRODUCT_TYPE_SWIFT_STDLIB_TOOL_FLAGS
extension BuildSetting {

    /// PRODUCT_TYPE_SWIFT_STDLIB_TOOL_FLAGS
    public static var productTypeSwiftStdlibToolFlags: BuildSetting { 
        BuildSetting(key: .productTypeSwiftStdlibToolFlags, value: "")
    }

    /// PRODUCT_TYPE_SWIFT_STDLIB_TOOL_FLAGS
    public static func productTypeSwiftStdlibToolFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .productTypeSwiftStdlibToolFlags, value: .array(value))
    }

    /// PRODUCT_TYPE_SWIFT_STDLIB_TOOL_FLAGS
    public static func productTypeSwiftStdlibToolFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .productTypeSwiftStdlibToolFlags, inherit: key)
    }

    /// PRODUCT_TYPE_SWIFT_STDLIB_TOOL_FLAGS
    public static func productTypeSwiftStdlibToolFlags(_ value: String...) -> BuildSetting { 
        .productTypeSwiftStdlibToolFlags(value)
    }
}

extension BuildSettingsKey {

    /// PRODUCT_TYPE_SWIFT_STDLIB_TOOL_FLAGS
    public static let productTypeSwiftStdlibToolFlags: BuildSettingsKey = "PRODUCT_TYPE_SWIFT_STDLIB_TOOL_FLAGS"
}

// MARK: PROFILING_CODE
extension BuildSetting {

    /// PROFILING_CODE
    public static var profilingCode: BuildSetting { 
        BuildSetting(key: .profilingCode, value: "NO")
    }

    /// PROFILING_CODE
    public static func profilingCode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .profilingCode, value: SettingValue(booleanLiteral: value))
    }

    /// PROFILING_CODE
    public static func profilingCode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .profilingCode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PROFILING_CODE
    public static let profilingCode: BuildSettingsKey = "PROFILING_CODE"
}

// MARK: PROJECT_DERIVED_FILE_DIR
extension BuildSetting {

    /// PROJECT_DERIVED_FILE_DIR
    public static var projectDerivedFileDir: BuildSetting { 
        BuildSetting(key: .projectDerivedFileDir, value: "$(OBJROOT)/$(PROJECT_NAME).build/DerivedSources")
    }

    /// PROJECT_DERIVED_FILE_DIR
    public static func projectDerivedFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectDerivedFileDir, value: "\(value)")
    }

    /// PROJECT_DERIVED_FILE_DIR
    public static func projectDerivedFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectDerivedFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PROJECT_DERIVED_FILE_DIR
    public static let projectDerivedFileDir: BuildSettingsKey = "PROJECT_DERIVED_FILE_DIR"
}

// MARK: PROJECT_DIR
extension BuildSetting {

    /// PROJECT_DIR
    public static var projectDir: BuildSetting { 
        .projectDir(inherit: .srcroot) 
    }

    /// PROJECT_DIR
    public static func projectDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectDir, value: "\(value)")
    }

    /// PROJECT_DIR
    public static func projectDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PROJECT_DIR
    public static let projectDir: BuildSettingsKey = "PROJECT_DIR"
}

// MARK: Project Name
extension BuildSetting {

    /// Project Name
    ///
    /// The name of the current project.
    public static var projectName: BuildSetting { 
        BuildSetting(key: .projectName, value: "")
    }

    /// Project Name
    ///
    /// The name of the current project.
    public static func projectName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectName, value: "\(value)")
    }

    /// Project Name
    ///
    /// The name of the current project.
    public static func projectName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Project Name
    ///
    /// The name of the current project.
    public static let projectName: BuildSettingsKey = "PROJECT_NAME"
}

// MARK: PROJECT_TEMP_DIR
extension BuildSetting {

    /// PROJECT_TEMP_DIR
    ///
    /// Identifies the directory in which the projects intermediate build files are placed. This directory is shared between all the targets defined by the project. Run Script build phases should generate intermediate build files in the directory identified by `DERIVED_FILE_DIR`, not the location this build setting specifies.
    public static var projectTempDir: BuildSetting { 
        BuildSetting(key: .projectTempDir, value: "$(PROJECT_TEMP_ROOT)/$(PROJECT_NAME).build")
    }

    /// PROJECT_TEMP_DIR
    ///
    /// Identifies the directory in which the projects intermediate build files are placed. This directory is shared between all the targets defined by the project. Run Script build phases should generate intermediate build files in the directory identified by `DERIVED_FILE_DIR`, not the location this build setting specifies.
    public static func projectTempDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectTempDir, value: "\(value)")
    }

    /// PROJECT_TEMP_DIR
    ///
    /// Identifies the directory in which the projects intermediate build files are placed. This directory is shared between all the targets defined by the project. Run Script build phases should generate intermediate build files in the directory identified by `DERIVED_FILE_DIR`, not the location this build setting specifies.
    public static func projectTempDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectTempDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PROJECT_TEMP_DIR
    ///
    /// Identifies the directory in which the projects intermediate build files are placed. This directory is shared between all the targets defined by the project. Run Script build phases should generate intermediate build files in the directory identified by `DERIVED_FILE_DIR`, not the location this build setting specifies.
    public static let projectTempDir: BuildSettingsKey = "PROJECT_TEMP_DIR"
}

// MARK: PROJECT_TEMP_ROOT
extension BuildSetting {

    /// PROJECT_TEMP_ROOT
    public static var projectTempRoot: BuildSetting { 
        .projectTempRoot(inherit: .intermediateBuildFilesPath) 
    }

    /// PROJECT_TEMP_ROOT
    public static func projectTempRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .projectTempRoot, value: "\(value)")
    }

    /// PROJECT_TEMP_ROOT
    public static func projectTempRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .projectTempRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PROJECT_TEMP_ROOT
    public static let projectTempRoot: BuildSettingsKey = "PROJECT_TEMP_ROOT"
}

// MARK: PROVISIONING_PROFILE
extension BuildSetting {

    /// PROVISIONING_PROFILE
    public static var provisioningProfile: BuildSetting { 
        BuildSetting(key: .provisioningProfile, value: "")
    }

    /// PROVISIONING_PROFILE
    public static func provisioningProfile(_ value: ProvisioningProfile) -> BuildSetting { 
        BuildSetting(key: .provisioningProfile, value: "\(value)")
    }

    /// PROVISIONING_PROFILE
    public static func provisioningProfile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .provisioningProfile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PROVISIONING_PROFILE
    public static let provisioningProfile: BuildSettingsKey = "PROVISIONING_PROFILE"
}

// MARK: PROVISIONING_PROFILE_DESTINATION_PATH
extension BuildSetting {

    /// PROVISIONING_PROFILE_DESTINATION_PATH
    public static var provisioningProfileDestinationPath: BuildSetting { 
        BuildSetting(key: .provisioningProfileDestinationPath, value: "$(TARGET_BUILD_DIR)/$(CONTENTS_FOLDER_PATH)")
    }

    /// PROVISIONING_PROFILE_DESTINATION_PATH
    public static func provisioningProfileDestinationPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .provisioningProfileDestinationPath, value: "\(value)")
    }

    /// PROVISIONING_PROFILE_DESTINATION_PATH
    public static func provisioningProfileDestinationPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .provisioningProfileDestinationPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PROVISIONING_PROFILE_DESTINATION_PATH
    public static let provisioningProfileDestinationPath: BuildSettingsKey = "PROVISIONING_PROFILE_DESTINATION_PATH"
}

// MARK: Provisioning Profile
extension BuildSetting {

    /// Provisioning Profile
    ///
    /// Must contain a profile name (or UUID). A missing or invalid profile will cause a build error. Use in conjunction with [Development Team (DEVELOPMENT\_TEAM)](itcaec37c2a6.html#dev186481df2) to fully specify provisioning profile.
    public static var provisioningProfile: BuildSetting { 
        BuildSetting(key: .provisioningProfile, value: "")
    }

    /// Provisioning Profile
    ///
    /// Must contain a profile name (or UUID). A missing or invalid profile will cause a build error. Use in conjunction with [Development Team (DEVELOPMENT\_TEAM)](itcaec37c2a6.html#dev186481df2) to fully specify provisioning profile.
    public static func provisioningProfile(_ value: ProvisioningProfileSpecifier) -> BuildSetting { 
        BuildSetting(key: .provisioningProfile, value: "\(value)")
    }

    /// Provisioning Profile
    ///
    /// Must contain a profile name (or UUID). A missing or invalid profile will cause a build error. Use in conjunction with [Development Team (DEVELOPMENT\_TEAM)](itcaec37c2a6.html#dev186481df2) to fully specify provisioning profile.
    public static func provisioningProfile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .provisioningProfile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Provisioning Profile
    ///
    /// Must contain a profile name (or UUID). A missing or invalid profile will cause a build error. Use in conjunction with [Development Team (DEVELOPMENT\_TEAM)](itcaec37c2a6.html#dev186481df2) to fully specify provisioning profile.
    public static let provisioningProfile: BuildSettingsKey = "PROVISIONING_PROFILE_SPECIFIER"
}

// MARK: Public Headers Folder Path
extension BuildSetting {

    /// Public Headers Folder Path
    ///
    /// The location to copy the public headers to during building, relative to the built products folder.
    public static var publicHeadersFolderPath: BuildSetting { 
        BuildSetting(key: .publicHeadersFolderPath, value: "")
    }

    /// Public Headers Folder Path
    ///
    /// The location to copy the public headers to during building, relative to the built products folder.
    public static func publicHeadersFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .publicHeadersFolderPath, value: "\(value)")
    }

    /// Public Headers Folder Path
    ///
    /// The location to copy the public headers to during building, relative to the built products folder.
    public static func publicHeadersFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .publicHeadersFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Public Headers Folder Path
    ///
    /// The location to copy the public headers to during building, relative to the built products folder.
    public static let publicHeadersFolderPath: BuildSettingsKey = "PUBLIC_HEADERS_FOLDER_PATH"
}

// MARK: PWD
extension BuildSetting {

    /// PWD
    public static func pwd(_ value: String) -> BuildSetting { 
        BuildSetting(key: .pwd, value: "\(value)")
    }

    /// PWD
    public static func pwd(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .pwd, inherit: key)
    }
}

extension BuildSettingsKey {

    /// PWD
    public static let pwd: BuildSettingsKey = "PWD"
}

// MARK: RC Generation Language
extension BuildSetting {

    /// RC Generation Language
    ///
    /// The Source-code language to use for generated RC objects. By default Xcode will generate Swift types that represent the objects in your scene. Adjust this setting to explicitly select "Swift", or select "None" to disable RC object generation.
    public static var rcGenerationLanguage: BuildSetting { 
        .rcGenerationLanguage(.swift) 
    }

    /// RC Generation Language
    ///
    /// The Source-code language to use for generated RC objects. By default Xcode will generate Swift types that represent the objects in your scene. Adjust this setting to explicitly select "Swift", or select "None" to disable RC object generation.
    public static func rcGenerationLanguage(_ value: RcGenerationLanguage) -> BuildSetting { 
        BuildSetting(key: .rcGenerationLanguage, value: "\(value)")
    }

    /// RC Generation Language
    ///
    /// The Source-code language to use for generated RC objects. By default Xcode will generate Swift types that represent the objects in your scene. Adjust this setting to explicitly select "Swift", or select "None" to disable RC object generation.
    public static func rcGenerationLanguage(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rcGenerationLanguage, inherit: key)
    }
}

extension BuildSettingsKey {

    /// RC Generation Language
    ///
    /// The Source-code language to use for generated RC objects. By default Xcode will generate Swift types that represent the objects in your scene. Adjust this setting to explicitly select "Swift", or select "None" to disable RC object generation.
    public static let rcGenerationLanguage: BuildSettingsKey = "RCPROJECT_CODEGEN_LANGUAGE"
}

public enum RcGenerationLanguage: String, Hashable, Codable, CustomStringConvertible {
    case swift = "Swift"
    case automatic = "Automatic"
    case none = "None"

    public var description: String {
        rawValue
    }
}

// MARK: Reality Composer Generation Swift Version
extension BuildSetting {

    /// Reality Composer Generation Swift Version
    public static var realityComposerGenerationSwiftVersion: BuildSetting { 
        .realityComposerGenerationSwiftVersion(inherit: .swiftLanguageVersion) 
    }

    /// Reality Composer Generation Swift Version
    public static func realityComposerGenerationSwiftVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .realityComposerGenerationSwiftVersion, value: "\(value)")
    }

    /// Reality Composer Generation Swift Version
    public static func realityComposerGenerationSwiftVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .realityComposerGenerationSwiftVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Reality Composer Generation Swift Version
    public static let realityComposerGenerationSwiftVersion: BuildSettingsKey = "RCPROJECT_CODEGEN_SWIFT_VERSION"
}

// MARK: Enable Reality Composer Generation Warnings
extension BuildSetting {

    /// Enable Reality Composer Generation Warnings
    public static var enableRealityComposerGenerationWarnings: BuildSetting { 
        .enableRealityComposerGenerationWarnings(.yes) 
    }

    /// Enable Reality Composer Generation Warnings
    public static func enableRealityComposerGenerationWarnings(_ value: EnableRealityComposerGenerationWarnings) -> BuildSetting { 
        BuildSetting(key: .enableRealityComposerGenerationWarnings, value: "\(value)")
    }

    /// Enable Reality Composer Generation Warnings
    public static func enableRealityComposerGenerationWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableRealityComposerGenerationWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Reality Composer Generation Warnings
    public static let enableRealityComposerGenerationWarnings: BuildSettingsKey = "RCPROJECT_ENABLE_WARNINGS"
}

public enum EnableRealityComposerGenerationWarnings: String, Hashable, Codable, CustomStringConvertible {
    case yes = "Yes"
    case no = "No"

    public var description: String {
        rawValue
    }
}

// MARK: RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS
extension BuildSetting {

    /// RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS
    public static var recursiveSearchPathsFollowSymlinks: BuildSetting { 
        BuildSetting(key: .recursiveSearchPathsFollowSymlinks, value: "YES")
    }

    /// RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS
    public static func recursiveSearchPathsFollowSymlinks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .recursiveSearchPathsFollowSymlinks, value: SettingValue(booleanLiteral: value))
    }

    /// RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS
    public static func recursiveSearchPathsFollowSymlinks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .recursiveSearchPathsFollowSymlinks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS
    public static let recursiveSearchPathsFollowSymlinks: BuildSettingsKey = "RECURSIVE_SEARCH_PATHS_FOLLOW_SYMLINKS"
}

// MARK: REEXPORTED_FRAMEWORK_INSTALL_NAMES
extension BuildSetting {

    /// REEXPORTED_FRAMEWORK_INSTALL_NAMES
    public static func reexportedFrameworkInstallNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reexportedFrameworkInstallNames, value: .array(value))
    }

    /// REEXPORTED_FRAMEWORK_INSTALL_NAMES
    public static func reexportedFrameworkInstallNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reexportedFrameworkInstallNames, inherit: key)
    }

    /// REEXPORTED_FRAMEWORK_INSTALL_NAMES
    public static func reexportedFrameworkInstallNames(_ value: String...) -> BuildSetting { 
        .reexportedFrameworkInstallNames(value)
    }
}

extension BuildSettingsKey {

    /// REEXPORTED_FRAMEWORK_INSTALL_NAMES
    public static let reexportedFrameworkInstallNames: BuildSettingsKey = "REEXPORTED_FRAMEWORK_INSTALL_NAMES"
}

// MARK: Re-Exported Framework Names
extension BuildSetting {

    /// Re-Exported Framework Names
    ///
    /// List of framework names that should have their symbols be reexported from the built library.
    public static func reExportedFrameworkNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reExportedFrameworkNames, value: .array(value))
    }

    /// Re-Exported Framework Names
    ///
    /// List of framework names that should have their symbols be reexported from the built library.
    public static func reExportedFrameworkNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reExportedFrameworkNames, inherit: key)
    }

    /// Re-Exported Framework Names
    ///
    /// List of framework names that should have their symbols be reexported from the built library.
    public static func reExportedFrameworkNames(_ value: String...) -> BuildSetting { 
        .reExportedFrameworkNames(value)
    }
}

extension BuildSettingsKey {

    /// Re-Exported Framework Names
    ///
    /// List of framework names that should have their symbols be reexported from the built library.
    public static let reExportedFrameworkNames: BuildSettingsKey = "REEXPORTED_FRAMEWORK_NAMES"
}

// MARK: REEXPORTED_LIBRARY_INSTALL_NAMES
extension BuildSetting {

    /// REEXPORTED_LIBRARY_INSTALL_NAMES
    public static func reexportedLibraryInstallNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reexportedLibraryInstallNames, value: .array(value))
    }

    /// REEXPORTED_LIBRARY_INSTALL_NAMES
    public static func reexportedLibraryInstallNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reexportedLibraryInstallNames, inherit: key)
    }

    /// REEXPORTED_LIBRARY_INSTALL_NAMES
    public static func reexportedLibraryInstallNames(_ value: String...) -> BuildSetting { 
        .reexportedLibraryInstallNames(value)
    }
}

extension BuildSettingsKey {

    /// REEXPORTED_LIBRARY_INSTALL_NAMES
    public static let reexportedLibraryInstallNames: BuildSettingsKey = "REEXPORTED_LIBRARY_INSTALL_NAMES"
}

// MARK: Re-Exported Library Names
extension BuildSetting {

    /// Re-Exported Library Names
    ///
    /// List of library names that should have their symbols be reexported from the built library.
    public static func reExportedLibraryNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reExportedLibraryNames, value: .array(value))
    }

    /// Re-Exported Library Names
    ///
    /// List of library names that should have their symbols be reexported from the built library.
    public static func reExportedLibraryNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reExportedLibraryNames, inherit: key)
    }

    /// Re-Exported Library Names
    ///
    /// List of library names that should have their symbols be reexported from the built library.
    public static func reExportedLibraryNames(_ value: String...) -> BuildSetting { 
        .reExportedLibraryNames(value)
    }
}

extension BuildSettingsKey {

    /// Re-Exported Library Names
    ///
    /// List of library names that should have their symbols be reexported from the built library.
    public static let reExportedLibraryNames: BuildSettingsKey = "REEXPORTED_LIBRARY_NAMES"
}

// MARK: Re-Exported Library Paths
extension BuildSetting {

    /// Re-Exported Library Paths
    ///
    /// List of library paths that should have their symbols be reexported from the built library.
    public static func reExportedLibraryPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .reExportedLibraryPaths, value: .array(value))
    }

    /// Re-Exported Library Paths
    ///
    /// List of library paths that should have their symbols be reexported from the built library.
    public static func reExportedLibraryPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reExportedLibraryPaths, inherit: key)
    }

    /// Re-Exported Library Paths
    ///
    /// List of library paths that should have their symbols be reexported from the built library.
    public static func reExportedLibraryPaths(_ value: String...) -> BuildSetting { 
        .reExportedLibraryPaths(value)
    }
}

extension BuildSettingsKey {

    /// Re-Exported Library Paths
    ///
    /// List of library paths that should have their symbols be reexported from the built library.
    public static let reExportedLibraryPaths: BuildSettingsKey = "REEXPORTED_LIBRARY_PATHS"
}

// MARK: REMOVE_CVS_FROM_RESOURCES
extension BuildSetting {

    /// REMOVE_CVS_FROM_RESOURCES
    ///
    /// Specifies whether to remove `CVS` directories from bundle resources when they are copied.
    public static var removeCvsFromResources: BuildSetting { 
        BuildSetting(key: .removeCvsFromResources, value: "YES")
    }

    /// REMOVE_CVS_FROM_RESOURCES
    ///
    /// Specifies whether to remove `CVS` directories from bundle resources when they are copied.
    public static func removeCvsFromResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeCvsFromResources, value: SettingValue(booleanLiteral: value))
    }

    /// REMOVE_CVS_FROM_RESOURCES
    ///
    /// Specifies whether to remove `CVS` directories from bundle resources when they are copied.
    public static func removeCvsFromResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeCvsFromResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// REMOVE_CVS_FROM_RESOURCES
    ///
    /// Specifies whether to remove `CVS` directories from bundle resources when they are copied.
    public static let removeCvsFromResources: BuildSettingsKey = "REMOVE_CVS_FROM_RESOURCES"
}

// MARK: REMOVE_GIT_FROM_RESOURCES
extension BuildSetting {

    /// REMOVE_GIT_FROM_RESOURCES
    ///
    /// Specifies whether to remove `.git` directories from bundle resources when they are copied.
    public static var removeGitFromResources: BuildSetting { 
        BuildSetting(key: .removeGitFromResources, value: "YES")
    }

    /// REMOVE_GIT_FROM_RESOURCES
    ///
    /// Specifies whether to remove `.git` directories from bundle resources when they are copied.
    public static func removeGitFromResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeGitFromResources, value: SettingValue(booleanLiteral: value))
    }

    /// REMOVE_GIT_FROM_RESOURCES
    ///
    /// Specifies whether to remove `.git` directories from bundle resources when they are copied.
    public static func removeGitFromResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeGitFromResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// REMOVE_GIT_FROM_RESOURCES
    ///
    /// Specifies whether to remove `.git` directories from bundle resources when they are copied.
    public static let removeGitFromResources: BuildSettingsKey = "REMOVE_GIT_FROM_RESOURCES"
}

// MARK: REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES
extension BuildSetting {

    /// REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES
    public static var removeHeadersFromEmbeddedBundles: BuildSetting { 
        BuildSetting(key: .removeHeadersFromEmbeddedBundles, value: "YES")
    }

    /// REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES
    public static func removeHeadersFromEmbeddedBundles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeHeadersFromEmbeddedBundles, value: SettingValue(booleanLiteral: value))
    }

    /// REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES
    public static func removeHeadersFromEmbeddedBundles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeHeadersFromEmbeddedBundles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES
    public static let removeHeadersFromEmbeddedBundles: BuildSettingsKey = "REMOVE_HEADERS_FROM_EMBEDDED_BUNDLES"
}

// MARK: REMOVE_HEADER_DIRECTORIES
extension BuildSetting {

    /// REMOVE_HEADER_DIRECTORIES
    public static var removeHeaderDirectories: BuildSetting { 
        BuildSetting(key: .removeHeaderDirectories, value: "NO")
    }

    /// REMOVE_HEADER_DIRECTORIES
    public static func removeHeaderDirectories(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeHeaderDirectories, value: SettingValue(booleanLiteral: value))
    }

    /// REMOVE_HEADER_DIRECTORIES
    public static func removeHeaderDirectories(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeHeaderDirectories, inherit: key)
    }
}

extension BuildSettingsKey {

    /// REMOVE_HEADER_DIRECTORIES
    public static let removeHeaderDirectories: BuildSettingsKey = "REMOVE_HEADER_DIRECTORIES"
}

// MARK: REMOVE_HG_FROM_RESOURCES
extension BuildSetting {

    /// REMOVE_HG_FROM_RESOURCES
    ///
    /// Specifies whether to remove `.hg` directories from bundle resources when they are copied.
    public static var removeHgFromResources: BuildSetting { 
        BuildSetting(key: .removeHgFromResources, value: "YES")
    }

    /// REMOVE_HG_FROM_RESOURCES
    ///
    /// Specifies whether to remove `.hg` directories from bundle resources when they are copied.
    public static func removeHgFromResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeHgFromResources, value: SettingValue(booleanLiteral: value))
    }

    /// REMOVE_HG_FROM_RESOURCES
    ///
    /// Specifies whether to remove `.hg` directories from bundle resources when they are copied.
    public static func removeHgFromResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeHgFromResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// REMOVE_HG_FROM_RESOURCES
    ///
    /// Specifies whether to remove `.hg` directories from bundle resources when they are copied.
    public static let removeHgFromResources: BuildSettingsKey = "REMOVE_HG_FROM_RESOURCES"
}

// MARK: REMOVE_SVN_FROM_RESOURCES
extension BuildSetting {

    /// REMOVE_SVN_FROM_RESOURCES
    ///
    /// Specifies whether to remove `SVN` directories from bundle resources when they are copied.
    public static var removeSvnFromResources: BuildSetting { 
        BuildSetting(key: .removeSvnFromResources, value: "YES")
    }

    /// REMOVE_SVN_FROM_RESOURCES
    ///
    /// Specifies whether to remove `SVN` directories from bundle resources when they are copied.
    public static func removeSvnFromResources(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeSvnFromResources, value: SettingValue(booleanLiteral: value))
    }

    /// REMOVE_SVN_FROM_RESOURCES
    ///
    /// Specifies whether to remove `SVN` directories from bundle resources when they are copied.
    public static func removeSvnFromResources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeSvnFromResources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// REMOVE_SVN_FROM_RESOURCES
    ///
    /// Specifies whether to remove `SVN` directories from bundle resources when they are copied.
    public static let removeSvnFromResources: BuildSettingsKey = "REMOVE_SVN_FROM_RESOURCES"
}

// MARK: File Fork of Binary Sources
extension BuildSetting {

    /// File Fork of Binary Sources
    ///
    /// Determines whether `ResMerger` treats binary input files as data-fork hosted or resource-fork hosted, or whether it automatically examines each input file.
    public static var fileForkOfBinarySources: BuildSetting { 
        .fileForkOfBinarySources(.auto) 
    }

    /// File Fork of Binary Sources
    ///
    /// Determines whether `ResMerger` treats binary input files as data-fork hosted or resource-fork hosted, or whether it automatically examines each input file.
    public static func fileForkOfBinarySources(_ value: FileForkOfBinarySources) -> BuildSetting { 
        BuildSetting(key: .fileForkOfBinarySources, value: "\(value)")
    }

    /// File Fork of Binary Sources
    ///
    /// Determines whether `ResMerger` treats binary input files as data-fork hosted or resource-fork hosted, or whether it automatically examines each input file.
    public static func fileForkOfBinarySources(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .fileForkOfBinarySources, inherit: key)
    }
}

extension BuildSettingsKey {

    /// File Fork of Binary Sources
    ///
    /// Determines whether `ResMerger` treats binary input files as data-fork hosted or resource-fork hosted, or whether it automatically examines each input file.
    public static let fileForkOfBinarySources: BuildSettingsKey = "RESMERGER_SOURCES_FORK"
}

public enum FileForkOfBinarySources: String, Hashable, Codable, CustomStringConvertible {
    case data = "data"
    case resource = "resource"
    case auto = "auto"

    public var description: String {
        rawValue
    }
}

// MARK: RESOURCES_PLATFORM_NAME
extension BuildSetting {

    /// RESOURCES_PLATFORM_NAME
    public static func resourcesPlatformName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .resourcesPlatformName, value: "\(value)")
    }

    /// RESOURCES_PLATFORM_NAME
    public static func resourcesPlatformName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resourcesPlatformName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// RESOURCES_PLATFORM_NAME
    public static let resourcesPlatformName: BuildSettingsKey = "RESOURCES_PLATFORM_NAME"
}

// MARK: Resources Targeted Device Family
extension BuildSetting {

    /// Resources Targeted Device Family
    ///
    /// Overrides [Targeted Device Family (TARGETED\_DEVICE\_FAMILY)](itcaec37c2a6.html#dev2f2f7890b) when the resource copying needs to differ from the default targeted device.
    public static func resourcesTargetedDeviceFamily(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .resourcesTargetedDeviceFamily, value: .array(value))
    }

    /// Resources Targeted Device Family
    ///
    /// Overrides [Targeted Device Family (TARGETED\_DEVICE\_FAMILY)](itcaec37c2a6.html#dev2f2f7890b) when the resource copying needs to differ from the default targeted device.
    public static func resourcesTargetedDeviceFamily(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resourcesTargetedDeviceFamily, inherit: key)
    }

    /// Resources Targeted Device Family
    ///
    /// Overrides [Targeted Device Family (TARGETED\_DEVICE\_FAMILY)](itcaec37c2a6.html#dev2f2f7890b) when the resource copying needs to differ from the default targeted device.
    public static func resourcesTargetedDeviceFamily(_ value: String...) -> BuildSetting { 
        .resourcesTargetedDeviceFamily(value)
    }
}

extension BuildSettingsKey {

    /// Resources Targeted Device Family
    ///
    /// Overrides [Targeted Device Family (TARGETED\_DEVICE\_FAMILY)](itcaec37c2a6.html#dev2f2f7890b) when the resource copying needs to differ from the default targeted device.
    public static let resourcesTargetedDeviceFamily: BuildSettingsKey = "RESOURCES_TARGETED_DEVICE_FAMILY"
}

// MARK: RESOURCES_UI_FRAMEWORK_FAMILY
extension BuildSetting {

    /// RESOURCES_UI_FRAMEWORK_FAMILY
    public static func resourcesUiFrameworkFamily(_ value: String) -> BuildSetting { 
        BuildSetting(key: .resourcesUiFrameworkFamily, value: "\(value)")
    }

    /// RESOURCES_UI_FRAMEWORK_FAMILY
    public static func resourcesUiFrameworkFamily(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resourcesUiFrameworkFamily, inherit: key)
    }
}

extension BuildSettingsKey {

    /// RESOURCES_UI_FRAMEWORK_FAMILY
    public static let resourcesUiFrameworkFamily: BuildSettingsKey = "RESOURCES_UI_FRAMEWORK_FAMILY"
}

// MARK: RESOURCE_RULES_PLIST_PATH
extension BuildSetting {

    /// RESOURCE_RULES_PLIST_PATH
    public static var resourceRulesPlistPath: BuildSetting { 
        BuildSetting(key: .resourceRulesPlistPath, value: "")
    }

    /// RESOURCE_RULES_PLIST_PATH
    public static func resourceRulesPlistPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .resourceRulesPlistPath, value: "\(value)")
    }

    /// RESOURCE_RULES_PLIST_PATH
    public static func resourceRulesPlistPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resourceRulesPlistPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// RESOURCE_RULES_PLIST_PATH
    public static let resourceRulesPlistPath: BuildSettingsKey = "RESOURCE_RULES_PLIST_PATH"
}

// MARK: RETAIN_RAW_BINARIES
extension BuildSetting {

    /// RETAIN_RAW_BINARIES
    ///
    /// Specifies whether to keep copies of unstripped binaries available.
    public static var retainRawBinaries: BuildSetting { 
        BuildSetting(key: .retainRawBinaries, value: "$(INSTALLED_PRODUCT_ASIDES)")
    }

    /// RETAIN_RAW_BINARIES
    ///
    /// Specifies whether to keep copies of unstripped binaries available.
    public static func retainRawBinaries(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .retainRawBinaries, value: SettingValue(booleanLiteral: value))
    }

    /// RETAIN_RAW_BINARIES
    ///
    /// Specifies whether to keep copies of unstripped binaries available.
    public static func retainRawBinaries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .retainRawBinaries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// RETAIN_RAW_BINARIES
    ///
    /// Specifies whether to keep copies of unstripped binaries available.
    public static let retainRawBinaries: BuildSettingsKey = "RETAIN_RAW_BINARIES"
}

// MARK: REZ_COLLECTOR_DIR
extension BuildSetting {

    /// REZ_COLLECTOR_DIR
    ///
    /// Specifies the directory in which the collected Resource Manager resources generated by `ResMerger` are stored before they are added to the product.
    public static var rezCollectorDir: BuildSetting { 
        BuildSetting(key: .rezCollectorDir, value: "$(TARGET_TEMP_DIR)/ResourceManagerResources")
    }

    /// REZ_COLLECTOR_DIR
    ///
    /// Specifies the directory in which the collected Resource Manager resources generated by `ResMerger` are stored before they are added to the product.
    public static func rezCollectorDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .rezCollectorDir, value: "\(value)")
    }

    /// REZ_COLLECTOR_DIR
    ///
    /// Specifies the directory in which the collected Resource Manager resources generated by `ResMerger` are stored before they are added to the product.
    public static func rezCollectorDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezCollectorDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// REZ_COLLECTOR_DIR
    ///
    /// Specifies the directory in which the collected Resource Manager resources generated by `ResMerger` are stored before they are added to the product.
    public static let rezCollectorDir: BuildSettingsKey = "REZ_COLLECTOR_DIR"
}

// MARK: REZ_EXECUTABLE
extension BuildSetting {

    /// REZ_EXECUTABLE
    public static var rezExecutable: BuildSetting { 
        BuildSetting(key: .rezExecutable, value: "")
    }

    /// REZ_EXECUTABLE
    public static func rezExecutable(_ value: String) -> BuildSetting { 
        BuildSetting(key: .rezExecutable, value: "\(value)")
    }

    /// REZ_EXECUTABLE
    public static func rezExecutable(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezExecutable, inherit: key)
    }
}

extension BuildSettingsKey {

    /// REZ_EXECUTABLE
    public static let rezExecutable: BuildSettingsKey = "REZ_EXECUTABLE"
}

// MARK: REZ_OBJECTS_DIR
extension BuildSetting {

    /// REZ_OBJECTS_DIR
    ///
    /// Specifies the directory in which compiled Resource Manager resources generated by `Rez` are stored before they are collected using `ResMerger`.
    public static var rezObjectsDir: BuildSetting { 
        BuildSetting(key: .rezObjectsDir, value: "$(REZ_COLLECTOR_DIR)/Objects")
    }

    /// REZ_OBJECTS_DIR
    ///
    /// Specifies the directory in which compiled Resource Manager resources generated by `Rez` are stored before they are collected using `ResMerger`.
    public static func rezObjectsDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .rezObjectsDir, value: "\(value)")
    }

    /// REZ_OBJECTS_DIR
    ///
    /// Specifies the directory in which compiled Resource Manager resources generated by `Rez` are stored before they are collected using `ResMerger`.
    public static func rezObjectsDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezObjectsDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// REZ_OBJECTS_DIR
    ///
    /// Specifies the directory in which compiled Resource Manager resources generated by `Rez` are stored before they are collected using `ResMerger`.
    public static let rezObjectsDir: BuildSettingsKey = "REZ_OBJECTS_DIR"
}

// MARK: Rez Prefix File
extension BuildSetting {

    /// Rez Prefix File
    ///
    /// Implicitly include the named file on the command line for each `Rez` file compiled. The path given should either be a project relative path or an absolute path.
    public static var rezPrefixFile: BuildSetting { 
        BuildSetting(key: .rezPrefixFile, value: "")
    }

    /// Rez Prefix File
    ///
    /// Implicitly include the named file on the command line for each `Rez` file compiled. The path given should either be a project relative path or an absolute path.
    public static func rezPrefixFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .rezPrefixFile, value: "\(value)")
    }

    /// Rez Prefix File
    ///
    /// Implicitly include the named file on the command line for each `Rez` file compiled. The path given should either be a project relative path or an absolute path.
    public static func rezPrefixFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezPrefixFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Rez Prefix File
    ///
    /// Implicitly include the named file on the command line for each `Rez` file compiled. The path given should either be a project relative path or an absolute path.
    public static let rezPrefixFile: BuildSettingsKey = "REZ_PREFIX_FILE"
}

// MARK: Preprocessor Defines
extension BuildSetting {

    /// Preprocessor Defines
    ///
    /// These strings will be defined when compiling resource manager resources.
    public static var preprocessorDefines: BuildSetting { 
        BuildSetting(key: .preprocessorDefines, value: "")
    }

    /// Preprocessor Defines
    ///
    /// These strings will be defined when compiling resource manager resources.
    public static func preprocessorDefines(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorDefines, value: .array(value))
    }

    /// Preprocessor Defines
    ///
    /// These strings will be defined when compiling resource manager resources.
    public static func preprocessorDefines(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorDefines, inherit: key)
    }

    /// Preprocessor Defines
    ///
    /// These strings will be defined when compiling resource manager resources.
    public static func preprocessorDefines(_ value: String...) -> BuildSetting { 
        .preprocessorDefines(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Defines
    ///
    /// These strings will be defined when compiling resource manager resources.
    public static let preprocessorDefines: BuildSettingsKey = "REZ_PREPROCESSOR_DEFINITIONS"
}

// MARK: Preprocessor Undefines
extension BuildSetting {

    /// Preprocessor Undefines
    ///
    /// These strings will be undefined when compiling resource manager resources.
    public static var preprocessorUndefines: BuildSetting { 
        BuildSetting(key: .preprocessorUndefines, value: "")
    }

    /// Preprocessor Undefines
    ///
    /// These strings will be undefined when compiling resource manager resources.
    public static func preprocessorUndefines(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .preprocessorUndefines, value: .array(value))
    }

    /// Preprocessor Undefines
    ///
    /// These strings will be undefined when compiling resource manager resources.
    public static func preprocessorUndefines(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .preprocessorUndefines, inherit: key)
    }

    /// Preprocessor Undefines
    ///
    /// These strings will be undefined when compiling resource manager resources.
    public static func preprocessorUndefines(_ value: String...) -> BuildSetting { 
        .preprocessorUndefines(value)
    }
}

extension BuildSettingsKey {

    /// Preprocessor Undefines
    ///
    /// These strings will be undefined when compiling resource manager resources.
    public static let preprocessorUndefines: BuildSettingsKey = "REZ_PREPROCESSOR_UNDEFINITIONS"
}

// MARK: Resolve Aliases
extension BuildSetting {

    /// Resolve Aliases
    ///
    /// Enables aliases to be unresolved or conditionally resolved. The default is to resolve aliases always.
    public static var resolveAliases: BuildSetting { 
        .resolveAliases(.always) 
    }

    /// Resolve Aliases
    ///
    /// Enables aliases to be unresolved or conditionally resolved. The default is to resolve aliases always.
    public static func resolveAliases(_ value: ResolveAliases) -> BuildSetting { 
        BuildSetting(key: .resolveAliases, value: "\(value)")
    }

    /// Resolve Aliases
    ///
    /// Enables aliases to be unresolved or conditionally resolved. The default is to resolve aliases always.
    public static func resolveAliases(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .resolveAliases, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Resolve Aliases
    ///
    /// Enables aliases to be unresolved or conditionally resolved. The default is to resolve aliases always.
    public static let resolveAliases: BuildSettingsKey = "REZ_RESOLVE_ALIASES"
}

public enum ResolveAliases: String, Hashable, Codable, CustomStringConvertible {
    case always = "Always"
    case never = "Never"
    case includes = "Includes"
    case outputs = "Outputs"

    public var description: String {
        rawValue
    }
}

// MARK: Read-only Resource Map
extension BuildSetting {

    /// Read-only Resource Map
    ///
    /// Enabling this option causes the resource map output to be read-only.
    public static var readOnlyResourceMap: BuildSetting { 
        BuildSetting(key: .readOnlyResourceMap, value: "NO")
    }

    /// Read-only Resource Map
    ///
    /// Enabling this option causes the resource map output to be read-only.
    public static func readOnlyResourceMap(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .readOnlyResourceMap, value: SettingValue(booleanLiteral: value))
    }

    /// Read-only Resource Map
    ///
    /// Enabling this option causes the resource map output to be read-only.
    public static func readOnlyResourceMap(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .readOnlyResourceMap, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Read-only Resource Map
    ///
    /// Enabling this option causes the resource map output to be read-only.
    public static let readOnlyResourceMap: BuildSettingsKey = "REZ_RESOURCE_MAP_READ_ONLY"
}

// MARK: Rez Script Type
extension BuildSetting {

    /// Rez Script Type
    ///
    /// Enables the recognition of a specific 2-byte character script identifier to use when compiling resource manager resources. This allows for 2-byte characters in strings to be handled as indivisible entities. The default language is Roman, which specifies 1-byte character sets.
    public static var rezScriptType: BuildSetting { 
        .rezScriptType(.roman) 
    }

    /// Rez Script Type
    ///
    /// Enables the recognition of a specific 2-byte character script identifier to use when compiling resource manager resources. This allows for 2-byte characters in strings to be handled as indivisible entities. The default language is Roman, which specifies 1-byte character sets.
    public static func rezScriptType(_ value: RezScriptType) -> BuildSetting { 
        BuildSetting(key: .rezScriptType, value: "\(value)")
    }

    /// Rez Script Type
    ///
    /// Enables the recognition of a specific 2-byte character script identifier to use when compiling resource manager resources. This allows for 2-byte characters in strings to be handled as indivisible entities. The default language is Roman, which specifies 1-byte character sets.
    public static func rezScriptType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezScriptType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Rez Script Type
    ///
    /// Enables the recognition of a specific 2-byte character script identifier to use when compiling resource manager resources. This allows for 2-byte characters in strings to be handled as indivisible entities. The default language is Roman, which specifies 1-byte character sets.
    public static let rezScriptType: BuildSettingsKey = "REZ_SCRIPT_TYPE"
}

public enum RezScriptType: String, Hashable, Codable, CustomStringConvertible {
    case roman = "Roman"
    case japanese = "Japanese"
    case korean = "Korean"
    case simpchinese = "SimpChinese"
    case tradchinese = "TradChinese"

    public var description: String {
        rawValue
    }
}

// MARK: Rez Search Paths
extension BuildSetting {

    /// Rez Search Paths
    ///
    /// This is a list of paths to search for files with resource manager resources. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static var rezSearchPaths: BuildSetting { 
        BuildSetting(key: .rezSearchPaths, value: "")
    }

    /// Rez Search Paths
    ///
    /// This is a list of paths to search for files with resource manager resources. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func rezSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .rezSearchPaths, value: .array(value))
    }

    /// Rez Search Paths
    ///
    /// This is a list of paths to search for files with resource manager resources. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func rezSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .rezSearchPaths, inherit: key)
    }

    /// Rez Search Paths
    ///
    /// This is a list of paths to search for files with resource manager resources. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static func rezSearchPaths(_ value: String...) -> BuildSetting { 
        .rezSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// Rez Search Paths
    ///
    /// This is a list of paths to search for files with resource manager resources. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted.
    public static let rezSearchPaths: BuildSettingsKey = "REZ_SEARCH_PATHS"
}

// MARK: Show Diagnostic Output
extension BuildSetting {

    /// Show Diagnostic Output
    ///
    /// Enabling this option causes version and progress information to be written when compiling resource manager resources.
    public static var showDiagnosticOutput: BuildSetting { 
        BuildSetting(key: .showDiagnosticOutput, value: "NO")
    }

    /// Show Diagnostic Output
    ///
    /// Enabling this option causes version and progress information to be written when compiling resource manager resources.
    public static func showDiagnosticOutput(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showDiagnosticOutput, value: SettingValue(booleanLiteral: value))
    }

    /// Show Diagnostic Output
    ///
    /// Enabling this option causes version and progress information to be written when compiling resource manager resources.
    public static func showDiagnosticOutput(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showDiagnosticOutput, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Diagnostic Output
    ///
    /// Enabling this option causes version and progress information to be written when compiling resource manager resources.
    public static let showDiagnosticOutput: BuildSettingsKey = "REZ_SHOW_DEBUG_OUTPUT"
}

// MARK: Suppress Type Redeclaration Warnings
extension BuildSetting {

    /// Suppress Type Redeclaration Warnings
    ///
    /// Enabling this option causes warnings about redeclared resource types to be suppressed.
    public static var suppressTypeRedeclarationWarnings: BuildSetting { 
        BuildSetting(key: .suppressTypeRedeclarationWarnings, value: "NO")
    }

    /// Suppress Type Redeclaration Warnings
    ///
    /// Enabling this option causes warnings about redeclared resource types to be suppressed.
    public static func suppressTypeRedeclarationWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressTypeRedeclarationWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress Type Redeclaration Warnings
    ///
    /// Enabling this option causes warnings about redeclared resource types to be suppressed.
    public static func suppressTypeRedeclarationWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressTypeRedeclarationWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress Type Redeclaration Warnings
    ///
    /// Enabling this option causes warnings about redeclared resource types to be suppressed.
    public static let suppressTypeRedeclarationWarnings: BuildSettingsKey = "REZ_SUPPRESS_REDECLARED_RESOURCE_TYPE_WARNINGS"
}

// MARK: Analyze During 'Build'
extension BuildSetting {

    /// Analyze During 'Build'
    ///
    /// Activating this setting will cause Xcode to run the `Clang` static analysis tool on qualifying source files during every build.
    public static var analyzeDuringBuild: BuildSetting { 
        BuildSetting(key: .analyzeDuringBuild, value: "NO")
    }

    /// Analyze During 'Build'
    ///
    /// Activating this setting will cause Xcode to run the `Clang` static analysis tool on qualifying source files during every build.
    public static func analyzeDuringBuild(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .analyzeDuringBuild, value: SettingValue(booleanLiteral: value))
    }

    /// Analyze During 'Build'
    ///
    /// Activating this setting will cause Xcode to run the `Clang` static analysis tool on qualifying source files during every build.
    public static func analyzeDuringBuild(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .analyzeDuringBuild, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Analyze During 'Build'
    ///
    /// Activating this setting will cause Xcode to run the `Clang` static analysis tool on qualifying source files during every build.
    public static let analyzeDuringBuild: BuildSettingsKey = "RUN_CLANG_STATIC_ANALYZER"
}

// MARK: RemoveFile
extension BuildSetting {

    /// RemoveFile
    public static func removefile(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removefile, value: SettingValue(booleanLiteral: value))
    }

    /// RemoveFile
    public static func removefile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removefile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// RemoveFile
    public static let removefile: BuildSettingsKey = "RemoveFile"
}

// MARK: RequiredArchitectures
extension BuildSetting {

    /// RequiredArchitectures
    public static func requiredarchitectures(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .requiredarchitectures, value: .array(value))
    }

    /// RequiredArchitectures
    public static func requiredarchitectures(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .requiredarchitectures, inherit: key)
    }

    /// RequiredArchitectures
    public static func requiredarchitectures(_ value: String...) -> BuildSetting { 
        .requiredarchitectures(value)
    }
}

extension BuildSettingsKey {

    /// RequiredArchitectures
    public static let requiredarchitectures: BuildSettingsKey = "RequiredArchitectures"
}

// MARK: Scan All Source Files for Includes
extension BuildSetting {

    /// Scan All Source Files for Includes
    ///
    /// Activating this setting will cause all source files to be scanned for includes (for example, of header files) when computing the dependency graph, in which case if an included file is changed then the including file will be rebuilt next time a target containing it is built. Normally only certain types of files, such as C-language source files, are scanned.

This setting is useful if your project contains files of unusual types, which are compiled using a custom build rule.
    public static var scanAllSourceFilesForIncludes: BuildSetting { 
        BuildSetting(key: .scanAllSourceFilesForIncludes, value: "NO")
    }

    /// Scan All Source Files for Includes
    ///
    /// Activating this setting will cause all source files to be scanned for includes (for example, of header files) when computing the dependency graph, in which case if an included file is changed then the including file will be rebuilt next time a target containing it is built. Normally only certain types of files, such as C-language source files, are scanned.

This setting is useful if your project contains files of unusual types, which are compiled using a custom build rule.
    public static func scanAllSourceFilesForIncludes(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .scanAllSourceFilesForIncludes, value: SettingValue(booleanLiteral: value))
    }

    /// Scan All Source Files for Includes
    ///
    /// Activating this setting will cause all source files to be scanned for includes (for example, of header files) when computing the dependency graph, in which case if an included file is changed then the including file will be rebuilt next time a target containing it is built. Normally only certain types of files, such as C-language source files, are scanned.

This setting is useful if your project contains files of unusual types, which are compiled using a custom build rule.
    public static func scanAllSourceFilesForIncludes(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .scanAllSourceFilesForIncludes, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Scan All Source Files for Includes
    ///
    /// Activating this setting will cause all source files to be scanned for includes (for example, of header files) when computing the dependency graph, in which case if an included file is changed then the including file will be rebuilt next time a target containing it is built. Normally only certain types of files, such as C-language source files, are scanned.

This setting is useful if your project contains files of unusual types, which are compiled using a custom build rule.
    public static let scanAllSourceFilesForIncludes: BuildSettingsKey = "SCAN_ALL_SOURCE_FILES_FOR_INCLUDES"
}

// MARK: SCENEKIT_DEPLOYMENT_TARGET
extension BuildSetting {

    /// SCENEKIT_DEPLOYMENT_TARGET
    public static var scenekitDeploymentTarget: BuildSetting { 
        BuildSetting(key: .scenekitDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// SCENEKIT_DEPLOYMENT_TARGET
    public static func scenekitDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .scenekitDeploymentTarget, value: "\(value)")
    }

    /// SCENEKIT_DEPLOYMENT_TARGET
    public static func scenekitDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .scenekitDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SCENEKIT_DEPLOYMENT_TARGET
    public static let scenekitDeploymentTarget: BuildSettingsKey = "SCENEKIT_DEPLOYMENT_TARGET"
}

// MARK: SCRIPTS_FOLDER_PATH
extension BuildSetting {

    /// SCRIPTS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products scripts.
    public static var scriptsFolderPath: BuildSetting { 
        BuildSetting(key: .scriptsFolderPath, value: "")
    }

    /// SCRIPTS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products scripts.
    public static func scriptsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .scriptsFolderPath, value: "\(value)")
    }

    /// SCRIPTS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products scripts.
    public static func scriptsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .scriptsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SCRIPTS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products scripts.
    public static let scriptsFolderPath: BuildSettingsKey = "SCRIPTS_FOLDER_PATH"
}

// MARK: Base SDK
extension BuildSetting {

    /// Base SDK
    ///
    /// The name or path of the base SDK being used during the build. The product will be built against the headers and libraries located inside the indicated SDK. This path will be prepended to all search paths, and will be passed through the environment to the compiler and linker. Additional SDKs can be specified in the [Additional SDKs (ADDITIONAL\_SDKS)](itcaec37c2a6.html#deva1a5b1b82) setting.
    public static var baseSdk: BuildSetting { 
        BuildSetting(key: .baseSdk, value: "")
    }

    /// Base SDK
    ///
    /// The name or path of the base SDK being used during the build. The product will be built against the headers and libraries located inside the indicated SDK. This path will be prepended to all search paths, and will be passed through the environment to the compiler and linker. Additional SDKs can be specified in the [Additional SDKs (ADDITIONAL\_SDKS)](itcaec37c2a6.html#deva1a5b1b82) setting.
    public static func baseSdk(_ value: String) -> BuildSetting { 
        BuildSetting(key: .baseSdk, value: "\(value)")
    }

    /// Base SDK
    ///
    /// The name or path of the base SDK being used during the build. The product will be built against the headers and libraries located inside the indicated SDK. This path will be prepended to all search paths, and will be passed through the environment to the compiler and linker. Additional SDKs can be specified in the [Additional SDKs (ADDITIONAL\_SDKS)](itcaec37c2a6.html#deva1a5b1b82) setting.
    public static func baseSdk(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .baseSdk, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Base SDK
    ///
    /// The name or path of the base SDK being used during the build. The product will be built against the headers and libraries located inside the indicated SDK. This path will be prepended to all search paths, and will be passed through the environment to the compiler and linker. Additional SDKs can be specified in the [Additional SDKs (ADDITIONAL\_SDKS)](itcaec37c2a6.html#deva1a5b1b82) setting.
    public static let baseSdk: BuildSettingsKey = "SDKROOT"
}

// MARK: Symbol Ordering Flags
extension BuildSetting {

    /// Symbol Ordering Flags
    ///
    /// These flags are typically used to specify options for ordering symbols within segments, for example the `-sectorder` option to `ld`.

Generally you should not specify symbol ordering options in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static var symbolOrderingFlags: BuildSetting { 
        BuildSetting(key: .symbolOrderingFlags, value: "")
    }

    /// Symbol Ordering Flags
    ///
    /// These flags are typically used to specify options for ordering symbols within segments, for example the `-sectorder` option to `ld`.

Generally you should not specify symbol ordering options in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func symbolOrderingFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .symbolOrderingFlags, value: .array(value))
    }

    /// Symbol Ordering Flags
    ///
    /// These flags are typically used to specify options for ordering symbols within segments, for example the `-sectorder` option to `ld`.

Generally you should not specify symbol ordering options in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func symbolOrderingFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .symbolOrderingFlags, inherit: key)
    }

    /// Symbol Ordering Flags
    ///
    /// These flags are typically used to specify options for ordering symbols within segments, for example the `-sectorder` option to `ld`.

Generally you should not specify symbol ordering options in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static func symbolOrderingFlags(_ value: String...) -> BuildSetting { 
        .symbolOrderingFlags(value)
    }
}

extension BuildSettingsKey {

    /// Symbol Ordering Flags
    ///
    /// These flags are typically used to specify options for ordering symbols within segments, for example the `-sectorder` option to `ld`.

Generally you should not specify symbol ordering options in Debug or Development configurations, as this will make the linked binary less readable to the debugger. Use them only in Release or Deployment configurations.
    public static let symbolOrderingFlags: BuildSettingsKey = "SECTORDER_FLAGS"
}

// MARK: SED
extension BuildSetting {

    /// SED
    public static var sed: BuildSetting { 
        BuildSetting(key: .sed, value: "/usr/bin/sed")
    }

    /// SED
    public static func sed(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sed, value: "\(value)")
    }

    /// SED
    public static func sed(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sed, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SED
    public static let sed: BuildSettingsKey = "SED"
}

// MARK: SEPARATE_STRIP
extension BuildSetting {

    /// SEPARATE_STRIP
    public static var separateStrip: BuildSetting { 
        BuildSetting(key: .separateStrip, value: "NO")
    }

    /// SEPARATE_STRIP
    public static func separateStrip(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .separateStrip, value: SettingValue(booleanLiteral: value))
    }

    /// SEPARATE_STRIP
    public static func separateStrip(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .separateStrip, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SEPARATE_STRIP
    public static let separateStrip: BuildSettingsKey = "SEPARATE_STRIP"
}

// MARK: Separately Edit Symbols
extension BuildSetting {

    /// Separately Edit Symbols
    ///
    /// Activating this setting when the linked product's symbols are to be edited will cause editing to occur via a separate invocation of `nmedit(1)`. Otherwise editing will occur during linking, if possible.
    public static var separatelyEditSymbols: BuildSetting { 
        BuildSetting(key: .separatelyEditSymbols, value: "NO")
    }

    /// Separately Edit Symbols
    ///
    /// Activating this setting when the linked product's symbols are to be edited will cause editing to occur via a separate invocation of `nmedit(1)`. Otherwise editing will occur during linking, if possible.
    public static func separatelyEditSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .separatelyEditSymbols, value: SettingValue(booleanLiteral: value))
    }

    /// Separately Edit Symbols
    ///
    /// Activating this setting when the linked product's symbols are to be edited will cause editing to occur via a separate invocation of `nmedit(1)`. Otherwise editing will occur during linking, if possible.
    public static func separatelyEditSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .separatelyEditSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Separately Edit Symbols
    ///
    /// Activating this setting when the linked product's symbols are to be edited will cause editing to occur via a separate invocation of `nmedit(1)`. Otherwise editing will occur during linking, if possible.
    public static let separatelyEditSymbols: BuildSettingsKey = "SEPARATE_SYMBOL_EDIT"
}

// MARK: SET_DIR_MODE_OWNER_GROUP
extension BuildSetting {

    /// SET_DIR_MODE_OWNER_GROUP
    public static var setDirModeOwnerGroup: BuildSetting { 
        BuildSetting(key: .setDirModeOwnerGroup, value: "YES")
    }

    /// SET_DIR_MODE_OWNER_GROUP
    public static func setDirModeOwnerGroup(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .setDirModeOwnerGroup, value: SettingValue(booleanLiteral: value))
    }

    /// SET_DIR_MODE_OWNER_GROUP
    public static func setDirModeOwnerGroup(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .setDirModeOwnerGroup, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SET_DIR_MODE_OWNER_GROUP
    public static let setDirModeOwnerGroup: BuildSettingsKey = "SET_DIR_MODE_OWNER_GROUP"
}

// MARK: SET_FILE_MODE_OWNER_GROUP
extension BuildSetting {

    /// SET_FILE_MODE_OWNER_GROUP
    public static var setFileModeOwnerGroup: BuildSetting { 
        BuildSetting(key: .setFileModeOwnerGroup, value: "NO")
    }

    /// SET_FILE_MODE_OWNER_GROUP
    public static func setFileModeOwnerGroup(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .setFileModeOwnerGroup, value: SettingValue(booleanLiteral: value))
    }

    /// SET_FILE_MODE_OWNER_GROUP
    public static func setFileModeOwnerGroup(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .setFileModeOwnerGroup, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SET_FILE_MODE_OWNER_GROUP
    public static let setFileModeOwnerGroup: BuildSettingsKey = "SET_FILE_MODE_OWNER_GROUP"
}

// MARK: SHALLOW_BUNDLE
extension BuildSetting {

    /// SHALLOW_BUNDLE
    public static var shallowBundle: BuildSetting { 
        BuildSetting(key: .shallowBundle, value: "NO")
    }

    /// SHALLOW_BUNDLE
    public static func shallowBundle(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .shallowBundle, value: SettingValue(booleanLiteral: value))
    }

    /// SHALLOW_BUNDLE
    public static func shallowBundle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .shallowBundle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SHALLOW_BUNDLE
    public static let shallowBundle: BuildSettingsKey = "SHALLOW_BUNDLE"
}

// MARK: SHARED_DERIVED_FILE_DIR
extension BuildSetting {

    /// SHARED_DERIVED_FILE_DIR
    public static var sharedDerivedFileDir: BuildSetting { 
        BuildSetting(key: .sharedDerivedFileDir, value: "$(BUILT_PRODUCTS_DIR)/DerivedSources")
    }

    /// SHARED_DERIVED_FILE_DIR
    public static func sharedDerivedFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sharedDerivedFileDir, value: "\(value)")
    }

    /// SHARED_DERIVED_FILE_DIR
    public static func sharedDerivedFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sharedDerivedFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SHARED_DERIVED_FILE_DIR
    public static let sharedDerivedFileDir: BuildSettingsKey = "SHARED_DERIVED_FILE_DIR"
}

// MARK: SHARED_FRAMEWORKS_FOLDER_PATH
extension BuildSetting {

    /// SHARED_FRAMEWORKS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products shared frameworks.
    public static var sharedFrameworksFolderPath: BuildSetting { 
        BuildSetting(key: .sharedFrameworksFolderPath, value: "")
    }

    /// SHARED_FRAMEWORKS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products shared frameworks.
    public static func sharedFrameworksFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sharedFrameworksFolderPath, value: "\(value)")
    }

    /// SHARED_FRAMEWORKS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products shared frameworks.
    public static func sharedFrameworksFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sharedFrameworksFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SHARED_FRAMEWORKS_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products shared frameworks.
    public static let sharedFrameworksFolderPath: BuildSettingsKey = "SHARED_FRAMEWORKS_FOLDER_PATH"
}

// MARK: Precompiled Headers Cache Path
extension BuildSetting {

    /// Precompiled Headers Cache Path
    ///
    /// The path where precompiled prefix header files are placed during a build. Defaults to `$(OBJROOT)/SharedPrecompiledHeaders`. Using a common location allows precompiled headers to be shared between multiple projects.
    public static var precompiledHeadersCachePath: BuildSetting { 
        BuildSetting(key: .precompiledHeadersCachePath, value: "$(OBJROOT)/SharedPrecompiledHeaders")
    }

    /// Precompiled Headers Cache Path
    ///
    /// The path where precompiled prefix header files are placed during a build. Defaults to `$(OBJROOT)/SharedPrecompiledHeaders`. Using a common location allows precompiled headers to be shared between multiple projects.
    public static func precompiledHeadersCachePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .precompiledHeadersCachePath, value: "\(value)")
    }

    /// Precompiled Headers Cache Path
    ///
    /// The path where precompiled prefix header files are placed during a build. Defaults to `$(OBJROOT)/SharedPrecompiledHeaders`. Using a common location allows precompiled headers to be shared between multiple projects.
    public static func precompiledHeadersCachePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompiledHeadersCachePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Precompiled Headers Cache Path
    ///
    /// The path where precompiled prefix header files are placed during a build. Defaults to `$(OBJROOT)/SharedPrecompiledHeaders`. Using a common location allows precompiled headers to be shared between multiple projects.
    public static let precompiledHeadersCachePath: BuildSettingsKey = "SHARED_PRECOMPS_DIR"
}

// MARK: SHARED_SUPPORT_FOLDER_PATH
extension BuildSetting {

    /// SHARED_SUPPORT_FOLDER_PATH
    public static var sharedSupportFolderPath: BuildSetting { 
        BuildSetting(key: .sharedSupportFolderPath, value: "")
    }

    /// SHARED_SUPPORT_FOLDER_PATH
    public static func sharedSupportFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sharedSupportFolderPath, value: "\(value)")
    }

    /// SHARED_SUPPORT_FOLDER_PATH
    public static func sharedSupportFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sharedSupportFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SHARED_SUPPORT_FOLDER_PATH
    public static let sharedSupportFolderPath: BuildSettingsKey = "SHARED_SUPPORT_FOLDER_PATH"
}

// MARK: SHELL
extension BuildSetting {

    /// SHELL
    public static func shell(_ value: String) -> BuildSetting { 
        BuildSetting(key: .shell, value: "\(value)")
    }

    /// SHELL
    public static func shell(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .shell, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SHELL
    public static let shell: BuildSettingsKey = "SHELL"
}

// MARK: Skip Install
extension BuildSetting {

    /// Skip Install
    ///
    /// If enabled, don't install built products even if deployment locations are active.
    public static var skipInstall: BuildSetting { 
        BuildSetting(key: .skipInstall, value: "NO")
    }

    /// Skip Install
    ///
    /// If enabled, don't install built products even if deployment locations are active.
    public static func skipInstall(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .skipInstall, value: SettingValue(booleanLiteral: value))
    }

    /// Skip Install
    ///
    /// If enabled, don't install built products even if deployment locations are active.
    public static func skipInstall(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .skipInstall, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Skip Install
    ///
    /// If enabled, don't install built products even if deployment locations are active.
    public static let skipInstall: BuildSettingsKey = "SKIP_INSTALL"
}

// MARK: Enable Skybox Warnings
extension BuildSetting {

    /// Enable Skybox Warnings
    public static var enableSkyboxWarnings: BuildSetting { 
        .enableSkyboxWarnings(.yes) 
    }

    /// Enable Skybox Warnings
    public static func enableSkyboxWarnings(_ value: EnableSkyboxWarnings) -> BuildSetting { 
        BuildSetting(key: .enableSkyboxWarnings, value: "\(value)")
    }

    /// Enable Skybox Warnings
    public static func enableSkyboxWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableSkyboxWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable Skybox Warnings
    public static let enableSkyboxWarnings: BuildSettingsKey = "SKYBOX_ENABLE_WARNINGS"
}

public enum EnableSkyboxWarnings: String, Hashable, Codable, CustomStringConvertible {
    case yes = "Yes"
    case no = "No"

    public var description: String {
        rawValue
    }
}

// MARK: SOURCE_ROOT
extension BuildSetting {

    /// SOURCE_ROOT
    public static var sourceRoot: BuildSetting { 
        .sourceRoot(inherit: .srcroot) 
    }

    /// SOURCE_ROOT
    public static func sourceRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .sourceRoot, value: "\(value)")
    }

    /// SOURCE_ROOT
    public static func sourceRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .sourceRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SOURCE_ROOT
    public static let sourceRoot: BuildSettingsKey = "SOURCE_ROOT"
}

// MARK: SRCROOT
extension BuildSetting {

    /// SRCROOT
    ///
    /// Identifies the directory containing the targets source files.
    public static var srcroot: BuildSetting { 
        BuildSetting(key: .srcroot, value: ".")
    }

    /// SRCROOT
    ///
    /// Identifies the directory containing the targets source files.
    public static func srcroot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .srcroot, value: "\(value)")
    }

    /// SRCROOT
    ///
    /// Identifies the directory containing the targets source files.
    public static func srcroot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .srcroot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SRCROOT
    ///
    /// Identifies the directory containing the targets source files.
    public static let srcroot: BuildSettingsKey = "SRCROOT"
}

// MARK: STORYBOARD_COMPILER_INFOPLIST_CONTENT_FILE
extension BuildSetting {

    /// STORYBOARD_COMPILER_INFOPLIST_CONTENT_FILE
    public static var storyboardCompilerInfoplistContentFile: BuildSetting { 
        BuildSetting(key: .storyboardCompilerInfoplistContentFile, value: "$(TARGET_TEMP_DIR)/$(InputFileRegionPathComponent)$(InputFileBase)-SBPartialInfo.plist")
    }

    /// STORYBOARD_COMPILER_INFOPLIST_CONTENT_FILE
    public static func storyboardCompilerInfoplistContentFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .storyboardCompilerInfoplistContentFile, value: "\(value)")
    }

    /// STORYBOARD_COMPILER_INFOPLIST_CONTENT_FILE
    public static func storyboardCompilerInfoplistContentFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .storyboardCompilerInfoplistContentFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// STORYBOARD_COMPILER_INFOPLIST_CONTENT_FILE
    public static let storyboardCompilerInfoplistContentFile: BuildSettingsKey = "STORYBOARD_COMPILER_INFOPLIST_CONTENT_FILE"
}

// MARK: STRINGS_FILE_INPUT_ENCODING
extension BuildSetting {

    /// STRINGS_FILE_INPUT_ENCODING
    public static var stringsFileInputEncoding: BuildSetting { 
        BuildSetting(key: .stringsFileInputEncoding, value: "$(InputFileTextEncoding)")
    }

    /// STRINGS_FILE_INPUT_ENCODING
    public static func stringsFileInputEncoding(_ value: String) -> BuildSetting { 
        BuildSetting(key: .stringsFileInputEncoding, value: "\(value)")
    }

    /// STRINGS_FILE_INPUT_ENCODING
    public static func stringsFileInputEncoding(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stringsFileInputEncoding, inherit: key)
    }
}

extension BuildSettingsKey {

    /// STRINGS_FILE_INPUT_ENCODING
    public static let stringsFileInputEncoding: BuildSettingsKey = "STRINGS_FILE_INPUT_ENCODING"
}

// MARK: Strings File Output Encoding
extension BuildSetting {

    /// Strings File Output Encoding
    ///
    /// Specify the encoding to be used for Strings files (by default, the output encoding will be 16-bit Unicode). The value can be either an `NSStringEncoding`, such as one of the numeric values recognized by `NSString`, or it can be an IANA character set name as understood by `CFString`. The operation will fail if the file cannot be converted to the specified encoding.
    public static var stringsFileOutputEncoding: BuildSetting { 
        .stringsFileOutputEncoding(.utf16) 
    }

    /// Strings File Output Encoding
    ///
    /// Specify the encoding to be used for Strings files (by default, the output encoding will be 16-bit Unicode). The value can be either an `NSStringEncoding`, such as one of the numeric values recognized by `NSString`, or it can be an IANA character set name as understood by `CFString`. The operation will fail if the file cannot be converted to the specified encoding.
    public static func stringsFileOutputEncoding(_ value: StringsFileOutputEncoding) -> BuildSetting { 
        BuildSetting(key: .stringsFileOutputEncoding, value: "\(value)")
    }

    /// Strings File Output Encoding
    ///
    /// Specify the encoding to be used for Strings files (by default, the output encoding will be 16-bit Unicode). The value can be either an `NSStringEncoding`, such as one of the numeric values recognized by `NSString`, or it can be an IANA character set name as understood by `CFString`. The operation will fail if the file cannot be converted to the specified encoding.
    public static func stringsFileOutputEncoding(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stringsFileOutputEncoding, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strings File Output Encoding
    ///
    /// Specify the encoding to be used for Strings files (by default, the output encoding will be 16-bit Unicode). The value can be either an `NSStringEncoding`, such as one of the numeric values recognized by `NSString`, or it can be an IANA character set name as understood by `CFString`. The operation will fail if the file cannot be converted to the specified encoding.
    public static let stringsFileOutputEncoding: BuildSettingsKey = "STRINGS_FILE_OUTPUT_ENCODING"
}

public enum StringsFileOutputEncoding: String, Hashable, Codable, CustomStringConvertible {
    case utf16 = "UTF-16"
    case utf8 = "UTF-8"
    case binary = "binary"

    public var description: String {
        rawValue
    }
}

// MARK: Additional Strip Flags
extension BuildSetting {

    /// Additional Strip Flags
    ///
    /// Additional flags to be passed when stripping the linked product of the build.
    public static var additionalStripFlags: BuildSetting { 
        BuildSetting(key: .additionalStripFlags, value: "")
    }

    /// Additional Strip Flags
    ///
    /// Additional flags to be passed when stripping the linked product of the build.
    public static func additionalStripFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .additionalStripFlags, value: .array(value))
    }

    /// Additional Strip Flags
    ///
    /// Additional flags to be passed when stripping the linked product of the build.
    public static func additionalStripFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .additionalStripFlags, inherit: key)
    }

    /// Additional Strip Flags
    ///
    /// Additional flags to be passed when stripping the linked product of the build.
    public static func additionalStripFlags(_ value: String...) -> BuildSetting { 
        .additionalStripFlags(value)
    }
}

extension BuildSettingsKey {

    /// Additional Strip Flags
    ///
    /// Additional flags to be passed when stripping the linked product of the build.
    public static let additionalStripFlags: BuildSettingsKey = "STRIPFLAGS"
}

// MARK: STRIP_BITCODE_FROM_COPIED_FILES
extension BuildSetting {

    /// STRIP_BITCODE_FROM_COPIED_FILES
    public static var stripBitcodeFromCopiedFiles: BuildSetting { 
        BuildSetting(key: .stripBitcodeFromCopiedFiles, value: "NO")
    }

    /// STRIP_BITCODE_FROM_COPIED_FILES
    public static func stripBitcodeFromCopiedFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripBitcodeFromCopiedFiles, value: SettingValue(booleanLiteral: value))
    }

    /// STRIP_BITCODE_FROM_COPIED_FILES
    public static func stripBitcodeFromCopiedFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripBitcodeFromCopiedFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// STRIP_BITCODE_FROM_COPIED_FILES
    public static let stripBitcodeFromCopiedFiles: BuildSettingsKey = "STRIP_BITCODE_FROM_COPIED_FILES"
}

// MARK: Strip Linked Product
extension BuildSetting {

    /// Strip Linked Product
    ///
    /// If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing.
    public static var stripLinkedProduct: BuildSetting { 
        BuildSetting(key: .stripLinkedProduct, value: "")
    }

    /// Strip Linked Product
    ///
    /// If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing.
    public static func stripLinkedProduct(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripLinkedProduct, value: SettingValue(booleanLiteral: value))
    }

    /// Strip Linked Product
    ///
    /// If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing.
    public static func stripLinkedProduct(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripLinkedProduct, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Linked Product
    ///
    /// If enabled, the linked product of the build will be stripped of symbols when performing deployment postprocessing.
    public static let stripLinkedProduct: BuildSettingsKey = "STRIP_INSTALLED_PRODUCT"
}

// MARK: Remove Text Metadata From PNG Files
extension BuildSetting {

    /// Remove Text Metadata From PNG Files
    ///
    /// Metadata in the form of text chunks in PNG files will be removed to reduce their footprint on disk.
    public static var removeTextMetadataFromPngFiles: BuildSetting { 
        BuildSetting(key: .removeTextMetadataFromPngFiles, value: "YES")
    }

    /// Remove Text Metadata From PNG Files
    ///
    /// Metadata in the form of text chunks in PNG files will be removed to reduce their footprint on disk.
    public static func removeTextMetadataFromPngFiles(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .removeTextMetadataFromPngFiles, value: SettingValue(booleanLiteral: value))
    }

    /// Remove Text Metadata From PNG Files
    ///
    /// Metadata in the form of text chunks in PNG files will be removed to reduce their footprint on disk.
    public static func removeTextMetadataFromPngFiles(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .removeTextMetadataFromPngFiles, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Remove Text Metadata From PNG Files
    ///
    /// Metadata in the form of text chunks in PNG files will be removed to reduce their footprint on disk.
    public static let removeTextMetadataFromPngFiles: BuildSettingsKey = "STRIP_PNG_TEXT"
}

// MARK: Strip Style
extension BuildSetting {

    /// Strip Style
    ///
    /// The level of symbol stripping to be performed on the linked product of the build. The default value is defined by the target's product type.

- _All Symbols:_ Completely strips the binary, removing the symbol table and relocation information. `all, -s`

- _Non-Global Symbols:_ Strips non-global symbols, but saves external symbols. `non-global, -x`

- _Debugging Symbols:_ Strips debugging symbols, but saves local and global symbols. `debugging, -S`
    public static var stripStyle: BuildSetting { 
        .stripStyle(.all) 
    }

    /// Strip Style
    ///
    /// The level of symbol stripping to be performed on the linked product of the build. The default value is defined by the target's product type.

- _All Symbols:_ Completely strips the binary, removing the symbol table and relocation information. `all, -s`

- _Non-Global Symbols:_ Strips non-global symbols, but saves external symbols. `non-global, -x`

- _Debugging Symbols:_ Strips debugging symbols, but saves local and global symbols. `debugging, -S`
    public static func stripStyle(_ value: StripStyle) -> BuildSetting { 
        BuildSetting(key: .stripStyle, value: "\(value)")
    }

    /// Strip Style
    ///
    /// The level of symbol stripping to be performed on the linked product of the build. The default value is defined by the target's product type.

- _All Symbols:_ Completely strips the binary, removing the symbol table and relocation information. `all, -s`

- _Non-Global Symbols:_ Strips non-global symbols, but saves external symbols. `non-global, -x`

- _Debugging Symbols:_ Strips debugging symbols, but saves local and global symbols. `debugging, -S`
    public static func stripStyle(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripStyle, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Style
    ///
    /// The level of symbol stripping to be performed on the linked product of the build. The default value is defined by the target's product type.

- _All Symbols:_ Completely strips the binary, removing the symbol table and relocation information. `all, -s`

- _Non-Global Symbols:_ Strips non-global symbols, but saves external symbols. `non-global, -x`

- _Debugging Symbols:_ Strips debugging symbols, but saves local and global symbols. `debugging, -S`
    public static let stripStyle: BuildSettingsKey = "STRIP_STYLE"
}

public enum StripStyle: String, Hashable, Codable, CustomStringConvertible {
    case all = "all"
    case nonGlobal = "non-global"
    case debugging = "debugging"

    public var description: String {
        rawValue
    }
}

// MARK: Strip Swift Symbols
extension BuildSetting {

    /// Strip Swift Symbols
    ///
    /// Adjust the level of symbol stripping specified by the STRIP\_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed.
    public static var stripSwiftSymbols: BuildSetting { 
        BuildSetting(key: .stripSwiftSymbols, value: "YES")
    }

    /// Strip Swift Symbols
    ///
    /// Adjust the level of symbol stripping specified by the STRIP\_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed.
    public static func stripSwiftSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .stripSwiftSymbols, value: SettingValue(booleanLiteral: value))
    }

    /// Strip Swift Symbols
    ///
    /// Adjust the level of symbol stripping specified by the STRIP\_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed.
    public static func stripSwiftSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .stripSwiftSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Strip Swift Symbols
    ///
    /// Adjust the level of symbol stripping specified by the STRIP\_STYLE setting so that when the linked product of the build is stripped, all Swift symbols will be removed.
    public static let stripSwiftSymbols: BuildSettingsKey = "STRIP_SWIFT_SYMBOLS"
}

// MARK: Supported Platforms
extension BuildSetting {

    /// Supported Platforms
    ///
    /// The list of supported platforms from which a base SDK can be used. This setting is used if the product can be built for multiple platforms using different SDKs.
    public static var supportedPlatforms: BuildSetting { 
        BuildSetting(key: .supportedPlatforms, value: "")
    }

    /// Supported Platforms
    ///
    /// The list of supported platforms from which a base SDK can be used. This setting is used if the product can be built for multiple platforms using different SDKs.
    public static func supportedPlatforms(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .supportedPlatforms, value: .array(value))
    }

    /// Supported Platforms
    ///
    /// The list of supported platforms from which a base SDK can be used. This setting is used if the product can be built for multiple platforms using different SDKs.
    public static func supportedPlatforms(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .supportedPlatforms, inherit: key)
    }

    /// Supported Platforms
    ///
    /// The list of supported platforms from which a base SDK can be used. This setting is used if the product can be built for multiple platforms using different SDKs.
    public static func supportedPlatforms(_ value: String...) -> BuildSetting { 
        .supportedPlatforms(value)
    }
}

extension BuildSettingsKey {

    /// Supported Platforms
    ///
    /// The list of supported platforms from which a base SDK can be used. This setting is used if the product can be built for multiple platforms using different SDKs.
    public static let supportedPlatforms: BuildSettingsKey = "SUPPORTED_PLATFORMS"
}

// MARK: Supports Mac Catalyst
extension BuildSetting {

    /// Supports Mac Catalyst
    ///
    /// Support building this target for Mac Catalyst.
    public static var supportsMacCatalyst: BuildSetting { 
        BuildSetting(key: .supportsMacCatalyst, value: "YES")
    }

    /// Supports Mac Catalyst
    ///
    /// Support building this target for Mac Catalyst.
    public static func supportsMacCatalyst(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .supportsMacCatalyst, value: SettingValue(booleanLiteral: value))
    }

    /// Supports Mac Catalyst
    ///
    /// Support building this target for Mac Catalyst.
    public static func supportsMacCatalyst(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .supportsMacCatalyst, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Supports Mac Catalyst
    ///
    /// Support building this target for Mac Catalyst.
    public static let supportsMacCatalyst: BuildSettingsKey = "SUPPORTS_MACCATALYST"
}

// MARK: Show Mac (Designed for iPhone & iPad) Destination
extension BuildSetting {

    /// Show Mac (Designed for iPhone & iPad) Destination
    ///
    /// Show the Mac (Designed for iPhone) and Mac (Designed for iPad) destinations.
    public static var showMacDesignedForIphoneIpadDestination: BuildSetting { 
        BuildSetting(key: .showMacDesignedForIphoneIpadDestination, value: "YES")
    }

    /// Show Mac (Designed for iPhone & iPad) Destination
    ///
    /// Show the Mac (Designed for iPhone) and Mac (Designed for iPad) destinations.
    public static func showMacDesignedForIphoneIpadDestination(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .showMacDesignedForIphoneIpadDestination, value: SettingValue(booleanLiteral: value))
    }

    /// Show Mac (Designed for iPhone & iPad) Destination
    ///
    /// Show the Mac (Designed for iPhone) and Mac (Designed for iPad) destinations.
    public static func showMacDesignedForIphoneIpadDestination(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .showMacDesignedForIphoneIpadDestination, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Show Mac (Designed for iPhone & iPad) Destination
    ///
    /// Show the Mac (Designed for iPhone) and Mac (Designed for iPad) destinations.
    public static let showMacDesignedForIphoneIpadDestination: BuildSettingsKey = "SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD"
}

// MARK: Supports Text-Based InstallAPI
extension BuildSetting {

    /// Supports Text-Based InstallAPI
    ///
    /// Enable to indicate that the target supports `Text-Based InstallAPI`, which will enable its generation during `install` builds.
    public static var supportsTextBasedInstallapi: BuildSetting { 
        BuildSetting(key: .supportsTextBasedInstallapi, value: "NO")
    }

    /// Supports Text-Based InstallAPI
    ///
    /// Enable to indicate that the target supports `Text-Based InstallAPI`, which will enable its generation during `install` builds.
    public static func supportsTextBasedInstallapi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .supportsTextBasedInstallapi, value: SettingValue(booleanLiteral: value))
    }

    /// Supports Text-Based InstallAPI
    ///
    /// Enable to indicate that the target supports `Text-Based InstallAPI`, which will enable its generation during `install` builds.
    public static func supportsTextBasedInstallapi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .supportsTextBasedInstallapi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Supports Text-Based InstallAPI
    ///
    /// Enable to indicate that the target supports `Text-Based InstallAPI`, which will enable its generation during `install` builds.
    public static let supportsTextBasedInstallapi: BuildSettingsKey = "SUPPORTS_TEXT_BASED_API"
}

// MARK: Active Compilation Conditions
extension BuildSetting {

    /// Active Compilation Conditions
    ///
    /// A list of compilation conditions to enable for conditional compilation expressions.
    public static func activeCompilationConditions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .activeCompilationConditions, value: .array(value))
    }

    /// Active Compilation Conditions
    ///
    /// A list of compilation conditions to enable for conditional compilation expressions.
    public static func activeCompilationConditions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .activeCompilationConditions, inherit: key)
    }

    /// Active Compilation Conditions
    ///
    /// A list of compilation conditions to enable for conditional compilation expressions.
    public static func activeCompilationConditions(_ value: String...) -> BuildSetting { 
        .activeCompilationConditions(value)
    }
}

extension BuildSettingsKey {

    /// Active Compilation Conditions
    ///
    /// A list of compilation conditions to enable for conditional compilation expressions.
    public static let activeCompilationConditions: BuildSettingsKey = "SWIFT_ACTIVE_COMPILATION_CONDITIONS"
}

// MARK: SWIFT_ADDRESS_SANITIZER
extension BuildSetting {

    /// SWIFT_ADDRESS_SANITIZER
    public static var swiftAddressSanitizer: BuildSetting { 
        BuildSetting(key: .swiftAddressSanitizer, value: "$(ENABLE_ADDRESS_SANITIZER)")
    }

    /// SWIFT_ADDRESS_SANITIZER
    public static func swiftAddressSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftAddressSanitizer, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_ADDRESS_SANITIZER
    public static func swiftAddressSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftAddressSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_ADDRESS_SANITIZER
    public static let swiftAddressSanitizer: BuildSettingsKey = "SWIFT_ADDRESS_SANITIZER"
}

// MARK: SWIFT_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
extension BuildSetting {

    /// SWIFT_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
    public static var swiftAddressSanitizerAllowErrorRecovery: BuildSetting { 
        BuildSetting(key: .swiftAddressSanitizerAllowErrorRecovery, value: "$(ENABLE_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY)")
    }

    /// SWIFT_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
    public static func swiftAddressSanitizerAllowErrorRecovery(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftAddressSanitizerAllowErrorRecovery, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
    public static func swiftAddressSanitizerAllowErrorRecovery(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftAddressSanitizerAllowErrorRecovery, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY
    public static let swiftAddressSanitizerAllowErrorRecovery: BuildSettingsKey = "SWIFT_ADDRESS_SANITIZER_ALLOW_ERROR_RECOVERY"
}

// MARK: SWIFT_BITCODE_GENERATION_MODE
extension BuildSetting {

    /// SWIFT_BITCODE_GENERATION_MODE
    public static var swiftBitcodeGenerationMode: BuildSetting { 
        .swiftBitcodeGenerationMode(inherit: .bitcodeGenerationMode) 
    }

    /// SWIFT_BITCODE_GENERATION_MODE
    public static func swiftBitcodeGenerationMode(_ value: SwiftBitcodeGenerationMode) -> BuildSetting { 
        BuildSetting(key: .swiftBitcodeGenerationMode, value: "\(value)")
    }

    /// SWIFT_BITCODE_GENERATION_MODE
    public static func swiftBitcodeGenerationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftBitcodeGenerationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_BITCODE_GENERATION_MODE
    public static let swiftBitcodeGenerationMode: BuildSettingsKey = "SWIFT_BITCODE_GENERATION_MODE"
}

public enum SwiftBitcodeGenerationMode: String, Hashable, Codable, CustomStringConvertible {
    case marker = "marker"
    case bitcode = "bitcode"

    public var description: String {
        rawValue
    }
}

// MARK: Compilation Mode
extension BuildSetting {

    /// Compilation Mode
    ///
    /// This setting controls the way the Swift files in a module are rebuilt.

- _Incremental_: Only rebuild the Swift source files in the module that are out of date, running multiple compiler processes as needed.

- _Whole Module_: Always rebuild all Swift source files in the module, in a single compiler process.
    public static var compilationMode: BuildSetting { 
        .compilationMode(.singlefile) 
    }

    /// Compilation Mode
    ///
    /// This setting controls the way the Swift files in a module are rebuilt.

- _Incremental_: Only rebuild the Swift source files in the module that are out of date, running multiple compiler processes as needed.

- _Whole Module_: Always rebuild all Swift source files in the module, in a single compiler process.
    public static func compilationMode(_ value: CompilationMode) -> BuildSetting { 
        BuildSetting(key: .compilationMode, value: "\(value)")
    }

    /// Compilation Mode
    ///
    /// This setting controls the way the Swift files in a module are rebuilt.

- _Incremental_: Only rebuild the Swift source files in the module that are out of date, running multiple compiler processes as needed.

- _Whole Module_: Always rebuild all Swift source files in the module, in a single compiler process.
    public static func compilationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .compilationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Compilation Mode
    ///
    /// This setting controls the way the Swift files in a module are rebuilt.

- _Incremental_: Only rebuild the Swift source files in the module that are out of date, running multiple compiler processes as needed.

- _Whole Module_: Always rebuild all Swift source files in the module, in a single compiler process.
    public static let compilationMode: BuildSettingsKey = "SWIFT_COMPILATION_MODE"
}

public enum CompilationMode: String, Hashable, Codable, CustomStringConvertible {
    case singlefile = "singlefile"
    case wholemodule = "wholemodule"

    public var description: String {
        rawValue
    }
}

// MARK: SWIFT_CROSS_MODULE_OPTIMIZATION
extension BuildSetting {

    /// SWIFT_CROSS_MODULE_OPTIMIZATION
    public static var swiftCrossModuleOptimization: BuildSetting { 
        BuildSetting(key: .swiftCrossModuleOptimization, value: "NO")
    }

    /// SWIFT_CROSS_MODULE_OPTIMIZATION
    public static func swiftCrossModuleOptimization(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftCrossModuleOptimization, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_CROSS_MODULE_OPTIMIZATION
    public static func swiftCrossModuleOptimization(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftCrossModuleOptimization, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_CROSS_MODULE_OPTIMIZATION
    public static let swiftCrossModuleOptimization: BuildSettingsKey = "SWIFT_CROSS_MODULE_OPTIMIZATION"
}

// MARK: SWIFT_DEPLOYMENT_TARGET
extension BuildSetting {

    /// SWIFT_DEPLOYMENT_TARGET
    public static var swiftDeploymentTarget: BuildSetting { 
        BuildSetting(key: .swiftDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// SWIFT_DEPLOYMENT_TARGET
    public static func swiftDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftDeploymentTarget, value: "\(value)")
    }

    /// SWIFT_DEPLOYMENT_TARGET
    public static func swiftDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_DEPLOYMENT_TARGET
    public static let swiftDeploymentTarget: BuildSettingsKey = "SWIFT_DEPLOYMENT_TARGET"
}

// MARK: Disable Safety Checks
extension BuildSetting {

    /// Disable Safety Checks
    ///
    /// Disable runtime safety checks when optimizing.
    public static var disableSafetyChecks: BuildSetting { 
        BuildSetting(key: .disableSafetyChecks, value: "NO")
    }

    /// Disable Safety Checks
    ///
    /// Disable runtime safety checks when optimizing.
    public static func disableSafetyChecks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .disableSafetyChecks, value: SettingValue(booleanLiteral: value))
    }

    /// Disable Safety Checks
    ///
    /// Disable runtime safety checks when optimizing.
    public static func disableSafetyChecks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .disableSafetyChecks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Disable Safety Checks
    ///
    /// Disable runtime safety checks when optimizing.
    public static let disableSafetyChecks: BuildSettingsKey = "SWIFT_DISABLE_SAFETY_CHECKS"
}

// MARK: SWIFT_EMIT_MODULE_INTERFACE
extension BuildSetting {

    /// SWIFT_EMIT_MODULE_INTERFACE
    public static var swiftEmitModuleInterface: BuildSetting { 
        .swiftEmitModuleInterface(inherit: .buildLibrariesForDistribution) 
    }

    /// SWIFT_EMIT_MODULE_INTERFACE
    public static func swiftEmitModuleInterface(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftEmitModuleInterface, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_EMIT_MODULE_INTERFACE
    public static func swiftEmitModuleInterface(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftEmitModuleInterface, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_EMIT_MODULE_INTERFACE
    public static let swiftEmitModuleInterface: BuildSettingsKey = "SWIFT_EMIT_MODULE_INTERFACE"
}

// MARK: SWIFT_ENABLE_APP_EXTENSION
extension BuildSetting {

    /// SWIFT_ENABLE_APP_EXTENSION
    public static var swiftEnableAppExtension: BuildSetting { 
        .swiftEnableAppExtension(inherit: .requireOnlyAppExtensionSafeApi) 
    }

    /// SWIFT_ENABLE_APP_EXTENSION
    public static func swiftEnableAppExtension(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftEnableAppExtension, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_ENABLE_APP_EXTENSION
    public static func swiftEnableAppExtension(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftEnableAppExtension, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_ENABLE_APP_EXTENSION
    public static let swiftEnableAppExtension: BuildSettingsKey = "SWIFT_ENABLE_APP_EXTENSION"
}

// MARK: SWIFT_ENABLE_BATCH_MODE
extension BuildSetting {

    /// SWIFT_ENABLE_BATCH_MODE
    public static var swiftEnableBatchMode: BuildSetting { 
        BuildSetting(key: .swiftEnableBatchMode, value: "YES")
    }

    /// SWIFT_ENABLE_BATCH_MODE
    public static func swiftEnableBatchMode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftEnableBatchMode, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_ENABLE_BATCH_MODE
    public static func swiftEnableBatchMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftEnableBatchMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_ENABLE_BATCH_MODE
    public static let swiftEnableBatchMode: BuildSettingsKey = "SWIFT_ENABLE_BATCH_MODE"
}

// MARK: SWIFT_ENABLE_INCREMENTAL_COMPILATION
extension BuildSetting {

    /// SWIFT_ENABLE_INCREMENTAL_COMPILATION
    public static var swiftEnableIncrementalCompilation: BuildSetting { 
        BuildSetting(key: .swiftEnableIncrementalCompilation, value: "YES")
    }

    /// SWIFT_ENABLE_INCREMENTAL_COMPILATION
    public static func swiftEnableIncrementalCompilation(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftEnableIncrementalCompilation, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_ENABLE_INCREMENTAL_COMPILATION
    public static func swiftEnableIncrementalCompilation(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftEnableIncrementalCompilation, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_ENABLE_INCREMENTAL_COMPILATION
    public static let swiftEnableIncrementalCompilation: BuildSettingsKey = "SWIFT_ENABLE_INCREMENTAL_COMPILATION"
}

// MARK: SWIFT_ENABLE_LIBRARY_EVOLUTION
extension BuildSetting {

    /// SWIFT_ENABLE_LIBRARY_EVOLUTION
    public static var swiftEnableLibraryEvolution: BuildSetting { 
        .swiftEnableLibraryEvolution(inherit: .buildLibrariesForDistribution) 
    }

    /// SWIFT_ENABLE_LIBRARY_EVOLUTION
    public static func swiftEnableLibraryEvolution(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftEnableLibraryEvolution, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_ENABLE_LIBRARY_EVOLUTION
    public static func swiftEnableLibraryEvolution(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftEnableLibraryEvolution, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_ENABLE_LIBRARY_EVOLUTION
    public static let swiftEnableLibraryEvolution: BuildSettingsKey = "SWIFT_ENABLE_LIBRARY_EVOLUTION"
}

// MARK: SWIFT_ENABLE_TESTABILITY
extension BuildSetting {

    /// SWIFT_ENABLE_TESTABILITY
    public static var swiftEnableTestability: BuildSetting { 
        .swiftEnableTestability(inherit: .enableTestability) 
    }

    /// SWIFT_ENABLE_TESTABILITY
    public static func swiftEnableTestability(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftEnableTestability, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_ENABLE_TESTABILITY
    public static func swiftEnableTestability(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftEnableTestability, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_ENABLE_TESTABILITY
    public static let swiftEnableTestability: BuildSettingsKey = "SWIFT_ENABLE_TESTABILITY"
}

// MARK: Exclusive Access to Memory
extension BuildSetting {

    /// Exclusive Access to Memory
    ///
    /// Enforce exclusive access at run-time.
    public static var exclusiveAccessToMemory: BuildSetting { 
        .exclusiveAccessToMemory(.on) 
    }

    /// Exclusive Access to Memory
    ///
    /// Enforce exclusive access at run-time.
    public static func exclusiveAccessToMemory(_ value: ExclusiveAccessToMemory) -> BuildSetting { 
        BuildSetting(key: .exclusiveAccessToMemory, value: "\(value)")
    }

    /// Exclusive Access to Memory
    ///
    /// Enforce exclusive access at run-time.
    public static func exclusiveAccessToMemory(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .exclusiveAccessToMemory, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Exclusive Access to Memory
    ///
    /// Enforce exclusive access at run-time.
    public static let exclusiveAccessToMemory: BuildSettingsKey = "SWIFT_ENFORCE_EXCLUSIVE_ACCESS"
}

public enum ExclusiveAccessToMemory: String, Hashable, Codable, CustomStringConvertible {
    case on = "on"
    case debugOnly = "debug-only"
    case off = "off"

    public var description: String {
        rawValue
    }
}

// MARK: SWIFT_EXEC
extension BuildSetting {

    /// SWIFT_EXEC
    public static var swiftExec: BuildSetting { 
        BuildSetting(key: .swiftExec, value: "swiftc")
    }

    /// SWIFT_EXEC
    public static func swiftExec(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftExec, value: "\(value)")
    }

    /// SWIFT_EXEC
    public static func swiftExec(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftExec, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_EXEC
    public static let swiftExec: BuildSettingsKey = "SWIFT_EXEC"
}

// MARK: Import Paths
extension BuildSetting {

    /// Import Paths
    ///
    /// A list of paths to be searched by the Swift compiler for additional Swift modules.
    public static func importPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .importPaths, value: .array(value))
    }

    /// Import Paths
    ///
    /// A list of paths to be searched by the Swift compiler for additional Swift modules.
    public static func importPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .importPaths, inherit: key)
    }

    /// Import Paths
    ///
    /// A list of paths to be searched by the Swift compiler for additional Swift modules.
    public static func importPaths(_ value: String...) -> BuildSetting { 
        .importPaths(value)
    }
}

extension BuildSettingsKey {

    /// Import Paths
    ///
    /// A list of paths to be searched by the Swift compiler for additional Swift modules.
    public static let importPaths: BuildSettingsKey = "SWIFT_INCLUDE_PATHS"
}

// MARK: SWIFT_INDEX_STORE_ENABLE
extension BuildSetting {

    /// SWIFT_INDEX_STORE_ENABLE
    public static var swiftIndexStoreEnable: BuildSetting { 
        BuildSetting(key: .swiftIndexStoreEnable, value: "$(INDEX_ENABLE_DATA_STORE)")
    }

    /// SWIFT_INDEX_STORE_ENABLE
    public static func swiftIndexStoreEnable(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftIndexStoreEnable, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_INDEX_STORE_ENABLE
    public static func swiftIndexStoreEnable(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftIndexStoreEnable, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_INDEX_STORE_ENABLE
    public static let swiftIndexStoreEnable: BuildSettingsKey = "SWIFT_INDEX_STORE_ENABLE"
}

// MARK: SWIFT_INDEX_STORE_PATH
extension BuildSetting {

    /// SWIFT_INDEX_STORE_PATH
    public static var swiftIndexStorePath: BuildSetting { 
        BuildSetting(key: .swiftIndexStorePath, value: "$(INDEX_DATA_STORE_DIR)")
    }

    /// SWIFT_INDEX_STORE_PATH
    public static func swiftIndexStorePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftIndexStorePath, value: "\(value)")
    }

    /// SWIFT_INDEX_STORE_PATH
    public static func swiftIndexStorePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftIndexStorePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_INDEX_STORE_PATH
    public static let swiftIndexStorePath: BuildSettingsKey = "SWIFT_INDEX_STORE_PATH"
}

// MARK: Install Objective-C Compatibility Header
extension BuildSetting {

    /// Install Objective-C Compatibility Header
    ///
    /// For frameworks, install the Objective-C compatibility header describing bridged Swift classes into the [Public Headers Folder Path (PUBLIC\_HEADERS\_FOLDER\_PATH)](itcaec37c2a6.html#devdbb795497) so they may be accessed from Objective-C code using the framework. Defaults to `YES`.
    public static var installObjectiveCCompatibilityHeader: BuildSetting { 
        BuildSetting(key: .installObjectiveCCompatibilityHeader, value: "YES")
    }

    /// Install Objective-C Compatibility Header
    ///
    /// For frameworks, install the Objective-C compatibility header describing bridged Swift classes into the [Public Headers Folder Path (PUBLIC\_HEADERS\_FOLDER\_PATH)](itcaec37c2a6.html#devdbb795497) so they may be accessed from Objective-C code using the framework. Defaults to `YES`.
    public static func installObjectiveCCompatibilityHeader(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .installObjectiveCCompatibilityHeader, value: SettingValue(booleanLiteral: value))
    }

    /// Install Objective-C Compatibility Header
    ///
    /// For frameworks, install the Objective-C compatibility header describing bridged Swift classes into the [Public Headers Folder Path (PUBLIC\_HEADERS\_FOLDER\_PATH)](itcaec37c2a6.html#devdbb795497) so they may be accessed from Objective-C code using the framework. Defaults to `YES`.
    public static func installObjectiveCCompatibilityHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .installObjectiveCCompatibilityHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Install Objective-C Compatibility Header
    ///
    /// For frameworks, install the Objective-C compatibility header describing bridged Swift classes into the [Public Headers Folder Path (PUBLIC\_HEADERS\_FOLDER\_PATH)](itcaec37c2a6.html#devdbb795497) so they may be accessed from Objective-C code using the framework. Defaults to `YES`.
    public static let installObjectiveCCompatibilityHeader: BuildSettingsKey = "SWIFT_INSTALL_OBJC_HEADER"
}

// MARK: SWIFT_LIBRARIES_ONLY
extension BuildSetting {

    /// SWIFT_LIBRARIES_ONLY
    public static var swiftLibrariesOnly: BuildSetting { 
        BuildSetting(key: .swiftLibrariesOnly, value: "NO")
    }

    /// SWIFT_LIBRARIES_ONLY
    public static func swiftLibrariesOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftLibrariesOnly, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_LIBRARIES_ONLY
    public static func swiftLibrariesOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftLibrariesOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_LIBRARIES_ONLY
    public static let swiftLibrariesOnly: BuildSettingsKey = "SWIFT_LIBRARIES_ONLY"
}

// MARK: SWIFT_LIBRARY_PATH
extension BuildSetting {

    /// SWIFT_LIBRARY_PATH
    public static var swiftLibraryPath: BuildSetting { 
        BuildSetting(key: .swiftLibraryPath, value: "")
    }

    /// SWIFT_LIBRARY_PATH
    public static func swiftLibraryPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftLibraryPath, value: "\(value)")
    }

    /// SWIFT_LIBRARY_PATH
    public static func swiftLibraryPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftLibraryPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_LIBRARY_PATH
    public static let swiftLibraryPath: BuildSettingsKey = "SWIFT_LIBRARY_PATH"
}

// MARK: SWIFT_LINK_OBJC_RUNTIME
extension BuildSetting {

    /// SWIFT_LINK_OBJC_RUNTIME
    public static var swiftLinkObjcRuntime: BuildSetting { 
        BuildSetting(key: .swiftLinkObjcRuntime, value: "YES")
    }

    /// SWIFT_LINK_OBJC_RUNTIME
    public static func swiftLinkObjcRuntime(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftLinkObjcRuntime, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_LINK_OBJC_RUNTIME
    public static func swiftLinkObjcRuntime(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftLinkObjcRuntime, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_LINK_OBJC_RUNTIME
    public static let swiftLinkObjcRuntime: BuildSettingsKey = "SWIFT_LINK_OBJC_RUNTIME"
}

// MARK: SWIFT_MIGRATE_CODE
extension BuildSetting {

    /// SWIFT_MIGRATE_CODE
    public static func swiftMigrateCode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftMigrateCode, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_MIGRATE_CODE
    public static func swiftMigrateCode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftMigrateCode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_MIGRATE_CODE
    public static let swiftMigrateCode: BuildSettingsKey = "SWIFT_MIGRATE_CODE"
}

// MARK: SWIFT_MODULE_NAME
extension BuildSetting {

    /// SWIFT_MODULE_NAME
    public static var swiftModuleName: BuildSetting { 
        .swiftModuleName(inherit: .productModuleName) 
    }

    /// SWIFT_MODULE_NAME
    public static func swiftModuleName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftModuleName, value: "\(value)")
    }

    /// SWIFT_MODULE_NAME
    public static func swiftModuleName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftModuleName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_MODULE_NAME
    public static let swiftModuleName: BuildSettingsKey = "SWIFT_MODULE_NAME"
}

// MARK: Objective-C Bridging Header
extension BuildSetting {

    /// Objective-C Bridging Header
    ///
    /// Path to the header defining the Objective-C interfaces to be exposed in Swift.
    public static var objectiveCBridgingHeader: BuildSetting { 
        BuildSetting(key: .objectiveCBridgingHeader, value: "")
    }

    /// Objective-C Bridging Header
    ///
    /// Path to the header defining the Objective-C interfaces to be exposed in Swift.
    public static func objectiveCBridgingHeader(_ value: String) -> BuildSetting { 
        BuildSetting(key: .objectiveCBridgingHeader, value: "\(value)")
    }

    /// Objective-C Bridging Header
    ///
    /// Path to the header defining the Objective-C interfaces to be exposed in Swift.
    public static func objectiveCBridgingHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objectiveCBridgingHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Objective-C Bridging Header
    ///
    /// Path to the header defining the Objective-C interfaces to be exposed in Swift.
    public static let objectiveCBridgingHeader: BuildSettingsKey = "SWIFT_OBJC_BRIDGING_HEADER"
}

// MARK: Objective-C Generated Interface Header Name
extension BuildSetting {

    /// Objective-C Generated Interface Header Name
    ///
    /// Name to use for the header that is generated by the Swift compiler for use in `#import` statements in Objective-C.
    public static var objectiveCGeneratedInterfaceHeaderName: BuildSetting { 
        BuildSetting(key: .objectiveCGeneratedInterfaceHeaderName, value: "$(SWIFT_MODULE_NAME)-Swift.h")
    }

    /// Objective-C Generated Interface Header Name
    ///
    /// Name to use for the header that is generated by the Swift compiler for use in `#import` statements in Objective-C.
    public static func objectiveCGeneratedInterfaceHeaderName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .objectiveCGeneratedInterfaceHeaderName, value: "\(value)")
    }

    /// Objective-C Generated Interface Header Name
    ///
    /// Name to use for the header that is generated by the Swift compiler for use in `#import` statements in Objective-C.
    public static func objectiveCGeneratedInterfaceHeaderName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .objectiveCGeneratedInterfaceHeaderName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Objective-C Generated Interface Header Name
    ///
    /// Name to use for the header that is generated by the Swift compiler for use in `#import` statements in Objective-C.
    public static let objectiveCGeneratedInterfaceHeaderName: BuildSettingsKey = "SWIFT_OBJC_INTERFACE_HEADER_NAME"
}

// MARK: Optimization Level
extension BuildSetting {

    /// Optimization Level
    ///
    /// - _None:_ Compile without any optimization. `-Onone`

- _Optimize for Speed:_&nbsp;`-O`

- _Optimize for Size:_&nbsp;`-Osize`

- _Whole Module Optimization:_&nbsp;`-O -whole-module-optimization`
    public static var optimizationLevel: BuildSetting { 
        .optimizationLevel(.O) 
    }

    /// Optimization Level
    ///
    /// - _None:_ Compile without any optimization. `-Onone`

- _Optimize for Speed:_&nbsp;`-O`

- _Optimize for Size:_&nbsp;`-Osize`

- _Whole Module Optimization:_&nbsp;`-O -whole-module-optimization`
    public static func optimizationLevel(_ value: OptimizationLevel) -> BuildSetting { 
        BuildSetting(key: .optimizationLevel, value: "\(value)")
    }

    /// Optimization Level
    ///
    /// - _None:_ Compile without any optimization. `-Onone`

- _Optimize for Speed:_&nbsp;`-O`

- _Optimize for Size:_&nbsp;`-Osize`

- _Whole Module Optimization:_&nbsp;`-O -whole-module-optimization`
    public static func optimizationLevel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .optimizationLevel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Optimization Level
    ///
    /// - _None:_ Compile without any optimization. `-Onone`

- _Optimize for Speed:_&nbsp;`-O`

- _Optimize for Size:_&nbsp;`-Osize`

- _Whole Module Optimization:_&nbsp;`-O -whole-module-optimization`
    public static let optimizationLevel: BuildSettingsKey = "SWIFT_OPTIMIZATION_LEVEL"
}

// MARK: SWIFT_PLATFORM_TARGET_PREFIX
extension BuildSetting {

    /// SWIFT_PLATFORM_TARGET_PREFIX
    public static var swiftPlatformTargetPrefix: BuildSetting { 
        BuildSetting(key: .swiftPlatformTargetPrefix, value: "")
    }

    /// SWIFT_PLATFORM_TARGET_PREFIX
    public static func swiftPlatformTargetPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftPlatformTargetPrefix, value: "\(value)")
    }

    /// SWIFT_PLATFORM_TARGET_PREFIX
    public static func swiftPlatformTargetPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftPlatformTargetPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_PLATFORM_TARGET_PREFIX
    public static let swiftPlatformTargetPrefix: BuildSettingsKey = "SWIFT_PLATFORM_TARGET_PREFIX"
}

// MARK: Precompile Bridging Header
extension BuildSetting {

    /// Precompile Bridging Header
    ///
    /// Generate a precompiled header for the Objective-C bridging header, if used, in order to reduce overall build times.
    public static var precompileBridgingHeader: BuildSetting { 
        BuildSetting(key: .precompileBridgingHeader, value: "YES")
    }

    /// Precompile Bridging Header
    ///
    /// Generate a precompiled header for the Objective-C bridging header, if used, in order to reduce overall build times.
    public static func precompileBridgingHeader(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .precompileBridgingHeader, value: SettingValue(booleanLiteral: value))
    }

    /// Precompile Bridging Header
    ///
    /// Generate a precompiled header for the Objective-C bridging header, if used, in order to reduce overall build times.
    public static func precompileBridgingHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .precompileBridgingHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Precompile Bridging Header
    ///
    /// Generate a precompiled header for the Objective-C bridging header, if used, in order to reduce overall build times.
    public static let precompileBridgingHeader: BuildSettingsKey = "SWIFT_PRECOMPILE_BRIDGING_HEADER"
}

// MARK: Reflection Metadata Level
extension BuildSetting {

    /// Reflection Metadata Level
    ///
    /// This setting controls the level of reflection metadata the Swift compiler emits.

- _All:_ Type information about stored properties of Swift structs and classes, Swift enum cases, and their names, are emitted into the binary for reflection and analysis in the Memory Graph Debugger.

- _Without Names:_ Only type information about stored properties and cases are emitted into the binary, with their names omitted. `-disable-reflection-names`

- _None:_ No reflection metadata is emitted into the binary. Accuracy of detecting memory issues involving Swift types in the Memory Graph Debugger will be degraded and reflection in Swift code may not be able to discover children of types, such as properties and enum cases. `-disable-reflection-metadata`
    public static var reflectionMetadataLevel: BuildSetting { 
        .reflectionMetadataLevel(.all) 
    }

    /// Reflection Metadata Level
    ///
    /// This setting controls the level of reflection metadata the Swift compiler emits.

- _All:_ Type information about stored properties of Swift structs and classes, Swift enum cases, and their names, are emitted into the binary for reflection and analysis in the Memory Graph Debugger.

- _Without Names:_ Only type information about stored properties and cases are emitted into the binary, with their names omitted. `-disable-reflection-names`

- _None:_ No reflection metadata is emitted into the binary. Accuracy of detecting memory issues involving Swift types in the Memory Graph Debugger will be degraded and reflection in Swift code may not be able to discover children of types, such as properties and enum cases. `-disable-reflection-metadata`
    public static func reflectionMetadataLevel(_ value: ReflectionMetadataLevel) -> BuildSetting { 
        BuildSetting(key: .reflectionMetadataLevel, value: "\(value)")
    }

    /// Reflection Metadata Level
    ///
    /// This setting controls the level of reflection metadata the Swift compiler emits.

- _All:_ Type information about stored properties of Swift structs and classes, Swift enum cases, and their names, are emitted into the binary for reflection and analysis in the Memory Graph Debugger.

- _Without Names:_ Only type information about stored properties and cases are emitted into the binary, with their names omitted. `-disable-reflection-names`

- _None:_ No reflection metadata is emitted into the binary. Accuracy of detecting memory issues involving Swift types in the Memory Graph Debugger will be degraded and reflection in Swift code may not be able to discover children of types, such as properties and enum cases. `-disable-reflection-metadata`
    public static func reflectionMetadataLevel(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .reflectionMetadataLevel, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Reflection Metadata Level
    ///
    /// This setting controls the level of reflection metadata the Swift compiler emits.

- _All:_ Type information about stored properties of Swift structs and classes, Swift enum cases, and their names, are emitted into the binary for reflection and analysis in the Memory Graph Debugger.

- _Without Names:_ Only type information about stored properties and cases are emitted into the binary, with their names omitted. `-disable-reflection-names`

- _None:_ No reflection metadata is emitted into the binary. Accuracy of detecting memory issues involving Swift types in the Memory Graph Debugger will be degraded and reflection in Swift code may not be able to discover children of types, such as properties and enum cases. `-disable-reflection-metadata`
    public static let reflectionMetadataLevel: BuildSettingsKey = "SWIFT_REFLECTION_METADATA_LEVEL"
}

public enum ReflectionMetadataLevel: String, Hashable, Codable, CustomStringConvertible {
    case all = "all"
    case withoutNames = "without-names"
    case none = "none"

    public var description: String {
        rawValue
    }
}

// MARK: SWIFT_RESOURCE_DIR
extension BuildSetting {

    /// SWIFT_RESOURCE_DIR
    public static func swiftResourceDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftResourceDir, value: "\(value)")
    }

    /// SWIFT_RESOURCE_DIR
    public static func swiftResourceDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftResourceDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_RESOURCE_DIR
    public static let swiftResourceDir: BuildSettingsKey = "SWIFT_RESOURCE_DIR"
}

// MARK: SWIFT_RESPONSE_FILE_PATH
extension BuildSetting {

    /// SWIFT_RESPONSE_FILE_PATH
    public static var swiftResponseFilePath: BuildSetting { 
        BuildSetting(key: .swiftResponseFilePath, value: "$(SWIFT_RESPONSE_FILE_PATH_$(variant)_$(arch))")
    }

    /// SWIFT_RESPONSE_FILE_PATH
    public static func swiftResponseFilePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftResponseFilePath, value: "\(value)")
    }

    /// SWIFT_RESPONSE_FILE_PATH
    public static func swiftResponseFilePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftResponseFilePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_RESPONSE_FILE_PATH
    public static let swiftResponseFilePath: BuildSettingsKey = "SWIFT_RESPONSE_FILE_PATH"
}

// MARK: SWIFT_SERIALIZE_DEBUGGING_OPTIONS
extension BuildSetting {

    /// SWIFT_SERIALIZE_DEBUGGING_OPTIONS
    public static var swiftSerializeDebuggingOptions: BuildSetting { 
        BuildSetting(key: .swiftSerializeDebuggingOptions, value: "YES")
    }

    /// SWIFT_SERIALIZE_DEBUGGING_OPTIONS
    public static func swiftSerializeDebuggingOptions(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftSerializeDebuggingOptions, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_SERIALIZE_DEBUGGING_OPTIONS
    public static func swiftSerializeDebuggingOptions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftSerializeDebuggingOptions, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_SERIALIZE_DEBUGGING_OPTIONS
    public static let swiftSerializeDebuggingOptions: BuildSettingsKey = "SWIFT_SERIALIZE_DEBUGGING_OPTIONS"
}

// MARK: SWIFT_STDLIB
extension BuildSetting {

    /// SWIFT_STDLIB
    public static var swiftStdlib: BuildSetting { 
        BuildSetting(key: .swiftStdlib, value: "swiftCore")
    }

    /// SWIFT_STDLIB
    public static func swiftStdlib(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlib, value: "\(value)")
    }

    /// SWIFT_STDLIB
    public static func swiftStdlib(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlib, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB
    public static let swiftStdlib: BuildSettingsKey = "SWIFT_STDLIB"
}

// MARK: SWIFT_STDLIB_TOOL_ACTION
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_ACTION
    public static func swiftStdlibToolAction(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolAction, value: "\(value)")
    }

    /// SWIFT_STDLIB_TOOL_ACTION
    public static func swiftStdlibToolAction(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolAction, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_ACTION
    public static let swiftStdlibToolAction: BuildSettingsKey = "SWIFT_STDLIB_TOOL_ACTION"
}

// MARK: SWIFT_STDLIB_TOOL_CODE_SIGN_IDENTITY
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_CODE_SIGN_IDENTITY
    public static var swiftStdlibToolCodeSignIdentity: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolCodeSignIdentity, value: "$(EXPANDED_CODE_SIGN_IDENTITY)")
    }

    /// SWIFT_STDLIB_TOOL_CODE_SIGN_IDENTITY
    public static func swiftStdlibToolCodeSignIdentity(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolCodeSignIdentity, value: "\(value)")
    }

    /// SWIFT_STDLIB_TOOL_CODE_SIGN_IDENTITY
    public static func swiftStdlibToolCodeSignIdentity(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolCodeSignIdentity, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_CODE_SIGN_IDENTITY
    public static let swiftStdlibToolCodeSignIdentity: BuildSettingsKey = "SWIFT_STDLIB_TOOL_CODE_SIGN_IDENTITY"
}

// MARK: SWIFT_STDLIB_TOOL_DESTINATION_DIR
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_DESTINATION_DIR
    public static var swiftStdlibToolDestinationDir: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolDestinationDir, value: "$(TARGET_BUILD_DIR)/$(FRAMEWORKS_FOLDER_PATH)")
    }

    /// SWIFT_STDLIB_TOOL_DESTINATION_DIR
    public static func swiftStdlibToolDestinationDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolDestinationDir, value: "\(value)")
    }

    /// SWIFT_STDLIB_TOOL_DESTINATION_DIR
    public static func swiftStdlibToolDestinationDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolDestinationDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_DESTINATION_DIR
    public static let swiftStdlibToolDestinationDir: BuildSettingsKey = "SWIFT_STDLIB_TOOL_DESTINATION_DIR"
}

// MARK: SWIFT_STDLIB_TOOL_EXECUTABLE_TO_SCAN
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_EXECUTABLE_TO_SCAN
    public static var swiftStdlibToolExecutableToScan: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolExecutableToScan, value: "$(InputPath)")
    }

    /// SWIFT_STDLIB_TOOL_EXECUTABLE_TO_SCAN
    public static func swiftStdlibToolExecutableToScan(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolExecutableToScan, value: "\(value)")
    }

    /// SWIFT_STDLIB_TOOL_EXECUTABLE_TO_SCAN
    public static func swiftStdlibToolExecutableToScan(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolExecutableToScan, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_EXECUTABLE_TO_SCAN
    public static let swiftStdlibToolExecutableToScan: BuildSettingsKey = "SWIFT_STDLIB_TOOL_EXECUTABLE_TO_SCAN"
}

// MARK: SWIFT_STDLIB_TOOL_FOLDERS_TO_SCAN
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_FOLDERS_TO_SCAN
    public static var swiftStdlibToolFoldersToScan: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolFoldersToScan, value: "")
    }

    /// SWIFT_STDLIB_TOOL_FOLDERS_TO_SCAN
    public static func swiftStdlibToolFoldersToScan(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolFoldersToScan, value: .array(value))
    }

    /// SWIFT_STDLIB_TOOL_FOLDERS_TO_SCAN
    public static func swiftStdlibToolFoldersToScan(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolFoldersToScan, inherit: key)
    }

    /// SWIFT_STDLIB_TOOL_FOLDERS_TO_SCAN
    public static func swiftStdlibToolFoldersToScan(_ value: String...) -> BuildSetting { 
        .swiftStdlibToolFoldersToScan(value)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_FOLDERS_TO_SCAN
    public static let swiftStdlibToolFoldersToScan: BuildSettingsKey = "SWIFT_STDLIB_TOOL_FOLDERS_TO_SCAN"
}

// MARK: SWIFT_STDLIB_TOOL_KEYCHAIN
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_KEYCHAIN
    public static var swiftStdlibToolKeychain: BuildSetting { 
        .swiftStdlibToolKeychain(inherit: .codeSignKeychain) 
    }

    /// SWIFT_STDLIB_TOOL_KEYCHAIN
    public static func swiftStdlibToolKeychain(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolKeychain, value: "\(value)")
    }

    /// SWIFT_STDLIB_TOOL_KEYCHAIN
    public static func swiftStdlibToolKeychain(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolKeychain, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_KEYCHAIN
    public static let swiftStdlibToolKeychain: BuildSettingsKey = "SWIFT_STDLIB_TOOL_KEYCHAIN"
}

// MARK: SWIFT_STDLIB_TOOL_OTHER_CODE_SIGN_FLAGS
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_OTHER_CODE_SIGN_FLAGS
    public static var swiftStdlibToolOtherCodeSignFlags: BuildSetting { 
        .swiftStdlibToolOtherCodeSignFlags(inherit: .otherCodeSigningFlags) 
    }

    /// SWIFT_STDLIB_TOOL_OTHER_CODE_SIGN_FLAGS
    public static func swiftStdlibToolOtherCodeSignFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolOtherCodeSignFlags, value: .array(value))
    }

    /// SWIFT_STDLIB_TOOL_OTHER_CODE_SIGN_FLAGS
    public static func swiftStdlibToolOtherCodeSignFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolOtherCodeSignFlags, inherit: key)
    }

    /// SWIFT_STDLIB_TOOL_OTHER_CODE_SIGN_FLAGS
    public static func swiftStdlibToolOtherCodeSignFlags(_ value: String...) -> BuildSetting { 
        .swiftStdlibToolOtherCodeSignFlags(value)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_OTHER_CODE_SIGN_FLAGS
    public static let swiftStdlibToolOtherCodeSignFlags: BuildSettingsKey = "SWIFT_STDLIB_TOOL_OTHER_CODE_SIGN_FLAGS"
}

// MARK: SWIFT_STDLIB_TOOL_SOURCE_LIBRARIES
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_SOURCE_LIBRARIES
    public static var swiftStdlibToolSourceLibraries: BuildSetting { 
        .swiftStdlibToolSourceLibraries(inherit: .swiftLibraryPath) 
    }

    /// SWIFT_STDLIB_TOOL_SOURCE_LIBRARIES
    public static func swiftStdlibToolSourceLibraries(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolSourceLibraries, value: "\(value)")
    }

    /// SWIFT_STDLIB_TOOL_SOURCE_LIBRARIES
    public static func swiftStdlibToolSourceLibraries(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolSourceLibraries, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_SOURCE_LIBRARIES
    public static let swiftStdlibToolSourceLibraries: BuildSettingsKey = "SWIFT_STDLIB_TOOL_SOURCE_LIBRARIES"
}

// MARK: SWIFT_STDLIB_TOOL_STRIP_BITCODE
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_STRIP_BITCODE
    public static var swiftStdlibToolStripBitcode: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolStripBitcode, value: "YES")
    }

    /// SWIFT_STDLIB_TOOL_STRIP_BITCODE
    public static func swiftStdlibToolStripBitcode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolStripBitcode, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_STDLIB_TOOL_STRIP_BITCODE
    public static func swiftStdlibToolStripBitcode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolStripBitcode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_STRIP_BITCODE
    public static let swiftStdlibToolStripBitcode: BuildSettingsKey = "SWIFT_STDLIB_TOOL_STRIP_BITCODE"
}

// MARK: SWIFT_STDLIB_TOOL_TOOLCHAINS
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_TOOLCHAINS
    public static var swiftStdlibToolToolchains: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolToolchains, value: "$(EFFECTIVE_TOOLCHAINS_DIRS)")
    }

    /// SWIFT_STDLIB_TOOL_TOOLCHAINS
    public static func swiftStdlibToolToolchains(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolToolchains, value: .array(value))
    }

    /// SWIFT_STDLIB_TOOL_TOOLCHAINS
    public static func swiftStdlibToolToolchains(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolToolchains, inherit: key)
    }

    /// SWIFT_STDLIB_TOOL_TOOLCHAINS
    public static func swiftStdlibToolToolchains(_ value: String...) -> BuildSetting { 
        .swiftStdlibToolToolchains(value)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_TOOLCHAINS
    public static let swiftStdlibToolToolchains: BuildSettingsKey = "SWIFT_STDLIB_TOOL_TOOLCHAINS"
}

// MARK: SWIFT_STDLIB_TOOL_UNSIGNED_DESTINATION_DIR
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_UNSIGNED_DESTINATION_DIR
    public static var swiftStdlibToolUnsignedDestinationDir: BuildSetting { 
        BuildSetting(key: .swiftStdlibToolUnsignedDestinationDir, value: "")
    }

    /// SWIFT_STDLIB_TOOL_UNSIGNED_DESTINATION_DIR
    public static func swiftStdlibToolUnsignedDestinationDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolUnsignedDestinationDir, value: "\(value)")
    }

    /// SWIFT_STDLIB_TOOL_UNSIGNED_DESTINATION_DIR
    public static func swiftStdlibToolUnsignedDestinationDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolUnsignedDestinationDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_UNSIGNED_DESTINATION_DIR
    public static let swiftStdlibToolUnsignedDestinationDir: BuildSettingsKey = "SWIFT_STDLIB_TOOL_UNSIGNED_DESTINATION_DIR"
}

// MARK: SWIFT_STDLIB_TOOL_VERBOSITY
extension BuildSetting {

    /// SWIFT_STDLIB_TOOL_VERBOSITY
    public static var swiftStdlibToolVerbosity: BuildSetting { 
        .swiftStdlibToolVerbosity(.verbose) 
    }

    /// SWIFT_STDLIB_TOOL_VERBOSITY
    public static func swiftStdlibToolVerbosity(_ value: SwiftStdlibToolVerbosity) -> BuildSetting { 
        BuildSetting(key: .swiftStdlibToolVerbosity, value: "\(value)")
    }

    /// SWIFT_STDLIB_TOOL_VERBOSITY
    public static func swiftStdlibToolVerbosity(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftStdlibToolVerbosity, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_STDLIB_TOOL_VERBOSITY
    public static let swiftStdlibToolVerbosity: BuildSettingsKey = "SWIFT_STDLIB_TOOL_VERBOSITY"
}

public enum SwiftStdlibToolVerbosity: String, Hashable, Codable, CustomStringConvertible {
    case none = "none"
    case verbose = "verbose"
    case extraVerbose = "extra-verbose"

    public var description: String {
        rawValue
    }
}

// MARK: Suppress Warnings
extension BuildSetting {

    /// Suppress Warnings
    ///
    /// Don't emit any warnings.
    public static var suppressWarnings: BuildSetting { 
        BuildSetting(key: .suppressWarnings, value: "NO")
    }

    /// Suppress Warnings
    ///
    /// Don't emit any warnings.
    public static func suppressWarnings(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .suppressWarnings, value: SettingValue(booleanLiteral: value))
    }

    /// Suppress Warnings
    ///
    /// Don't emit any warnings.
    public static func suppressWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .suppressWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Suppress Warnings
    ///
    /// Don't emit any warnings.
    public static let suppressWarnings: BuildSettingsKey = "SWIFT_SUPPRESS_WARNINGS"
}

// MARK: Swift 3 @objc Inference
extension BuildSetting {

    /// Swift 3 @objc Inference
    ///
    /// Control how the Swift compiler infers @objc for declarations.
    public static var swift3ObjcInference: BuildSetting { 
        .swift3ObjcInference(.default) 
    }

    /// Swift 3 @objc Inference
    ///
    /// Control how the Swift compiler infers @objc for declarations.
    public static func swift3ObjcInference(_ value: Swift3ObjcInference) -> BuildSetting { 
        BuildSetting(key: .swift3ObjcInference, value: "\(value)")
    }

    /// Swift 3 @objc Inference
    ///
    /// Control how the Swift compiler infers @objc for declarations.
    public static func swift3ObjcInference(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swift3ObjcInference, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift 3 @objc Inference
    ///
    /// Control how the Swift compiler infers @objc for declarations.
    public static let swift3ObjcInference: BuildSettingsKey = "SWIFT_SWIFT3_OBJC_INFERENCE"
}

public enum Swift3ObjcInference: String, Hashable, Codable, CustomStringConvertible {
    case `default` = "Default"
    case on = "On"
    case off = "Off"

    public var description: String {
        rawValue
    }
}

// MARK: SWIFT_TARGET_TRIPLE
extension BuildSetting {

    /// SWIFT_TARGET_TRIPLE
    public static var swiftTargetTriple: BuildSetting { 
        BuildSetting(key: .swiftTargetTriple, value: "$(CURRENT_ARCH)-apple-$(SWIFT_PLATFORM_TARGET_PREFIX)$(SWIFT_DEPLOYMENT_TARGET)$(LLVM_TARGET_TRIPLE_SUFFIX)")
    }

    /// SWIFT_TARGET_TRIPLE
    public static func swiftTargetTriple(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftTargetTriple, value: "\(value)")
    }

    /// SWIFT_TARGET_TRIPLE
    public static func swiftTargetTriple(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftTargetTriple, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_TARGET_TRIPLE
    public static let swiftTargetTriple: BuildSettingsKey = "SWIFT_TARGET_TRIPLE"
}

// MARK: SWIFT_TARGET_TRIPLE_VARIANTS
extension BuildSetting {

    /// SWIFT_TARGET_TRIPLE_VARIANTS
    public static func swiftTargetTripleVariants(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .swiftTargetTripleVariants, value: .array(value))
    }

    /// SWIFT_TARGET_TRIPLE_VARIANTS
    public static func swiftTargetTripleVariants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftTargetTripleVariants, inherit: key)
    }

    /// SWIFT_TARGET_TRIPLE_VARIANTS
    public static func swiftTargetTripleVariants(_ value: String...) -> BuildSetting { 
        .swiftTargetTripleVariants(value)
    }
}

extension BuildSettingsKey {

    /// SWIFT_TARGET_TRIPLE_VARIANTS
    public static let swiftTargetTripleVariants: BuildSettingsKey = "SWIFT_TARGET_TRIPLE_VARIANTS"
}

// MARK: SWIFT_THREAD_SANITIZER
extension BuildSetting {

    /// SWIFT_THREAD_SANITIZER
    public static var swiftThreadSanitizer: BuildSetting { 
        BuildSetting(key: .swiftThreadSanitizer, value: "$(ENABLE_THREAD_SANITIZER)")
    }

    /// SWIFT_THREAD_SANITIZER
    public static func swiftThreadSanitizer(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftThreadSanitizer, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_THREAD_SANITIZER
    public static func swiftThreadSanitizer(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftThreadSanitizer, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_THREAD_SANITIZER
    public static let swiftThreadSanitizer: BuildSettingsKey = "SWIFT_THREAD_SANITIZER"
}

// MARK: SWIFT_TOOLCHAIN_FLAGS
extension BuildSetting {

    /// SWIFT_TOOLCHAIN_FLAGS
    public static func swiftToolchainFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .swiftToolchainFlags, value: .array(value))
    }

    /// SWIFT_TOOLCHAIN_FLAGS
    public static func swiftToolchainFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftToolchainFlags, inherit: key)
    }

    /// SWIFT_TOOLCHAIN_FLAGS
    public static func swiftToolchainFlags(_ value: String...) -> BuildSetting { 
        .swiftToolchainFlags(value)
    }
}

extension BuildSettingsKey {

    /// SWIFT_TOOLCHAIN_FLAGS
    public static let swiftToolchainFlags: BuildSettingsKey = "SWIFT_TOOLCHAIN_FLAGS"
}

// MARK: Treat Warnings as Errors
extension BuildSetting {

    /// Treat Warnings as Errors
    ///
    /// Treat all warnings as errors.
    public static var treatWarningsAsErrors: BuildSetting { 
        BuildSetting(key: .treatWarningsAsErrors, value: "NO")
    }

    /// Treat Warnings as Errors
    ///
    /// Treat all warnings as errors.
    public static func treatWarningsAsErrors(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatWarningsAsErrors, value: SettingValue(booleanLiteral: value))
    }

    /// Treat Warnings as Errors
    ///
    /// Treat all warnings as errors.
    public static func treatWarningsAsErrors(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatWarningsAsErrors, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat Warnings as Errors
    ///
    /// Treat all warnings as errors.
    public static let treatWarningsAsErrors: BuildSettingsKey = "SWIFT_TREAT_WARNINGS_AS_ERRORS"
}

// MARK: SWIFT_USE_PARALLEL_WHOLE_MODULE_OPTIMIZATION
extension BuildSetting {

    /// SWIFT_USE_PARALLEL_WHOLE_MODULE_OPTIMIZATION
    public static var swiftUseParallelWholeModuleOptimization: BuildSetting { 
        BuildSetting(key: .swiftUseParallelWholeModuleOptimization, value: "YES")
    }

    /// SWIFT_USE_PARALLEL_WHOLE_MODULE_OPTIMIZATION
    public static func swiftUseParallelWholeModuleOptimization(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftUseParallelWholeModuleOptimization, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_USE_PARALLEL_WHOLE_MODULE_OPTIMIZATION
    public static func swiftUseParallelWholeModuleOptimization(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftUseParallelWholeModuleOptimization, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_USE_PARALLEL_WHOLE_MODULE_OPTIMIZATION
    public static let swiftUseParallelWholeModuleOptimization: BuildSettingsKey = "SWIFT_USE_PARALLEL_WHOLE_MODULE_OPTIMIZATION"
}

// MARK: SWIFT_USE_PARALLEL_WMO_TARGETS
extension BuildSetting {

    /// SWIFT_USE_PARALLEL_WMO_TARGETS
    public static var swiftUseParallelWmoTargets: BuildSetting { 
        BuildSetting(key: .swiftUseParallelWmoTargets, value: "YES")
    }

    /// SWIFT_USE_PARALLEL_WMO_TARGETS
    public static func swiftUseParallelWmoTargets(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftUseParallelWmoTargets, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_USE_PARALLEL_WMO_TARGETS
    public static func swiftUseParallelWmoTargets(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftUseParallelWmoTargets, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_USE_PARALLEL_WMO_TARGETS
    public static let swiftUseParallelWmoTargets: BuildSettingsKey = "SWIFT_USE_PARALLEL_WMO_TARGETS"
}

// MARK: Swift Language Version
extension BuildSetting {

    /// Swift Language Version
    ///
    /// 
    public static var swiftLanguageVersion: BuildSetting { 
        BuildSetting(key: .swiftLanguageVersion, value: "")
    }

    /// Swift Language Version
    ///
    /// 
    public static func swiftLanguageVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .swiftLanguageVersion, value: "\(value)")
    }

    /// Swift Language Version
    ///
    /// 
    public static func swiftLanguageVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftLanguageVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Swift Language Version
    ///
    /// 
    public static let swiftLanguageVersion: BuildSettingsKey = "SWIFT_VERSION"
}

// MARK: SWIFT_WHOLE_MODULE_OPTIMIZATION
extension BuildSetting {

    /// SWIFT_WHOLE_MODULE_OPTIMIZATION
    public static var swiftWholeModuleOptimization: BuildSetting { 
        BuildSetting(key: .swiftWholeModuleOptimization, value: "NO")
    }

    /// SWIFT_WHOLE_MODULE_OPTIMIZATION
    public static func swiftWholeModuleOptimization(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .swiftWholeModuleOptimization, value: SettingValue(booleanLiteral: value))
    }

    /// SWIFT_WHOLE_MODULE_OPTIMIZATION
    public static func swiftWholeModuleOptimization(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .swiftWholeModuleOptimization, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SWIFT_WHOLE_MODULE_OPTIMIZATION
    public static let swiftWholeModuleOptimization: BuildSettingsKey = "SWIFT_WHOLE_MODULE_OPTIMIZATION"
}

// MARK: SYMBOL_HEADER
extension BuildSetting {

    /// SYMBOL_HEADER
    public static var symbolHeader: BuildSetting { 
        BuildSetting(key: .symbolHeader, value: "")
    }

    /// SYMBOL_HEADER
    public static func symbolHeader(_ value: String) -> BuildSetting { 
        BuildSetting(key: .symbolHeader, value: "\(value)")
    }

    /// SYMBOL_HEADER
    public static func symbolHeader(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .symbolHeader, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SYMBOL_HEADER
    public static let symbolHeader: BuildSettingsKey = "SYMBOL_HEADER"
}

// MARK: Build Products Path
extension BuildSetting {

    /// Build Products Path
    ///
    /// The path at which all products will be placed when performing a build. Typically this path is not set per target, but is set per-project or per-user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static var buildProductsPath: BuildSetting { 
        BuildSetting(key: .buildProductsPath, value: "build")
    }

    /// Build Products Path
    ///
    /// The path at which all products will be placed when performing a build. Typically this path is not set per target, but is set per-project or per-user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static func buildProductsPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .buildProductsPath, value: "\(value)")
    }

    /// Build Products Path
    ///
    /// The path at which all products will be placed when performing a build. Typically this path is not set per target, but is set per-project or per-user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static func buildProductsPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .buildProductsPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Build Products Path
    ///
    /// The path at which all products will be placed when performing a build. Typically this path is not set per target, but is set per-project or per-user. By default, this is set to `$(PROJECT_DIR)/build`.
    public static let buildProductsPath: BuildSettingsKey = "SYMROOT"
}

// MARK: SYSTEM_DEXT_INSTALL_PATH
extension BuildSetting {

    /// SYSTEM_DEXT_INSTALL_PATH
    public static var systemDextInstallPath: BuildSetting { 
        BuildSetting(key: .systemDextInstallPath, value: "$(SYSTEM_LIBRARY_DIR)/DriverExtensions")
    }

    /// SYSTEM_DEXT_INSTALL_PATH
    public static func systemDextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .systemDextInstallPath, value: "\(value)")
    }

    /// SYSTEM_DEXT_INSTALL_PATH
    public static func systemDextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .systemDextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SYSTEM_DEXT_INSTALL_PATH
    public static let systemDextInstallPath: BuildSettingsKey = "SYSTEM_DEXT_INSTALL_PATH"
}

// MARK: System Framework Search Paths
extension BuildSetting {

    /// System Framework Search Paths
    ///
    /// This is a list of paths to folders containing system frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Framework Search Paths", except that the search paths are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system framework search paths, then the search paths are appended to any existing framework search paths defined in "Framework Search Paths".
    public static var systemFrameworkSearchPaths: BuildSetting { 
        BuildSetting(key: .systemFrameworkSearchPaths, value: "")
    }

    /// System Framework Search Paths
    ///
    /// This is a list of paths to folders containing system frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Framework Search Paths", except that the search paths are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system framework search paths, then the search paths are appended to any existing framework search paths defined in "Framework Search Paths".
    public static func systemFrameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .systemFrameworkSearchPaths, value: .array(value))
    }

    /// System Framework Search Paths
    ///
    /// This is a list of paths to folders containing system frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Framework Search Paths", except that the search paths are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system framework search paths, then the search paths are appended to any existing framework search paths defined in "Framework Search Paths".
    public static func systemFrameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .systemFrameworkSearchPaths, inherit: key)
    }

    /// System Framework Search Paths
    ///
    /// This is a list of paths to folders containing system frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Framework Search Paths", except that the search paths are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system framework search paths, then the search paths are appended to any existing framework search paths defined in "Framework Search Paths".
    public static func systemFrameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .systemFrameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// System Framework Search Paths
    ///
    /// This is a list of paths to folders containing system frameworks to be searched by the compiler for both included or imported header files when compiling C, Objective-C, C++, or Objective-C++, and by the linker for frameworks used by the product. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Framework Search Paths", except that the search paths are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system framework search paths, then the search paths are appended to any existing framework search paths defined in "Framework Search Paths".
    public static let systemFrameworkSearchPaths: BuildSettingsKey = "SYSTEM_FRAMEWORK_SEARCH_PATHS"
}

// MARK: System Header Search Paths
extension BuildSetting {

    /// System Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported system header files when compiling C, Objective-C, C++, or Objective-C++. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Header Search Paths", except that headers are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system header search paths, then the search paths are appended to any existing header search paths defined in "Header Search Paths".
    public static var systemHeaderSearchPaths: BuildSetting { 
        BuildSetting(key: .systemHeaderSearchPaths, value: "")
    }

    /// System Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported system header files when compiling C, Objective-C, C++, or Objective-C++. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Header Search Paths", except that headers are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system header search paths, then the search paths are appended to any existing header search paths defined in "Header Search Paths".
    public static func systemHeaderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .systemHeaderSearchPaths, value: .array(value))
    }

    /// System Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported system header files when compiling C, Objective-C, C++, or Objective-C++. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Header Search Paths", except that headers are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system header search paths, then the search paths are appended to any existing header search paths defined in "Header Search Paths".
    public static func systemHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .systemHeaderSearchPaths, inherit: key)
    }

    /// System Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported system header files when compiling C, Objective-C, C++, or Objective-C++. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Header Search Paths", except that headers are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system header search paths, then the search paths are appended to any existing header search paths defined in "Header Search Paths".
    public static func systemHeaderSearchPaths(_ value: String...) -> BuildSetting { 
        .systemHeaderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// System Header Search Paths
    ///
    /// This is a list of paths to folders to be searched by the compiler for included or imported system header files when compiling C, Objective-C, C++, or Objective-C++. The order is from highest to lowest precedence. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. This setting is very similar to "Header Search Paths", except that headers are passed to the compiler in a way that suppresses most warnings for headers found in system search paths. If the compiler doesn't support the concept of system header search paths, then the search paths are appended to any existing header search paths defined in "Header Search Paths".
    public static let systemHeaderSearchPaths: BuildSettingsKey = "SYSTEM_HEADER_SEARCH_PATHS"
}

// MARK: SYSTEM_KEXT_INSTALL_PATH
extension BuildSetting {

    /// SYSTEM_KEXT_INSTALL_PATH
    public static var systemKextInstallPath: BuildSetting { 
        BuildSetting(key: .systemKextInstallPath, value: "$(SYSTEM_LIBRARY_DIR)/Extensions")
    }

    /// SYSTEM_KEXT_INSTALL_PATH
    public static func systemKextInstallPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .systemKextInstallPath, value: "\(value)")
    }

    /// SYSTEM_KEXT_INSTALL_PATH
    public static func systemKextInstallPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .systemKextInstallPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SYSTEM_KEXT_INSTALL_PATH
    public static let systemKextInstallPath: BuildSettingsKey = "SYSTEM_KEXT_INSTALL_PATH"
}

// MARK: SigningCert
extension BuildSetting {

    /// SigningCert
    public static func signingcert(_ value: String) -> BuildSetting { 
        BuildSetting(key: .signingcert, value: "\(value)")
    }

    /// SigningCert
    public static func signingcert(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .signingcert, inherit: key)
    }
}

extension BuildSettingsKey {

    /// SigningCert
    public static let signingcert: BuildSettingsKey = "SigningCert"
}

// MARK: TAPI_APPLICATION_EXTENSION_API_ONLY
extension BuildSetting {

    /// TAPI_APPLICATION_EXTENSION_API_ONLY
    public static var tapiApplicationExtensionApiOnly: BuildSetting { 
        .tapiApplicationExtensionApiOnly(inherit: .requireOnlyAppExtensionSafeApi) 
    }

    /// TAPI_APPLICATION_EXTENSION_API_ONLY
    public static func tapiApplicationExtensionApiOnly(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiApplicationExtensionApiOnly, value: SettingValue(booleanLiteral: value))
    }

    /// TAPI_APPLICATION_EXTENSION_API_ONLY
    public static func tapiApplicationExtensionApiOnly(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiApplicationExtensionApiOnly, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_APPLICATION_EXTENSION_API_ONLY
    public static let tapiApplicationExtensionApiOnly: BuildSettingsKey = "TAPI_APPLICATION_EXTENSION_API_ONLY"
}

// MARK: TAPI_ARCHS
extension BuildSetting {

    /// TAPI_ARCHS
    public static var tapiArchs: BuildSetting { 
        .tapiArchs(inherit: .architectures) 
    }

    /// TAPI_ARCHS
    public static func tapiArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiArchs, value: .array(value))
    }

    /// TAPI_ARCHS
    public static func tapiArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiArchs, inherit: key)
    }

    /// TAPI_ARCHS
    public static func tapiArchs(_ value: String...) -> BuildSetting { 
        .tapiArchs(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_ARCHS
    public static let tapiArchs: BuildSettingsKey = "TAPI_ARCHS"
}

// MARK: TAPI_DEPLOYMENT_TARGET
extension BuildSetting {

    /// TAPI_DEPLOYMENT_TARGET
    public static var tapiDeploymentTarget: BuildSetting { 
        BuildSetting(key: .tapiDeploymentTarget, value: "$($(DEPLOYMENT_TARGET_SETTING_NAME))")
    }

    /// TAPI_DEPLOYMENT_TARGET
    public static func tapiDeploymentTarget(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiDeploymentTarget, value: "\(value)")
    }

    /// TAPI_DEPLOYMENT_TARGET
    public static func tapiDeploymentTarget(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDeploymentTarget, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_DEPLOYMENT_TARGET
    public static let tapiDeploymentTarget: BuildSettingsKey = "TAPI_DEPLOYMENT_TARGET"
}

// MARK: TAPI_DYLIB_ALLOWABLE_CLIENTS
extension BuildSetting {

    /// TAPI_DYLIB_ALLOWABLE_CLIENTS
    public static var tapiDylibAllowableClients: BuildSetting { 
        .tapiDylibAllowableClients(inherit: .dynamicLibraryAllowableClients) 
    }

    /// TAPI_DYLIB_ALLOWABLE_CLIENTS
    public static func tapiDylibAllowableClients(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiDylibAllowableClients, value: .array(value))
    }

    /// TAPI_DYLIB_ALLOWABLE_CLIENTS
    public static func tapiDylibAllowableClients(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDylibAllowableClients, inherit: key)
    }

    /// TAPI_DYLIB_ALLOWABLE_CLIENTS
    public static func tapiDylibAllowableClients(_ value: String...) -> BuildSetting { 
        .tapiDylibAllowableClients(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_DYLIB_ALLOWABLE_CLIENTS
    public static let tapiDylibAllowableClients: BuildSettingsKey = "TAPI_DYLIB_ALLOWABLE_CLIENTS"
}

// MARK: TAPI_DYLIB_COMPATIBILITY_VERSION
extension BuildSetting {

    /// TAPI_DYLIB_COMPATIBILITY_VERSION
    public static var tapiDylibCompatibilityVersion: BuildSetting { 
        .tapiDylibCompatibilityVersion(inherit: .compatibilityVersion) 
    }

    /// TAPI_DYLIB_COMPATIBILITY_VERSION
    public static func tapiDylibCompatibilityVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiDylibCompatibilityVersion, value: "\(value)")
    }

    /// TAPI_DYLIB_COMPATIBILITY_VERSION
    public static func tapiDylibCompatibilityVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDylibCompatibilityVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_DYLIB_COMPATIBILITY_VERSION
    public static let tapiDylibCompatibilityVersion: BuildSettingsKey = "TAPI_DYLIB_COMPATIBILITY_VERSION"
}

// MARK: TAPI_DYLIB_CURRENT_VERSION
extension BuildSetting {

    /// TAPI_DYLIB_CURRENT_VERSION
    public static var tapiDylibCurrentVersion: BuildSetting { 
        .tapiDylibCurrentVersion(inherit: .currentLibraryVersion) 
    }

    /// TAPI_DYLIB_CURRENT_VERSION
    public static func tapiDylibCurrentVersion(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiDylibCurrentVersion, value: "\(value)")
    }

    /// TAPI_DYLIB_CURRENT_VERSION
    public static func tapiDylibCurrentVersion(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDylibCurrentVersion, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_DYLIB_CURRENT_VERSION
    public static let tapiDylibCurrentVersion: BuildSettingsKey = "TAPI_DYLIB_CURRENT_VERSION"
}

// MARK: TAPI_DYLIB_INSTALL_NAME
extension BuildSetting {

    /// TAPI_DYLIB_INSTALL_NAME
    public static var tapiDylibInstallName: BuildSetting { 
        .tapiDylibInstallName(inherit: .dynamicLibraryInstallName) 
    }

    /// TAPI_DYLIB_INSTALL_NAME
    public static func tapiDylibInstallName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiDylibInstallName, value: "\(value)")
    }

    /// TAPI_DYLIB_INSTALL_NAME
    public static func tapiDylibInstallName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiDylibInstallName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_DYLIB_INSTALL_NAME
    public static let tapiDylibInstallName: BuildSettingsKey = "TAPI_DYLIB_INSTALL_NAME"
}

// MARK: TAPI_EMIT_PROFILING_SYMBOLS
extension BuildSetting {

    /// TAPI_EMIT_PROFILING_SYMBOLS
    public static var tapiEmitProfilingSymbols: BuildSetting { 
        BuildSetting(key: .tapiEmitProfilingSymbols, value: "YES")
    }

    /// TAPI_EMIT_PROFILING_SYMBOLS
    public static func tapiEmitProfilingSymbols(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiEmitProfilingSymbols, value: SettingValue(booleanLiteral: value))
    }

    /// TAPI_EMIT_PROFILING_SYMBOLS
    public static func tapiEmitProfilingSymbols(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiEmitProfilingSymbols, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_EMIT_PROFILING_SYMBOLS
    public static let tapiEmitProfilingSymbols: BuildSettingsKey = "TAPI_EMIT_PROFILING_SYMBOLS"
}

// MARK: TAPI_ENABLE_MODULES
extension BuildSetting {

    /// TAPI_ENABLE_MODULES
    public static var tapiEnableModules: BuildSetting { 
        BuildSetting(key: .tapiEnableModules, value: "NO")
    }

    /// TAPI_ENABLE_MODULES
    public static func tapiEnableModules(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiEnableModules, value: SettingValue(booleanLiteral: value))
    }

    /// TAPI_ENABLE_MODULES
    public static func tapiEnableModules(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiEnableModules, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_ENABLE_MODULES
    public static let tapiEnableModules: BuildSettingsKey = "TAPI_ENABLE_MODULES"
}

// MARK: TAPI_ENABLE_VERIFICATION_MODE
extension BuildSetting {

    /// TAPI_ENABLE_VERIFICATION_MODE
    public static var tapiEnableVerificationMode: BuildSetting { 
        BuildSetting(key: .tapiEnableVerificationMode, value: "YES")
    }

    /// TAPI_ENABLE_VERIFICATION_MODE
    public static func tapiEnableVerificationMode(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiEnableVerificationMode, value: SettingValue(booleanLiteral: value))
    }

    /// TAPI_ENABLE_VERIFICATION_MODE
    public static func tapiEnableVerificationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiEnableVerificationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_ENABLE_VERIFICATION_MODE
    public static let tapiEnableVerificationMode: BuildSettingsKey = "TAPI_ENABLE_VERIFICATION_MODE"
}

// MARK: TAPI_FRAMEWORK_SEARCH_PATHS
extension BuildSetting {

    /// TAPI_FRAMEWORK_SEARCH_PATHS
    public static var tapiFrameworkSearchPaths: BuildSetting { 
        .tapiFrameworkSearchPaths(inherit: .frameworkSearchPaths) 
    }

    /// TAPI_FRAMEWORK_SEARCH_PATHS
    public static func tapiFrameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiFrameworkSearchPaths, value: .array(value))
    }

    /// TAPI_FRAMEWORK_SEARCH_PATHS
    public static func tapiFrameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiFrameworkSearchPaths, inherit: key)
    }

    /// TAPI_FRAMEWORK_SEARCH_PATHS
    public static func tapiFrameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .tapiFrameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_FRAMEWORK_SEARCH_PATHS
    public static let tapiFrameworkSearchPaths: BuildSettingsKey = "TAPI_FRAMEWORK_SEARCH_PATHS"
}

// MARK: TAPI_HEADER_SEARCH_PATHS
extension BuildSetting {

    /// TAPI_HEADER_SEARCH_PATHS
    public static var tapiHeaderSearchPaths: BuildSetting { 
        .tapiHeaderSearchPaths(inherit: .headerSearchPaths) 
    }

    /// TAPI_HEADER_SEARCH_PATHS
    public static func tapiHeaderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiHeaderSearchPaths, value: .array(value))
    }

    /// TAPI_HEADER_SEARCH_PATHS
    public static func tapiHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiHeaderSearchPaths, inherit: key)
    }

    /// TAPI_HEADER_SEARCH_PATHS
    public static func tapiHeaderSearchPaths(_ value: String...) -> BuildSetting { 
        .tapiHeaderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_HEADER_SEARCH_PATHS
    public static let tapiHeaderSearchPaths: BuildSettingsKey = "TAPI_HEADER_SEARCH_PATHS"
}

// MARK: TAPI_INPUTS
extension BuildSetting {

    /// TAPI_INPUTS
    public static func tapiInputs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiInputs, value: .array(value))
    }

    /// TAPI_INPUTS
    public static func tapiInputs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiInputs, inherit: key)
    }

    /// TAPI_INPUTS
    public static func tapiInputs(_ value: String...) -> BuildSetting { 
        .tapiInputs(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_INPUTS
    public static let tapiInputs: BuildSettingsKey = "TAPI_INPUTS"
}

// MARK: TAPI_LIBRARY_SEARCH_PATHS
extension BuildSetting {

    /// TAPI_LIBRARY_SEARCH_PATHS
    public static var tapiLibrarySearchPaths: BuildSetting { 
        .tapiLibrarySearchPaths(inherit: .librarySearchPaths) 
    }

    /// TAPI_LIBRARY_SEARCH_PATHS
    public static func tapiLibrarySearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiLibrarySearchPaths, value: .array(value))
    }

    /// TAPI_LIBRARY_SEARCH_PATHS
    public static func tapiLibrarySearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiLibrarySearchPaths, inherit: key)
    }

    /// TAPI_LIBRARY_SEARCH_PATHS
    public static func tapiLibrarySearchPaths(_ value: String...) -> BuildSetting { 
        .tapiLibrarySearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_LIBRARY_SEARCH_PATHS
    public static let tapiLibrarySearchPaths: BuildSettingsKey = "TAPI_LIBRARY_SEARCH_PATHS"
}

// MARK: TAPI_MODULES_VALIDATE_SYSTEM_HEADERS
extension BuildSetting {

    /// TAPI_MODULES_VALIDATE_SYSTEM_HEADERS
    public static var tapiModulesValidateSystemHeaders: BuildSetting { 
        .tapiModulesValidateSystemHeaders(inherit: .clangModulesValidateSystemHeaders) 
    }

    /// TAPI_MODULES_VALIDATE_SYSTEM_HEADERS
    public static func tapiModulesValidateSystemHeaders(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .tapiModulesValidateSystemHeaders, value: SettingValue(booleanLiteral: value))
    }

    /// TAPI_MODULES_VALIDATE_SYSTEM_HEADERS
    public static func tapiModulesValidateSystemHeaders(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiModulesValidateSystemHeaders, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_MODULES_VALIDATE_SYSTEM_HEADERS
    public static let tapiModulesValidateSystemHeaders: BuildSettingsKey = "TAPI_MODULES_VALIDATE_SYSTEM_HEADERS"
}

// MARK: TAPI_MODULE_CACHE_PATH
extension BuildSetting {

    /// TAPI_MODULE_CACHE_PATH
    public static var tapiModuleCachePath: BuildSetting { 
        .tapiModuleCachePath(inherit: .clangModuleCachePath) 
    }

    /// TAPI_MODULE_CACHE_PATH
    public static func tapiModuleCachePath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiModuleCachePath, value: "\(value)")
    }

    /// TAPI_MODULE_CACHE_PATH
    public static func tapiModuleCachePath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiModuleCachePath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_MODULE_CACHE_PATH
    public static let tapiModuleCachePath: BuildSettingsKey = "TAPI_MODULE_CACHE_PATH"
}

// MARK: TAPI_PREPROCESSOR_DEFINITIONS
extension BuildSetting {

    /// TAPI_PREPROCESSOR_DEFINITIONS
    public static var tapiPreprocessorDefinitions: BuildSetting { 
        BuildSetting(key: .tapiPreprocessorDefinitions, value: "$(GCC_PREPROCESSOR_DEFINITIONS) $(GCC_PREPROCESSOR_DEFINITIONS_NOT_USED_IN_PRECOMPS)")
    }

    /// TAPI_PREPROCESSOR_DEFINITIONS
    public static func tapiPreprocessorDefinitions(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiPreprocessorDefinitions, value: .array(value))
    }

    /// TAPI_PREPROCESSOR_DEFINITIONS
    public static func tapiPreprocessorDefinitions(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiPreprocessorDefinitions, inherit: key)
    }

    /// TAPI_PREPROCESSOR_DEFINITIONS
    public static func tapiPreprocessorDefinitions(_ value: String...) -> BuildSetting { 
        .tapiPreprocessorDefinitions(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_PREPROCESSOR_DEFINITIONS
    public static let tapiPreprocessorDefinitions: BuildSettingsKey = "TAPI_PREPROCESSOR_DEFINITIONS"
}

// MARK: TAPI_PRODUCT_TYPE
extension BuildSetting {

    /// TAPI_PRODUCT_TYPE
    public static var tapiProductType: BuildSetting { 
        .tapiProductType(inherit: .productType) 
    }

    /// TAPI_PRODUCT_TYPE
    public static func tapiProductType(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiProductType, value: "\(value)")
    }

    /// TAPI_PRODUCT_TYPE
    public static func tapiProductType(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiProductType, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_PRODUCT_TYPE
    public static let tapiProductType: BuildSettingsKey = "TAPI_PRODUCT_TYPE"
}

// MARK: TAPI_REEXPORTED_FRAMEWORK_INSTALL_NAMES
extension BuildSetting {

    /// TAPI_REEXPORTED_FRAMEWORK_INSTALL_NAMES
    public static var tapiReexportedFrameworkInstallNames: BuildSetting { 
        .tapiReexportedFrameworkInstallNames(inherit: .reexportedFrameworkInstallNames) 
    }

    /// TAPI_REEXPORTED_FRAMEWORK_INSTALL_NAMES
    public static func tapiReexportedFrameworkInstallNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedFrameworkInstallNames, value: .array(value))
    }

    /// TAPI_REEXPORTED_FRAMEWORK_INSTALL_NAMES
    public static func tapiReexportedFrameworkInstallNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedFrameworkInstallNames, inherit: key)
    }

    /// TAPI_REEXPORTED_FRAMEWORK_INSTALL_NAMES
    public static func tapiReexportedFrameworkInstallNames(_ value: String...) -> BuildSetting { 
        .tapiReexportedFrameworkInstallNames(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_REEXPORTED_FRAMEWORK_INSTALL_NAMES
    public static let tapiReexportedFrameworkInstallNames: BuildSettingsKey = "TAPI_REEXPORTED_FRAMEWORK_INSTALL_NAMES"
}

// MARK: TAPI_REEXPORTED_FRAMEWORK_NAMES
extension BuildSetting {

    /// TAPI_REEXPORTED_FRAMEWORK_NAMES
    public static var tapiReexportedFrameworkNames: BuildSetting { 
        .tapiReexportedFrameworkNames(inherit: .reExportedFrameworkNames) 
    }

    /// TAPI_REEXPORTED_FRAMEWORK_NAMES
    public static func tapiReexportedFrameworkNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedFrameworkNames, value: .array(value))
    }

    /// TAPI_REEXPORTED_FRAMEWORK_NAMES
    public static func tapiReexportedFrameworkNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedFrameworkNames, inherit: key)
    }

    /// TAPI_REEXPORTED_FRAMEWORK_NAMES
    public static func tapiReexportedFrameworkNames(_ value: String...) -> BuildSetting { 
        .tapiReexportedFrameworkNames(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_REEXPORTED_FRAMEWORK_NAMES
    public static let tapiReexportedFrameworkNames: BuildSettingsKey = "TAPI_REEXPORTED_FRAMEWORK_NAMES"
}

// MARK: TAPI_REEXPORTED_LIBRARY_INSTALL_NAMES
extension BuildSetting {

    /// TAPI_REEXPORTED_LIBRARY_INSTALL_NAMES
    public static var tapiReexportedLibraryInstallNames: BuildSetting { 
        .tapiReexportedLibraryInstallNames(inherit: .reexportedLibraryInstallNames) 
    }

    /// TAPI_REEXPORTED_LIBRARY_INSTALL_NAMES
    public static func tapiReexportedLibraryInstallNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedLibraryInstallNames, value: .array(value))
    }

    /// TAPI_REEXPORTED_LIBRARY_INSTALL_NAMES
    public static func tapiReexportedLibraryInstallNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedLibraryInstallNames, inherit: key)
    }

    /// TAPI_REEXPORTED_LIBRARY_INSTALL_NAMES
    public static func tapiReexportedLibraryInstallNames(_ value: String...) -> BuildSetting { 
        .tapiReexportedLibraryInstallNames(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_REEXPORTED_LIBRARY_INSTALL_NAMES
    public static let tapiReexportedLibraryInstallNames: BuildSettingsKey = "TAPI_REEXPORTED_LIBRARY_INSTALL_NAMES"
}

// MARK: TAPI_REEXPORTED_LIBRARY_NAMES
extension BuildSetting {

    /// TAPI_REEXPORTED_LIBRARY_NAMES
    public static var tapiReexportedLibraryNames: BuildSetting { 
        .tapiReexportedLibraryNames(inherit: .reExportedLibraryNames) 
    }

    /// TAPI_REEXPORTED_LIBRARY_NAMES
    public static func tapiReexportedLibraryNames(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedLibraryNames, value: .array(value))
    }

    /// TAPI_REEXPORTED_LIBRARY_NAMES
    public static func tapiReexportedLibraryNames(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedLibraryNames, inherit: key)
    }

    /// TAPI_REEXPORTED_LIBRARY_NAMES
    public static func tapiReexportedLibraryNames(_ value: String...) -> BuildSetting { 
        .tapiReexportedLibraryNames(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_REEXPORTED_LIBRARY_NAMES
    public static let tapiReexportedLibraryNames: BuildSettingsKey = "TAPI_REEXPORTED_LIBRARY_NAMES"
}

// MARK: TAPI_REEXPORTED_LIBRARY_PATHS
extension BuildSetting {

    /// TAPI_REEXPORTED_LIBRARY_PATHS
    public static var tapiReexportedLibraryPaths: BuildSetting { 
        .tapiReexportedLibraryPaths(inherit: .reExportedLibraryPaths) 
    }

    /// TAPI_REEXPORTED_LIBRARY_PATHS
    public static func tapiReexportedLibraryPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiReexportedLibraryPaths, value: .array(value))
    }

    /// TAPI_REEXPORTED_LIBRARY_PATHS
    public static func tapiReexportedLibraryPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiReexportedLibraryPaths, inherit: key)
    }

    /// TAPI_REEXPORTED_LIBRARY_PATHS
    public static func tapiReexportedLibraryPaths(_ value: String...) -> BuildSetting { 
        .tapiReexportedLibraryPaths(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_REEXPORTED_LIBRARY_PATHS
    public static let tapiReexportedLibraryPaths: BuildSettingsKey = "TAPI_REEXPORTED_LIBRARY_PATHS"
}

// MARK: TAPI_SYSTEM_FRAMEWORK_SEARCH_PATHS
extension BuildSetting {

    /// TAPI_SYSTEM_FRAMEWORK_SEARCH_PATHS
    public static var tapiSystemFrameworkSearchPaths: BuildSetting { 
        .tapiSystemFrameworkSearchPaths(inherit: .systemFrameworkSearchPaths) 
    }

    /// TAPI_SYSTEM_FRAMEWORK_SEARCH_PATHS
    public static func tapiSystemFrameworkSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiSystemFrameworkSearchPaths, value: .array(value))
    }

    /// TAPI_SYSTEM_FRAMEWORK_SEARCH_PATHS
    public static func tapiSystemFrameworkSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiSystemFrameworkSearchPaths, inherit: key)
    }

    /// TAPI_SYSTEM_FRAMEWORK_SEARCH_PATHS
    public static func tapiSystemFrameworkSearchPaths(_ value: String...) -> BuildSetting { 
        .tapiSystemFrameworkSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_SYSTEM_FRAMEWORK_SEARCH_PATHS
    public static let tapiSystemFrameworkSearchPaths: BuildSettingsKey = "TAPI_SYSTEM_FRAMEWORK_SEARCH_PATHS"
}

// MARK: TAPI_SYSTEM_HEADER_SEARCH_PATHS
extension BuildSetting {

    /// TAPI_SYSTEM_HEADER_SEARCH_PATHS
    public static var tapiSystemHeaderSearchPaths: BuildSetting { 
        .tapiSystemHeaderSearchPaths(inherit: .systemHeaderSearchPaths) 
    }

    /// TAPI_SYSTEM_HEADER_SEARCH_PATHS
    public static func tapiSystemHeaderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiSystemHeaderSearchPaths, value: .array(value))
    }

    /// TAPI_SYSTEM_HEADER_SEARCH_PATHS
    public static func tapiSystemHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiSystemHeaderSearchPaths, inherit: key)
    }

    /// TAPI_SYSTEM_HEADER_SEARCH_PATHS
    public static func tapiSystemHeaderSearchPaths(_ value: String...) -> BuildSetting { 
        .tapiSystemHeaderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_SYSTEM_HEADER_SEARCH_PATHS
    public static let tapiSystemHeaderSearchPaths: BuildSettingsKey = "TAPI_SYSTEM_HEADER_SEARCH_PATHS"
}

// MARK: TAPI_TARGET_TRIPLE_ARCHS
extension BuildSetting {

    /// TAPI_TARGET_TRIPLE_ARCHS
    public static var tapiTargetTripleArchs: BuildSetting { 
        .tapiTargetTripleArchs(inherit: .architectures) 
    }

    /// TAPI_TARGET_TRIPLE_ARCHS
    public static func tapiTargetTripleArchs(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiTargetTripleArchs, value: .array(value))
    }

    /// TAPI_TARGET_TRIPLE_ARCHS
    public static func tapiTargetTripleArchs(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiTargetTripleArchs, inherit: key)
    }

    /// TAPI_TARGET_TRIPLE_ARCHS
    public static func tapiTargetTripleArchs(_ value: String...) -> BuildSetting { 
        .tapiTargetTripleArchs(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_TARGET_TRIPLE_ARCHS
    public static let tapiTargetTripleArchs: BuildSettingsKey = "TAPI_TARGET_TRIPLE_ARCHS"
}

// MARK: TAPI_TARGET_TRIPLE_VARIANTS
extension BuildSetting {

    /// TAPI_TARGET_TRIPLE_VARIANTS
    public static func tapiTargetTripleVariants(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .tapiTargetTripleVariants, value: .array(value))
    }

    /// TAPI_TARGET_TRIPLE_VARIANTS
    public static func tapiTargetTripleVariants(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiTargetTripleVariants, inherit: key)
    }

    /// TAPI_TARGET_TRIPLE_VARIANTS
    public static func tapiTargetTripleVariants(_ value: String...) -> BuildSetting { 
        .tapiTargetTripleVariants(value)
    }
}

extension BuildSettingsKey {

    /// TAPI_TARGET_TRIPLE_VARIANTS
    public static let tapiTargetTripleVariants: BuildSettingsKey = "TAPI_TARGET_TRIPLE_VARIANTS"
}

// MARK: TAPI_VERIFY_AGAINST
extension BuildSetting {

    /// TAPI_VERIFY_AGAINST
    public static var tapiVerifyAgainst: BuildSetting { 
        BuildSetting(key: .tapiVerifyAgainst, value: "$(BuiltBinaryPath)")
    }

    /// TAPI_VERIFY_AGAINST
    public static func tapiVerifyAgainst(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tapiVerifyAgainst, value: "\(value)")
    }

    /// TAPI_VERIFY_AGAINST
    public static func tapiVerifyAgainst(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tapiVerifyAgainst, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TAPI_VERIFY_AGAINST
    public static let tapiVerifyAgainst: BuildSettingsKey = "TAPI_VERIFY_AGAINST"
}

// MARK: Text-Based InstallAPI Verification Mode
extension BuildSetting {

    /// Text-Based InstallAPI Verification Mode
    ///
    /// Selects the level of warnings and errors to report when building `Text-Based InstallAPI`.
    public static var textBasedInstallapiVerificationMode: BuildSetting { 
        .textBasedInstallapiVerificationMode(.errorsonly) 
    }

    /// Text-Based InstallAPI Verification Mode
    ///
    /// Selects the level of warnings and errors to report when building `Text-Based InstallAPI`.
    public static func textBasedInstallapiVerificationMode(_ value: TextBasedInstallapiVerificationMode) -> BuildSetting { 
        BuildSetting(key: .textBasedInstallapiVerificationMode, value: "\(value)")
    }

    /// Text-Based InstallAPI Verification Mode
    ///
    /// Selects the level of warnings and errors to report when building `Text-Based InstallAPI`.
    public static func textBasedInstallapiVerificationMode(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .textBasedInstallapiVerificationMode, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Text-Based InstallAPI Verification Mode
    ///
    /// Selects the level of warnings and errors to report when building `Text-Based InstallAPI`.
    public static let textBasedInstallapiVerificationMode: BuildSettingsKey = "TAPI_VERIFY_MODE"
}

public enum TextBasedInstallapiVerificationMode: String, Hashable, Codable, CustomStringConvertible {
    case errorsonly = "ErrorsOnly"
    case errorsandwarnings = "ErrorsAndWarnings"
    case pedantic = "Pedantic"

    public var description: String {
        rawValue
    }
}

// MARK: TARGET_BUILD_DIR
extension BuildSetting {

    /// TARGET_BUILD_DIR
    ///
    /// Identifies the root of the directory hierarchy that contains the products files (no intermediate build files). Run Script build phases that operate on product files of the target that defines them should use the value of this build setting, but Run Script build phases that operate on product files of other targets should use `BUILT_PRODUCTS_DIR` instead.
    public static var targetBuildDir: BuildSetting { 
        BuildSetting(key: .targetBuildDir, value: "$(CONFIGURATION_BUILD_DIR)$(TARGET_BUILD_SUBPATH)")
    }

    /// TARGET_BUILD_DIR
    ///
    /// Identifies the root of the directory hierarchy that contains the products files (no intermediate build files). Run Script build phases that operate on product files of the target that defines them should use the value of this build setting, but Run Script build phases that operate on product files of other targets should use `BUILT_PRODUCTS_DIR` instead.
    public static func targetBuildDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .targetBuildDir, value: "\(value)")
    }

    /// TARGET_BUILD_DIR
    ///
    /// Identifies the root of the directory hierarchy that contains the products files (no intermediate build files). Run Script build phases that operate on product files of the target that defines them should use the value of this build setting, but Run Script build phases that operate on product files of other targets should use `BUILT_PRODUCTS_DIR` instead.
    public static func targetBuildDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .targetBuildDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TARGET_BUILD_DIR
    ///
    /// Identifies the root of the directory hierarchy that contains the products files (no intermediate build files). Run Script build phases that operate on product files of the target that defines them should use the value of this build setting, but Run Script build phases that operate on product files of other targets should use `BUILT_PRODUCTS_DIR` instead.
    public static let targetBuildDir: BuildSettingsKey = "TARGET_BUILD_DIR"
}

// MARK: TARGET_BUILD_SUBPATH
extension BuildSetting {

    /// TARGET_BUILD_SUBPATH
    public static var targetBuildSubpath: BuildSetting { 
        BuildSetting(key: .targetBuildSubpath, value: "")
    }

    /// TARGET_BUILD_SUBPATH
    public static func targetBuildSubpath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .targetBuildSubpath, value: "\(value)")
    }

    /// TARGET_BUILD_SUBPATH
    public static func targetBuildSubpath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .targetBuildSubpath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TARGET_BUILD_SUBPATH
    public static let targetBuildSubpath: BuildSettingsKey = "TARGET_BUILD_SUBPATH"
}

// MARK: Target Name
extension BuildSetting {

    /// Target Name
    ///
    /// The name of the current target.
    public static var targetName: BuildSetting { 
        BuildSetting(key: .targetName, value: "")
    }

    /// Target Name
    ///
    /// The name of the current target.
    public static func targetName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .targetName, value: "\(value)")
    }

    /// Target Name
    ///
    /// The name of the current target.
    public static func targetName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .targetName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Target Name
    ///
    /// The name of the current target.
    public static let targetName: BuildSettingsKey = "TARGET_NAME"
}

// MARK: TARGET_TEMP_DIR
extension BuildSetting {

    /// TARGET_TEMP_DIR
    ///
    /// Identifies the directory containing the targets intermediate build files. Run Script build phases should place intermediate files at the location indicated by `DERIVED_FILE_DIR`, not the directory identified by this build setting.
    public static var targetTempDir: BuildSetting { 
        BuildSetting(key: .targetTempDir, value: "$(CONFIGURATION_TEMP_DIR)/$(TARGET_NAME).build")
    }

    /// TARGET_TEMP_DIR
    ///
    /// Identifies the directory containing the targets intermediate build files. Run Script build phases should place intermediate files at the location indicated by `DERIVED_FILE_DIR`, not the directory identified by this build setting.
    public static func targetTempDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .targetTempDir, value: "\(value)")
    }

    /// TARGET_TEMP_DIR
    ///
    /// Identifies the directory containing the targets intermediate build files. Run Script build phases should place intermediate files at the location indicated by `DERIVED_FILE_DIR`, not the directory identified by this build setting.
    public static func targetTempDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .targetTempDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TARGET_TEMP_DIR
    ///
    /// Identifies the directory containing the targets intermediate build files. Run Script build phases should place intermediate files at the location indicated by `DERIVED_FILE_DIR`, not the directory identified by this build setting.
    public static let targetTempDir: BuildSettingsKey = "TARGET_TEMP_DIR"
}

// MARK: TEMP_DIR
extension BuildSetting {

    /// TEMP_DIR
    public static var tempDir: BuildSetting { 
        .tempDir(inherit: .targetTempDir) 
    }

    /// TEMP_DIR
    public static func tempDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tempDir, value: "\(value)")
    }

    /// TEMP_DIR
    public static func tempDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tempDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TEMP_DIR
    public static let tempDir: BuildSettingsKey = "TEMP_DIR"
}

// MARK: TEMP_FILES_DIR
extension BuildSetting {

    /// TEMP_FILES_DIR
    public static var tempFilesDir: BuildSetting { 
        .tempFilesDir(inherit: .tempFileDir) 
    }

    /// TEMP_FILES_DIR
    public static func tempFilesDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tempFilesDir, value: "\(value)")
    }

    /// TEMP_FILES_DIR
    public static func tempFilesDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tempFilesDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TEMP_FILES_DIR
    public static let tempFilesDir: BuildSettingsKey = "TEMP_FILES_DIR"
}

// MARK: TEMP_FILE_DIR
extension BuildSetting {

    /// TEMP_FILE_DIR
    public static var tempFileDir: BuildSetting { 
        .tempFileDir(inherit: .targetTempDir) 
    }

    /// TEMP_FILE_DIR
    public static func tempFileDir(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tempFileDir, value: "\(value)")
    }

    /// TEMP_FILE_DIR
    public static func tempFileDir(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tempFileDir, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TEMP_FILE_DIR
    public static let tempFileDir: BuildSettingsKey = "TEMP_FILE_DIR"
}

// MARK: TEMP_ROOT
extension BuildSetting {

    /// TEMP_ROOT
    public static var tempRoot: BuildSetting { 
        .tempRoot(inherit: .intermediateBuildFilesPath) 
    }

    /// TEMP_ROOT
    public static func tempRoot(_ value: String) -> BuildSetting { 
        BuildSetting(key: .tempRoot, value: "\(value)")
    }

    /// TEMP_ROOT
    public static func tempRoot(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .tempRoot, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TEMP_ROOT
    public static let tempRoot: BuildSettingsKey = "TEMP_ROOT"
}

// MARK: Test Host
extension BuildSetting {

    /// Test Host
    ///
    /// Path to the executable into which a bundle of tests is injected. Only specify this setting if testing an application or other executable.
    public static var testHost: BuildSetting { 
        BuildSetting(key: .testHost, value: "")
    }

    /// Test Host
    ///
    /// Path to the executable into which a bundle of tests is injected. Only specify this setting if testing an application or other executable.
    public static func testHost(_ value: String) -> BuildSetting { 
        BuildSetting(key: .testHost, value: "\(value)")
    }

    /// Test Host
    ///
    /// Path to the executable into which a bundle of tests is injected. Only specify this setting if testing an application or other executable.
    public static func testHost(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .testHost, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Test Host
    ///
    /// Path to the executable into which a bundle of tests is injected. Only specify this setting if testing an application or other executable.
    public static let testHost: BuildSettingsKey = "TEST_HOST"
}

// MARK: TEXTURE_ATLAS_ENABLE_WARNINGS
extension BuildSetting {

    /// TEXTURE_ATLAS_ENABLE_WARNINGS
    public static var textureAtlasEnableWarnings: BuildSetting { 
        .textureAtlasEnableWarnings(.yes) 
    }

    /// TEXTURE_ATLAS_ENABLE_WARNINGS
    public static func textureAtlasEnableWarnings(_ value: TextureAtlasEnableWarnings) -> BuildSetting { 
        BuildSetting(key: .textureAtlasEnableWarnings, value: "\(value)")
    }

    /// TEXTURE_ATLAS_ENABLE_WARNINGS
    public static func textureAtlasEnableWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .textureAtlasEnableWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TEXTURE_ATLAS_ENABLE_WARNINGS
    public static let textureAtlasEnableWarnings: BuildSettingsKey = "TEXTURE_ATLAS_ENABLE_WARNINGS"
}

public enum TextureAtlasEnableWarnings: String, Hashable, Codable, CustomStringConvertible {
    case yes = "Yes"
    case no = "No"

    public var description: String {
        rawValue
    }
}

// MARK: TEXTURE_ATLAS_FORMAT
extension BuildSetting {

    /// TEXTURE_ATLAS_FORMAT
    public static var textureAtlasFormat: BuildSetting { 
        .textureAtlasFormat(.rgba8888Png) 
    }

    /// TEXTURE_ATLAS_FORMAT
    public static func textureAtlasFormat(_ value: TextureAtlasFormat) -> BuildSetting { 
        BuildSetting(key: .textureAtlasFormat, value: "\(value)")
    }

    /// TEXTURE_ATLAS_FORMAT
    public static func textureAtlasFormat(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .textureAtlasFormat, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TEXTURE_ATLAS_FORMAT
    public static let textureAtlasFormat: BuildSettingsKey = "TEXTURE_ATLAS_FORMAT"
}

public enum TextureAtlasFormat: String, Hashable, Codable, CustomStringConvertible {
    case rgba8888Png = "RGBA8888_PNG"
    case rgba8888Compressed = "RGBA8888_COMPRESSED"
    case rgba4444Compressed = "RGBA4444_COMPRESSED"
    case rgba5551Compressed = "RGBA5551_COMPRESSED"
    case rgb565Compressed = "RGB565_COMPRESSED"

    public var description: String {
        rawValue
    }
}

// MARK: TEXTURE_ATLAS_MAXIMUM_SIZE
extension BuildSetting {

    /// TEXTURE_ATLAS_MAXIMUM_SIZE
    public static var textureAtlasMaximumSize: BuildSetting { 
        .textureAtlasMaximumSize(._2048x2048) 
    }

    /// TEXTURE_ATLAS_MAXIMUM_SIZE
    public static func textureAtlasMaximumSize(_ value: TextureAtlasMaximumSize) -> BuildSetting { 
        BuildSetting(key: .textureAtlasMaximumSize, value: "\(value)")
    }

    /// TEXTURE_ATLAS_MAXIMUM_SIZE
    public static func textureAtlasMaximumSize(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .textureAtlasMaximumSize, inherit: key)
    }
}

extension BuildSettingsKey {

    /// TEXTURE_ATLAS_MAXIMUM_SIZE
    public static let textureAtlasMaximumSize: BuildSettingsKey = "TEXTURE_ATLAS_MAXIMUM_SIZE"
}

public enum TextureAtlasMaximumSize: String, Hashable, Codable, CustomStringConvertible {
    case _2048x2048 = "2048x2048"
    case _4096x4096 = "4096x4096"

    public var description: String {
        rawValue
    }
}

// MARK: TOOLCHAINS
extension BuildSetting {

    /// TOOLCHAINS
    public static var toolchains: BuildSetting { 
        BuildSetting(key: .toolchains, value: "")
    }

    /// TOOLCHAINS
    public static func toolchains(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .toolchains, value: .array(value))
    }

    /// TOOLCHAINS
    public static func toolchains(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .toolchains, inherit: key)
    }

    /// TOOLCHAINS
    public static func toolchains(_ value: String...) -> BuildSetting { 
        .toolchains(value)
    }
}

extension BuildSettingsKey {

    /// TOOLCHAINS
    public static let toolchains: BuildSettingsKey = "TOOLCHAINS"
}

// MARK: Treat missing baselines as test failures
extension BuildSetting {

    /// Treat missing baselines as test failures
    ///
    /// When running tests that measure performance via `XCTestCase`, report missing baselines as test failures.
    public static var treatMissingBaselinesAsTestFailures: BuildSetting { 
        BuildSetting(key: .treatMissingBaselinesAsTestFailures, value: "NO")
    }

    /// Treat missing baselines as test failures
    ///
    /// When running tests that measure performance via `XCTestCase`, report missing baselines as test failures.
    public static func treatMissingBaselinesAsTestFailures(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .treatMissingBaselinesAsTestFailures, value: SettingValue(booleanLiteral: value))
    }

    /// Treat missing baselines as test failures
    ///
    /// When running tests that measure performance via `XCTestCase`, report missing baselines as test failures.
    public static func treatMissingBaselinesAsTestFailures(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .treatMissingBaselinesAsTestFailures, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Treat missing baselines as test failures
    ///
    /// When running tests that measure performance via `XCTestCase`, report missing baselines as test failures.
    public static let treatMissingBaselinesAsTestFailures: BuildSettingsKey = "TREAT_MISSING_BASELINES_AS_TEST_FAILURES"
}

// MARK: Unexported Symbols File
extension BuildSetting {

    /// Unexported Symbols File
    ///
    /// A project-relative path to a file that lists the symbols not to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static var unexportedSymbolsFile: BuildSetting { 
        BuildSetting(key: .unexportedSymbolsFile, value: "")
    }

    /// Unexported Symbols File
    ///
    /// A project-relative path to a file that lists the symbols not to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static func unexportedSymbolsFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .unexportedSymbolsFile, value: "\(value)")
    }

    /// Unexported Symbols File
    ///
    /// A project-relative path to a file that lists the symbols not to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static func unexportedSymbolsFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unexportedSymbolsFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Unexported Symbols File
    ///
    /// A project-relative path to a file that lists the symbols not to export. See `ld -exported_symbols_list` for details on exporting symbols.
    public static let unexportedSymbolsFile: BuildSettingsKey = "UNEXPORTED_SYMBOLS_FILE"
}

// MARK: UNLOCALIZED_RESOURCES_FOLDER_PATH
extension BuildSetting {

    /// UNLOCALIZED_RESOURCES_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products unlocalized resources.
    public static var unlocalizedResourcesFolderPath: BuildSetting { 
        BuildSetting(key: .unlocalizedResourcesFolderPath, value: "")
    }

    /// UNLOCALIZED_RESOURCES_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products unlocalized resources.
    public static func unlocalizedResourcesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .unlocalizedResourcesFolderPath, value: "\(value)")
    }

    /// UNLOCALIZED_RESOURCES_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products unlocalized resources.
    public static func unlocalizedResourcesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unlocalizedResourcesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// UNLOCALIZED_RESOURCES_FOLDER_PATH
    ///
    /// Specifies the directory that contains the products unlocalized resources.
    public static let unlocalizedResourcesFolderPath: BuildSettingsKey = "UNLOCALIZED_RESOURCES_FOLDER_PATH"
}

// MARK: UNSTRIPPED_PRODUCT
extension BuildSetting {

    /// UNSTRIPPED_PRODUCT
    public static var unstrippedProduct: BuildSetting { 
        BuildSetting(key: .unstrippedProduct, value: "NO")
    }

    /// UNSTRIPPED_PRODUCT
    public static func unstrippedProduct(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .unstrippedProduct, value: SettingValue(booleanLiteral: value))
    }

    /// UNSTRIPPED_PRODUCT
    public static func unstrippedProduct(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .unstrippedProduct, inherit: key)
    }
}

extension BuildSettingsKey {

    /// UNSTRIPPED_PRODUCT
    public static let unstrippedProduct: BuildSettingsKey = "UNSTRIPPED_PRODUCT"
}

// MARK: Enable USDZ Warnings
extension BuildSetting {

    /// Enable USDZ Warnings
    public static var enableUsdzWarnings: BuildSetting { 
        .enableUsdzWarnings(.yes) 
    }

    /// Enable USDZ Warnings
    public static func enableUsdzWarnings(_ value: EnableUsdzWarnings) -> BuildSetting { 
        BuildSetting(key: .enableUsdzWarnings, value: "\(value)")
    }

    /// Enable USDZ Warnings
    public static func enableUsdzWarnings(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .enableUsdzWarnings, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Enable USDZ Warnings
    public static let enableUsdzWarnings: BuildSettingsKey = "USDZ_ENABLE_WARNINGS"
}

public enum EnableUsdzWarnings: String, Hashable, Codable, CustomStringConvertible {
    case yes = "Yes"
    case no = "No"

    public var description: String {
        rawValue
    }
}

// MARK: USER
extension BuildSetting {

    /// USER
    public static func user(_ value: String) -> BuildSetting { 
        BuildSetting(key: .user, value: "\(value)")
    }

    /// USER
    public static func user(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .user, inherit: key)
    }
}

extension BuildSettingsKey {

    /// USER
    public static let user: BuildSettingsKey = "USER"
}

// MARK: User Header Search Paths
extension BuildSetting {

    /// User Header Search Paths
    @available(*, deprecated, message: "This is a list of paths to folders to be searched by the compiler for included or imported user header files (those headers listed in quotes) when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. See [Always Search User Paths (Deprecated) (ALWAYS\_SEARCH\_USER\_PATHS)](itcaec37c2a6.html#devc34d7d3e9) for more details on how this setting is used. If the compiler doesn't support the concept of user headers, then the search paths are prepended to the any existing header search paths defined in [Header Search Paths (HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#dev3c9f85d97).")
    public static func userHeaderSearchPaths(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .userHeaderSearchPaths, value: .array(value))
    }

    /// User Header Search Paths
    @available(*, deprecated, message: "This is a list of paths to folders to be searched by the compiler for included or imported user header files (those headers listed in quotes) when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. See [Always Search User Paths (Deprecated) (ALWAYS\_SEARCH\_USER\_PATHS)](itcaec37c2a6.html#devc34d7d3e9) for more details on how this setting is used. If the compiler doesn't support the concept of user headers, then the search paths are prepended to the any existing header search paths defined in [Header Search Paths (HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#dev3c9f85d97).")
    public static func userHeaderSearchPaths(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .userHeaderSearchPaths, inherit: key)
    }

    /// User Header Search Paths
    @available(*, deprecated, message: "This is a list of paths to folders to be searched by the compiler for included or imported user header files (those headers listed in quotes) when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. See [Always Search User Paths (Deprecated) (ALWAYS\_SEARCH\_USER\_PATHS)](itcaec37c2a6.html#devc34d7d3e9) for more details on how this setting is used. If the compiler doesn't support the concept of user headers, then the search paths are prepended to the any existing header search paths defined in [Header Search Paths (HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#dev3c9f85d97).")
    public static func userHeaderSearchPaths(_ value: String...) -> BuildSetting { 
        .userHeaderSearchPaths(value)
    }
}

extension BuildSettingsKey {

    /// User Header Search Paths
    @available(*, deprecated, message: "This is a list of paths to folders to be searched by the compiler for included or imported user header files (those headers listed in quotes) when compiling C, Objective-C, C++, or Objective-C++. Paths are delimited by whitespace, so any paths with spaces in them need to be properly quoted. See [Always Search User Paths (Deprecated) (ALWAYS\_SEARCH\_USER\_PATHS)](itcaec37c2a6.html#devc34d7d3e9) for more details on how this setting is used. If the compiler doesn't support the concept of user headers, then the search paths are prepended to the any existing header search paths defined in [Header Search Paths (HEADER\_SEARCH\_PATHS)](itcaec37c2a6.html#dev3c9f85d97).")
    public static let userHeaderSearchPaths: BuildSettingsKey = "USER_HEADER_SEARCH_PATHS"
}

// MARK: USE_DYNAMIC_NO_PIC
extension BuildSetting {

    /// USE_DYNAMIC_NO_PIC
    public static var useDynamicNoPic: BuildSetting { 
        BuildSetting(key: .useDynamicNoPic, value: "YES")
    }

    /// USE_DYNAMIC_NO_PIC
    public static func useDynamicNoPic(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useDynamicNoPic, value: SettingValue(booleanLiteral: value))
    }

    /// USE_DYNAMIC_NO_PIC
    public static func useDynamicNoPic(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useDynamicNoPic, inherit: key)
    }
}

extension BuildSettingsKey {

    /// USE_DYNAMIC_NO_PIC
    public static let useDynamicNoPic: BuildSettingsKey = "USE_DYNAMIC_NO_PIC"
}

// MARK: USE_GCC3_PFE_SUPPORT
extension BuildSetting {

    /// USE_GCC3_PFE_SUPPORT
    public static var useGcc3PfeSupport: BuildSetting { 
        BuildSetting(key: .useGcc3PfeSupport, value: "")
    }

    /// USE_GCC3_PFE_SUPPORT
    public static func useGcc3PfeSupport(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useGcc3PfeSupport, value: SettingValue(booleanLiteral: value))
    }

    /// USE_GCC3_PFE_SUPPORT
    public static func useGcc3PfeSupport(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useGcc3PfeSupport, inherit: key)
    }
}

extension BuildSettingsKey {

    /// USE_GCC3_PFE_SUPPORT
    public static let useGcc3PfeSupport: BuildSettingsKey = "USE_GCC3_PFE_SUPPORT"
}

// MARK: Use Header Maps
extension BuildSetting {

    /// Use Header Maps
    ///
    /// Enable the use of _Header Maps_, which provide the compiler with a mapping from textual header names to their locations, bypassing the normal compiler header search path mechanisms. This allows source code to include headers from various locations in the file system without needing to update the header search path build settings.
    public static var useHeaderMaps: BuildSetting { 
        BuildSetting(key: .useHeaderMaps, value: "YES")
    }

    /// Use Header Maps
    ///
    /// Enable the use of _Header Maps_, which provide the compiler with a mapping from textual header names to their locations, bypassing the normal compiler header search path mechanisms. This allows source code to include headers from various locations in the file system without needing to update the header search path build settings.
    public static func useHeaderMaps(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useHeaderMaps, value: SettingValue(booleanLiteral: value))
    }

    /// Use Header Maps
    ///
    /// Enable the use of _Header Maps_, which provide the compiler with a mapping from textual header names to their locations, bypassing the normal compiler header search path mechanisms. This allows source code to include headers from various locations in the file system without needing to update the header search path build settings.
    public static func useHeaderMaps(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useHeaderMaps, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Use Header Maps
    ///
    /// Enable the use of _Header Maps_, which provide the compiler with a mapping from textual header names to their locations, bypassing the normal compiler header search path mechanisms. This allows source code to include headers from various locations in the file system without needing to update the header search path build settings.
    public static let useHeaderMaps: BuildSettingsKey = "USE_HEADERMAP"
}

// MARK: USE_HEADER_SYMLINKS
extension BuildSetting {

    /// USE_HEADER_SYMLINKS
    public static var useHeaderSymlinks: BuildSetting { 
        BuildSetting(key: .useHeaderSymlinks, value: "NO")
    }

    /// USE_HEADER_SYMLINKS
    public static func useHeaderSymlinks(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useHeaderSymlinks, value: SettingValue(booleanLiteral: value))
    }

    /// USE_HEADER_SYMLINKS
    public static func useHeaderSymlinks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useHeaderSymlinks, inherit: key)
    }
}

extension BuildSettingsKey {

    /// USE_HEADER_SYMLINKS
    public static let useHeaderSymlinks: BuildSettingsKey = "USE_HEADER_SYMLINKS"
}

// MARK: USE_LLVM_TARGET_TRIPLES
extension BuildSetting {

    /// USE_LLVM_TARGET_TRIPLES
    public static var useLlvmTargetTriples: BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriples, value: "YES")
    }

    /// USE_LLVM_TARGET_TRIPLES
    public static func useLlvmTargetTriples(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriples, value: SettingValue(booleanLiteral: value))
    }

    /// USE_LLVM_TARGET_TRIPLES
    public static func useLlvmTargetTriples(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useLlvmTargetTriples, inherit: key)
    }
}

extension BuildSettingsKey {

    /// USE_LLVM_TARGET_TRIPLES
    public static let useLlvmTargetTriples: BuildSettingsKey = "USE_LLVM_TARGET_TRIPLES"
}

// MARK: USE_LLVM_TARGET_TRIPLES_FOR_CLANG
extension BuildSetting {

    /// USE_LLVM_TARGET_TRIPLES_FOR_CLANG
    public static var useLlvmTargetTriplesForClang: BuildSetting { 
        .useLlvmTargetTriplesForClang(inherit: .useLlvmTargetTriples) 
    }

    /// USE_LLVM_TARGET_TRIPLES_FOR_CLANG
    public static func useLlvmTargetTriplesForClang(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriplesForClang, value: SettingValue(booleanLiteral: value))
    }

    /// USE_LLVM_TARGET_TRIPLES_FOR_CLANG
    public static func useLlvmTargetTriplesForClang(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useLlvmTargetTriplesForClang, inherit: key)
    }
}

extension BuildSettingsKey {

    /// USE_LLVM_TARGET_TRIPLES_FOR_CLANG
    public static let useLlvmTargetTriplesForClang: BuildSettingsKey = "USE_LLVM_TARGET_TRIPLES_FOR_CLANG"
}

// MARK: USE_LLVM_TARGET_TRIPLES_FOR_LD
extension BuildSetting {

    /// USE_LLVM_TARGET_TRIPLES_FOR_LD
    public static var useLlvmTargetTriplesForLd: BuildSetting { 
        .useLlvmTargetTriplesForLd(inherit: .useLlvmTargetTriples) 
    }

    /// USE_LLVM_TARGET_TRIPLES_FOR_LD
    public static func useLlvmTargetTriplesForLd(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriplesForLd, value: SettingValue(booleanLiteral: value))
    }

    /// USE_LLVM_TARGET_TRIPLES_FOR_LD
    public static func useLlvmTargetTriplesForLd(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useLlvmTargetTriplesForLd, inherit: key)
    }
}

extension BuildSettingsKey {

    /// USE_LLVM_TARGET_TRIPLES_FOR_LD
    public static let useLlvmTargetTriplesForLd: BuildSettingsKey = "USE_LLVM_TARGET_TRIPLES_FOR_LD"
}

// MARK: USE_LLVM_TARGET_TRIPLES_FOR_TAPI
extension BuildSetting {

    /// USE_LLVM_TARGET_TRIPLES_FOR_TAPI
    public static var useLlvmTargetTriplesForTapi: BuildSetting { 
        .useLlvmTargetTriplesForTapi(inherit: .useLlvmTargetTriples) 
    }

    /// USE_LLVM_TARGET_TRIPLES_FOR_TAPI
    public static func useLlvmTargetTriplesForTapi(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .useLlvmTargetTriplesForTapi, value: SettingValue(booleanLiteral: value))
    }

    /// USE_LLVM_TARGET_TRIPLES_FOR_TAPI
    public static func useLlvmTargetTriplesForTapi(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .useLlvmTargetTriplesForTapi, inherit: key)
    }
}

extension BuildSettingsKey {

    /// USE_LLVM_TARGET_TRIPLES_FOR_TAPI
    public static let useLlvmTargetTriplesForTapi: BuildSettingsKey = "USE_LLVM_TARGET_TRIPLES_FOR_TAPI"
}

// MARK: VALIDATE_PLIST_FILES_WHILE_COPYING
extension BuildSetting {

    /// VALIDATE_PLIST_FILES_WHILE_COPYING
    public static var validatePlistFilesWhileCopying: BuildSetting { 
        BuildSetting(key: .validatePlistFilesWhileCopying, value: "NO")
    }

    /// VALIDATE_PLIST_FILES_WHILE_COPYING
    public static func validatePlistFilesWhileCopying(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .validatePlistFilesWhileCopying, value: SettingValue(booleanLiteral: value))
    }

    /// VALIDATE_PLIST_FILES_WHILE_COPYING
    public static func validatePlistFilesWhileCopying(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validatePlistFilesWhileCopying, inherit: key)
    }
}

extension BuildSettingsKey {

    /// VALIDATE_PLIST_FILES_WHILE_COPYING
    public static let validatePlistFilesWhileCopying: BuildSettingsKey = "VALIDATE_PLIST_FILES_WHILE_COPYING"
}

// MARK: Validate Built Product
extension BuildSetting {

    /// Validate Built Product
    ///
    /// If enabled, perform validation checks on the product as part of the build process.
    public static var validateBuiltProduct: BuildSetting { 
        BuildSetting(key: .validateBuiltProduct, value: "NO")
    }

    /// Validate Built Product
    ///
    /// If enabled, perform validation checks on the product as part of the build process.
    public static func validateBuiltProduct(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .validateBuiltProduct, value: SettingValue(booleanLiteral: value))
    }

    /// Validate Built Product
    ///
    /// If enabled, perform validation checks on the product as part of the build process.
    public static func validateBuiltProduct(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validateBuiltProduct, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Validate Built Product
    ///
    /// If enabled, perform validation checks on the product as part of the build process.
    public static let validateBuiltProduct: BuildSettingsKey = "VALIDATE_PRODUCT"
}

// MARK: VALIDATE_STRINGS_FILES_WHILE_COPYING
extension BuildSetting {

    /// VALIDATE_STRINGS_FILES_WHILE_COPYING
    public static var validateStringsFilesWhileCopying: BuildSetting { 
        BuildSetting(key: .validateStringsFilesWhileCopying, value: "YES")
    }

    /// VALIDATE_STRINGS_FILES_WHILE_COPYING
    public static func validateStringsFilesWhileCopying(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .validateStringsFilesWhileCopying, value: SettingValue(booleanLiteral: value))
    }

    /// VALIDATE_STRINGS_FILES_WHILE_COPYING
    public static func validateStringsFilesWhileCopying(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validateStringsFilesWhileCopying, inherit: key)
    }
}

extension BuildSettingsKey {

    /// VALIDATE_STRINGS_FILES_WHILE_COPYING
    public static let validateStringsFilesWhileCopying: BuildSettingsKey = "VALIDATE_STRINGS_FILES_WHILE_COPYING"
}

// MARK: Validate Workspace
extension BuildSetting {

    /// Validate Workspace
    ///
    /// If enabled, perform validation checks on the workspace configuration as part of the build process.
    public static var validateWorkspace: BuildSetting { 
        .validateWorkspace(.no) 
    }

    /// Validate Workspace
    ///
    /// If enabled, perform validation checks on the workspace configuration as part of the build process.
    public static func validateWorkspace(_ value: ValidateWorkspace) -> BuildSetting { 
        BuildSetting(key: .validateWorkspace, value: "\(value)")
    }

    /// Validate Workspace
    ///
    /// If enabled, perform validation checks on the workspace configuration as part of the build process.
    public static func validateWorkspace(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validateWorkspace, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Validate Workspace
    ///
    /// If enabled, perform validation checks on the workspace configuration as part of the build process.
    public static let validateWorkspace: BuildSettingsKey = "VALIDATE_WORKSPACE"
}

public enum ValidateWorkspace: String, Hashable, Codable, CustomStringConvertible {
    case yes = "YES"
    case no = "NO"
    case yesError = "YES_ERROR"

    public var description: String {
        rawValue
    }
}


extension ValidateWorkspace: ExpressibleByBooleanLiteral {
    
    public init(booleanLiteral value: Bool) {
        self = value ? .yes : .no
    }
}

// MARK: Validate Workspace - Ignored Frameworks
extension BuildSetting {

    /// Validate Workspace - Ignored Frameworks
    ///
    /// List of framework names for which to suppress deprecation warnings and missing framework errors in the workspace validator.
    public static var validateWorkspaceIgnoredFrameworks: BuildSetting { 
        BuildSetting(key: .validateWorkspaceIgnoredFrameworks, value: "")
    }

    /// Validate Workspace - Ignored Frameworks
    ///
    /// List of framework names for which to suppress deprecation warnings and missing framework errors in the workspace validator.
    public static func validateWorkspaceIgnoredFrameworks(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .validateWorkspaceIgnoredFrameworks, value: .array(value))
    }

    /// Validate Workspace - Ignored Frameworks
    ///
    /// List of framework names for which to suppress deprecation warnings and missing framework errors in the workspace validator.
    public static func validateWorkspaceIgnoredFrameworks(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validateWorkspaceIgnoredFrameworks, inherit: key)
    }

    /// Validate Workspace - Ignored Frameworks
    ///
    /// List of framework names for which to suppress deprecation warnings and missing framework errors in the workspace validator.
    public static func validateWorkspaceIgnoredFrameworks(_ value: String...) -> BuildSetting { 
        .validateWorkspaceIgnoredFrameworks(value)
    }
}

extension BuildSettingsKey {

    /// Validate Workspace - Ignored Frameworks
    ///
    /// List of framework names for which to suppress deprecation warnings and missing framework errors in the workspace validator.
    public static let validateWorkspaceIgnoredFrameworks: BuildSettingsKey = "VALIDATE_WORKSPACE_SKIPPED_SDK_FRAMEWORKS"
}

// MARK: Valid Architectures
extension BuildSetting {

    /// Valid Architectures
    ///
    /// A space-separated list of architectures for which the target should actually be built. For each target, this is intersected with the list specified in [Architectures (ARCHS)](itcaec37c2a6.html#devf0a9d5aca), and the resulting set is built. This allows individual targets to opt out of building for particular architectures. If the resulting set of architectures is empty, no executable will be produced.
    public static func validArchitectures(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .validArchitectures, value: .array(value))
    }

    /// Valid Architectures
    ///
    /// A space-separated list of architectures for which the target should actually be built. For each target, this is intersected with the list specified in [Architectures (ARCHS)](itcaec37c2a6.html#devf0a9d5aca), and the resulting set is built. This allows individual targets to opt out of building for particular architectures. If the resulting set of architectures is empty, no executable will be produced.
    public static func validArchitectures(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .validArchitectures, inherit: key)
    }

    /// Valid Architectures
    ///
    /// A space-separated list of architectures for which the target should actually be built. For each target, this is intersected with the list specified in [Architectures (ARCHS)](itcaec37c2a6.html#devf0a9d5aca), and the resulting set is built. This allows individual targets to opt out of building for particular architectures. If the resulting set of architectures is empty, no executable will be produced.
    public static func validArchitectures(_ value: String...) -> BuildSetting { 
        .validArchitectures(value)
    }
}

extension BuildSettingsKey {

    /// Valid Architectures
    ///
    /// A space-separated list of architectures for which the target should actually be built. For each target, this is intersected with the list specified in [Architectures (ARCHS)](itcaec37c2a6.html#devf0a9d5aca), and the resulting set is built. This allows individual targets to opt out of building for particular architectures. If the resulting set of architectures is empty, no executable will be produced.
    public static let validArchitectures: BuildSettingsKey = "VALID_ARCHS"
}

// MARK: VERBOSE_PBXCP
extension BuildSetting {

    /// VERBOSE_PBXCP
    ///
    /// Specifies whether the targets Copy Files build phases generate additional information when copying files.
    public static var verbosePbxcp: BuildSetting { 
        BuildSetting(key: .verbosePbxcp, value: "NO")
    }

    /// VERBOSE_PBXCP
    ///
    /// Specifies whether the targets Copy Files build phases generate additional information when copying files.
    public static func verbosePbxcp(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .verbosePbxcp, value: SettingValue(booleanLiteral: value))
    }

    /// VERBOSE_PBXCP
    ///
    /// Specifies whether the targets Copy Files build phases generate additional information when copying files.
    public static func verbosePbxcp(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .verbosePbxcp, inherit: key)
    }
}

extension BuildSettingsKey {

    /// VERBOSE_PBXCP
    ///
    /// Specifies whether the targets Copy Files build phases generate additional information when copying files.
    public static let verbosePbxcp: BuildSettingsKey = "VERBOSE_PBXCP"
}

// MARK: VERSIONING_STUB
extension BuildSetting {

    /// VERSIONING_STUB
    public static var versioningStub: BuildSetting { 
        BuildSetting(key: .versioningStub, value: "")
    }

    /// VERSIONING_STUB
    public static func versioningStub(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versioningStub, value: "\(value)")
    }

    /// VERSIONING_STUB
    public static func versioningStub(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningStub, inherit: key)
    }
}

extension BuildSettingsKey {

    /// VERSIONING_STUB
    public static let versioningStub: BuildSettingsKey = "VERSIONING_STUB"
}

// MARK: Versioning System
extension BuildSetting {

    /// Versioning System
    ///
    /// Selects the process used for version-stamping generated files.

- _None:_ Use no versioning system.

- _Apple Generic:_ Use the current project version setting. `apple-generic`
    public static var versioningSystem: BuildSetting { 
        .versioningSystem(.empty) 
    }

    /// Versioning System
    ///
    /// Selects the process used for version-stamping generated files.

- _None:_ Use no versioning system.

- _Apple Generic:_ Use the current project version setting. `apple-generic`
    public static func versioningSystem(_ value: VersioningSystem) -> BuildSetting { 
        BuildSetting(key: .versioningSystem, value: "\(value)")
    }

    /// Versioning System
    ///
    /// Selects the process used for version-stamping generated files.

- _None:_ Use no versioning system.

- _Apple Generic:_ Use the current project version setting. `apple-generic`
    public static func versioningSystem(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningSystem, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versioning System
    ///
    /// Selects the process used for version-stamping generated files.

- _None:_ Use no versioning system.

- _Apple Generic:_ Use the current project version setting. `apple-generic`
    public static let versioningSystem: BuildSettingsKey = "VERSIONING_SYSTEM"
}

public enum VersioningSystem: String, Hashable, Codable, CustomStringConvertible {
    case empty = ""
    case appleGeneric = "apple-generic"

    public var description: String {
        rawValue
    }
}

// MARK: VERSIONPLIST_PATH
extension BuildSetting {

    /// VERSIONPLIST_PATH
    public static var versionplistPath: BuildSetting { 
        BuildSetting(key: .versionplistPath, value: "")
    }

    /// VERSIONPLIST_PATH
    public static func versionplistPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versionplistPath, value: "\(value)")
    }

    /// VERSIONPLIST_PATH
    public static func versionplistPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versionplistPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// VERSIONPLIST_PATH
    public static let versionplistPath: BuildSettingsKey = "VERSIONPLIST_PATH"
}

// MARK: VERSIONS_FOLDER_PATH
extension BuildSetting {

    /// VERSIONS_FOLDER_PATH
    public static var versionsFolderPath: BuildSetting { 
        BuildSetting(key: .versionsFolderPath, value: "")
    }

    /// VERSIONS_FOLDER_PATH
    public static func versionsFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versionsFolderPath, value: "\(value)")
    }

    /// VERSIONS_FOLDER_PATH
    public static func versionsFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versionsFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// VERSIONS_FOLDER_PATH
    public static let versionsFolderPath: BuildSettingsKey = "VERSIONS_FOLDER_PATH"
}

// MARK: Versioning Username
extension BuildSetting {

    /// Versioning Username
    ///
    /// This defines a reference to the user performing a build to be included in the generated Apple Generic Versioning stub. Defaults to the value of the `USER` environment variable.
    public static var versioningUsername: BuildSetting { 
        .versioningUsername(inherit: .user) 
    }

    /// Versioning Username
    ///
    /// This defines a reference to the user performing a build to be included in the generated Apple Generic Versioning stub. Defaults to the value of the `USER` environment variable.
    public static func versioningUsername(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versioningUsername, value: "\(value)")
    }

    /// Versioning Username
    ///
    /// This defines a reference to the user performing a build to be included in the generated Apple Generic Versioning stub. Defaults to the value of the `USER` environment variable.
    public static func versioningUsername(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningUsername, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versioning Username
    ///
    /// This defines a reference to the user performing a build to be included in the generated Apple Generic Versioning stub. Defaults to the value of the `USER` environment variable.
    public static let versioningUsername: BuildSettingsKey = "VERSION_INFO_BUILDER"
}

// MARK: Generated Versioning Variables
extension BuildSetting {

    /// Generated Versioning Variables
    ///
    /// This defines a prefix string for the version info symbol declaration in the generated Apple Generic Versioning stub. This can be used, for example, to add an optional `export` keyword to the version symbol declaration. This should rarely be changed.
    public static var generatedVersioningVariables: BuildSetting { 
        BuildSetting(key: .generatedVersioningVariables, value: "")
    }

    /// Generated Versioning Variables
    ///
    /// This defines a prefix string for the version info symbol declaration in the generated Apple Generic Versioning stub. This can be used, for example, to add an optional `export` keyword to the version symbol declaration. This should rarely be changed.
    public static func generatedVersioningVariables(_ value: String) -> BuildSetting { 
        BuildSetting(key: .generatedVersioningVariables, value: "\(value)")
    }

    /// Generated Versioning Variables
    ///
    /// This defines a prefix string for the version info symbol declaration in the generated Apple Generic Versioning stub. This can be used, for example, to add an optional `export` keyword to the version symbol declaration. This should rarely be changed.
    public static func generatedVersioningVariables(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatedVersioningVariables, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generated Versioning Variables
    ///
    /// This defines a prefix string for the version info symbol declaration in the generated Apple Generic Versioning stub. This can be used, for example, to add an optional `export` keyword to the version symbol declaration. This should rarely be changed.
    public static let generatedVersioningVariables: BuildSettingsKey = "VERSION_INFO_EXPORT_DECL"
}

// MARK: Generated Versioning Source Filename
extension BuildSetting {

    /// Generated Versioning Source Filename
    ///
    /// Used to specify a name for the source file that will be generated by Apple Generic Versioning and compiled into your product. By default, this is set to `$(PRODUCT_NAME)_vers.c`.
    public static var generatedVersioningSourceFilename: BuildSetting { 
        BuildSetting(key: .generatedVersioningSourceFilename, value: "$(PRODUCT_NAME)_vers.c")
    }

    /// Generated Versioning Source Filename
    ///
    /// Used to specify a name for the source file that will be generated by Apple Generic Versioning and compiled into your product. By default, this is set to `$(PRODUCT_NAME)_vers.c`.
    public static func generatedVersioningSourceFilename(_ value: String) -> BuildSetting { 
        BuildSetting(key: .generatedVersioningSourceFilename, value: "\(value)")
    }

    /// Generated Versioning Source Filename
    ///
    /// Used to specify a name for the source file that will be generated by Apple Generic Versioning and compiled into your product. By default, this is set to `$(PRODUCT_NAME)_vers.c`.
    public static func generatedVersioningSourceFilename(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatedVersioningSourceFilename, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generated Versioning Source Filename
    ///
    /// Used to specify a name for the source file that will be generated by Apple Generic Versioning and compiled into your product. By default, this is set to `$(PRODUCT_NAME)_vers.c`.
    public static let generatedVersioningSourceFilename: BuildSettingsKey = "VERSION_INFO_FILE"
}

// MARK: Versioning Name Prefix
extension BuildSetting {

    /// Versioning Name Prefix
    ///
    /// Used as a prefix for the name of the version info symbol in the generated versioning source file. If you prefix your exported symbols you will probably want to set this to the same prefix.
    public static var versioningNamePrefix: BuildSetting { 
        BuildSetting(key: .versioningNamePrefix, value: "")
    }

    /// Versioning Name Prefix
    ///
    /// Used as a prefix for the name of the version info symbol in the generated versioning source file. If you prefix your exported symbols you will probably want to set this to the same prefix.
    public static func versioningNamePrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versioningNamePrefix, value: "\(value)")
    }

    /// Versioning Name Prefix
    ///
    /// Used as a prefix for the name of the version info symbol in the generated versioning source file. If you prefix your exported symbols you will probably want to set this to the same prefix.
    public static func versioningNamePrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningNamePrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versioning Name Prefix
    ///
    /// Used as a prefix for the name of the version info symbol in the generated versioning source file. If you prefix your exported symbols you will probably want to set this to the same prefix.
    public static let versioningNamePrefix: BuildSettingsKey = "VERSION_INFO_PREFIX"
}

// MARK: VERSION_INFO_STRING
extension BuildSetting {

    /// VERSION_INFO_STRING
    public static var versionInfoString: BuildSetting { 
        BuildSetting(key: .versionInfoString, value: ""@(#)PROGRAM:$(PRODUCT_NAME)  PROJECT:$(PROJECT_NAME)-$(CURRENT_PROJECT_VERSION)"")
    }

    /// VERSION_INFO_STRING
    public static func versionInfoString(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versionInfoString, value: "\(value)")
    }

    /// VERSION_INFO_STRING
    public static func versionInfoString(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versionInfoString, inherit: key)
    }
}

extension BuildSettingsKey {

    /// VERSION_INFO_STRING
    public static let versionInfoString: BuildSettingsKey = "VERSION_INFO_STRING"
}

// MARK: Versioning Name Suffix
extension BuildSetting {

    /// Versioning Name Suffix
    ///
    /// Used as a suffix for the name of the version info symbol in the generated versioning source file. This is rarely used.
    public static var versioningNameSuffix: BuildSetting { 
        BuildSetting(key: .versioningNameSuffix, value: "")
    }

    /// Versioning Name Suffix
    ///
    /// Used as a suffix for the name of the version info symbol in the generated versioning source file. This is rarely used.
    public static func versioningNameSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .versioningNameSuffix, value: "\(value)")
    }

    /// Versioning Name Suffix
    ///
    /// Used as a suffix for the name of the version info symbol in the generated versioning source file. This is rarely used.
    public static func versioningNameSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .versioningNameSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Versioning Name Suffix
    ///
    /// Used as a suffix for the name of the version info symbol in the generated versioning source file. This is rarely used.
    public static let versioningNameSuffix: BuildSettingsKey = "VERSION_INFO_SUFFIX"
}

// MARK: Other Warning Flags
extension BuildSetting {

    /// Other Warning Flags
    ///
    /// Space-separated list of additional warning flags to pass to the compiler. Use this setting if Xcode does not already provide UI for a particular compiler warning flag.
    public static var otherWarningFlags: BuildSetting { 
        BuildSetting(key: .otherWarningFlags, value: "")
    }

    /// Other Warning Flags
    ///
    /// Space-separated list of additional warning flags to pass to the compiler. Use this setting if Xcode does not already provide UI for a particular compiler warning flag.
    public static func otherWarningFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherWarningFlags, value: .array(value))
    }

    /// Other Warning Flags
    ///
    /// Space-separated list of additional warning flags to pass to the compiler. Use this setting if Xcode does not already provide UI for a particular compiler warning flag.
    public static func otherWarningFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherWarningFlags, inherit: key)
    }

    /// Other Warning Flags
    ///
    /// Space-separated list of additional warning flags to pass to the compiler. Use this setting if Xcode does not already provide UI for a particular compiler warning flag.
    public static func otherWarningFlags(_ value: String...) -> BuildSetting { 
        .otherWarningFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Warning Flags
    ///
    /// Space-separated list of additional warning flags to pass to the compiler. Use this setting if Xcode does not already provide UI for a particular compiler warning flag.
    public static let otherWarningFlags: BuildSettingsKey = "WARNING_CFLAGS"
}

// MARK: Warning Linker Flags
extension BuildSetting {

    /// Warning Linker Flags
    ///
    /// These flags are passed with linker invocations, and by default give the `-no_arch_warnings` flag to the linker to avoid many warnings being generated during multi-architecture builds.
    public static var warningLinkerFlags: BuildSetting { 
        BuildSetting(key: .warningLinkerFlags, value: "")
    }

    /// Warning Linker Flags
    ///
    /// These flags are passed with linker invocations, and by default give the `-no_arch_warnings` flag to the linker to avoid many warnings being generated during multi-architecture builds.
    public static func warningLinkerFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .warningLinkerFlags, value: .array(value))
    }

    /// Warning Linker Flags
    ///
    /// These flags are passed with linker invocations, and by default give the `-no_arch_warnings` flag to the linker to avoid many warnings being generated during multi-architecture builds.
    public static func warningLinkerFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .warningLinkerFlags, inherit: key)
    }

    /// Warning Linker Flags
    ///
    /// These flags are passed with linker invocations, and by default give the `-no_arch_warnings` flag to the linker to avoid many warnings being generated during multi-architecture builds.
    public static func warningLinkerFlags(_ value: String...) -> BuildSetting { 
        .warningLinkerFlags(value)
    }
}

extension BuildSettingsKey {

    /// Warning Linker Flags
    ///
    /// These flags are passed with linker invocations, and by default give the `-no_arch_warnings` flag to the linker to avoid many warnings being generated during multi-architecture builds.
    public static let warningLinkerFlags: BuildSettingsKey = "WARNING_LDFLAGS"
}

// MARK: Wrapper Extension
extension BuildSetting {

    /// Wrapper Extension
    ///
    /// The extension used for product wrappers, which has a default value based on the product type.
    public static var wrapperExtension: BuildSetting { 
        BuildSetting(key: .wrapperExtension, value: "")
    }

    /// Wrapper Extension
    ///
    /// The extension used for product wrappers, which has a default value based on the product type.
    public static func wrapperExtension(_ value: String) -> BuildSetting { 
        BuildSetting(key: .wrapperExtension, value: "\(value)")
    }

    /// Wrapper Extension
    ///
    /// The extension used for product wrappers, which has a default value based on the product type.
    public static func wrapperExtension(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapperExtension, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Wrapper Extension
    ///
    /// The extension used for product wrappers, which has a default value based on the product type.
    public static let wrapperExtension: BuildSettingsKey = "WRAPPER_EXTENSION"
}

// MARK: WRAPPER_NAME
extension BuildSetting {

    /// WRAPPER_NAME
    ///
    /// Specifies the filename, including the appropriate extension, of the product bundle.
    public static var wrapperName: BuildSetting { 
        BuildSetting(key: .wrapperName, value: "")
    }

    /// WRAPPER_NAME
    ///
    /// Specifies the filename, including the appropriate extension, of the product bundle.
    public static func wrapperName(_ value: String) -> BuildSetting { 
        BuildSetting(key: .wrapperName, value: "\(value)")
    }

    /// WRAPPER_NAME
    ///
    /// Specifies the filename, including the appropriate extension, of the product bundle.
    public static func wrapperName(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapperName, inherit: key)
    }
}

extension BuildSettingsKey {

    /// WRAPPER_NAME
    ///
    /// Specifies the filename, including the appropriate extension, of the product bundle.
    public static let wrapperName: BuildSettingsKey = "WRAPPER_NAME"
}

// MARK: WRAPPER_PREFIX
extension BuildSetting {

    /// WRAPPER_PREFIX
    public static var wrapperPrefix: BuildSetting { 
        BuildSetting(key: .wrapperPrefix, value: "")
    }

    /// WRAPPER_PREFIX
    public static func wrapperPrefix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .wrapperPrefix, value: "\(value)")
    }

    /// WRAPPER_PREFIX
    public static func wrapperPrefix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapperPrefix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// WRAPPER_PREFIX
    public static let wrapperPrefix: BuildSettingsKey = "WRAPPER_PREFIX"
}

// MARK: WRAPPER_SUFFIX
extension BuildSetting {

    /// WRAPPER_SUFFIX
    ///
    /// Specifies the suffix of the product bundle name, including the character that separates the extension from the rest of the bundle name.
    public static var wrapperSuffix: BuildSetting { 
        BuildSetting(key: .wrapperSuffix, value: "")
    }

    /// WRAPPER_SUFFIX
    ///
    /// Specifies the suffix of the product bundle name, including the character that separates the extension from the rest of the bundle name.
    public static func wrapperSuffix(_ value: String) -> BuildSetting { 
        BuildSetting(key: .wrapperSuffix, value: "\(value)")
    }

    /// WRAPPER_SUFFIX
    ///
    /// Specifies the suffix of the product bundle name, including the character that separates the extension from the rest of the bundle name.
    public static func wrapperSuffix(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapperSuffix, inherit: key)
    }
}

extension BuildSettingsKey {

    /// WRAPPER_SUFFIX
    ///
    /// Specifies the suffix of the product bundle name, including the character that separates the extension from the rest of the bundle name.
    public static let wrapperSuffix: BuildSettingsKey = "WRAPPER_SUFFIX"
}

// MARK: WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES
extension BuildSetting {

    /// WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES
    public static var wrapAssetPacksInSeparateDirectories: BuildSetting { 
        BuildSetting(key: .wrapAssetPacksInSeparateDirectories, value: "NO")
    }

    /// WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES
    public static func wrapAssetPacksInSeparateDirectories(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .wrapAssetPacksInSeparateDirectories, value: SettingValue(booleanLiteral: value))
    }

    /// WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES
    public static func wrapAssetPacksInSeparateDirectories(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .wrapAssetPacksInSeparateDirectories, inherit: key)
    }
}

extension BuildSettingsKey {

    /// WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES
    public static let wrapAssetPacksInSeparateDirectories: BuildSettingsKey = "WRAP_ASSET_PACKS_IN_SEPARATE_DIRECTORIES"
}

// MARK: XCODE_DEVELOPER_DIR_PATH
extension BuildSetting {

    /// XCODE_DEVELOPER_DIR_PATH
    public static func xcodeDeveloperDirPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .xcodeDeveloperDirPath, value: "\(value)")
    }

    /// XCODE_DEVELOPER_DIR_PATH
    public static func xcodeDeveloperDirPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .xcodeDeveloperDirPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// XCODE_DEVELOPER_DIR_PATH
    public static let xcodeDeveloperDirPath: BuildSettingsKey = "XCODE_DEVELOPER_DIR_PATH"
}

// MARK: XIB_COMPILER_INFOPLIST_CONTENT_FILE
extension BuildSetting {

    /// XIB_COMPILER_INFOPLIST_CONTENT_FILE
    public static var xibCompilerInfoplistContentFile: BuildSetting { 
        BuildSetting(key: .xibCompilerInfoplistContentFile, value: "$(TARGET_TEMP_DIR)/$(InputFileRegionPathComponent)$(InputFileBase)-PartialInfo.plist")
    }

    /// XIB_COMPILER_INFOPLIST_CONTENT_FILE
    public static func xibCompilerInfoplistContentFile(_ value: String) -> BuildSetting { 
        BuildSetting(key: .xibCompilerInfoplistContentFile, value: "\(value)")
    }

    /// XIB_COMPILER_INFOPLIST_CONTENT_FILE
    public static func xibCompilerInfoplistContentFile(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .xibCompilerInfoplistContentFile, inherit: key)
    }
}

extension BuildSettingsKey {

    /// XIB_COMPILER_INFOPLIST_CONTENT_FILE
    public static let xibCompilerInfoplistContentFile: BuildSettingsKey = "XIB_COMPILER_INFOPLIST_CONTENT_FILE"
}

// MARK: XPCSERVICES_FOLDER_PATH
extension BuildSetting {

    /// XPCSERVICES_FOLDER_PATH
    public static var xpcservicesFolderPath: BuildSetting { 
        BuildSetting(key: .xpcservicesFolderPath, value: "$(CONTENTS_FOLDER_PATH)/XPCServices")
    }

    /// XPCSERVICES_FOLDER_PATH
    public static func xpcservicesFolderPath(_ value: String) -> BuildSetting { 
        BuildSetting(key: .xpcservicesFolderPath, value: "\(value)")
    }

    /// XPCSERVICES_FOLDER_PATH
    public static func xpcservicesFolderPath(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .xpcservicesFolderPath, inherit: key)
    }
}

extension BuildSettingsKey {

    /// XPCSERVICES_FOLDER_PATH
    public static let xpcservicesFolderPath: BuildSettingsKey = "XPCSERVICES_FOLDER_PATH"
}

// MARK: YACC
extension BuildSetting {

    /// YACC
    public static var yacc: BuildSetting { 
        BuildSetting(key: .yacc, value: "yacc")
    }

    /// YACC
    public static func yacc(_ value: String) -> BuildSetting { 
        BuildSetting(key: .yacc, value: "\(value)")
    }

    /// YACC
    public static func yacc(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .yacc, inherit: key)
    }
}

extension BuildSettingsKey {

    /// YACC
    public static let yacc: BuildSettingsKey = "YACC"
}

// MARK: Other Yacc Flags
extension BuildSetting {

    /// Other Yacc Flags
    ///
    /// Space-separated list of additional flags to pass to `yacc`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `yacc` flag.
    public static var otherYaccFlags: BuildSetting { 
        BuildSetting(key: .otherYaccFlags, value: "")
    }

    /// Other Yacc Flags
    ///
    /// Space-separated list of additional flags to pass to `yacc`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `yacc` flag.
    public static func otherYaccFlags(_ value: [String]) -> BuildSetting { 
        BuildSetting(key: .otherYaccFlags, value: .array(value))
    }

    /// Other Yacc Flags
    ///
    /// Space-separated list of additional flags to pass to `yacc`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `yacc` flag.
    public static func otherYaccFlags(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .otherYaccFlags, inherit: key)
    }

    /// Other Yacc Flags
    ///
    /// Space-separated list of additional flags to pass to `yacc`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `yacc` flag.
    public static func otherYaccFlags(_ value: String...) -> BuildSetting { 
        .otherYaccFlags(value)
    }
}

extension BuildSettingsKey {

    /// Other Yacc Flags
    ///
    /// Space-separated list of additional flags to pass to `yacc`. Be sure to backslash-escape any arguments that contain spaces or special characters, such as path names that may contain spaces. Use this setting if Xcode does not already provide UI for a `yacc` flag.
    public static let otherYaccFlags: BuildSettingsKey = "YACCFLAGS"
}

// MARK: Generated File Stem
extension BuildSetting {

    /// Generated File Stem
    ///
    /// The file stem to use for the files generated by `yacc`. The files will be named `<stem>.tab.c` and `<stem>.tab.h` based on the value of this setting. The Standard (`y`) option will cause all `yacc` source files in the same target to produce the same output file, and it is not recommended for targets containing multiple `yacc` source files.
    public static var generatedFileStem: BuildSetting { 
        .generatedFileStem(.standard) 
    }

    /// Generated File Stem
    ///
    /// The file stem to use for the files generated by `yacc`. The files will be named `<stem>.tab.c` and `<stem>.tab.h` based on the value of this setting. The Standard (`y`) option will cause all `yacc` source files in the same target to produce the same output file, and it is not recommended for targets containing multiple `yacc` source files.
    public static func generatedFileStem(_ value: GeneratedFileStem) -> BuildSetting { 
        BuildSetting(key: .generatedFileStem, value: "\(value)")
    }

    /// Generated File Stem
    ///
    /// The file stem to use for the files generated by `yacc`. The files will be named `<stem>.tab.c` and `<stem>.tab.h` based on the value of this setting. The Standard (`y`) option will cause all `yacc` source files in the same target to produce the same output file, and it is not recommended for targets containing multiple `yacc` source files.
    public static func generatedFileStem(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generatedFileStem, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generated File Stem
    ///
    /// The file stem to use for the files generated by `yacc`. The files will be named `<stem>.tab.c` and `<stem>.tab.h` based on the value of this setting. The Standard (`y`) option will cause all `yacc` source files in the same target to produce the same output file, and it is not recommended for targets containing multiple `yacc` source files.
    public static let generatedFileStem: BuildSettingsKey = "YACC_GENERATED_FILE_STEM"
}

public enum GeneratedFileStem: String, Hashable, Codable, CustomStringConvertible {
    case standard = "Standard"
    case inputfilestem = "InputFileStem"

    public var description: String {
        rawValue
    }
}

// MARK: Generate Debugging Directives
extension BuildSetting {

    /// Generate Debugging Directives
    ///
    /// Enabling this option changes the preprocessor directives generated by `yacc` so that debugging statements will be incorporated in the compiled code.
    public static var generateDebuggingDirectives: BuildSetting { 
        BuildSetting(key: .generateDebuggingDirectives, value: "NO")
    }

    /// Generate Debugging Directives
    ///
    /// Enabling this option changes the preprocessor directives generated by `yacc` so that debugging statements will be incorporated in the compiled code.
    public static func generateDebuggingDirectives(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .generateDebuggingDirectives, value: SettingValue(booleanLiteral: value))
    }

    /// Generate Debugging Directives
    ///
    /// Enabling this option changes the preprocessor directives generated by `yacc` so that debugging statements will be incorporated in the compiled code.
    public static func generateDebuggingDirectives(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .generateDebuggingDirectives, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Generate Debugging Directives
    ///
    /// Enabling this option changes the preprocessor directives generated by `yacc` so that debugging statements will be incorporated in the compiled code.
    public static let generateDebuggingDirectives: BuildSettingsKey = "YACC_GENERATE_DEBUGGING_DIRECTIVES"
}

// MARK: Insert #line Directives
extension BuildSetting {

    /// Insert #line Directives
    ///
    /// Enabling this option causes `yacc` to insert the `#line` directives in the generated code. The `#line` directives let the C compiler relate errors in the generated code to the user's original code. If this option is disabled, `#line` directives specified by the user in the source file will still be retained.
    public static var insertLineDirectives: BuildSetting { 
        BuildSetting(key: .insertLineDirectives, value: "YES")
    }

    /// Insert #line Directives
    ///
    /// Enabling this option causes `yacc` to insert the `#line` directives in the generated code. The `#line` directives let the C compiler relate errors in the generated code to the user's original code. If this option is disabled, `#line` directives specified by the user in the source file will still be retained.
    public static func insertLineDirectives(_ value: Bool) -> BuildSetting { 
        BuildSetting(key: .insertLineDirectives, value: SettingValue(booleanLiteral: value))
    }

    /// Insert #line Directives
    ///
    /// Enabling this option causes `yacc` to insert the `#line` directives in the generated code. The `#line` directives let the C compiler relate errors in the generated code to the user's original code. If this option is disabled, `#line` directives specified by the user in the source file will still be retained.
    public static func insertLineDirectives(inherit key: BuildSettingsKey) -> BuildSetting {
        BuildSetting(key: .insertLineDirectives, inherit: key)
    }
}

extension BuildSettingsKey {

    /// Insert #line Directives
    ///
    /// Enabling this option causes `yacc` to insert the `#line` directives in the generated code. The `#line` directives let the C compiler relate errors in the generated code to the user's original code. If this option is disabled, `#line` directives specified by the user in the source file will still be retained.
    public static let insertLineDirectives: BuildSettingsKey = "YACC_INSERT_LINE_DIRECTIVES"
}
